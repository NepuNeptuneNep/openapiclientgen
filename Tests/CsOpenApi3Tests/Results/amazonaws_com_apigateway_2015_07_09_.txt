//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ApiKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="customerId")]
		public string CustomerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.DateTimeOffset CreatedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedDate")]
		public System.DateTimeOffset LastUpdatedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageKeys")]
		public string[] StageKeys { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfStringToString
	{
	}
	
	/// <summary>
	/// A reference to a unique stage identified in the format <code>{restApiId}/{stage}</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StageKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="restApiId")]
		public string RestApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageName")]
		public string StageName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BadRequestException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UnauthorizedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TooManyRequestsException
	{
	}
	
	/// <summary>
	/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Authorizer
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public AuthorizerType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="providerARNs")]
		public string[] ProviderARNs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authType")]
		public string AuthType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerUri")]
		public string AuthorizerUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerCredentials")]
		public string AuthorizerCredentials { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="identitySource")]
		public string IdentitySource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="identityValidationExpression")]
		public string IdentityValidationExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerResultTtlInSeconds")]
		public System.Nullable<System.Int32> AuthorizerResultTtlInSeconds { get; set; }
	}
	
	/// <summary>
	/// The authorizer type. Valid values are <code>TOKEN</code> for a Lambda function using a single authorization token submitted in a custom header, <code>REQUEST</code> for a Lambda function using incoming request parameters, and <code>COGNITO_USER_POOLS</code> for using an Amazon Cognito user pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AuthorizerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOKEN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUEST = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COGNITO_USER_POOLS = 2,
	}
	
	/// <summary>
	/// Represents the base path that callers of the API must provide as part of the URL after the domain name.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BasePathMapping
	{
		
		[System.Runtime.Serialization.DataMember(Name="basePath")]
		public string BasePath { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="restApiId")]
		public string RestApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stage")]
		public string Stage { get; set; }
	}
	
	/// <summary>
	/// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Deployment
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.DateTimeOffset CreatedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiSummary")]
		public PathToMapOfMethodSnapshot ApiSummary { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PathToMapOfMethodSnapshot
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceUnavailableException
	{
	}
	
	/// <summary>
	/// A documentation part for a targeted API entity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentationPart
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public DocumentationPartLocation Location { get; set; }
		
		/// <summary>
		/// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., <code>"{ \"description\": \"The API does ...\" }"</code>. Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of <code>x-amazon-apigateway-documentation</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public object Properties { get; set; }
	}
	
	/// <summary>
	/// Specifies the target API entity to which the documentation applies.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentationPartLocation
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DocumentationPartType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public string StatusCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DocumentationPartType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHORIZER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODEL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOURCE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH_PARAMETER = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUERY_PARAMETER = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUEST_HEADER = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUEST_BODY = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESPONSE = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESPONSE_HEADER = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESPONSE_BODY = 11,
	}
	
	/// <summary>
	/// A snapshot of the documentation of an API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentationVersion
	{
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.DateTimeOffset CreatedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	/// <summary>
	/// Represents a custom domain name as a user-friendly host name of an API (RestApi).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DomainName
	{
		
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		public string DomainName1 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificateName")]
		public string CertificateName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificateArn")]
		public string CertificateArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificateUploadDate")]
		public System.DateTimeOffset CertificateUploadDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regionalDomainName")]
		public string RegionalDomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regionalHostedZoneId")]
		public string RegionalHostedZoneId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regionalCertificateName")]
		public string RegionalCertificateName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regionalCertificateArn")]
		public string RegionalCertificateArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="distributionDomainName")]
		public string DistributionDomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="distributionHostedZoneId")]
		public string DistributionHostedZoneId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpointConfiguration")]
		public EndpointConfiguration EndpointConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="domainNameStatus")]
		public DomainNameStatus DomainNameStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="domainNameStatusMessage")]
		public string DomainNameStatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public SecurityPolicy SecurityPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mutualTlsAuthentication")]
		public MutualTlsAuthentication MutualTlsAuthentication { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ownershipVerificationCertificateArn")]
		public string OwnershipVerificationCertificateArn { get; set; }
	}
	
	/// <summary>
	/// The endpoint configuration to indicate the types of endpoints an API (RestApi) or its custom domain name (DomainName) has. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EndpointConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="types")]
		public EndpointType[] Types { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vpcEndpointIds")]
		public string[] VpcEndpointIds { get; set; }
	}
	
	/// <summary>
	/// The endpoint type. The valid values are <code>EDGE</code> for edge-optimized API setup, most suitable for mobile applications; <code>REGIONAL</code> for regional API endpoint setup, most suitable for calling from AWS Region; and <code>PRIVATE</code> for private APIs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum EndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EDGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainNameStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_CERTIFICATE_REIMPORT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_OWNERSHIP_VERIFICATION = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SecurityPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS_1_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS_1_2 = 1,
	}
	
	/// <summary>
	/// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MutualTlsAuthentication
	{
		
		[System.Runtime.Serialization.DataMember(Name="truststoreUri")]
		public string TruststoreUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truststoreVersion")]
		public string TruststoreVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truststoreWarnings")]
		public string[] TruststoreWarnings { get; set; }
	}
	
	/// <summary>
	/// Represents the data structure of a method's request or response payload.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Model
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
	}
	
	/// <summary>
	/// A set of validation rules for incoming Method requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RequestValidator
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="validateRequestBody")]
		public System.Nullable<System.Boolean> ValidateRequestBody { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="validateRequestParameters")]
		public System.Nullable<System.Boolean> ValidateRequestParameters { get; set; }
	}
	
	/// <summary>
	/// Represents an API resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Resource
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="parentId")]
		public string ParentId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pathPart")]
		public string PathPart { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resourceMethods")]
		public MapOfMethod ResourceMethods { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfMethod
	{
	}
	
	/// <summary>
	/// Represents a REST API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RestApi
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.DateTimeOffset CreatedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public string[] Warnings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="binaryMediaTypes")]
		public string[] BinaryMediaTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minimumCompressionSize")]
		public System.Nullable<System.Int32> MinimumCompressionSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiKeySource")]
		public ApiKeySourceType ApiKeySource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpointConfiguration")]
		public EndpointConfiguration EndpointConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disableExecuteApiEndpoint")]
		public System.Nullable<System.Boolean> DisableExecuteApiEndpoint { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ApiKeySourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEADER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHORIZER = 1,
	}
	
	/// <summary>
	/// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Stage
	{
		
		[System.Runtime.Serialization.DataMember(Name="deploymentId")]
		public string DeploymentId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientCertificateId")]
		public string ClientCertificateId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageName")]
		public string StageName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheClusterEnabled")]
		public System.Nullable<System.Boolean> CacheClusterEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheClusterSize")]
		public CacheClusterSize CacheClusterSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheClusterStatus")]
		public CacheClusterStatus CacheClusterStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="methodSettings")]
		public MapOfMethodSettings MethodSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="variables")]
		public MapOfStringToString Variables { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="documentationVersion")]
		public string DocumentationVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="accessLogSettings")]
		public AccessLogSettings AccessLogSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="canarySettings")]
		public CanarySettings CanarySettings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tracingEnabled")]
		public System.Nullable<System.Boolean> TracingEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="webAclArn")]
		public string WebAclArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.DateTimeOffset CreatedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedDate")]
		public System.DateTimeOffset LastUpdatedDate { get; set; }
	}
	
	/// <summary>
	/// Returns the size of the CacheCluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CacheClusterSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0.5")]
		_0_5 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1.6")]
		_1_6 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6.1")]
		_6_1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="13.5")]
		_13_5 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="28.4")]
		_28_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="58.2")]
		_58_2 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="118")]
		_118 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="237")]
		_237 = 7,
	}
	
	/// <summary>
	/// Returns the status of the CacheCluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CacheClusterStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATE_IN_PROGRESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE_IN_PROGRESS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_AVAILABLE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FLUSH_IN_PROGRESS = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfMethodSettings
	{
	}
	
	/// <summary>
	/// Access log settings, including the access log format and access log destination ARN.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccessLogSettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationArn")]
		public string DestinationArn { get; set; }
	}
	
	/// <summary>
	/// Configuration settings of a canary deployment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CanarySettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="percentTraffic")]
		public System.Nullable<System.Double> PercentTraffic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deploymentId")]
		public string DeploymentId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageVariableOverrides")]
		public MapOfStringToString StageVariableOverrides { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="useStageCache")]
		public System.Nullable<System.Boolean> UseStageCache { get; set; }
	}
	
	/// <summary>
	/// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Don’t rely on usage plans to control costs. Consider using <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html">Amazon Web Services Budgets</a> to monitor costs and <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF</a> to manage API requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UsagePlan
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiStages")]
		public ApiStage[] ApiStages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="throttle")]
		public ThrottleSettings Throttle { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="quota")]
		public QuotaSettings Quota { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="productCode")]
		public string ProductCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	/// <summary>
	/// API stage name of the associated API stage in a usage plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ApiStage
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiId")]
		public string ApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stage")]
		public string Stage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="throttle")]
		public MapOfApiStageThrottleSettings Throttle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfApiStageThrottleSettings
	{
	}
	
	/// <summary>
	///  The API request rate limits.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ThrottleSettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="burstLimit")]
		public System.Nullable<System.Int32> BurstLimit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rateLimit")]
		public System.Nullable<System.Double> RateLimit { get; set; }
	}
	
	/// <summary>
	/// Quotas configured for a usage plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QuotaSettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="limit")]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="offset")]
		public System.Nullable<System.Int32> Offset { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="period")]
		public QuotaPeriodType Period { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum QuotaPeriodType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DAY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEEK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MONTH = 2,
	}
	
	/// <summary>
	/// Represents a usage plan key to identify a plan customer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UsagePlanKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VpcLink
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetArns")]
		public string[] TargetArns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public VpcLinkStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum VpcLinkStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
	}
	
	/// <summary>
	/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClientCertificate
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientCertificateId")]
		public string ClientCertificateId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pemEncodedCertificate")]
		public string PemEncodedCertificate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.DateTimeOffset CreatedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expirationDate")]
		public System.DateTimeOffset ExpirationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	/// <summary>
	/// Represents an AWS account that is associated with API Gateway.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Account
	{
		
		[System.Runtime.Serialization.DataMember(Name="cloudwatchRoleArn")]
		public string CloudwatchRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="throttleSettings")]
		public ThrottleSettings ThrottleSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="features")]
		public string[] Features { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiKeyVersion")]
		public string ApiKeyVersion { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of API keys as represented by an ApiKeys resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ApiKeys
	{
		
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public string[] Warnings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ApiKey[] Items { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of Authorizer resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Authorizers
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Authorizer[] Items { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of BasePathMapping resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BasePathMappings
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public BasePathMapping[] Items { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of ClientCertificate resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClientCertificates
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ClientCertificate[] Items { get; set; }
	}
	
	/// <summary>
	/// Represents a collection resource that contains zero or more references to your existing deployments, and links that guide you on how to interact with your collection. The collection offers a paginated view of the contained deployments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Deployments
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Deployment[] Items { get; set; }
	}
	
	/// <summary>
	/// The collection of documentation parts of an API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentationParts
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public DocumentationPart[] Items { get; set; }
	}
	
	/// <summary>
	/// The collection of documentation snapshots of an API. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentationVersions
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public DocumentationVersion[] Items { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of DomainName resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DomainNames
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public DomainName[] Items { get; set; }
	}
	
	/// <summary>
	/// The binary blob response to GetExport, which contains the generated SDK.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExportResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	/// <summary>
	/// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GatewayResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="responseType")]
		public GatewayResponseType ResponseType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public string StatusCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public MapOfStringToString ResponseParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseTemplates")]
		public MapOfStringToString ResponseTemplates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultResponse")]
		public System.Nullable<System.Boolean> DefaultResponse { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GatewayResponseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT_4XX = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT_5XX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOURCE_NOT_FOUND = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNAUTHORIZED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_API_KEY = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCESS_DENIED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHORIZER_FAILURE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHORIZER_CONFIGURATION_ERROR = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_SIGNATURE = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED_TOKEN = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MISSING_AUTHENTICATION_TOKEN = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTEGRATION_FAILURE = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTEGRATION_TIMEOUT = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_CONFIGURATION_ERROR = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSUPPORTED_MEDIA_TYPE = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BAD_REQUEST_PARAMETERS = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BAD_REQUEST_BODY = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUEST_TOO_LARGE = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THROTTLED = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUOTA_EXCEEDED = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WAF_FILTERED = 20,
	}
	
	/// <summary>
	/// The collection of the GatewayResponse instances of a RestApi as a <code>responseType</code>-to-GatewayResponse object map of key-value pairs. As such, pagination is not supported for querying this collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GatewayResponses
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public GatewayResponse[] Items { get; set; }
	}
	
	/// <summary>
	/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Integration
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public IntegrationType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpMethod")]
		public string HttpMethod { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="connectionType")]
		public ConnectionType ConnectionType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="credentials")]
		public string Credentials { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestParameters")]
		public MapOfStringToString RequestParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestTemplates")]
		public MapOfStringToString RequestTemplates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="passthroughBehavior")]
		public string PassthroughBehavior { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contentHandling")]
		public ContentHandlingStrategy ContentHandling { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeoutInMillis")]
		public System.Nullable<System.Int32> TimeoutInMillis { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheNamespace")]
		public string CacheNamespace { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheKeyParameters")]
		public string[] CacheKeyParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="integrationResponses")]
		public MapOfIntegrationResponse IntegrationResponses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tlsConfig")]
		public TlsConfig TlsConfig { get; set; }
	}
	
	/// <summary>
	/// The integration type. The valid value is <code>HTTP</code> for integrating an API method with an HTTP backend; <code>AWS</code> with any AWS service endpoints; <code>MOCK</code> for testing without actually invoking the backend; <code>HTTP_PROXY</code> for integrating with the HTTP proxy integration; <code>AWS_PROXY</code> for integrating with the Lambda proxy integration. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum IntegrationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MOCK = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP_PROXY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_PROXY = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNET = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC_LINK = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ContentHandlingStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONVERT_TO_BINARY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONVERT_TO_TEXT = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfIntegrationResponse
	{
	}
	
	/// <summary>
	/// Specifies the TLS configuration for an integration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TlsConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="insecureSkipVerification")]
		public System.Nullable<System.Boolean> InsecureSkipVerification { get; set; }
	}
	
	/// <summary>
	/// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IntegrationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public string StatusCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="selectionPattern")]
		public string SelectionPattern { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public MapOfStringToString ResponseParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseTemplates")]
		public MapOfStringToString ResponseTemplates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contentHandling")]
		public ContentHandlingStrategy ContentHandling { get; set; }
	}
	
	/// <summary>
	///  Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Method
	{
		
		[System.Runtime.Serialization.DataMember(Name="httpMethod")]
		public string HttpMethod { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizationType")]
		public string AuthorizationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerId")]
		public string AuthorizerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiKeyRequired")]
		public System.Nullable<System.Boolean> ApiKeyRequired { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestValidatorId")]
		public string RequestValidatorId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operationName")]
		public string OperationName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestParameters")]
		public MapOfStringToBoolean RequestParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestModels")]
		public MapOfStringToString RequestModels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="methodResponses")]
		public MapOfMethodResponse MethodResponses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="methodIntegration")]
		public Integration MethodIntegration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizationScopes")]
		public string[] AuthorizationScopes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfStringToBoolean
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfMethodResponse
	{
	}
	
	/// <summary>
	/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MethodResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public string StatusCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public MapOfStringToBoolean ResponseParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseModels")]
		public MapOfStringToString ResponseModels { get; set; }
	}
	
	/// <summary>
	/// Represents a mapping template used to transform a payload.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Template
	{
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of Model resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Models
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Model[] Items { get; set; }
	}
	
	/// <summary>
	/// A collection of RequestValidator resources of a given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RequestValidators
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public RequestValidator[] Items { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of Resource resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Resources
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Resource[] Items { get; set; }
	}
	
	/// <summary>
	/// Contains references to your APIs and links that guide you in how to interact with your collection. A collection offers a paginated view of your APIs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RestApis
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public RestApi[] Items { get; set; }
	}
	
	/// <summary>
	/// The binary blob response to GetSdk, which contains the generated SDK.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SdkResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	/// <summary>
	/// A type of SDK that API Gateway can generate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SdkType
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="friendlyName")]
		public string FriendlyName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="configurationProperties")]
		public SdkConfigurationProperty[] ConfigurationProperties { get; set; }
	}
	
	/// <summary>
	/// A configuration property of an SDK type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SdkConfigurationProperty
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="friendlyName")]
		public string FriendlyName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required")]
		public System.Nullable<System.Boolean> Required { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultValue")]
		public string DefaultValue { get; set; }
	}
	
	/// <summary>
	/// The collection of SdkType instances.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SdkTypes
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public SdkType[] Items { get; set; }
	}
	
	/// <summary>
	/// A list of Stage resources that are associated with the ApiKey resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Stages
	{
		
		[System.Runtime.Serialization.DataMember(Name="item")]
		public Stage[] Item { get; set; }
	}
	
	/// <summary>
	/// The collection of tags. Each tag element is associated with a given resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Tags
	{
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags1 { get; set; }
	}
	
	/// <summary>
	/// Represents the usage data of a usage plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Usage
	{
		
		[System.Runtime.Serialization.DataMember(Name="usagePlanId")]
		public string UsagePlanId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public string StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endDate")]
		public string EndDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public MapOfKeyUsages Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfKeyUsages
	{
	}
	
	/// <summary>
	/// Represents the collection of usage plan keys added to usage plans for the associated API keys and, possibly, other types of keys.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UsagePlanKeys
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public UsagePlanKey[] Items { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of usage plans for an AWS account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UsagePlans
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public UsagePlan[] Items { get; set; }
	}
	
	/// <summary>
	/// The collection of VPC links under the caller's account in a region.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VpcLinks
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public VpcLink[] Items { get; set; }
	}
	
	/// <summary>
	/// The identifier of an ApiKey used in a UsagePlan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ApiKeyIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public string[] Warnings { get; set; }
	}
	
	/// <summary>
	/// A collection of the imported DocumentationPart identifiers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentationPartIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public string[] Warnings { get; set; }
	}
	
	/// <summary>
	/// Represents the response of the test invoke request for a custom Authorizer
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestInvokeAuthorizerResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientStatus")]
		public System.Nullable<System.Int32> ClientStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="log")]
		public string Log { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latency")]
		public System.Nullable<System.Int32> Latency { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="principalId")]
		public string PrincipalId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorization")]
		public MapOfStringToList Authorization { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="claims")]
		public MapOfStringToString Claims { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfStringToList
	{
	}
	
	/// <summary>
	/// Represents the response of the test invoke request in the HTTP method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestInvokeMethodResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public MapOfStringToString Headers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="multiValueHeaders")]
		public MapOfStringToList MultiValueHeaders { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="log")]
		public string Log { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latency")]
		public System.Nullable<System.Int32> Latency { get; set; }
	}
	
	/// <summary>
	/// For more information about supported patch operations, see <a href="https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html">Patch Operations</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchOperation
	{
		
		[System.Runtime.Serialization.DataMember(Name="op")]
		public Op Op { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Op
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		add = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		remove = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replace = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		move = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		copy = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		test = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ApiKeysFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		csv = 0,
	}
	
	/// <summary>
	/// Request to create an ApiKey resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateApiKeyRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="generateDistinctId")]
		public System.Nullable<System.Boolean> GenerateDistinctId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageKeys")]
		public StageKey[] StageKeys { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="customerId")]
		public string CustomerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	/// <summary>
	/// Request to add a new Authorizer to an existing RestApi resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateAuthorizerRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public AuthorizerType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="providerARNs")]
		public string[] ProviderARNs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authType")]
		public string AuthType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerUri")]
		public string AuthorizerUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerCredentials")]
		public string AuthorizerCredentials { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="identitySource")]
		public string IdentitySource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="identityValidationExpression")]
		public string IdentityValidationExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerResultTtlInSeconds")]
		public System.Nullable<System.Int32> AuthorizerResultTtlInSeconds { get; set; }
	}
	
	/// <summary>
	/// Requests API Gateway to create a new BasePathMapping resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateBasePathMappingRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="basePath")]
		public string BasePath { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restApiId")]
		public string RestApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stage")]
		public string Stage { get; set; }
	}
	
	/// <summary>
	/// The input configuration for a canary deployment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeploymentCanarySettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="percentTraffic")]
		public System.Nullable<System.Double> PercentTraffic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageVariableOverrides")]
		public MapOfStringToString StageVariableOverrides { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="useStageCache")]
		public System.Nullable<System.Boolean> UseStageCache { get; set; }
	}
	
	/// <summary>
	/// Requests API Gateway to create a Deployment resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateDeploymentRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="stageName")]
		public string StageName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageDescription")]
		public string StageDescription { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheClusterEnabled")]
		public System.Nullable<System.Boolean> CacheClusterEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheClusterSize")]
		public CacheClusterSize CacheClusterSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="variables")]
		public MapOfStringToString Variables { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="canarySettings")]
		public DeploymentCanarySettings CanarySettings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tracingEnabled")]
		public System.Nullable<System.Boolean> TracingEnabled { get; set; }
	}
	
	/// <summary>
	/// Creates a new documentation part of a given API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateDocumentationPartRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public DocumentationPartLocation Location { get; set; }
		
		/// <summary>
		/// The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public object Properties { get; set; }
	}
	
	/// <summary>
	/// Creates a new documentation version of a given API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateDocumentationVersionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="documentationVersion")]
		public string DocumentationVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageName")]
		public string StageName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	/// <summary>
	/// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MutualTlsAuthenticationInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="truststoreUri")]
		public string TruststoreUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truststoreVersion")]
		public string TruststoreVersion { get; set; }
	}
	
	/// <summary>
	/// A request to create a new domain name.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateDomainNameRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		public string DomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificateName")]
		public string CertificateName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificateBody")]
		public string CertificateBody { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificatePrivateKey")]
		public string CertificatePrivateKey { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificateChain")]
		public string CertificateChain { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificateArn")]
		public string CertificateArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regionalCertificateName")]
		public string RegionalCertificateName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regionalCertificateArn")]
		public string RegionalCertificateArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpointConfiguration")]
		public EndpointConfiguration EndpointConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public SecurityPolicy SecurityPolicy { get; set; }
		
		/// <summary>
		/// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mutualTlsAuthentication")]
		public MutualTlsAuthenticationInput MutualTlsAuthentication { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ownershipVerificationCertificateArn")]
		public string OwnershipVerificationCertificateArn { get; set; }
	}
	
	/// <summary>
	/// Request to add a new Model to an existing RestApi resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateModelRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
	}
	
	/// <summary>
	/// Creates a RequestValidator of a given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateRequestValidatorRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="validateRequestBody")]
		public System.Nullable<System.Boolean> ValidateRequestBody { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="validateRequestParameters")]
		public System.Nullable<System.Boolean> ValidateRequestParameters { get; set; }
	}
	
	/// <summary>
	/// Requests API Gateway to create a Resource resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pathPart")]
		public string PathPart { get; set; }
	}
	
	/// <summary>
	/// The POST Request to add a new RestApi resource to your collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateRestApiRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cloneFrom")]
		public string CloneFrom { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="binaryMediaTypes")]
		public string[] BinaryMediaTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minimumCompressionSize")]
		public System.Nullable<System.Int32> MinimumCompressionSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiKeySource")]
		public ApiKeySourceType ApiKeySource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpointConfiguration")]
		public EndpointConfiguration EndpointConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disableExecuteApiEndpoint")]
		public System.Nullable<System.Boolean> DisableExecuteApiEndpoint { get; set; }
	}
	
	/// <summary>
	/// Requests API Gateway to create a Stage resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateStageRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stageName")]
		public string StageName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deploymentId")]
		public string DeploymentId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheClusterEnabled")]
		public System.Nullable<System.Boolean> CacheClusterEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheClusterSize")]
		public CacheClusterSize CacheClusterSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="variables")]
		public MapOfStringToString Variables { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="documentationVersion")]
		public string DocumentationVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="canarySettings")]
		public CanarySettings CanarySettings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tracingEnabled")]
		public System.Nullable<System.Boolean> TracingEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	/// <summary>
	/// The POST request to create a usage plan key for adding an existing API key to a usage plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateUsagePlanKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyId")]
		public string KeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyType")]
		public string KeyType { get; set; }
	}
	
	/// <summary>
	/// The POST request to create a usage plan with the name, description, throttle limits and quota limits, as well as the associated API stages, specified in the payload.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateUsagePlanRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiStages")]
		public ApiStage[] ApiStages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="throttle")]
		public ThrottleSettings Throttle { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="quota")]
		public QuotaSettings Quota { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	/// <summary>
	/// Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateVpcLinkRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetArns")]
		public string[] TargetArns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	/// <summary>
	/// A request to delete the ApiKey resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteApiKeyRequest
	{
	}
	
	/// <summary>
	/// Request to delete an existing Authorizer resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteAuthorizerRequest
	{
	}
	
	/// <summary>
	/// A request to delete the BasePathMapping resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteBasePathMappingRequest
	{
	}
	
	/// <summary>
	/// A request to delete the ClientCertificate resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteClientCertificateRequest
	{
	}
	
	/// <summary>
	/// Requests API Gateway to delete a Deployment resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteDeploymentRequest
	{
	}
	
	/// <summary>
	/// Deletes an existing documentation part of an API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteDocumentationPartRequest
	{
	}
	
	/// <summary>
	/// Deletes an existing documentation version of an API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteDocumentationVersionRequest
	{
	}
	
	/// <summary>
	/// A request to delete the DomainName resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteDomainNameRequest
	{
	}
	
	/// <summary>
	/// Clears any customization of a GatewayResponse of a specified response type on the given RestApi and resets it with the default settings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteGatewayResponseRequest
	{
	}
	
	/// <summary>
	/// Represents a delete integration request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteIntegrationRequest
	{
	}
	
	/// <summary>
	/// Represents a delete integration response request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteIntegrationResponseRequest
	{
	}
	
	/// <summary>
	/// Request to delete an existing Method resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteMethodRequest
	{
	}
	
	/// <summary>
	/// A request to delete an existing MethodResponse resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteMethodResponseRequest
	{
	}
	
	/// <summary>
	/// Request to delete an existing model in an existing RestApi resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteModelRequest
	{
	}
	
	/// <summary>
	/// Deletes a specified RequestValidator of a given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteRequestValidatorRequest
	{
	}
	
	/// <summary>
	/// Request to delete a Resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteResourceRequest
	{
	}
	
	/// <summary>
	/// Request to delete the specified API from your collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteRestApiRequest
	{
	}
	
	/// <summary>
	/// Requests API Gateway to delete a Stage resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteStageRequest
	{
	}
	
	/// <summary>
	/// The DELETE request to delete a usage plan key and remove the underlying API key from the associated usage plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteUsagePlanKeyRequest
	{
	}
	
	/// <summary>
	/// The DELETE request to delete a usage plan of a given plan Id.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteUsagePlanRequest
	{
	}
	
	/// <summary>
	/// Deletes an existing VpcLink of a specified identifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteVpcLinkRequest
	{
	}
	
	/// <summary>
	/// Request to flush authorizer cache entries on a specified stage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FlushStageAuthorizersCacheRequest
	{
	}
	
	/// <summary>
	/// Requests API Gateway to flush a stage's cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FlushStageCacheRequest
	{
	}
	
	/// <summary>
	/// A request to generate a ClientCertificate resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GenerateClientCertificateRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	/// <summary>
	/// Requests API Gateway to get information about the current Account resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetAccountRequest
	{
	}
	
	/// <summary>
	/// A request to get information about the current ApiKey resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetApiKeyRequest
	{
	}
	
	/// <summary>
	/// A request to get information about the current ApiKeys resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetApiKeysRequest
	{
	}
	
	/// <summary>
	/// Request to describe an existing Authorizer resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetAuthorizerRequest
	{
	}
	
	/// <summary>
	/// Request to describe an existing Authorizers resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetAuthorizersRequest
	{
	}
	
	/// <summary>
	/// Request to describe a BasePathMapping resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetBasePathMappingRequest
	{
	}
	
	/// <summary>
	/// A request to get information about a collection of BasePathMapping resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetBasePathMappingsRequest
	{
	}
	
	/// <summary>
	/// A request to get information about the current ClientCertificate resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetClientCertificateRequest
	{
	}
	
	/// <summary>
	/// A request to get information about a collection of ClientCertificate resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetClientCertificatesRequest
	{
	}
	
	/// <summary>
	/// Requests API Gateway to get information about a Deployment resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDeploymentRequest
	{
	}
	
	/// <summary>
	/// Requests API Gateway to get information about a Deployments collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDeploymentsRequest
	{
	}
	
	/// <summary>
	/// Gets a specified documentation part of a given API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentationPartRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LocationStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENTED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNDOCUMENTED = 1,
	}
	
	/// <summary>
	/// Gets the documentation parts of an API. The result may be filtered by the type, name, or path of API entities (targets).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentationPartsRequest
	{
	}
	
	/// <summary>
	/// Gets a documentation snapshot of an API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentationVersionRequest
	{
	}
	
	/// <summary>
	/// Gets the documentation versions of an API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentationVersionsRequest
	{
	}
	
	/// <summary>
	/// Request to get the name of a DomainName resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDomainNameRequest
	{
	}
	
	/// <summary>
	/// Request to describe a collection of DomainName resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDomainNamesRequest
	{
	}
	
	/// <summary>
	/// Request a new export of a RestApi for a particular Stage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetExportRequest
	{
	}
	
	/// <summary>
	/// Gets a GatewayResponse of a specified response type on the given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetGatewayResponseRequest
	{
	}
	
	/// <summary>
	/// Gets the GatewayResponses collection on the given RestApi. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default GatewayResponses collection for the supported response types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetGatewayResponsesRequest
	{
	}
	
	/// <summary>
	/// Represents a request to get the integration configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetIntegrationRequest
	{
	}
	
	/// <summary>
	/// Represents a get integration response request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetIntegrationResponseRequest
	{
	}
	
	/// <summary>
	/// Request to describe an existing Method resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetMethodRequest
	{
	}
	
	/// <summary>
	/// Request to describe a MethodResponse resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetMethodResponseRequest
	{
	}
	
	/// <summary>
	/// Request to list information about a model in an existing RestApi resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetModelRequest
	{
	}
	
	/// <summary>
	/// Request to generate a sample mapping template used to transform the payload.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetModelTemplateRequest
	{
	}
	
	/// <summary>
	/// Request to list existing Models defined for a RestApi resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetModelsRequest
	{
	}
	
	/// <summary>
	/// Gets a RequestValidator of a given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetRequestValidatorRequest
	{
	}
	
	/// <summary>
	/// Gets the RequestValidators collection of a given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetRequestValidatorsRequest
	{
	}
	
	/// <summary>
	/// Request to list information about a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetResourceRequest
	{
	}
	
	/// <summary>
	/// Request to list information about a collection of resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetResourcesRequest
	{
	}
	
	/// <summary>
	/// The GET request to list an existing RestApi defined for your collection. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetRestApiRequest
	{
	}
	
	/// <summary>
	/// The GET request to list existing RestApis defined for your collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetRestApisRequest
	{
	}
	
	/// <summary>
	/// Request a new generated client SDK for a RestApi and Stage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetSdkRequest
	{
	}
	
	/// <summary>
	/// Get an SdkType instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetSdkTypeRequest
	{
	}
	
	/// <summary>
	/// Get the SdkTypes collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetSdkTypesRequest
	{
	}
	
	/// <summary>
	/// Requests API Gateway to get information about a Stage resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStageRequest
	{
	}
	
	/// <summary>
	/// Requests API Gateway to get information about one or more Stage resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStagesRequest
	{
	}
	
	/// <summary>
	/// Gets the Tags collection for a given resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetTagsRequest
	{
	}
	
	/// <summary>
	/// The GET request to get a usage plan key of a given key identifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetUsagePlanKeyRequest
	{
	}
	
	/// <summary>
	/// The GET request to get all the usage plan keys representing the API keys added to a specified usage plan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetUsagePlanKeysRequest
	{
	}
	
	/// <summary>
	/// The GET request to get a usage plan of a given plan identifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetUsagePlanRequest
	{
	}
	
	/// <summary>
	/// The GET request to get all the usage plans of the caller's account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetUsagePlansRequest
	{
	}
	
	/// <summary>
	/// The GET request to get the usage data of a usage plan in a specified time interval.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetUsageRequest
	{
	}
	
	/// <summary>
	/// Gets a specified VPC link under the caller's account in a region.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetVpcLinkRequest
	{
	}
	
	/// <summary>
	/// Gets the VpcLinks collection under the caller's account in a selected region.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetVpcLinksRequest
	{
	}
	
	/// <summary>
	/// The POST request to import API keys from an external source, such as a CSV-formatted file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportApiKeysRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PutMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		merge = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		overwrite = 1,
	}
	
	/// <summary>
	/// Import documentation parts from an external (e.g., OpenAPI) definition file. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportDocumentationPartsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	/// <summary>
	/// A POST request to import an API to API Gateway using an input of an API definition file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportRestApiRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	/// <summary>
	/// Specifies the method setting properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MethodSetting
	{
		
		[System.Runtime.Serialization.DataMember(Name="metricsEnabled")]
		public System.Nullable<System.Boolean> MetricsEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="loggingLevel")]
		public string LoggingLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dataTraceEnabled")]
		public System.Nullable<System.Boolean> DataTraceEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="throttlingBurstLimit")]
		public System.Nullable<System.Int32> ThrottlingBurstLimit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="throttlingRateLimit")]
		public System.Nullable<System.Double> ThrottlingRateLimit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cachingEnabled")]
		public System.Nullable<System.Boolean> CachingEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheTtlInSeconds")]
		public System.Nullable<System.Int32> CacheTtlInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheDataEncrypted")]
		public System.Nullable<System.Boolean> CacheDataEncrypted { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requireAuthorizationForCacheControl")]
		public System.Nullable<System.Boolean> RequireAuthorizationForCacheControl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unauthorizedCacheControlHeaderStrategy")]
		public UnauthorizedCacheControlHeaderStrategy UnauthorizedCacheControlHeaderStrategy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UnauthorizedCacheControlHeaderStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAIL_WITH_403 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEED_WITH_RESPONSE_HEADER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEED_WITHOUT_RESPONSE_HEADER = 2,
	}
	
	/// <summary>
	/// Represents a summary of a Method resource, given a particular date and time.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MethodSnapshot
	{
		
		[System.Runtime.Serialization.DataMember(Name="authorizationType")]
		public string AuthorizationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiKeyRequired")]
		public System.Nullable<System.Boolean> ApiKeyRequired { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MapOfMethodSnapshot
	{
	}
	
	/// <summary>
	/// Creates a customization of a GatewayResponse of a specified response type and status code on the given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PutGatewayResponseRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public string StatusCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public MapOfStringToString ResponseParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseTemplates")]
		public MapOfStringToString ResponseTemplates { get; set; }
	}
	
	/// <summary>
	/// Sets up a method's integration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PutIntegrationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public IntegrationType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="integrationHttpMethod")]
		public string IntegrationHttpMethod { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="connectionType")]
		public ConnectionType ConnectionType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="credentials")]
		public string Credentials { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestParameters")]
		public MapOfStringToString RequestParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestTemplates")]
		public MapOfStringToString RequestTemplates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="passthroughBehavior")]
		public string PassthroughBehavior { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheNamespace")]
		public string CacheNamespace { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cacheKeyParameters")]
		public string[] CacheKeyParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contentHandling")]
		public ContentHandlingStrategy ContentHandling { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeoutInMillis")]
		public System.Nullable<System.Int32> TimeoutInMillis { get; set; }
		
		/// <summary>
		/// Specifies the TLS configuration for an integration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tlsConfig")]
		public TlsConfig TlsConfig { get; set; }
	}
	
	/// <summary>
	/// Represents a put integration response request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PutIntegrationResponseRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="selectionPattern")]
		public string SelectionPattern { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public MapOfStringToString ResponseParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseTemplates")]
		public MapOfStringToString ResponseTemplates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contentHandling")]
		public ContentHandlingStrategy ContentHandling { get; set; }
	}
	
	/// <summary>
	/// Request to add a method to an existing Resource resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PutMethodRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizationType")]
		public string AuthorizationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerId")]
		public string AuthorizerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiKeyRequired")]
		public System.Nullable<System.Boolean> ApiKeyRequired { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operationName")]
		public string OperationName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestParameters")]
		public MapOfStringToBoolean RequestParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestModels")]
		public MapOfStringToString RequestModels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestValidatorId")]
		public string RequestValidatorId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizationScopes")]
		public string[] AuthorizationScopes { get; set; }
	}
	
	/// <summary>
	/// Request to add a MethodResponse to an existing Method resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PutMethodResponseRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public MapOfStringToBoolean ResponseParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseModels")]
		public MapOfStringToString ResponseModels { get; set; }
	}
	
	/// <summary>
	/// A PUT request to update an existing API, with external API definitions specified as the request body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PutRestApiRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	/// <summary>
	/// Adds or updates a tag on a given resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public MapOfStringToString Tags { get; set; }
	}
	
	/// <summary>
	/// Make a request to simulate the invocation of an Authorizer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestInvokeAuthorizerRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public MapOfStringToString Headers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="multiValueHeaders")]
		public MapOfStringToList MultiValueHeaders { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pathWithQueryString")]
		public string PathWithQueryString { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageVariables")]
		public MapOfStringToString StageVariables { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="additionalContext")]
		public MapOfStringToString AdditionalContext { get; set; }
	}
	
	/// <summary>
	/// Make a request to simulate the invocation of a Method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestInvokeMethodRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="pathWithQueryString")]
		public string PathWithQueryString { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public MapOfStringToString Headers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="multiValueHeaders")]
		public MapOfStringToList MultiValueHeaders { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientCertificateId")]
		public string ClientCertificateId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageVariables")]
		public MapOfStringToString StageVariables { get; set; }
	}
	
	/// <summary>
	/// Removes a tag from a given resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UntagResourceRequest
	{
	}
	
	/// <summary>
	/// Requests API Gateway to change information about the current Account resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateAccountRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// A request to change information about an ApiKey resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateApiKeyRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Request to update an existing Authorizer resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateAuthorizerRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// A request to change information about the BasePathMapping resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateBasePathMappingRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// A request to change information about an ClientCertificate resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateClientCertificateRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Requests API Gateway to change information about a Deployment resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateDeploymentRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Updates an existing documentation part of a given API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateDocumentationPartRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Updates an existing documentation version of an API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateDocumentationVersionRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// A request to change information about the DomainName resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateDomainNameRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Updates a GatewayResponse of a specified response type on the given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateGatewayResponseRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Represents an update integration request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateIntegrationRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Represents an update integration response request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateIntegrationResponseRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Request to update an existing Method resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateMethodRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// A request to update an existing MethodResponse resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateMethodResponseRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Request to update an existing model in an existing RestApi resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateModelRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Updates a RequestValidator of a given RestApi.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateRequestValidatorRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Request to change information about a Resource resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateResourceRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Request to update an existing RestApi resource in your collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateRestApiRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Requests API Gateway to change information about a Stage resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateStageRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// The PATCH request to update a usage plan of a given plan Id.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateUsagePlanRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// The PATCH request to grant a temporary extension to the remaining quota of a usage plan associated with a specified API key.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateUsageRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	/// <summary>
	/// Updates an existing VpcLink of a specified identifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateVpcLinkRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Create an ApiKey resource.
		/// CreateApiKey apikeys
		/// </summary>
		public async Task CreateApiKeyAsync(CreateApiKeyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apikeys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about the current ApiKeys resource.
		/// GetApiKeys apikeys
		/// </summary>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <param name="name">The name of queried API keys.</param>
		/// <param name="customerId">The identifier of a customer in AWS Marketplace or an external system, such as a developer portal.</param>
		/// <param name="includeValues">A boolean flag to specify whether (<code>true</code>) or not (<code>false</code>) the result contains key values.</param>
		/// <returns>Success</returns>
		public async Task<ApiKeys> GetApiKeysAsync(string position, int limit, string name, string customerId, bool includeValues, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apikeys?position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&customerId=" + (customerId==null? "" : System.Uri.EscapeDataString(customerId))+"&includeValues="+includeValues;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKeys>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a new Authorizer resource to an existing RestApi resource.
		/// CreateAuthorizer restapis/{restapi_id}/authorizers
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		public async Task CreateAuthorizerAsync(string restapi_id, CreateAuthorizerPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/authorizers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describe an existing Authorizers resource.
		/// GetAuthorizers restapis/{restapi_id}/authorizers
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<Authorizers> GetAuthorizersAsync(string restapi_id, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/authorizers&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Authorizers>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new BasePathMapping resource.
		/// CreateBasePathMapping domainnames/{domain_name}/basepathmappings
		/// </summary>
		/// <param name="domain_name">The domain name of the BasePathMapping resource to create.</param>
		public async Task CreateBasePathMappingAsync(string domain_name, CreateBasePathMappingPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames/"+ (domain_name==null? "" : System.Uri.EscapeDataString(domain_name))+"/basepathmappings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents a collection of BasePathMapping resources.
		/// GetBasePathMappings domainnames/{domain_name}/basepathmappings
		/// </summary>
		/// <param name="domain_name">The domain name of a BasePathMapping resource.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<BasePathMappings> GetBasePathMappingsAsync(string domain_name, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames/"+ (domain_name==null? "" : System.Uri.EscapeDataString(domain_name))+"/basepathmappings&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BasePathMappings>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a Deployment resource, which makes a specified RestApi callable over the internet.
		/// CreateDeployment restapis/{restapi_id}/deployments
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		public async Task CreateDeploymentAsync(string restapi_id, CreateDeploymentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/deployments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a Deployments collection.
		/// GetDeployments restapis/{restapi_id}/deployments
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<Deployments> GetDeploymentsAsync(string restapi_id, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/deployments&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deployments>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a documentation part.
		/// CreateDocumentationPart restapis/{restapi_id}/documentation/parts
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		public async Task CreateDocumentationPartAsync(string restapi_id, CreateDocumentationPartPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/parts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets documentation parts.
		/// GetDocumentationParts restapis/{restapi_id}/documentation/parts
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="type">The type of API entities of the to-be-retrieved documentation parts. </param>
		/// <param name="name">The name of API entities of the to-be-retrieved documentation parts.</param>
		/// <param name="path">The path of API entities of the to-be-retrieved documentation parts.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <param name="locationStatus">The status of the API documentation parts to retrieve. Valid values are <code>DOCUMENTED</code> for retrieving DocumentationPart resources with content and <code>UNDOCUMENTED</code> for DocumentationPart resources without content.</param>
		/// <returns>Success</returns>
		public async Task<DocumentationParts> GetDocumentationPartsAsync(string restapi_id, DocumentationPartType type, string name, string path, string position, int limit, LocationStatusType locationStatus, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/parts&type=" + type+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit+"&locationStatus=" + locationStatus;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DocumentationParts>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Imports documentation parts
		/// ImportDocumentationParts restapis/{restapi_id}/documentation/parts
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="mode">A query parameter to indicate whether to overwrite (<code>OVERWRITE</code>) any existing DocumentationParts definition or to merge (<code>MERGE</code>) the new definition into the existing one. The default value is <code>MERGE</code>.</param>
		/// <param name="failonwarnings">A query parameter to specify whether to rollback the documentation importation (<code>true</code>) or not (<code>false</code>) when a warning is encountered. The default value is <code>false</code>.</param>
		/// <returns>Success</returns>
		public async Task<DocumentationPartIds> ImportDocumentationPartsAsync(string restapi_id, PutMode mode, bool failonwarnings, ImportDocumentationPartsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/parts&mode=" + mode+"&failonwarnings="+failonwarnings;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DocumentationPartIds>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a documentation version
		/// CreateDocumentationVersion restapis/{restapi_id}/documentation/versions
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		public async Task CreateDocumentationVersionAsync(string restapi_id, CreateDocumentationVersionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/versions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets documentation versions.
		/// GetDocumentationVersions restapis/{restapi_id}/documentation/versions
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<DocumentationVersions> GetDocumentationVersionsAsync(string restapi_id, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/versions&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DocumentationVersions>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new domain name.
		/// CreateDomainName domainnames
		/// </summary>
		public async Task CreateDomainNameAsync(CreateDomainNamePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents a collection of DomainName resources.
		/// GetDomainNames domainnames
		/// </summary>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<DomainNames> GetDomainNamesAsync(string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames?position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DomainNames>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a new Model resource to an existing RestApi resource.
		/// CreateModel restapis/{restapi_id}/models
		/// </summary>
		/// <param name="restapi_id">The RestApi identifier under which the Model will be created.</param>
		public async Task CreateModelAsync(string restapi_id, CreateModelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/models";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes existing Models defined for a RestApi resource.
		/// GetModels restapis/{restapi_id}/models
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<Models> GetModelsAsync(string restapi_id, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/models&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Models>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a RequestValidator of a given RestApi.
		/// CreateRequestValidator restapis/{restapi_id}/requestvalidators
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		public async Task CreateRequestValidatorAsync(string restapi_id, CreateRequestValidatorPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/requestvalidators";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the RequestValidators collection of a given RestApi.
		/// GetRequestValidators restapis/{restapi_id}/requestvalidators
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<RequestValidators> GetRequestValidatorsAsync(string restapi_id, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/requestvalidators&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RequestValidators>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a Resource resource.
		/// CreateResource restapis/{restapi_id}/resources/{parent_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="parent_id">The parent resource's identifier.</param>
		public async Task CreateResourceAsync(string restapi_id, string parent_id, CreateResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (parent_id==null? "" : System.Uri.EscapeDataString(parent_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new RestApi resource.
		/// CreateRestApi restapis
		/// </summary>
		public async Task CreateRestApiAsync(CreateRestApiPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the RestApis resources for your collection.
		/// GetRestApis restapis
		/// </summary>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<RestApis> GetRestApisAsync(string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis?position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RestApis>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new Stage resource that references a pre-existing Deployment for the API.
		/// CreateStage restapis/{restapi_id}/stages
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		public async Task CreateStageAsync(string restapi_id, CreateStagePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about one or more Stage resources.
		/// GetStages restapis/{restapi_id}/stages
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="deploymentId">The stages' deployment identifiers.</param>
		/// <returns>Success</returns>
		public async Task<Stages> GetStagesAsync(string restapi_id, string deploymentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages&deploymentId=" + (deploymentId==null? "" : System.Uri.EscapeDataString(deploymentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Stages>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a usage plan with the throttle and quota limits, as well as the associated API stages, specified in the payload.
		/// CreateUsagePlan usageplans
		/// </summary>
		public async Task CreateUsagePlanAsync(CreateUsagePlanPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all the usage plans of the caller's account.
		/// GetUsagePlans usageplans
		/// </summary>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="keyId">The identifier of the API key associated with the usage plans.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<UsagePlans> GetUsagePlansAsync(string position, string keyId, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans?position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&keyId=" + (keyId==null? "" : System.Uri.EscapeDataString(keyId))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UsagePlans>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a usage plan key for adding an existing API key to a usage plan.
		/// CreateUsagePlanKey usageplans/{usageplanId}/keys
		/// </summary>
		/// <param name="usageplanId">The Id of the UsagePlan resource representing the usage plan containing the to-be-created UsagePlanKey resource representing a plan customer.</param>
		public async Task CreateUsagePlanKeyAsync(string usageplanId, CreateUsagePlanKeyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId))+"/keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all the usage plan keys representing the API keys added to a specified usage plan.
		/// GetUsagePlanKeys usageplans/{usageplanId}/keys
		/// </summary>
		/// <param name="usageplanId">The Id of the UsagePlan resource representing the usage plan containing the to-be-retrieved UsagePlanKey resource representing a plan customer.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <param name="name">A query parameter specifying the name of the to-be-returned usage plan keys.</param>
		/// <returns>Success</returns>
		public async Task<UsagePlanKeys> GetUsagePlanKeysAsync(string usageplanId, string position, int limit, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId))+"/keys&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UsagePlanKeys>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.
		/// CreateVpcLink vpclinks
		/// </summary>
		public async Task CreateVpcLinkAsync(CreateVpcLinkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vpclinks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the VpcLinks collection under the caller's account in a selected region.
		/// GetVpcLinks vpclinks
		/// </summary>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<VpcLinks> GetVpcLinksAsync(string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vpclinks?position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<VpcLinks>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the ApiKey resource.
		/// DeleteApiKey apikeys/{api_Key}
		/// </summary>
		/// <param name="api_Key">The identifier of the ApiKey resource to be deleted.</param>
		public async Task DeleteApiKeyAsync(string api_Key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apikeys/"+ (api_Key==null? "" : System.Uri.EscapeDataString(api_Key));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about the current ApiKey resource.
		/// GetApiKey apikeys/{api_Key}
		/// </summary>
		/// <param name="api_Key">The identifier of the ApiKey resource.</param>
		/// <param name="includeValue">A boolean flag to specify whether (<code>true</code>) or not (<code>false</code>) the result contains the key value.</param>
		/// <returns>Success</returns>
		public async Task<ApiKey> GetApiKeyAsync(string api_Key, bool includeValue, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apikeys/"+ (api_Key==null? "" : System.Uri.EscapeDataString(api_Key))+"&includeValue="+includeValue;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about an ApiKey resource.
		/// UpdateApiKey apikeys/{api_Key}
		/// </summary>
		/// <param name="api_Key">The identifier of the ApiKey resource to be updated.</param>
		/// <returns>Success</returns>
		public async Task<ApiKey> UpdateApiKeyAsync(string api_Key, UpdateApiKeyPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apikeys/"+ (api_Key==null? "" : System.Uri.EscapeDataString(api_Key));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing Authorizer resource.
		/// DeleteAuthorizer restapis/{restapi_id}/authorizers/{authorizer_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="authorizer_id">The identifier of the Authorizer resource.</param>
		public async Task DeleteAuthorizerAsync(string restapi_id, string authorizer_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/authorizers/"+ (authorizer_id==null? "" : System.Uri.EscapeDataString(authorizer_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describe an existing Authorizer resource.
		/// GetAuthorizer restapis/{restapi_id}/authorizers/{authorizer_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="authorizer_id">The identifier of the Authorizer resource.</param>
		/// <returns>Success</returns>
		public async Task<Authorizer> GetAuthorizerAsync(string restapi_id, string authorizer_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/authorizers/"+ (authorizer_id==null? "" : System.Uri.EscapeDataString(authorizer_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Authorizer>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Simulate the execution of an Authorizer in your RestApi with headers, parameters, and an incoming request body.
		/// TestInvokeAuthorizer restapis/{restapi_id}/authorizers/{authorizer_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="authorizer_id">Specifies a test invoke authorizer request's Authorizer ID.</param>
		/// <returns>Success</returns>
		public async Task<TestInvokeAuthorizerResponse> TestInvokeAuthorizerAsync(string restapi_id, string authorizer_id, TestInvokeAuthorizerPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/authorizers/"+ (authorizer_id==null? "" : System.Uri.EscapeDataString(authorizer_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestInvokeAuthorizerResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing Authorizer resource.
		/// UpdateAuthorizer restapis/{restapi_id}/authorizers/{authorizer_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="authorizer_id">The identifier of the Authorizer resource.</param>
		/// <returns>Success</returns>
		public async Task<Authorizer> UpdateAuthorizerAsync(string restapi_id, string authorizer_id, UpdateAuthorizerPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/authorizers/"+ (authorizer_id==null? "" : System.Uri.EscapeDataString(authorizer_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Authorizer>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the BasePathMapping resource.
		/// DeleteBasePathMapping domainnames/{domain_name}/basepathmappings/{base_path}
		/// </summary>
		/// <param name="domain_name">The domain name of the BasePathMapping resource to delete.</param>
		/// <param name="base_path"><p>The base path name of the BasePathMapping resource to delete.</p> <p>To specify an empty base path, set this parameter to <code>'(none)'</code>.</p></param>
		public async Task DeleteBasePathMappingAsync(string domain_name, string base_path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames/"+ (domain_name==null? "" : System.Uri.EscapeDataString(domain_name))+"/basepathmappings/"+ (base_path==null? "" : System.Uri.EscapeDataString(base_path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describe a BasePathMapping resource.
		/// GetBasePathMapping domainnames/{domain_name}/basepathmappings/{base_path}
		/// </summary>
		/// <param name="domain_name">The domain name of the BasePathMapping resource to be described.</param>
		/// <param name="base_path">The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify any base path name after the domain name.</param>
		/// <returns>Success</returns>
		public async Task<BasePathMapping> GetBasePathMappingAsync(string domain_name, string base_path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames/"+ (domain_name==null? "" : System.Uri.EscapeDataString(domain_name))+"/basepathmappings/"+ (base_path==null? "" : System.Uri.EscapeDataString(base_path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BasePathMapping>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about the BasePathMapping resource.
		/// UpdateBasePathMapping domainnames/{domain_name}/basepathmappings/{base_path}
		/// </summary>
		/// <param name="domain_name">The domain name of the BasePathMapping resource to change.</param>
		/// <param name="base_path"><p>The base path of the BasePathMapping resource to change.</p> <p>To specify an empty base path, set this parameter to <code>'(none)'</code>.</p></param>
		/// <returns>Success</returns>
		public async Task<BasePathMapping> UpdateBasePathMappingAsync(string domain_name, string base_path, UpdateBasePathMappingPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames/"+ (domain_name==null? "" : System.Uri.EscapeDataString(domain_name))+"/basepathmappings/"+ (base_path==null? "" : System.Uri.EscapeDataString(base_path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BasePathMapping>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the ClientCertificate resource.
		/// DeleteClientCertificate clientcertificates/{clientcertificate_id}
		/// </summary>
		/// <param name="clientcertificate_id">The identifier of the ClientCertificate resource to be deleted.</param>
		public async Task DeleteClientCertificateAsync(string clientcertificate_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "clientcertificates/"+ (clientcertificate_id==null? "" : System.Uri.EscapeDataString(clientcertificate_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about the current ClientCertificate resource.
		/// GetClientCertificate clientcertificates/{clientcertificate_id}
		/// </summary>
		/// <param name="clientcertificate_id">The identifier of the ClientCertificate resource to be described.</param>
		/// <returns>Success</returns>
		public async Task<ClientCertificate> GetClientCertificateAsync(string clientcertificate_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "clientcertificates/"+ (clientcertificate_id==null? "" : System.Uri.EscapeDataString(clientcertificate_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ClientCertificate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about an ClientCertificate resource.
		/// UpdateClientCertificate clientcertificates/{clientcertificate_id}
		/// </summary>
		/// <param name="clientcertificate_id">The identifier of the ClientCertificate resource to be updated.</param>
		/// <returns>Success</returns>
		public async Task<ClientCertificate> UpdateClientCertificateAsync(string clientcertificate_id, UpdateClientCertificatePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "clientcertificates/"+ (clientcertificate_id==null? "" : System.Uri.EscapeDataString(clientcertificate_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ClientCertificate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a Deployment resource. Deleting a deployment will only succeed if there are no Stage resources associated with it.
		/// DeleteDeployment restapis/{restapi_id}/deployments/{deployment_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="deployment_id">The identifier of the Deployment resource to delete.</param>
		public async Task DeleteDeploymentAsync(string restapi_id, string deployment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/deployments/"+ (deployment_id==null? "" : System.Uri.EscapeDataString(deployment_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a Deployment resource.
		/// GetDeployment restapis/{restapi_id}/deployments/{deployment_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="deployment_id">The identifier of the Deployment resource to get information about.</param>
		/// <param name="embed">A query parameter to retrieve the specified embedded resources of the returned Deployment resource in the response. In a REST API call, this <code>embed</code> parameter value is a list of comma-separated strings, as in <code>GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=var1,var2</code>. The SDK and other platform-dependent libraries might use a different format for the list. Currently, this request supports only retrieval of the embedded API summary this way. Hence, the parameter value must be a single-valued list containing only the <code>"apisummary"</code> string. For example, <code>GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=apisummary</code>.</param>
		/// <returns>Success</returns>
		public async Task<Deployment> GetDeploymentAsync(string restapi_id, string deployment_id, string[] embed, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/deployments/"+ (deployment_id==null? "" : System.Uri.EscapeDataString(deployment_id))+"&"+string.Join("&", embed.Select(z => $"embed={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deployment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about a Deployment resource.
		/// UpdateDeployment restapis/{restapi_id}/deployments/{deployment_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="deployment_id">The replacement identifier for the Deployment resource to change information about.</param>
		/// <returns>Success</returns>
		public async Task<Deployment> UpdateDeploymentAsync(string restapi_id, string deployment_id, UpdateDeploymentPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/deployments/"+ (deployment_id==null? "" : System.Uri.EscapeDataString(deployment_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deployment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a documentation part
		/// DeleteDocumentationPart restapis/{restapi_id}/documentation/parts/{part_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="part_id">The identifier of the to-be-deleted documentation part.</param>
		public async Task DeleteDocumentationPartAsync(string restapi_id, string part_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/parts/"+ (part_id==null? "" : System.Uri.EscapeDataString(part_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a documentation part.
		/// GetDocumentationPart restapis/{restapi_id}/documentation/parts/{part_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="part_id">The string identifier of the associated RestApi.</param>
		/// <returns>Success</returns>
		public async Task<DocumentationPart> GetDocumentationPartAsync(string restapi_id, string part_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/parts/"+ (part_id==null? "" : System.Uri.EscapeDataString(part_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DocumentationPart>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a documentation part.
		/// UpdateDocumentationPart restapis/{restapi_id}/documentation/parts/{part_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="part_id">The identifier of the to-be-updated documentation part.</param>
		/// <returns>Success</returns>
		public async Task<DocumentationPart> UpdateDocumentationPartAsync(string restapi_id, string part_id, UpdateDocumentationPartPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/parts/"+ (part_id==null? "" : System.Uri.EscapeDataString(part_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DocumentationPart>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a documentation version.
		/// DeleteDocumentationVersion restapis/{restapi_id}/documentation/versions/{doc_version}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="doc_version">The version identifier of a to-be-deleted documentation snapshot.</param>
		public async Task DeleteDocumentationVersionAsync(string restapi_id, string doc_version, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/versions/"+ (doc_version==null? "" : System.Uri.EscapeDataString(doc_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a documentation version.
		/// GetDocumentationVersion restapis/{restapi_id}/documentation/versions/{doc_version}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="doc_version">The version identifier of the to-be-retrieved documentation snapshot.</param>
		/// <returns>Success</returns>
		public async Task<DocumentationVersion> GetDocumentationVersionAsync(string restapi_id, string doc_version, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/versions/"+ (doc_version==null? "" : System.Uri.EscapeDataString(doc_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DocumentationVersion>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a documentation version.
		/// UpdateDocumentationVersion restapis/{restapi_id}/documentation/versions/{doc_version}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi..</param>
		/// <param name="doc_version">The version identifier of the to-be-updated documentation version.</param>
		/// <returns>Success</returns>
		public async Task<DocumentationVersion> UpdateDocumentationVersionAsync(string restapi_id, string doc_version, UpdateDocumentationVersionPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/documentation/versions/"+ (doc_version==null? "" : System.Uri.EscapeDataString(doc_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DocumentationVersion>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the DomainName resource.
		/// DeleteDomainName domainnames/{domain_name}
		/// </summary>
		/// <param name="domain_name">The name of the DomainName resource to be deleted.</param>
		public async Task DeleteDomainNameAsync(string domain_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames/"+ (domain_name==null? "" : System.Uri.EscapeDataString(domain_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents a domain name that is contained in a simpler, more intuitive URL that can be called.
		/// GetDomainName domainnames/{domain_name}
		/// </summary>
		/// <param name="domain_name">The name of the DomainName resource.</param>
		/// <returns>Success</returns>
		public async Task<DomainName> GetDomainNameAsync(string domain_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames/"+ (domain_name==null? "" : System.Uri.EscapeDataString(domain_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DomainName>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about the DomainName resource.
		/// UpdateDomainName domainnames/{domain_name}
		/// </summary>
		/// <param name="domain_name">The name of the DomainName resource to be changed.</param>
		/// <returns>Success</returns>
		public async Task<DomainName> UpdateDomainNameAsync(string domain_name, UpdateDomainNamePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domainnames/"+ (domain_name==null? "" : System.Uri.EscapeDataString(domain_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DomainName>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Clears any customization of a GatewayResponse of a specified response type on the given RestApi and resets it with the default settings.
		/// DeleteGatewayResponse restapis/{restapi_id}/gatewayresponses/{response_type}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="response_type">The response type of the associated GatewayResponse.</param>
		public async Task DeleteGatewayResponseAsync(string restapi_id, GatewayResponseType response_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/gatewayresponses/"+response_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a GatewayResponse of a specified response type on the given RestApi.
		/// GetGatewayResponse restapis/{restapi_id}/gatewayresponses/{response_type}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="response_type">The response type of the associated GatewayResponse.</param>
		/// <returns>Success</returns>
		public async Task<GatewayResponse> GetGatewayResponseAsync(string restapi_id, GatewayResponseType response_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/gatewayresponses/"+response_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GatewayResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a customization of a GatewayResponse of a specified response type and status code on the given RestApi.
		/// PutGatewayResponse restapis/{restapi_id}/gatewayresponses/{response_type}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="response_type">The response type of the associated GatewayResponse</param>
		public async Task PutGatewayResponseAsync(string restapi_id, GatewayResponseType response_type, PutGatewayResponsePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/gatewayresponses/"+response_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a GatewayResponse of a specified response type on the given RestApi.
		/// UpdateGatewayResponse restapis/{restapi_id}/gatewayresponses/{response_type}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="response_type">The response type of the associated GatewayResponse.</param>
		/// <returns>Success</returns>
		public async Task<GatewayResponse> UpdateGatewayResponseAsync(string restapi_id, GatewayResponseType response_type, UpdateGatewayResponsePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/gatewayresponses/"+response_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GatewayResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents a delete integration.
		/// DeleteIntegration restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Specifies a delete integration request's resource identifier.</param>
		/// <param name="http_method">Specifies a delete integration request's HTTP method.</param>
		public async Task DeleteIntegrationAsync(string restapi_id, string resource_id, string http_method, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/integration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the integration settings.
		/// GetIntegration restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Specifies a get integration request's resource identifier</param>
		/// <param name="http_method">Specifies a get integration request's HTTP method.</param>
		/// <returns>Success</returns>
		public async Task<Integration> GetIntegrationAsync(string restapi_id, string resource_id, string http_method, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/integration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Integration>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets up a method's integration.
		/// PutIntegration restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Specifies a put integration request's resource ID.</param>
		/// <param name="http_method">Specifies the HTTP method for the integration.</param>
		public async Task PutIntegrationAsync(string restapi_id, string resource_id, string http_method, PutIntegrationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/integration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents an update integration.
		/// UpdateIntegration restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Represents an update integration request's resource identifier.</param>
		/// <param name="http_method">Represents an update integration request's HTTP method.</param>
		/// <returns>Success</returns>
		public async Task<Integration> UpdateIntegrationAsync(string restapi_id, string resource_id, string http_method, UpdateIntegrationPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/integration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Integration>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents a delete integration response.
		/// DeleteIntegrationResponse restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Specifies a delete integration response request's resource identifier.</param>
		/// <param name="http_method">Specifies a delete integration response request's HTTP method.</param>
		/// <param name="status_code">Specifies a delete integration response request's status code.</param>
		public async Task DeleteIntegrationResponseAsync(string restapi_id, string resource_id, string http_method, string status_code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/integration/responses/"+ (status_code==null? "" : System.Uri.EscapeDataString(status_code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents a get integration response.
		/// GetIntegrationResponse restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Specifies a get integration response request's resource identifier.</param>
		/// <param name="http_method">Specifies a get integration response request's HTTP method.</param>
		/// <param name="status_code">Specifies a get integration response request's status code.</param>
		/// <returns>Success</returns>
		public async Task<IntegrationResponse> GetIntegrationResponseAsync(string restapi_id, string resource_id, string http_method, string status_code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/integration/responses/"+ (status_code==null? "" : System.Uri.EscapeDataString(status_code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IntegrationResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents a put integration.
		/// PutIntegrationResponse restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Specifies a put integration response request's resource identifier.</param>
		/// <param name="http_method">Specifies a put integration response request's HTTP method.</param>
		/// <param name="status_code">Specifies the status code that is used to map the integration response to an existing MethodResponse.</param>
		public async Task PutIntegrationResponseAsync(string restapi_id, string resource_id, string http_method, string status_code, PutIntegrationResponsePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/integration/responses/"+ (status_code==null? "" : System.Uri.EscapeDataString(status_code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Represents an update integration response.
		/// UpdateIntegrationResponse restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Specifies an update integration response request's resource identifier.</param>
		/// <param name="http_method">Specifies an update integration response request's HTTP method.</param>
		/// <param name="status_code">Specifies an update integration response request's status code.</param>
		/// <returns>Success</returns>
		public async Task<IntegrationResponse> UpdateIntegrationResponseAsync(string restapi_id, string resource_id, string http_method, string status_code, UpdateIntegrationResponsePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/integration/responses/"+ (status_code==null? "" : System.Uri.EscapeDataString(status_code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IntegrationResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing Method resource.
		/// DeleteMethod restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The Resource identifier for the Method resource.</param>
		/// <param name="http_method">The HTTP verb of the Method resource.</param>
		public async Task DeleteMethodAsync(string restapi_id, string resource_id, string http_method, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describe an existing Method resource.
		/// GetMethod restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The Resource identifier for the Method resource.</param>
		/// <param name="http_method">Specifies the method request's HTTP method type.</param>
		/// <returns>Success</returns>
		public async Task<Method> GetMethodAsync(string restapi_id, string resource_id, string http_method, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Method>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a method to an existing Resource resource.
		/// PutMethod restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The Resource identifier for the new Method resource.</param>
		/// <param name="http_method">Specifies the method request's HTTP method type.</param>
		public async Task PutMethodAsync(string restapi_id, string resource_id, string http_method, PutMethodPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Simulate the invocation of a Method in your RestApi with headers, parameters, and an incoming request body.
		/// TestInvokeMethod restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">Specifies a test invoke method request's resource ID.</param>
		/// <param name="http_method">Specifies a test invoke method request's HTTP method.</param>
		/// <returns>Success</returns>
		public async Task<TestInvokeMethodResponse> TestInvokeMethodAsync(string restapi_id, string resource_id, string http_method, TestInvokeMethodPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestInvokeMethodResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing Method resource.
		/// UpdateMethod restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The Resource identifier for the Method resource.</param>
		/// <param name="http_method">The HTTP verb of the Method resource.</param>
		/// <returns>Success</returns>
		public async Task<Method> UpdateMethodAsync(string restapi_id, string resource_id, string http_method, UpdateMethodPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Method>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing MethodResponse resource.
		/// DeleteMethodResponse restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The Resource identifier for the MethodResponse resource.</param>
		/// <param name="http_method">The HTTP verb of the Method resource.</param>
		/// <param name="status_code">The status code identifier for the MethodResponse resource.</param>
		public async Task DeleteMethodResponseAsync(string restapi_id, string resource_id, string http_method, string status_code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/responses/"+ (status_code==null? "" : System.Uri.EscapeDataString(status_code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes a MethodResponse resource.
		/// GetMethodResponse restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The Resource identifier for the MethodResponse resource.</param>
		/// <param name="http_method">The HTTP verb of the Method resource.</param>
		/// <param name="status_code">The status code for the MethodResponse resource.</param>
		/// <returns>Success</returns>
		public async Task<MethodResponse> GetMethodResponseAsync(string restapi_id, string resource_id, string http_method, string status_code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/responses/"+ (status_code==null? "" : System.Uri.EscapeDataString(status_code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<MethodResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a MethodResponse to an existing Method resource.
		/// PutMethodResponse restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The Resource identifier for the Method resource.</param>
		/// <param name="http_method">The HTTP verb of the Method resource.</param>
		/// <param name="status_code">The method response's status code.</param>
		public async Task PutMethodResponseAsync(string restapi_id, string resource_id, string http_method, string status_code, PutMethodResponsePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/responses/"+ (status_code==null? "" : System.Uri.EscapeDataString(status_code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing MethodResponse resource.
		/// UpdateMethodResponse restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The Resource identifier for the MethodResponse resource.</param>
		/// <param name="http_method">The HTTP verb of the Method resource.</param>
		/// <param name="status_code">The status code for the MethodResponse resource.</param>
		public async Task UpdateMethodResponseAsync(string restapi_id, string resource_id, string http_method, string status_code, UpdateMethodResponsePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"/methods/"+ (http_method==null? "" : System.Uri.EscapeDataString(http_method))+"/responses/"+ (status_code==null? "" : System.Uri.EscapeDataString(status_code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a model.
		/// DeleteModel restapis/{restapi_id}/models/{model_name}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="model_name">The name of the model to delete.</param>
		public async Task DeleteModelAsync(string restapi_id, string model_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/models/"+ (model_name==null? "" : System.Uri.EscapeDataString(model_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes an existing model defined for a RestApi resource.
		/// GetModel restapis/{restapi_id}/models/{model_name}
		/// </summary>
		/// <param name="restapi_id">The RestApi identifier under which the Model exists.</param>
		/// <param name="model_name">The name of the model as an identifier.</param>
		/// <param name="flatten">A query parameter of a Boolean value to resolve (<code>true</code>) all external model references and returns a flattened model schema or not (<code>false</code>) The default is <code>false</code>.</param>
		/// <returns>Success</returns>
		public async Task<Model> GetModelAsync(string restapi_id, string model_name, bool flatten, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/models/"+ (model_name==null? "" : System.Uri.EscapeDataString(model_name))+"&flatten="+flatten;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Model>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about a model.
		/// UpdateModel restapis/{restapi_id}/models/{model_name}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="model_name">The name of the model to update.</param>
		/// <returns>Success</returns>
		public async Task<Model> UpdateModelAsync(string restapi_id, string model_name, UpdateModelPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/models/"+ (model_name==null? "" : System.Uri.EscapeDataString(model_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Model>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a RequestValidator of a given RestApi.
		/// DeleteRequestValidator restapis/{restapi_id}/requestvalidators/{requestvalidator_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="requestvalidator_id">The identifier of the RequestValidator to be deleted.</param>
		public async Task DeleteRequestValidatorAsync(string restapi_id, string requestvalidator_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/requestvalidators/"+ (requestvalidator_id==null? "" : System.Uri.EscapeDataString(requestvalidator_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a RequestValidator of a given RestApi.
		/// GetRequestValidator restapis/{restapi_id}/requestvalidators/{requestvalidator_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="requestvalidator_id">The identifier of the RequestValidator to be retrieved.</param>
		/// <returns>Success</returns>
		public async Task<RequestValidator> GetRequestValidatorAsync(string restapi_id, string requestvalidator_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/requestvalidators/"+ (requestvalidator_id==null? "" : System.Uri.EscapeDataString(requestvalidator_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RequestValidator>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a RequestValidator of a given RestApi.
		/// UpdateRequestValidator restapis/{restapi_id}/requestvalidators/{requestvalidator_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="requestvalidator_id">The identifier of RequestValidator to be updated.</param>
		/// <returns>Success</returns>
		public async Task<RequestValidator> UpdateRequestValidatorAsync(string restapi_id, string requestvalidator_id, UpdateRequestValidatorPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/requestvalidators/"+ (requestvalidator_id==null? "" : System.Uri.EscapeDataString(requestvalidator_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RequestValidator>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a Resource resource.
		/// DeleteResource restapis/{restapi_id}/resources/{resource_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The identifier of the Resource resource.</param>
		public async Task DeleteResourceAsync(string restapi_id, string resource_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists information about a resource.
		/// GetResource restapis/{restapi_id}/resources/{resource_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The identifier for the Resource resource.</param>
		/// <param name="embed">A query parameter to retrieve the specified resources embedded in the returned Resource representation in the response. This <code>embed</code> parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded Method resources this way. The query parameter value must be a single-valued list and contain the <code>"methods"</code> string. For example, <code>GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods</code>.</param>
		/// <returns>Success</returns>
		public async Task<Resource> GetResourceAsync(string restapi_id, string resource_id, string[] embed, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"&"+string.Join("&", embed.Select(z => $"embed={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Resource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about a Resource resource.
		/// UpdateResource restapis/{restapi_id}/resources/{resource_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="resource_id">The identifier of the Resource resource.</param>
		/// <returns>Success</returns>
		public async Task<Resource> UpdateResourceAsync(string restapi_id, string resource_id, UpdateResourcePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources/"+ (resource_id==null? "" : System.Uri.EscapeDataString(resource_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Resource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified API.
		/// DeleteRestApi restapis/{restapi_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		public async Task DeleteRestApiAsync(string restapi_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the RestApi resource in the collection.
		/// GetRestApi restapis/{restapi_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <returns>Success</returns>
		public async Task<RestApi> GetRestApiAsync(string restapi_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RestApi>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// A feature of the API Gateway control service for updating an existing API with an input of external API definitions. The update can take the form of merging the supplied definition into the existing API or overwriting the existing API.
		/// PutRestApi restapis/{restapi_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="mode">The <code>mode</code> query parameter to specify the update mode. Valid values are "merge" and "overwrite". By default, the update mode is "merge".</param>
		/// <param name="failonwarnings">A query parameter to indicate whether to rollback the API update (<code>true</code>) or not (<code>false</code>) when a warning is encountered. The default value is <code>false</code>.</param>
		/// <param name="parameters">Custom header parameters as part of the request. For example, to exclude DocumentationParts from an imported API, set <code>ignore=documentation</code> as a <code>parameters</code> value, as in the AWS CLI command of <code>aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'</code>.</param>
		/// <returns>Success</returns>
		public async Task<RestApi> PutRestApiAsync(string restapi_id, PutMode mode, bool failonwarnings, System.Collections.Generic.Dictionary<string, string> parameters, PutRestApiPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"&mode=" + mode+"&failonwarnings="+failonwarnings+"&parameters=" + parameters;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RestApi>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about the specified API.
		/// UpdateRestApi restapis/{restapi_id}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <returns>Success</returns>
		public async Task<RestApi> UpdateRestApiAsync(string restapi_id, UpdateRestApiPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RestApi>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a Stage resource.
		/// DeleteStage restapis/{restapi_id}/stages/{stage_name}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="stage_name">The name of the Stage resource to delete.</param>
		public async Task DeleteStageAsync(string restapi_id, string stage_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages/"+ (stage_name==null? "" : System.Uri.EscapeDataString(stage_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a Stage resource.
		/// GetStage restapis/{restapi_id}/stages/{stage_name}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="stage_name">The name of the Stage resource to get information about.</param>
		/// <returns>Success</returns>
		public async Task<Stage> GetStageAsync(string restapi_id, string stage_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages/"+ (stage_name==null? "" : System.Uri.EscapeDataString(stage_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Stage>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about a Stage resource.
		/// UpdateStage restapis/{restapi_id}/stages/{stage_name}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="stage_name">The name of the Stage resource to change information about.</param>
		/// <returns>Success</returns>
		public async Task<Stage> UpdateStageAsync(string restapi_id, string stage_name, UpdateStagePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages/"+ (stage_name==null? "" : System.Uri.EscapeDataString(stage_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Stage>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a usage plan of a given plan Id.
		/// DeleteUsagePlan usageplans/{usageplanId}
		/// </summary>
		/// <param name="usageplanId">The Id of the to-be-deleted usage plan.</param>
		public async Task DeleteUsagePlanAsync(string usageplanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a usage plan of a given plan identifier.
		/// GetUsagePlan usageplans/{usageplanId}
		/// </summary>
		/// <param name="usageplanId">The identifier of the UsagePlan resource to be retrieved.</param>
		/// <returns>Success</returns>
		public async Task<UsagePlan> GetUsagePlanAsync(string usageplanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UsagePlan>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a usage plan of a given plan Id.
		/// UpdateUsagePlan usageplans/{usageplanId}
		/// </summary>
		/// <param name="usageplanId">The Id of the to-be-updated usage plan.</param>
		/// <returns>Success</returns>
		public async Task<UsagePlan> UpdateUsagePlanAsync(string usageplanId, UpdateUsagePlanPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UsagePlan>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a usage plan key and remove the underlying API key from the associated usage plan.
		/// DeleteUsagePlanKey usageplans/{usageplanId}/keys/{keyId}
		/// </summary>
		/// <param name="usageplanId">The Id of the UsagePlan resource representing the usage plan containing the to-be-deleted UsagePlanKey resource representing a plan customer.</param>
		/// <param name="keyId">The Id of the UsagePlanKey resource to be deleted.</param>
		public async Task DeleteUsagePlanKeyAsync(string usageplanId, string keyId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId))+"/keys/"+ (keyId==null? "" : System.Uri.EscapeDataString(keyId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a usage plan key of a given key identifier.
		/// GetUsagePlanKey usageplans/{usageplanId}/keys/{keyId}
		/// </summary>
		/// <param name="usageplanId">The Id of the UsagePlan resource representing the usage plan containing the to-be-retrieved UsagePlanKey resource representing a plan customer.</param>
		/// <param name="keyId">The key Id of the to-be-retrieved UsagePlanKey resource representing a plan customer.</param>
		/// <returns>Success</returns>
		public async Task<UsagePlanKey> GetUsagePlanKeyAsync(string usageplanId, string keyId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId))+"/keys/"+ (keyId==null? "" : System.Uri.EscapeDataString(keyId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UsagePlanKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing VpcLink of a specified identifier.
		/// DeleteVpcLink vpclinks/{vpclink_id}
		/// </summary>
		/// <param name="vpclink_id">The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.</param>
		public async Task DeleteVpcLinkAsync(string vpclink_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vpclinks/"+ (vpclink_id==null? "" : System.Uri.EscapeDataString(vpclink_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a specified VPC link under the caller's account in a region.
		/// GetVpcLink vpclinks/{vpclink_id}
		/// </summary>
		/// <param name="vpclink_id">The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.</param>
		/// <returns>Success</returns>
		public async Task<VpcLink> GetVpcLinkAsync(string vpclink_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vpclinks/"+ (vpclink_id==null? "" : System.Uri.EscapeDataString(vpclink_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<VpcLink>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing VpcLink of a specified identifier.
		/// UpdateVpcLink vpclinks/{vpclink_id}
		/// </summary>
		/// <param name="vpclink_id">The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.</param>
		/// <returns>Success</returns>
		public async Task<VpcLink> UpdateVpcLinkAsync(string vpclink_id, UpdateVpcLinkPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vpclinks/"+ (vpclink_id==null? "" : System.Uri.EscapeDataString(vpclink_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<VpcLink>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Flushes all authorizer cache entries on a stage.
		/// FlushStageAuthorizersCache restapis/{restapi_id}/stages/{stage_name}/cache/authorizers
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="stage_name">The name of the stage to flush.</param>
		public async Task FlushStageAuthorizersCacheAsync(string restapi_id, string stage_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages/"+ (stage_name==null? "" : System.Uri.EscapeDataString(stage_name))+"/cache/authorizers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Flushes a stage's cache.
		/// FlushStageCache restapis/{restapi_id}/stages/{stage_name}/cache/data
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="stage_name">The name of the stage to flush its cache.</param>
		public async Task FlushStageCacheAsync(string restapi_id, string stage_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages/"+ (stage_name==null? "" : System.Uri.EscapeDataString(stage_name))+"/cache/data";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Generates a ClientCertificate resource.
		/// GenerateClientCertificate clientcertificates
		/// </summary>
		public async Task GenerateClientCertificateAsync(GenerateClientCertificatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "clientcertificates";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a collection of ClientCertificate resources.
		/// GetClientCertificates clientcertificates
		/// </summary>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<ClientCertificates> GetClientCertificatesAsync(string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "clientcertificates?position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ClientCertificates>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about the current Account resource.
		/// GetAccount account
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Account> GetAccountAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Account>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes information about the current Account resource.
		/// UpdateAccount account
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Account> UpdateAccountAsync(UpdateAccountPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Account>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Exports a deployed version of a RestApi in a specified format.
		/// GetExport restapis/{restapi_id}/stages/{stage_name}/exports/{export_type}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="stage_name">The name of the Stage that will be exported.</param>
		/// <param name="export_type">The type of export. Acceptable values are 'oas30' for OpenAPI 3.0.x and 'swagger' for Swagger/OpenAPI 2.0.</param>
		/// <param name="parameters">A key-value map of query string parameters that specify properties of the export, depending on the requested <code>exportType</code>. For <code>exportType</code> <code>oas30</code> and <code>swagger</code>, any combination of the following parameters are supported: <code>extensions='integrations'</code> or <code>extensions='apigateway'</code> will export the API with x-amazon-apigateway-integration extensions. <code>extensions='authorizers'</code> will export the API with x-amazon-apigateway-authorizer extensions. <code>postman</code> will export the API with Postman extensions, allowing for import to the Postman tool</param>
		/// <returns>Success</returns>
		public async Task<ExportResponse> GetExportAsync(string restapi_id, string stage_name, string export_type, System.Collections.Generic.Dictionary<string, string> parameters, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages/"+ (stage_name==null? "" : System.Uri.EscapeDataString(stage_name))+"/exports/"+ (export_type==null? "" : System.Uri.EscapeDataString(export_type))+"&parameters=" + parameters;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ExportResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the GatewayResponses collection on the given RestApi. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default GatewayResponses collection for the supported response types.
		/// GetGatewayResponses restapis/{restapi_id}/gatewayresponses
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="position">The current pagination position in the paged result set. The GatewayResponse collection does not support pagination and the position does not apply here.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500. The GatewayResponses collection does not support pagination and the limit does not apply here.</param>
		/// <returns>Success</returns>
		public async Task<GatewayResponses> GetGatewayResponsesAsync(string restapi_id, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/gatewayresponses&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GatewayResponses>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Generates a sample mapping template that can be used to transform a payload into the structure of a model.
		/// GetModelTemplate restapis/{restapi_id}/models/{model_name}/default_template
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="model_name">The name of the model for which to generate a template.</param>
		/// <returns>Success</returns>
		public async Task<Template> GetModelTemplateAsync(string restapi_id, string model_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/models/"+ (model_name==null? "" : System.Uri.EscapeDataString(model_name))+"/default_template";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Template>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists information about a collection of Resource resources.
		/// GetResources restapis/{restapi_id}/resources
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <param name="embed">A query parameter used to retrieve the specified resources embedded in the returned Resources resource in the response. This <code>embed</code> parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded Method resources this way. The query parameter value must be a single-valued list and contain the <code>"methods"</code> string. For example, <code>GET /restapis/{restapi_id}/resources?embed=methods</code>.</param>
		/// <returns>Success</returns>
		public async Task<Resources> GetResourcesAsync(string restapi_id, string position, int limit, string[] embed, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/resources&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit+"&"+string.Join("&", embed.Select(z => $"embed={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Resources>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Generates a client SDK for a RestApi and Stage.
		/// GetSdk restapis/{restapi_id}/stages/{stage_name}/sdks/{sdk_type}
		/// </summary>
		/// <param name="restapi_id">The string identifier of the associated RestApi.</param>
		/// <param name="stage_name">The name of the Stage that the SDK will use.</param>
		/// <param name="sdk_type">The language for the generated SDK. Currently <code>java</code>, <code>javascript</code>, <code>android</code>, <code>objectivec</code> (for iOS), <code>swift</code> (for iOS), and <code>ruby</code> are supported.</param>
		/// <param name="parameters">A string-to-string key-value map of query parameters <code>sdkType</code>-dependent properties of the SDK. For <code>sdkType</code> of <code>objectivec</code> or <code>swift</code>, a parameter named <code>classPrefix</code> is required. For <code>sdkType</code> of <code>android</code>, parameters named <code>groupId</code>, <code>artifactId</code>, <code>artifactVersion</code>, and <code>invokerPackage</code> are required. For <code>sdkType</code> of <code>java</code>, parameters named <code>serviceName</code> and <code>javaPackageName</code> are required. </param>
		/// <returns>Success</returns>
		public async Task<SdkResponse> GetSdkAsync(string restapi_id, string stage_name, string sdk_type, System.Collections.Generic.Dictionary<string, string> parameters, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis/"+ (restapi_id==null? "" : System.Uri.EscapeDataString(restapi_id))+"/stages/"+ (stage_name==null? "" : System.Uri.EscapeDataString(stage_name))+"/sdks/"+ (sdk_type==null? "" : System.Uri.EscapeDataString(sdk_type))+"&parameters=" + parameters;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SdkResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an SDK type.
		/// GetSdkType sdktypes/{sdktype_id}
		/// </summary>
		/// <param name="sdktype_id">The identifier of the queried SdkType instance.</param>
		/// <returns>Success</returns>
		public async Task<SdkType> GetSdkTypeAsync(string sdktype_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sdktypes/"+ (sdktype_id==null? "" : System.Uri.EscapeDataString(sdktype_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SdkType>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets SDK types
		/// GetSdkTypes sdktypes
		/// </summary>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<SdkTypes> GetSdkTypesAsync(string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sdktypes?position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SdkTypes>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the Tags collection for a given resource.
		/// GetTags tags/{resource_arn}
		/// </summary>
		/// <param name="resource_arn">The ARN of a resource that can be tagged.</param>
		/// <param name="position">(Not currently supported) The current pagination position in the paged result set.</param>
		/// <param name="limit">(Not currently supported) The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<Tags> GetTagsAsync(string resource_arn, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resource_arn==null? "" : System.Uri.EscapeDataString(resource_arn))+"&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Tags>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds or updates a tag on a given resource.
		/// TagResource tags/{resource_arn}
		/// </summary>
		/// <param name="resource_arn">The ARN of a resource that can be tagged.</param>
		public async Task TagResourceAsync(string resource_arn, TagResourcePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resource_arn==null? "" : System.Uri.EscapeDataString(resource_arn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the usage data of a usage plan in a specified time interval.
		/// GetUsage usageplans/{usageplanId}/usage#startDate&endDate
		/// </summary>
		/// <param name="usageplanId">The Id of the usage plan associated with the usage data.</param>
		/// <param name="keyId">The Id of the API key associated with the resultant usage data.</param>
		/// <param name="startDate">The starting date (e.g., 2016-01-01) of the usage data.</param>
		/// <param name="endDate">The ending date (e.g., 2016-12-31) of the usage data.</param>
		/// <param name="position">The current pagination position in the paged result set.</param>
		/// <param name="limit">The maximum number of returned results per page. The default value is 25 and the maximum value is 500.</param>
		/// <returns>Success</returns>
		public async Task<Usage> GetUsageAsync(string usageplanId, string keyId, string startDate, string endDate, string position, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId))+"/usage#startDate&endDate&keyId=" + (keyId==null? "" : System.Uri.EscapeDataString(keyId))+"&startDate=" + (startDate==null? "" : System.Uri.EscapeDataString(startDate))+"&endDate=" + (endDate==null? "" : System.Uri.EscapeDataString(endDate))+"&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Usage>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Import API keys from an external source, such as a CSV-formatted file.
		/// ImportApiKeys apikeys#mode=import&format
		/// </summary>
		/// <param name="format">A query parameter to specify the input format to imported API keys. Currently, only the <code>csv</code> format is supported.</param>
		/// <param name="failonwarnings">A query parameter to indicate whether to rollback ApiKey importation (<code>true</code>) or not (<code>false</code>) when error is encountered.</param>
		public async Task ImportApiKeysAsync(ApiKeysFormat format, bool failonwarnings, ImportApiKeysMode mode, ImportApiKeysPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apikeys#mode=import&format?format=" + format+"&failonwarnings="+failonwarnings+"&mode=" + mode;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// A feature of the API Gateway control service for creating a new API from an external API definition file.
		/// ImportRestApi restapis#mode=import
		/// </summary>
		/// <param name="failonwarnings">A query parameter to indicate whether to rollback the API creation (<code>true</code>) or not (<code>false</code>) when a warning is encountered. The default value is <code>false</code>.</param>
		/// <param name="parameters"><p>A key-value map of context-specific query string parameters specifying the behavior of different API importing operations. The following shows operation-specific parameters and their supported values.</p> <p> To exclude DocumentationParts from the import, set <code>parameters</code> as <code>ignore=documentation</code>.</p> <p> To configure the endpoint type, set <code>parameters</code> as <code>endpointConfigurationTypes=EDGE</code>, <code>endpointConfigurationTypes=REGIONAL</code>, or <code>endpointConfigurationTypes=PRIVATE</code>. The default endpoint type is <code>EDGE</code>.</p> <p> To handle imported <code>basepath</code>, set <code>parameters</code> as <code>basepath=ignore</code>, <code>basepath=prepend</code> or <code>basepath=split</code>.</p> <p>For example, the AWS CLI command to exclude documentation from the imported API is:</p> <p>The AWS CLI command to set the regional endpoint on the imported API is:</p></param>
		public async Task ImportRestApiAsync(bool failonwarnings, System.Collections.Generic.Dictionary<string, string> parameters, ImportApiKeysMode mode, ImportRestApiPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "restapis#mode=import?failonwarnings="+failonwarnings+"&parameters=" + parameters+"&mode=" + mode;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from a given resource.
		/// UntagResource tags/{resource_arn}#tagKeys
		/// </summary>
		/// <param name="resource_arn">The ARN of a resource that can be tagged.</param>
		/// <param name="tagKeys">The Tag keys to delete.</param>
		public async Task UntagResourceAsync(string resource_arn, string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resource_arn==null? "" : System.Uri.EscapeDataString(resource_arn))+"#tagKeys&"+string.Join("&", tagKeys.Select(z => $"tagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Grants a temporary extension to the remaining quota of a usage plan associated with a specified API key.
		/// UpdateUsage usageplans/{usageplanId}/keys/{keyId}/usage
		/// </summary>
		/// <param name="usageplanId">The Id of the usage plan associated with the usage data.</param>
		/// <param name="keyId">The identifier of the API key associated with the usage plan in which a temporary extension is granted to the remaining quota.</param>
		/// <returns>Success</returns>
		public async Task<Usage> UpdateUsageAsync(string usageplanId, string keyId, UpdateUsagePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "usageplans/"+ (usageplanId==null? "" : System.Uri.EscapeDataString(usageplanId))+"/keys/"+ (keyId==null? "" : System.Uri.EscapeDataString(keyId))+"/usage";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Usage>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class CreateApiKeyPostBody
	{
		
		/// <summary>
		/// The name of the ApiKey.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The description of the ApiKey.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Specifies whether the ApiKey can be used by callers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Specifies whether (<code>true</code>) or not (<code>false</code>) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="generateDistinctId")]
		public System.Nullable<System.Boolean> GenerateDistinctId { get; set; }
		
		/// <summary>
		/// Specifies a value of the API key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		/// <summary>
		/// DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stageKeys")]
		public StageKey[] StageKeys { get; set; }
		
		/// <summary>
		/// An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerId")]
		public string CustomerId { get; set; }
		
		/// <summary>
		/// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class CreateAuthorizerPostBody
	{
		
		/// <summary>
		/// The name of the authorizer.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The authorizer type. Valid values are <code>TOKEN</code> for a Lambda function using a single authorization token submitted in a custom header, <code>REQUEST</code> for a Lambda function using incoming request parameters, and <code>COGNITO_USER_POOLS</code> for using an Amazon Cognito user pool.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public AuthorizerType Type { get; set; }
		
		/// <summary>
		/// A list of the Amazon Cognito user pool ARNs for the <code>COGNITO_USER_POOLS</code> authorizer. Each element is of this format: <code>arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}</code>. For a <code>TOKEN</code> or <code>REQUEST</code> authorizer, this is not defined. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="providerARNs")]
		public string[] ProviderARNs { get; set; }
		
		/// <summary>
		/// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authType")]
		public string AuthType { get; set; }
		
		/// <summary>
		/// Specifies the authorizer's Uniform Resource Identifier (URI). For <code>TOKEN</code> or <code>REQUEST</code> authorizers, this must be a well-formed Lambda function URI, for example, <code>arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations</code>. In general, the URI has this form <code>arn:aws:apigateway:{region}:lambda:path/{service_api}</code>, where <code>{region}</code> is the same as the region hosting the Lambda function, <code>path</code> indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial <code>/</code>. For Lambda functions, this is usually of the form <code>/2015-03-31/functions/[FunctionARN]/invocations</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizerUri")]
		public string AuthorizerUri { get; set; }
		
		/// <summary>
		/// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizerCredentials")]
		public string AuthorizerCredentials { get; set; }
		
		/// <summary>
		/// The identity source for which authorization is requested. For a <code>TOKEN</code> or <code>COGNITO_USER_POOLS</code> authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is <code>Auth</code>, the header mapping expression is <code>method.request.header.Auth</code>. For the <code>REQUEST</code> authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an <code>Auth</code> header, a <code>Name</code> query string parameter are defined as identity sources, this value is <code>method.request.header.Auth, method.request.querystring.Name</code>. These parameters will be used to derive the authorization caching key and to perform runtime validation of the <code>REQUEST</code> authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identitySource")]
		public string IdentitySource { get; set; }
		
		/// <summary>
		/// A validation expression for the incoming identity token. For <code>TOKEN</code> authorizers, this value is a regular expression. For <code>COGNITO_USER_POOLS</code> authorizers, API Gateway will match the <code>aud</code> field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the <code>REQUEST</code> authorizer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identityValidationExpression")]
		public string IdentityValidationExpression { get; set; }
		
		/// <summary>
		/// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizerResultTtlInSeconds")]
		public System.Nullable<System.Int32> AuthorizerResultTtlInSeconds { get; set; }
	}
	
	public class CreateBasePathMappingPostBody
	{
		
		/// <summary>
		/// The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify a base path name after the domain name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="basePath")]
		public string BasePath { get; set; }
		
		/// <summary>
		/// The string identifier of the associated RestApi.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restApiId")]
		public string RestApiId { get; set; }
		
		/// <summary>
		/// The name of the API's stage that you want to use for this mapping. Specify '(none)' if you want callers to explicitly specify the stage name after any base path name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stage")]
		public string Stage { get; set; }
	}
	
	public class CreateDeploymentPostBody
	{
		
		/// <summary>
		/// The name of the Stage resource for the Deployment resource to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stageName")]
		public string StageName { get; set; }
		
		/// <summary>
		/// The description of the Stage resource for the Deployment resource to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stageDescription")]
		public string StageDescription { get; set; }
		
		/// <summary>
		/// The description for the Deployment resource to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Enables a cache cluster for the Stage resource specified in the input.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheClusterEnabled")]
		public System.Nullable<System.Boolean> CacheClusterEnabled { get; set; }
		
		/// <summary>
		/// Returns the size of the CacheCluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheClusterSize")]
		public System.Nullable<CreateDeploymentPostBodyCacheClusterSize> CacheClusterSize { get; set; }
		
		/// <summary>
		/// A map that defines the stage variables for the Stage resource that is associated with the new deployment. Variable names can have alphanumeric and underscore characters, and the values must match <code>[A-Za-z0-9-._~:/?#&amp;=,]+</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variables")]
		public System.Collections.Generic.Dictionary<string, string> Variables { get; set; }
		
		/// <summary>
		/// The input configuration for a canary deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canarySettings")]
		public CreateDeploymentPostBodyCanarySettings CanarySettings { get; set; }
		
		/// <summary>
		/// Specifies whether active tracing with X-ray is enabled for the Stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tracingEnabled")]
		public System.Nullable<System.Boolean> TracingEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateDeploymentPostBodyCacheClusterSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0.5")]
		_0_5 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1.6")]
		_1_6 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6.1")]
		_6_1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="13.5")]
		_13_5 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="28.4")]
		_28_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="58.2")]
		_58_2 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="118")]
		_118 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="237")]
		_237 = 7,
	}
	
	public class CreateDeploymentPostBodyCanarySettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="percentTraffic")]
		public System.Nullable<System.Double> PercentTraffic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageVariableOverrides")]
		public MapOfStringToString StageVariableOverrides { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="useStageCache")]
		public System.Nullable<System.Boolean> UseStageCache { get; set; }
	}
	
	public class CreateDocumentationPartPostBody
	{
		
		/// <summary>
		/// Specifies the target API entity to which the documentation applies.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public CreateDocumentationPartPostBodyLocation Location { get; set; }
		
		/// <summary>
		/// The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public string Properties { get; set; }
	}
	
	public class CreateDocumentationPartPostBodyLocation
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DocumentationPartType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public string StatusCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ImportDocumentationPartsPutBody
	{
		
		/// <summary>
		/// Raw byte array representing the to-be-imported documentation parts. To import from an OpenAPI file, this is a JSON object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class CreateDocumentationVersionPostBody
	{
		
		/// <summary>
		/// The version identifier of the new snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="documentationVersion")]
		public string DocumentationVersion { get; set; }
		
		/// <summary>
		/// The stage name to be associated with the new documentation snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stageName")]
		public string StageName { get; set; }
		
		/// <summary>
		/// A description about the new documentation snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	public class CreateDomainNamePostBody
	{
		
		/// <summary>
		/// The name of the DomainName resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		public string DomainName { get; set; }
		
		/// <summary>
		/// The user-friendly name of the certificate that will be used by edge-optimized endpoint for this domain name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateName")]
		public string CertificateName { get; set; }
		
		/// <summary>
		/// [Deprecated] The body of the server certificate that will be used by edge-optimized endpoint for this domain name provided by your certificate authority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateBody")]
		public string CertificateBody { get; set; }
		
		/// <summary>
		/// [Deprecated] Your edge-optimized endpoint's domain name certificate's private key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificatePrivateKey")]
		public string CertificatePrivateKey { get; set; }
		
		/// <summary>
		/// [Deprecated] The intermediate certificates and optionally the root certificate, one after the other without any blank lines, used by an edge-optimized endpoint for this domain name. If you include the root certificate, your certificate chain must start with intermediate certificates and end with the root certificate. Use the intermediate certificates that were provided by your certificate authority. Do not include any intermediaries that are not in the chain of trust path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateChain")]
		public string CertificateChain { get; set; }
		
		/// <summary>
		/// The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateArn")]
		public string CertificateArn { get; set; }
		
		/// <summary>
		/// The user-friendly name of the certificate that will be used by regional endpoint for this domain name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regionalCertificateName")]
		public string RegionalCertificateName { get; set; }
		
		/// <summary>
		/// The reference to an AWS-managed certificate that will be used by regional endpoint for this domain name. AWS Certificate Manager is the only supported source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regionalCertificateArn")]
		public string RegionalCertificateArn { get; set; }
		
		/// <summary>
		/// The endpoint configuration to indicate the types of endpoints an API (RestApi) or its custom domain name (DomainName) has. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpointConfiguration")]
		public CreateDomainNamePostBodyEndpointConfiguration EndpointConfiguration { get; set; }
		
		/// <summary>
		/// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are <code>TLS_1_0</code> and <code>TLS_1_2</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public SecurityPolicy SecurityPolicy { get; set; }
		
		/// <summary>
		/// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mutualTlsAuthentication")]
		public CreateDomainNamePostBodyMutualTlsAuthentication MutualTlsAuthentication { get; set; }
		
		/// <summary>
		/// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ownershipVerificationCertificateArn")]
		public string OwnershipVerificationCertificateArn { get; set; }
	}
	
	public class CreateDomainNamePostBodyEndpointConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="types")]
		public EndpointType[] Types { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vpcEndpointIds")]
		public string[] VpcEndpointIds { get; set; }
	}
	
	public class CreateDomainNamePostBodyMutualTlsAuthentication
	{
		
		[System.Runtime.Serialization.DataMember(Name="truststoreUri")]
		public string TruststoreUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truststoreVersion")]
		public string TruststoreVersion { get; set; }
	}
	
	public class CreateModelPostBody
	{
		
		/// <summary>
		/// The name of the model. Must be alphanumeric.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The description of the model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The schema for the model. For <code>application/json</code> models, this should be JSON schema draft 4 model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
		
		/// <summary>
		/// The content-type for the model.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
	}
	
	public class CreateRequestValidatorPostBody
	{
		
		/// <summary>
		/// The name of the to-be-created RequestValidator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A Boolean flag to indicate whether to validate request body according to the configured model schema for the method (<code>true</code>) or not (<code>false</code>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validateRequestBody")]
		public System.Nullable<System.Boolean> ValidateRequestBody { get; set; }
		
		/// <summary>
		/// A Boolean flag to indicate whether to validate request parameters, <code>true</code>, or not <code>false</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validateRequestParameters")]
		public System.Nullable<System.Boolean> ValidateRequestParameters { get; set; }
	}
	
	public class CreateResourcePostBody
	{
		
		/// <summary>
		/// The last path segment for this resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pathPart")]
		public string PathPart { get; set; }
	}
	
	public class CreateRestApiPostBody
	{
		
		/// <summary>
		/// The name of the RestApi.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The description of the RestApi.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A version identifier for the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// The ID of the RestApi that you want to clone from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloneFrom")]
		public string CloneFrom { get; set; }
		
		/// <summary>
		/// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="binaryMediaTypes")]
		public string[] BinaryMediaTypes { get; set; }
		
		/// <summary>
		/// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumCompressionSize")]
		public System.Nullable<System.Int32> MinimumCompressionSize { get; set; }
		
		/// <summary>
		/// The source of the API key for metering requests according to a usage plan. Valid values are: &gt;<code>HEADER</code> to read the API key from the <code>X-API-Key</code> header of a request. <code>AUTHORIZER</code> to read the API key from the <code>UsageIdentifierKey</code> from a custom authorizer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiKeySource")]
		public ApiKeySourceType ApiKeySource { get; set; }
		
		/// <summary>
		/// The endpoint configuration to indicate the types of endpoints an API (RestApi) or its custom domain name (DomainName) has. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpointConfiguration")]
		public CreateRestApiPostBodyEndpointConfiguration EndpointConfiguration { get; set; }
		
		/// <summary>
		/// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		/// <summary>
		/// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// Specifies whether clients can invoke your API by using the default <code>execute-api</code> endpoint. By default, clients can invoke your API with the default <code>https://{api_id}.execute-api.{region}.amazonaws.com</code> endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableExecuteApiEndpoint")]
		public System.Nullable<System.Boolean> DisableExecuteApiEndpoint { get; set; }
	}
	
	public class CreateRestApiPostBodyEndpointConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="types")]
		public EndpointType[] Types { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vpcEndpointIds")]
		public string[] VpcEndpointIds { get; set; }
	}
	
	public class CreateStagePostBody
	{
		
		/// <summary>
		/// The name for the Stage resource. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stageName")]
		public string StageName { get; set; }
		
		/// <summary>
		/// The identifier of the Deployment resource for the Stage resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deploymentId")]
		public string DeploymentId { get; set; }
		
		/// <summary>
		/// The description of the Stage resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Whether cache clustering is enabled for the stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheClusterEnabled")]
		public System.Nullable<System.Boolean> CacheClusterEnabled { get; set; }
		
		/// <summary>
		/// Returns the size of the CacheCluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheClusterSize")]
		public System.Nullable<CreateStagePostBodyCacheClusterSize> CacheClusterSize { get; set; }
		
		/// <summary>
		/// A map that defines the stage variables for the new Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match <code>[A-Za-z0-9-._~:/?#&amp;=,]+</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variables")]
		public System.Collections.Generic.Dictionary<string, string> Variables { get; set; }
		
		/// <summary>
		/// The version of the associated API documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="documentationVersion")]
		public string DocumentationVersion { get; set; }
		
		/// <summary>
		/// Configuration settings of a canary deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canarySettings")]
		public CreateStagePostBodyCanarySettings CanarySettings { get; set; }
		
		/// <summary>
		/// Specifies whether active tracing with X-ray is enabled for the Stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tracingEnabled")]
		public System.Nullable<System.Boolean> TracingEnabled { get; set; }
		
		/// <summary>
		/// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateStagePostBodyCacheClusterSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0.5")]
		_0_5 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1.6")]
		_1_6 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6.1")]
		_6_1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="13.5")]
		_13_5 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="28.4")]
		_28_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="58.2")]
		_58_2 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="118")]
		_118 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="237")]
		_237 = 7,
	}
	
	public class CreateStagePostBodyCanarySettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="percentTraffic")]
		public System.Nullable<System.Double> PercentTraffic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deploymentId")]
		public string DeploymentId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stageVariableOverrides")]
		public MapOfStringToString StageVariableOverrides { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="useStageCache")]
		public System.Nullable<System.Boolean> UseStageCache { get; set; }
	}
	
	public class CreateUsagePlanPostBody
	{
		
		/// <summary>
		/// The name of the usage plan.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The description of the usage plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The associated API stages of the usage plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiStages")]
		public ApiStage[] ApiStages { get; set; }
		
		/// <summary>
		///  The API request rate limits.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="throttle")]
		public CreateUsagePlanPostBodyThrottle Throttle { get; set; }
		
		/// <summary>
		/// Quotas configured for a usage plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quota")]
		public CreateUsagePlanPostBodyQuota Quota { get; set; }
		
		/// <summary>
		/// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class CreateUsagePlanPostBodyThrottle
	{
		
		[System.Runtime.Serialization.DataMember(Name="burstLimit")]
		public System.Nullable<System.Int32> BurstLimit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rateLimit")]
		public System.Nullable<System.Double> RateLimit { get; set; }
	}
	
	public class CreateUsagePlanPostBodyQuota
	{
		
		[System.Runtime.Serialization.DataMember(Name="limit")]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="offset")]
		public System.Nullable<System.Int32> Offset { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="period")]
		public QuotaPeriodType Period { get; set; }
	}
	
	public class CreateUsagePlanKeyPostBody
	{
		
		/// <summary>
		/// The identifier of a UsagePlanKey resource for a plan customer.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyId")]
		public string KeyId { get; set; }
		
		/// <summary>
		/// The type of a UsagePlanKey resource for a plan customer.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyType")]
		public string KeyType { get; set; }
	}
	
	public class CreateVpcLinkPostBody
	{
		
		/// <summary>
		/// The name used to label and identify the VPC link.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The description of the VPC link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetArns")]
		public string[] TargetArns { get; set; }
		
		/// <summary>
		/// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class UpdateApiKeyPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class TestInvokeAuthorizerPostBody
	{
		
		/// <summary>
		/// A key-value map of headers to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, should be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// The headers as a map from string to list of values to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, may be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multiValueHeaders")]
		public System.Collections.Generic.Dictionary<string, string[]> MultiValueHeaders { get; set; }
		
		/// <summary>
		/// The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathWithQueryString")]
		public string PathWithQueryString { get; set; }
		
		/// <summary>
		/// The simulated request body of an incoming invocation request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// A key-value map of stage variables to simulate an invocation on a deployed Stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stageVariables")]
		public System.Collections.Generic.Dictionary<string, string> StageVariables { get; set; }
		
		/// <summary>
		/// A key-value map of additional context variables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalContext")]
		public System.Collections.Generic.Dictionary<string, string> AdditionalContext { get; set; }
	}
	
	public class UpdateAuthorizerPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateBasePathMappingPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateClientCertificatePatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateDeploymentPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateDocumentationPartPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateDocumentationVersionPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateDomainNamePatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class PutGatewayResponsePutBody
	{
		
		/// <summary>
		/// The status code.
		/// Pattern: [1-5]\d\d
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[1-5]\d\d")]
		public string StatusCode { get; set; }
		
		/// <summary>
		/// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public System.Collections.Generic.Dictionary<string, string> ResponseParameters { get; set; }
		
		/// <summary>
		/// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseTemplates")]
		public System.Collections.Generic.Dictionary<string, string> ResponseTemplates { get; set; }
	}
	
	public class UpdateGatewayResponsePatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class PutIntegrationPutBody
	{
		
		/// <summary>
		/// The integration type. The valid value is <code>HTTP</code> for integrating an API method with an HTTP backend; <code>AWS</code> with any AWS service endpoints; <code>MOCK</code> for testing without actually invoking the backend; <code>HTTP_PROXY</code> for integrating with the HTTP proxy integration; <code>AWS_PROXY</code> for integrating with the Lambda proxy integration. 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public IntegrationType Type { get; set; }
		
		/// <summary>
		/// The HTTP method for the integration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpMethod")]
		public string HttpMethod { get; set; }
		
		/// <summary>
		/// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or <code>HTTP_PROXY</code> integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification, for either standard integration, where <code>connectionType</code> is not <code>VPC_LINK</code>, or private integration, where <code>connectionType</code> is <code>VPC_LINK</code>. For a private HTTP integration, the URI is not used for routing. For <code>AWS</code> or <code>AWS_PROXY</code> integrations, the URI is of the form <code>arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api</code>}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&amp;{p1}={v1}&amp;p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of <code>GetObject</code>, the <code>uri</code> can be either <code>arn:aws:apigateway:us-west-2:s3:action/GetObject&amp;Bucket={bucket}&amp;Key={key}</code> or <code>arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// The type of the network connection to the integration endpoint. The valid value is <code>INTERNET</code> for connections through the public routable internet or <code>VPC_LINK</code> for private connections between API Gateway and a network load balancer in a VPC. The default value is <code>INTERNET</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionType")]
		public ConnectionType ConnectionType { get; set; }
		
		/// <summary>
		/// The ID of the VpcLink used for the integration. Specify this value only if you specify <code>VPC_LINK</code> as the connection type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		/// <summary>
		/// Specifies whether credentials are required for a put integration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credentials")]
		public string Credentials { get; set; }
		
		/// <summary>
		/// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> must be a valid and unique method request parameter name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestParameters")]
		public System.Collections.Generic.Dictionary<string, string> RequestParameters { get; set; }
		
		/// <summary>
		/// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestTemplates")]
		public System.Collections.Generic.Dictionary<string, string> RequestTemplates { get; set; }
		
		/// <summary>
		/// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the <code>requestTemplates</code> property on the Integration resource. There are three valid values: <code>WHEN_NO_MATCH</code>, <code>WHEN_NO_TEMPLATES</code>, and <code>NEVER</code>. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passthroughBehavior")]
		public string PassthroughBehavior { get; set; }
		
		/// <summary>
		/// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the <code>cacheNamespace</code>. You can specify the same <code>cacheNamespace</code> across resources to return the same cached data for requests to different resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheNamespace")]
		public string CacheNamespace { get; set; }
		
		/// <summary>
		/// A list of request parameters whose values API Gateway caches. To be valid values for <code>cacheKeyParameters</code>, these parameters must also be specified for Method <code>requestParameters</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheKeyParameters")]
		public string[] CacheKeyParameters { get; set; }
		
		/// <summary>
		/// <p>Specifies how to handle request payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p> <p>If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the <code>passthroughBehavior</code> is configured to support payload pass-through.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentHandling")]
		public ContentHandlingStrategy ContentHandling { get; set; }
		
		/// <summary>
		/// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutInMillis")]
		public System.Nullable<System.Int32> TimeoutInMillis { get; set; }
		
		/// <summary>
		/// Specifies the TLS configuration for an integration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tlsConfig")]
		public PutIntegrationPutBodyTlsConfig TlsConfig { get; set; }
	}
	
	public class PutIntegrationPutBodyTlsConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="insecureSkipVerification")]
		public System.Nullable<System.Boolean> InsecureSkipVerification { get; set; }
	}
	
	public class UpdateIntegrationPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class PutIntegrationResponsePutBody
	{
		
		/// <summary>
		/// Specifies the selection pattern of a put integration response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selectionPattern")]
		public string SelectionPattern { get; set; }
		
		/// <summary>
		/// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. The mapped non-static value must match the pattern of <code>integration.response.header.{name}</code> or <code>integration.response.body.{JSON-expression}</code>, where <code>name</code> must be a valid and unique response header name and <code>JSON-expression</code> a valid JSON expression without the <code>$</code> prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public System.Collections.Generic.Dictionary<string, string> ResponseParameters { get; set; }
		
		/// <summary>
		/// Specifies a put integration response's templates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseTemplates")]
		public System.Collections.Generic.Dictionary<string, string> ResponseTemplates { get; set; }
		
		/// <summary>
		/// <p>Specifies how to handle response payload content type conversions. Supported values are <code>CONVERT_TO_BINARY</code> and <code>CONVERT_TO_TEXT</code>, with the following behaviors:</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentHandling")]
		public ContentHandlingStrategy ContentHandling { get; set; }
	}
	
	public class UpdateIntegrationResponsePatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class PutMethodPutBody
	{
		
		/// <summary>
		/// The method's authorization type. Valid values are <code>NONE</code> for open access, <code>AWS_IAM</code> for using AWS IAM permissions, <code>CUSTOM</code> for using a custom authorizer, or <code>COGNITO_USER_POOLS</code> for using a Cognito user pool.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizationType")]
		public string AuthorizationType { get; set; }
		
		/// <summary>
		/// Specifies the identifier of an Authorizer to use on this Method, if the type is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by API Gateway when you created the authorizer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizerId")]
		public string AuthorizerId { get; set; }
		
		/// <summary>
		/// Specifies whether the method required a valid ApiKey.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiKeyRequired")]
		public System.Nullable<System.Boolean> ApiKeyRequired { get; set; }
		
		/// <summary>
		/// A human-friendly operation identifier for the method. For example, you can assign the <code>operationName</code> of <code>ListPets</code> for the <code>GET /pets</code> method in the <code>PetStore</code> example.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationName")]
		public string OperationName { get; set; }
		
		/// <summary>
		/// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key defines a method request parameter name matching the pattern of <code>method.request.{location}.{name}</code>, where <code>location</code> is <code>querystring</code>, <code>path</code>, or <code>header</code> and <code>name</code> is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (<code>true</code>) or optional (<code>false</code>). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or body-mapping templates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestParameters")]
		public System.Collections.Generic.Dictionary<string, bool> RequestParameters { get; set; }
		
		/// <summary>
		/// Specifies the Model resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a Model name as the value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestModels")]
		public System.Collections.Generic.Dictionary<string, string> RequestModels { get; set; }
		
		/// <summary>
		/// The identifier of a RequestValidator for validating the method request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestValidatorId")]
		public string RequestValidatorId { get; set; }
		
		/// <summary>
		/// A list of authorization scopes configured on the method. The scopes are used with a <code>COGNITO_USER_POOLS</code> authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizationScopes")]
		public string[] AuthorizationScopes { get; set; }
	}
	
	public class TestInvokeMethodPostBody
	{
		
		/// <summary>
		/// The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathWithQueryString")]
		public string PathWithQueryString { get; set; }
		
		/// <summary>
		/// The simulated request body of an incoming invocation request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// A key-value map of headers to simulate an incoming invocation request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// The headers as a map from string to list of values to simulate an incoming invocation request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multiValueHeaders")]
		public System.Collections.Generic.Dictionary<string, string[]> MultiValueHeaders { get; set; }
		
		/// <summary>
		/// A ClientCertificate identifier to use in the test invocation. API Gateway will use the certificate when making the HTTPS request to the defined back-end endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificateId")]
		public string ClientCertificateId { get; set; }
		
		/// <summary>
		/// A key-value map of stage variables to simulate an invocation on a deployed Stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stageVariables")]
		public System.Collections.Generic.Dictionary<string, string> StageVariables { get; set; }
	}
	
	public class UpdateMethodPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class PutMethodResponsePutBody
	{
		
		/// <summary>
		/// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header name and the associated value is a Boolean flag indicating whether the method response parameter is required or not. The method response header names must match the pattern of <code>method.response.header.{name}</code>, where <code>name</code> is a valid and unique header name. The response parameter names defined here are available in the integration response to be mapped from an integration response header expressed in <code>integration.response.header.{name}</code>, a static value enclosed within a pair of single quotes (e.g., <code>'application/json'</code>), or a JSON expression from the back-end response payload in the form of <code>integration.response.body.{JSON-expression}</code>, where <code>JSON-expression</code> is a valid JSON expression without the <code>$</code> prefix.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseParameters")]
		public System.Collections.Generic.Dictionary<string, bool> ResponseParameters { get; set; }
		
		/// <summary>
		/// Specifies the Model resources used for the response's content type. Response models are represented as a key/value map, with a content type as the key and a Model name as the value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseModels")]
		public System.Collections.Generic.Dictionary<string, string> ResponseModels { get; set; }
	}
	
	public class UpdateMethodResponsePatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateModelPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateRequestValidatorPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateResourcePatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class PutRestApiPutBody
	{
		
		/// <summary>
		/// The PUT request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class UpdateRestApiPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateStagePatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateUsagePlanPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class UpdateVpcLinkPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class GenerateClientCertificatePostBody
	{
		
		/// <summary>
		/// The description of the ClientCertificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class UpdateAccountPatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
	
	public class TagResourcePutBody
	{
		
		/// <summary>
		/// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to 256 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public enum ImportApiKeysMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		import = 0,
	}
	
	public class ImportApiKeysPostBody
	{
		
		/// <summary>
		/// The payload of the POST request to import API keys. For the payload format, see API Key File Format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class ImportRestApiPostBody
	{
		
		/// <summary>
		/// The POST request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class UpdateUsagePatchBody
	{
		
		/// <summary>
		/// A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchOperations")]
		public PatchOperation[] PatchOperations { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
