//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// GitHub Actions Cache Usage by repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_cache_usage_by_repository
	{
		
		/// <summary>
		/// The number of active caches in the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="active_caches_count")]
		public int Active_caches_count { get; set; }
		
		/// <summary>
		/// The sum of the size in bytes of all the active cache items in the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="active_caches_size_in_bytes")]
		public int Active_caches_size_in_bytes { get; set; }
		
		/// <summary>
		/// The repository owner and name for the cache usage being shown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_cache_usage_org_enterprise
	{
		
		/// <summary>
		/// The count of active caches across all repositories of an enterprise or an organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_active_caches_count")]
		public int Total_active_caches_count { get; set; }
		
		/// <summary>
		/// The total size in bytes of all active cache items across all repositories of an enterprise or an organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_active_caches_size_in_bytes")]
		public int Total_active_caches_size_in_bytes { get; set; }
	}
	
	/// <summary>
	/// GitHub Actions cache usage policy for an enterprise.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_cache_usage_policy_enterprise
	{
		
		/// <summary>
		/// For repositories in an enterprise, the maximum value that can be set as the limit for the sum of all caches in a repository, in gigabytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_repo_cache_size_limit_in_gb")]
		public System.Nullable<System.Int32> Max_repo_cache_size_limit_in_gb { get; set; }
		
		/// <summary>
		/// For repositories in an enterprise, the default size limit for the sum of all caches in a repository, in gigabytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repo_cache_size_limit_in_gb")]
		public System.Nullable<System.Int32> Repo_cache_size_limit_in_gb { get; set; }
	}
	
	/// <summary>
	/// GitHub Actions cache usage policy for repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_cache_usage_policy_for_repository
	{
		
		/// <summary>
		/// The size limit for the sum of all caches, in gigabytes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo_cache_size_limit_in_gb")]
		public int Repo_cache_size_limit_in_gb { get; set; }
	}
	
	/// <summary>
	/// The default workflow permissions granted to the GITHUB_TOKEN when running workflows.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Actions_default_workflow_permissions
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		write = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_enterprise_permissions
	{
		
		/// <summary>
		/// The permissions policy that controls the actions that are allowed to run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed_actions")]
		public System.Nullable<Actions_enterprise_permissionsAllowed_actions> Allowed_actions { get; set; }
		
		/// <summary>
		/// The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled_organizations")]
		public Actions_enterprise_permissionsEnabled_organizations Enabled_organizations { get; set; }
		
		/// <summary>
		/// The API URL to use to get or set the actions that are allowed to run, when `allowed_actions` is set to `selected`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_actions_url")]
		public string Selected_actions_url { get; set; }
		
		/// <summary>
		/// The API URL to use to get or set the selected organizations that are allowed to run GitHub Actions, when `enabled_organizations` is set to `selected`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_organizations_url")]
		public string Selected_organizations_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Actions_enterprise_permissionsAllowed_actions
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		local_only = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Actions_enterprise_permissionsEnabled_organizations
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_get_default_workflow_permissions
	{
		
		/// <summary>
		/// Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="can_approve_pull_request_reviews")]
		public bool Can_approve_pull_request_reviews { get; set; }
		
		/// <summary>
		/// The default workflow permissions granted to the GITHUB_TOKEN when running workflows.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default_workflow_permissions")]
		public Actions_default_workflow_permissions Default_workflow_permissions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_organization_permissions
	{
		
		/// <summary>
		/// The permissions policy that controls the actions that are allowed to run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed_actions")]
		public Actions_enterprise_permissionsAllowed_actions Allowed_actions { get; set; }
		
		/// <summary>
		/// The policy that controls the repositories in the organization that are allowed to run GitHub Actions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled_repositories")]
		public Actions_enterprise_permissionsEnabled_organizations Enabled_repositories { get; set; }
		
		/// <summary>
		/// The API URL to use to get or set the actions that are allowed to run, when `allowed_actions` is set to `selected`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_actions_url")]
		public string Selected_actions_url { get; set; }
		
		/// <summary>
		/// The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_repositories_url")]
		public string Selected_repositories_url { get; set; }
	}
	
	/// <summary>
	/// The public key used for setting Actions Secrets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_public_key
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The Base64 encoded public key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The identifier for the key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_repository_permissions
	{
		
		/// <summary>
		/// The permissions policy that controls the actions that are allowed to run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed_actions")]
		public Actions_enterprise_permissionsAllowed_actions Allowed_actions { get; set; }
		
		/// <summary>
		/// Whether GitHub Actions is enabled on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// The API URL to use to get or set the actions that are allowed to run, when `allowed_actions` is set to `selected`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_actions_url")]
		public string Selected_actions_url { get; set; }
	}
	
	/// <summary>
	/// Set secrets for GitHub Actions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_secret
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The name of the secret.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_set_default_workflow_permissions
	{
		
		/// <summary>
		/// Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="can_approve_pull_request_reviews")]
		public System.Nullable<System.Boolean> Can_approve_pull_request_reviews { get; set; }
		
		/// <summary>
		/// The default workflow permissions granted to the GITHUB_TOKEN when running workflows.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="default_workflow_permissions")]
		public Actions_default_workflow_permissions Default_workflow_permissions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actions_workflow_access_to_repository
	{
		
		/// <summary>
		/// Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the
		///repository.
		///
		///`none` means the access is only possible from workflows in this repository. `organization` level access allows sharing across the organization. `enterprise` level access allows sharing across the enterprise.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access_level")]
		public Actions_workflow_access_to_repositoryAccess_level Access_level { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Actions_workflow_access_to_repositoryAccess_level
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		organization = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise = 2,
	}
	
	/// <summary>
	/// Actor
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Actor
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="display_login")]
		public string Display_login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Added to Project Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Added_to_project_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="project_card")]
		public Added_to_project_issue_eventProject_card Project_card { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A GitHub user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Simple_user
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_at")]
		public string Starred_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_integration
	{
		
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The list of events for the GitHub app
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="external_url")]
		public string External_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the GitHub app
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The number of installations associated with the GitHub app
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="installations_count")]
		public System.Nullable<System.Int32> Installations_count { get; set; }
		
		/// <summary>
		/// The name of the GitHub app
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Nullable_simple_user Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pem")]
		public string Pem { get; set; }
		
		/// <summary>
		/// The set of permissions for the GitHub app
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Nullable_integrationPermissions Permissions { get; set; }
		
		/// <summary>
		/// The slug name of the GitHub app
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="webhook_secret")]
		public string Webhook_secret { get; set; }
	}
	
	/// <summary>
	/// A GitHub user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_simple_user
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_at")]
		public string Starred_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Nullable_integrationPermissions
	{
		
		[System.Runtime.Serialization.DataMember(Name="checks")]
		public string Checks { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deployments")]
		public string Deployments { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issues")]
		public string Issues { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
	}
	
	public class Added_to_project_issue_eventProject_card
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column_name")]
		public string Column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_column_name")]
		public string Previous_column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_id")]
		public int Project_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_url")]
		public string Project_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Advanced_security_active_committers
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Advanced_security_active_committers_repository[] Repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total_advanced_security_committers")]
		public System.Nullable<System.Int32> Total_advanced_security_committers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public System.Nullable<System.Int32> Total_count { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Advanced_security_active_committers_repository
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="advanced_security_committers")]
		public int Advanced_security_committers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="advanced_security_committers_breakdown")]
		public Advanced_security_active_committers_user[] Advanced_security_committers_breakdown { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Advanced_security_active_committers_user
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_pushed_date")]
		public string Last_pushed_date { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user_login")]
		public string User_login { get; set; }
	}
	
	/// <summary>
	/// The permissions policy that controls the actions that are allowed to run.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Allowed_actions
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		local_only = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	/// <summary>
	/// Enterprise global announcement
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Announcement
	{
		
		/// <summary>
		/// The announcement text in GitHub Flavored Markdown. For more information about GitHub Flavored Markdown, see "[Basic writing and formatting syntax](https://docs.github.com/enterprise-server@3.6/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)."
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="announcement")]
		public string Announcement1 { get; set; }
		
		/// <summary>
		/// The time at which the announcement expires. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. To set an announcement that never expires, omit this parameter, set it to `null`, or set it to an empty string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public System.Nullable<System.DateTimeOffset> Expires_at { get; set; }
	}
	
	/// <summary>
	/// Api Overview
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Api_overview
	{
		
		[System.Runtime.Serialization.DataMember(Name="dependabot")]
		public string[] Dependabot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="installed_version")]
		public string Installed_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="packages")]
		public string[] Packages { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verifiable_password_authentication")]
		public bool Verifiable_password_authentication { get; set; }
	}
	
	/// <summary>
	/// The permissions granted to the user-to-server access token.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class App_permissions
	{
		
		/// <summary>
		/// The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Actions_default_workflow_permissions Actions { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="administration")]
		public Actions_default_workflow_permissions Administration { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for checks on code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checks")]
		public Actions_default_workflow_permissions Checks { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public Actions_default_workflow_permissions Contents { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for deployments and deployment statuses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deployments")]
		public Actions_default_workflow_permissions Deployments { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for managing repository environments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environments")]
		public Actions_default_workflow_permissions Environments { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issues")]
		public Actions_default_workflow_permissions Issues { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for organization teams and members.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members")]
		public Actions_default_workflow_permissions Members { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Actions_default_workflow_permissions Metadata { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage access to an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_administration")]
		public Actions_default_workflow_permissions Organization_administration { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage the post-receive hooks for an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_hooks")]
		public Actions_default_workflow_permissions Organization_hooks { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for organization packages published to GitHub Packages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_packages")]
		public Actions_default_workflow_permissions Organization_packages { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for viewing an organization's plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_plan")]
		public System.Nullable<App_permissionsOrganization_plan> Organization_plan { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage organization projects and projects beta (where available).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_projects")]
		public System.Nullable<App_permissionsOrganization_projects> Organization_projects { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage organization secrets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_secrets")]
		public Actions_default_workflow_permissions Organization_secrets { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_self_hosted_runners")]
		public Actions_default_workflow_permissions Organization_self_hosted_runners { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to view and manage users blocked by the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_user_blocking")]
		public Actions_default_workflow_permissions Organization_user_blocking { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for packages published to GitHub Packages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packages")]
		public Actions_default_workflow_permissions Packages { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public Actions_default_workflow_permissions Pages { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pull_requests")]
		public Actions_default_workflow_permissions Pull_requests { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage the post-receive hooks for a repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_hooks")]
		public Actions_default_workflow_permissions Repository_hooks { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage repository projects, columns, and cards.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_projects")]
		public App_permissionsOrganization_projects Repository_projects { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to view and manage secret scanning alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret_scanning_alerts")]
		public Actions_default_workflow_permissions Secret_scanning_alerts { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage repository secrets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public Actions_default_workflow_permissions Secrets { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to view and manage security events like code scanning alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security_events")]
		public Actions_default_workflow_permissions Security_events { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage just a single file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="single_file")]
		public Actions_default_workflow_permissions Single_file { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token for commit statuses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public Actions_default_workflow_permissions Statuses { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage team discussions and related comments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="team_discussions")]
		public Actions_default_workflow_permissions Team_discussions { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to manage Dependabot alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vulnerability_alerts")]
		public Actions_default_workflow_permissions Vulnerability_alerts { get; set; }
		
		/// <summary>
		/// The level of permission to grant the access token to update GitHub Actions workflow files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workflows")]
		public System.Nullable<App_permissionsWorkflows> Workflows { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum App_permissionsOrganization_plan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum App_permissionsOrganization_projects
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		write = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum App_permissionsWorkflows
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		write = 0,
	}
	
	/// <summary>
	/// The authorization associated with an OAuth Access.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Application_grant
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app")]
		public Application_grantApp App { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Application_grantApp
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// An artifact
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Artifact
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_download_url")]
		public string Archive_download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Whether or not the artifact has expired.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expired")]
		public bool Expired { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public System.Nullable<System.DateTimeOffset> Expires_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The name of the artifact.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The size in bytes of the artifact.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size_in_bytes")]
		public int Size_in_bytes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="workflow_run")]
		public ArtifactWorkflow_run Workflow_run { get; set; }
	}
	
	public class ArtifactWorkflow_run
	{
		
		[System.Runtime.Serialization.DataMember(Name="head_branch")]
		public string Head_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="head_repository_id")]
		public System.Nullable<System.Int32> Head_repository_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="head_sha")]
		public string Head_sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repository_id")]
		public System.Nullable<System.Int32> Repository_id { get; set; }
	}
	
	/// <summary>
	/// Assigned Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Assigned_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Simple_user Assignee { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assigner")]
		public Simple_user Assigner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Integration
	{
		
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The list of events for the GitHub app
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="external_url")]
		public string External_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the GitHub app
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The number of installations associated with the GitHub app
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="installations_count")]
		public System.Nullable<System.Int32> Installations_count { get; set; }
		
		/// <summary>
		/// The name of the GitHub app
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Nullable_simple_user Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pem")]
		public string Pem { get; set; }
		
		/// <summary>
		/// The set of permissions for the GitHub app
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public IntegrationPermissions Permissions { get; set; }
		
		/// <summary>
		/// The slug name of the GitHub app
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="webhook_secret")]
		public string Webhook_secret { get; set; }
	}
	
	public class IntegrationPermissions
	{
		
		[System.Runtime.Serialization.DataMember(Name="checks")]
		public string Checks { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deployments")]
		public string Deployments { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issues")]
		public string Issues { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Audit_log_event
	{
		
		/// <summary>
		/// The time the audit log event occurred, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="@timestamp")]
		public System.Nullable<System.Int32> _timestamp { get; set; }
		
		/// <summary>
		/// A unique identifier for an audit event.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string _document_id { get; set; }
		
		/// <summary>
		/// The name of the action that was performed, for example `user.login` or `repo.create`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="active_was")]
		public System.Nullable<System.Boolean> Active_was { get; set; }
		
		/// <summary>
		/// The actor who performed the action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public string Actor { get; set; }
		
		/// <summary>
		/// The id of the actor who performed the action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actor_id")]
		public System.Nullable<System.Int32> Actor_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="actor_location")]
		public Audit_log_eventActor_location Actor_location { get; set; }
		
		/// <summary>
		/// The username of the account being blocked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blocked_user")]
		public string Blocked_user { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="business")]
		public string Business { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="business_id")]
		public System.Nullable<System.Int32> Business_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="config")]
		public string[] Config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="config_was")]
		public string[] Config_was { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		/// <summary>
		/// The time the audit log event was recorded, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.Int32> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deploy_key_fingerprint")]
		public string Deploy_key_fingerprint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="emoji")]
		public string Emoji { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events_were")]
		public string[] Events_were { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="explanation")]
		public string Explanation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hook_id")]
		public System.Nullable<System.Int32> Hook_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="limited_availability")]
		public System.Nullable<System.Boolean> Limited_availability { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="old_user")]
		public string Old_user { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openssh_public_key")]
		public string Openssh_public_key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operation_type")]
		public string Operation_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="org")]
		public string Org { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="org_id")]
		public System.Nullable<System.Int32> Org_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_visibility")]
		public string Previous_visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="read_only")]
		public System.Nullable<System.Boolean> Read_only { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public string Repo { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public string Repository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repository_public")]
		public System.Nullable<System.Boolean> Repository_public { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target_login")]
		public string Target_login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="team")]
		public string Team { get; set; }
		
		/// <summary>
		/// The type of protocol (for example, HTTP or SSH) used to transfer Git data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transport_protocol")]
		public System.Nullable<System.Int32> Transport_protocol { get; set; }
		
		/// <summary>
		/// A human readable name for the protocol (for example, HTTP or SSH) used to transfer Git data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transport_protocol_name")]
		public string Transport_protocol_name { get; set; }
		
		/// <summary>
		/// The user that was affected by the action performed (if available).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_id")]
		public System.Nullable<System.Int32> User_id { get; set; }
		
		/// <summary>
		/// The repository visibility, for example `public` or `private`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
	}
	
	public class Audit_log_eventActor_location
	{
		
		[System.Runtime.Serialization.DataMember(Name="country_name")]
		public string Country_name { get; set; }
	}
	
	/// <summary>
	/// Authentication Token
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Authentication_token
	{
		
		/// <summary>
		/// The time this token expires
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public System.DateTimeOffset Expires_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string Permissions { get; set; }
		
		/// <summary>
		/// The repositories this token has access to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Repository[] Repositories { get; set; }
		
		/// <summary>
		/// Describe whether all repositories have been selected or there's a selection involved
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_selection")]
		public System.Nullable<Authentication_tokenRepository_selection> Repository_selection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="single_file")]
		public string Single_file { get; set; }
		
		/// <summary>
		/// The token used for authentication
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// A repository on GitHub.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Repository
	{
		
		/// <summary>
		/// Whether to allow Auto-merge to be used on pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		/// <summary>
		/// Whether to allow forking this repo
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		/// <summary>
		/// Whether to allow merge commits for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		/// <summary>
		/// Whether to allow rebase merges for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		/// <summary>
		/// Whether to allow squash merges for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_update_branch")]
		public System.Nullable<System.Boolean> Allow_update_branch { get; set; }
		
		/// <summary>
		/// Whether anonymous git access is enabled for this repository
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="anonymous_access_enabled")]
		public System.Nullable<System.Boolean> Anonymous_access_enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// Whether the repository is archived.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; } = false;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The default branch of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		/// <summary>
		/// Whether to delete head branches when pull requests are merged
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Returns whether or not this repository disabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public bool Disabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public int Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public int Forks_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Whether downloads are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public bool Has_downloads { get; set; } = true;
		
		/// <summary>
		/// Whether issues are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public bool Has_issues { get; set; } = true;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public bool Has_pages { get; set; }
		
		/// <summary>
		/// Whether projects are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public bool Has_projects { get; set; } = true;
		
		/// <summary>
		/// Whether the wiki is enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public bool Has_wiki { get; set; } = true;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Whether this repository acts as a template that can be used to generate new repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// License Simple
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Nullable_license_simple License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="master_branch")]
		public string Master_branch { get; set; }
		
		/// <summary>
		/// The default value for a merge commit message.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `PR_BODY` - default to the pull request's body.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_message")]
		public System.Nullable<RepositoryMerge_commit_message> Merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a merge commit title.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_title")]
		public System.Nullable<RepositoryMerge_commit_title> Merge_commit_title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network_count")]
		public System.Nullable<System.Int32> Network_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public int Open_issues_count { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public Nullable_simple_user Organization { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Simple_user Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public RepositoryPermissions Permissions { get; set; }
		
		/// <summary>
		/// Whether the repository is private or public.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; } = false;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public System.Nullable<System.DateTimeOffset> Pushed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		/// <summary>
		/// The size of the repository. Size is calculated hourly. When a repository is initially created, the size is 0.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit message:
		///
		///- `PR_BODY` - default to the pull request's body.
		///- `COMMIT_MESSAGES` - default to the branch's commit messages.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_message")]
		public System.Nullable<RepositorySquash_merge_commit_message> Squash_merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit title:
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_title")]
		public System.Nullable<RepositorySquash_merge_commit_title> Squash_merge_commit_title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public int Stargazers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_at")]
		public string Starred_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscribers_count")]
		public System.Nullable<System.Int32> Subscribers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="template_repository")]
		public RepositoryTemplate_repository Template_repository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Whether a squash merge commit can use the pull request title as default. **This property has been deprecated. Please use `squash_merge_commit_title` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_squash_pr_title_as_default")]
		public System.Nullable<System.Boolean> Use_squash_pr_title_as_default { get; set; }
		
		/// <summary>
		/// The repository visibility: public, private, or internal.
		/// </summary>
		[System.ComponentModel.DefaultValue("public")]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; } = "public";
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers")]
		public int Watchers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public int Watchers_count { get; set; }
		
		/// <summary>
		/// Whether to require contributors to sign off on web-based commits
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	/// <summary>
	/// License Simple
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_license_simple
	{
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spdx_id")]
		public string Spdx_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RepositoryMerge_commit_message
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PR_BODY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PR_TITLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BLANK = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RepositoryMerge_commit_title
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PR_TITLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MERGE_MESSAGE = 1,
	}
	
	public class RepositoryPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RepositorySquash_merge_commit_message
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PR_BODY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMIT_MESSAGES = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BLANK = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RepositorySquash_merge_commit_title
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PR_TITLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMIT_OR_PR_TITLE = 1,
	}
	
	public class RepositoryTemplate_repository
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_update_branch")]
		public System.Nullable<System.Boolean> Allow_update_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public System.Nullable<System.Boolean> Fork { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public System.Nullable<System.Int32> Forks_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public System.Nullable<System.Boolean> Has_downloads { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public System.Nullable<System.Boolean> Has_issues { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public System.Nullable<System.Boolean> Has_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public System.Nullable<System.Boolean> Has_projects { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public System.Nullable<System.Boolean> Has_wiki { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// The default value for a merge commit message.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `PR_BODY` - default to the pull request's body.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_message")]
		public RepositoryMerge_commit_message Merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a merge commit title.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_title")]
		public RepositoryMerge_commit_title Merge_commit_title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network_count")]
		public System.Nullable<System.Int32> Network_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public System.Nullable<System.Int32> Open_issues_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public RepositoryTemplate_repositoryOwner Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public RepositoryTemplate_repositoryPermissions Permissions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public string Pushed_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit message:
		///
		///- `PR_BODY` - default to the pull request's body.
		///- `COMMIT_MESSAGES` - default to the branch's commit messages.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_message")]
		public RepositorySquash_merge_commit_message Squash_merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit title:
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_title")]
		public RepositorySquash_merge_commit_title Squash_merge_commit_title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public System.Nullable<System.Int32> Stargazers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscribers_count")]
		public System.Nullable<System.Int32> Subscribers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="use_squash_pr_title_as_default")]
		public System.Nullable<System.Boolean> Use_squash_pr_title_as_default { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public System.Nullable<System.Int32> Watchers_count { get; set; }
	}
	
	public class RepositoryTemplate_repositoryOwner
	{
		
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public System.Nullable<System.Boolean> Site_admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class RepositoryTemplate_repositoryPermissions
	{
		
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public System.Nullable<System.Boolean> Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public System.Nullable<System.Boolean> Pull { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="push")]
		public System.Nullable<System.Boolean> Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Authentication_tokenRepository_selection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 1,
	}
	
	/// <summary>
	/// How the author is associated with the repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Author_association
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLLABORATOR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTRIBUTOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIRST_TIMER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIRST_TIME_CONTRIBUTOR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANNEQUIN = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MEMBER = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNER = 7,
	}
	
	/// <summary>
	/// The authorization for an OAuth app, GitHub App, or a Personal Access Token.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Authorization
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app")]
		public AuthorizationApp App { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public System.Nullable<System.DateTimeOffset> Expires_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hashed_token")]
		public string Hashed_token { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="installation")]
		public Nullable_scoped_installation Installation { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="note_url")]
		public string Note_url { get; set; }
		
		/// <summary>
		/// A list of scopes that this authorization is in.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token_last_eight")]
		public string Token_last_eight { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class AuthorizationApp
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_scoped_installation
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="account")]
		public Simple_user Account { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_multiple_single_files")]
		public System.Nullable<System.Boolean> Has_multiple_single_files { get; set; }
		
		/// <summary>
		/// The permissions granted to the user-to-server access token.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public App_permissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories_url")]
		public string Repositories_url { get; set; }
		
		/// <summary>
		/// Describe whether all repositories have been selected or there's a selection involved
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_selection")]
		public Authentication_tokenRepository_selection Repository_selection { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="single_file_name")]
		public string Single_file_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="single_file_paths")]
		public string[] Single_file_paths { get; set; }
	}
	
	/// <summary>
	/// The status of auto merging a pull request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Auto_merge
	{
		
		/// <summary>
		/// Commit message for the merge commit.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_message")]
		public string Commit_message { get; set; }
		
		/// <summary>
		/// Title for the merge commit message.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_title")]
		public string Commit_title { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled_by")]
		public Simple_user Enabled_by { get; set; }
		
		/// <summary>
		/// The merge method to use.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merge_method")]
		public Auto_mergeMerge_method Merge_method { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Auto_mergeMerge_method
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		merge = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		squash = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rebase = 2,
	}
	
	/// <summary>
	/// An autolink reference.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Autolink
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The prefix of a key that is linkified.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key_prefix")]
		public string Key_prefix { get; set; }
		
		/// <summary>
		/// A template for the target URL that is generated if a key was found.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url_template")]
		public string Url_template { get; set; }
	}
	
	/// <summary>
	/// Base Gist
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Base_gist
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public int Comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="files")]
		public System.Collections.Generic.Dictionary<string, Base_gistFiles> Files { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public string[] Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_pull_url")]
		public string Git_pull_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_push_url")]
		public string Git_push_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="history")]
		public string[] History { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Simple_user Owner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public")]
		public bool Public { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truncated")]
		public System.Nullable<System.Boolean> Truncated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Base_gistFiles
	{
		
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="raw_url")]
		public string Raw_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Basic Error
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Basic_error
	{
		
		[System.Runtime.Serialization.DataMember(Name="documentation_url")]
		public string Documentation_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Blob
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Blob
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encoding")]
		public string Encoding { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="highlighted_content")]
		public string Highlighted_content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Branch Protection
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Branch_protection
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_deletions")]
		public Branch_protectionAllow_deletions Allow_deletions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_force_pushes")]
		public Branch_protectionAllow_force_pushes Allow_force_pushes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="block_creations")]
		public Branch_protectionBlock_creations Block_creations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Protected Branch Admin Enforced
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforce_admins")]
		public Protected_branch_admin_enforced Enforce_admins { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protection_url")]
		public string Protection_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_conversation_resolution")]
		public Branch_protectionRequired_conversation_resolution Required_conversation_resolution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_linear_history")]
		public Branch_protectionRequired_linear_history Required_linear_history { get; set; }
		
		/// <summary>
		/// Protected Branch Pull Request Review
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_pull_request_reviews")]
		public Protected_branch_pull_request_review Required_pull_request_reviews { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_signatures")]
		public Branch_protectionRequired_signatures Required_signatures { get; set; }
		
		/// <summary>
		/// Protected Branch Required Status Check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_status_checks")]
		public Protected_branch_required_status_check Required_status_checks { get; set; }
		
		/// <summary>
		/// Branch Restriction Policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restrictions")]
		public Branch_restriction_policy Restrictions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Branch_protectionAllow_deletions
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class Branch_protectionAllow_force_pushes
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class Branch_protectionBlock_creations
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// Protected Branch Admin Enforced
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Protected_branch_admin_enforced
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Branch_protectionRequired_conversation_resolution
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class Branch_protectionRequired_linear_history
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// Protected Branch Pull Request Review
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Protected_branch_pull_request_review
	{
		
		/// <summary>
		/// Allow specific users, teams, or apps to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bypass_pull_request_allowances")]
		public Protected_branch_pull_request_reviewBypass_pull_request_allowances Bypass_pull_request_allowances { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismiss_stale_reviews")]
		public bool Dismiss_stale_reviews { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dismissal_restrictions")]
		public Protected_branch_pull_request_reviewDismissal_restrictions Dismissal_restrictions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="require_code_owner_reviews")]
		public bool Require_code_owner_reviews { get; set; }
		
		/// <summary>
		/// Minimum: 0
		/// Maximum: 6
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_approving_review_count")]
		[System.ComponentModel.DataAnnotations.Range(0, 6)]
		public System.Nullable<System.Int32> Required_approving_review_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Protected_branch_pull_request_reviewBypass_pull_request_allowances
	{
		
		/// <summary>
		/// The list of apps allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public Integration[] Apps { get; set; }
		
		/// <summary>
		/// The list of teams allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public Team[] Teams { get; set; }
		
		/// <summary>
		/// The list of users allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public Simple_user[] Users { get; set; }
	}
	
	/// <summary>
	/// Groups of organization members that gives permissions on specified repositories.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Groups of organization members that gives permissions on specified repositories.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public Nullable_team_simple Parent { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public TeamPermissions Permissions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public string Privacy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories_url")]
		public string Repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Groups of organization members that gives permissions on specified repositories.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_team_simple
	{
		
		/// <summary>
		/// Description of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Distinguished Name (DN) that team maps to within LDAP environment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		/// <summary>
		/// Name of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Permission that the team will have for its repositories
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; }
		
		/// <summary>
		/// The level of privacy this team should have
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public string Privacy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories_url")]
		public string Repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// URL for the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class TeamPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public bool Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public bool Triage { get; set; }
	}
	
	public class Protected_branch_pull_request_reviewDismissal_restrictions
	{
		
		/// <summary>
		/// The list of apps with review dismissal access.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public Integration[] Apps { get; set; }
		
		/// <summary>
		/// The list of teams with review dismissal access.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public Team[] Teams { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The list of users with review dismissal access.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public Simple_user[] Users { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="users_url")]
		public string Users_url { get; set; }
	}
	
	public class Branch_protectionRequired_signatures
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Protected Branch Required Status Check
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Protected_branch_required_status_check
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="checks")]
		public Protected_branch_required_status_checkChecks[] Protected_branch_required_status_checkChecks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contexts")]
		public string[] Contexts { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contexts_url")]
		public string Contexts_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enforcement_level")]
		public string Enforcement_level { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="strict")]
		public System.Nullable<System.Boolean> Strict { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Protected_branch_required_status_checkChecks
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app_id")]
		public System.Nullable<System.Int32> App_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
	}
	
	/// <summary>
	/// Branch Restriction Policy
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Branch_restriction_policy
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public Branch_restriction_policyApps[] Branch_restriction_policyApps { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apps_url")]
		public string Apps_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public Branch_restriction_policyTeams[] Branch_restriction_policyTeams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users")]
		public Branch_restriction_policyUsers[] Branch_restriction_policyUsers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users_url")]
		public string Users_url { get; set; }
	}
	
	public class Branch_restriction_policyApps
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="external_url")]
		public string External_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Branch_restriction_policyAppsOwner Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Branch_restriction_policyAppsPermissions Permissions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	public class Branch_restriction_policyAppsOwner
	{
		
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="public_members_url")]
		public string Public_members_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public System.Nullable<System.Boolean> Site_admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Branch_restriction_policyAppsPermissions
	{
		
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issues")]
		public string Issues { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="single_file")]
		public string Single_file { get; set; }
	}
	
	public class Branch_restriction_policyTeams
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public string Parent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public string Privacy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repositories_url")]
		public string Repositories_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Branch_restriction_policyUsers
	{
		
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public System.Nullable<System.Boolean> Site_admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Branch Short
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Branch_short
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit")]
		public Branch_shortCommit Commit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protected")]
		public bool Protected { get; set; }
	}
	
	public class Branch_shortCommit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Branch With Protection
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Branch_with_protection
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Branch_with_protection_links _links { get; set; }
		
		/// <summary>
		/// Commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit")]
		public Commit Commit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pattern")]
		public string Pattern { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protected")]
		public bool Protected { get; set; }
		
		/// <summary>
		/// Branch Protection
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Branch_protection Protection { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection_url")]
		public string Protection_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_approving_review_count")]
		public System.Nullable<System.Int32> Required_approving_review_count { get; set; }
	}
	
	public class Branch_with_protection_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	/// <summary>
	/// Commit
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Commit
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Nullable_simple_user Author { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit")]
		public CommitCommit1 Commit1 { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public Nullable_simple_user Committer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="files")]
		public Diff_entry[] Files { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parents")]
		public CommitParents[] CommitParents { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stats")]
		public CommitStats Stats { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class CommitCommit1
	{
		
		/// <summary>
		/// Metaproperties for Git author/committer information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Nullable_git_user Author { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment_count")]
		public int Comment_count { get; set; }
		
		/// <summary>
		/// Metaproperties for Git author/committer information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public Nullable_git_user Committer { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree")]
		public CommitCommit1Tree Tree { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="verification")]
		public Verification Verification { get; set; }
	}
	
	/// <summary>
	/// Metaproperties for Git author/committer information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_git_user
	{
		
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CommitCommit1Tree
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Verification
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public string Payload { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public bool Verified { get; set; }
	}
	
	/// <summary>
	/// Diff Entry
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Diff_entry
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="additions")]
		public int Additions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blob_url")]
		public string Blob_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="changes")]
		public int Changes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deletions")]
		public int Deletions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="patch")]
		public string Patch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_filename")]
		public string Previous_filename { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="raw_url")]
		public string Raw_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Diff_entryStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Diff_entryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		added = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		removed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		modified = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		renamed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		copied = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		changed = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unchanged = 6,
	}
	
	public class CommitParents
	{
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class CommitStats
	{
		
		[System.Runtime.Serialization.DataMember(Name="additions")]
		public System.Nullable<System.Int32> Additions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deletions")]
		public System.Nullable<System.Int32> Deletions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Check Annotation
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Check_annotation
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="annotation_level")]
		public string Annotation_level { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blob_href")]
		public string Blob_href { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end_column")]
		public System.Nullable<System.Int32> End_column { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end_line")]
		public int End_line { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="raw_details")]
		public string Raw_details { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start_column")]
		public System.Nullable<System.Int32> Start_column { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public int Start_line { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// A check performed on the code of a given code change
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Check_run
	{
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app")]
		public Nullable_integration App { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="check_suite")]
		public Check_runCheck_suite Check_suite { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="completed_at")]
		public System.Nullable<System.DateTimeOffset> Completed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conclusion")]
		public System.Nullable<Check_runConclusion> Conclusion { get; set; }
		
		/// <summary>
		/// A deployment created as the result of an Actions check run from a workflow that references an environment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deployment")]
		public Deployment_simple Deployment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="details_url")]
		public string Details_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="external_id")]
		public string External_id { get; set; }
		
		/// <summary>
		/// The SHA of the commit that is being checked.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_sha")]
		public string Head_sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The id of the check.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The name of the check.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output")]
		public Check_runOutput Output { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_requests")]
		public Pull_request_minimal[] Pull_requests { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started_at")]
		public System.Nullable<System.DateTimeOffset> Started_at { get; set; }
		
		/// <summary>
		/// The phase of the lifecycle that the check is currently in.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Check_runStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Check_runCheck_suite
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Check_runConclusion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		neutral = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cancelled = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		skipped = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		timed_out = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		action_required = 6,
	}
	
	/// <summary>
	/// A deployment created as the result of an Actions check run from a workflow that references an environment
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Deployment_simple
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Name for the target deployment environment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public string Environment { get; set; }
		
		/// <summary>
		/// Unique identifier of the deployment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="original_environment")]
		public string Original_environment { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Specifies if the given environment is one that end-users directly interact with. Default: false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="production_environment")]
		public System.Nullable<System.Boolean> Production_environment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// Parameter to specify a task to execute
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="task")]
		public string Task { get; set; }
		
		/// <summary>
		/// Specifies if the given environment is will no longer exist at some point in the future. Default: false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transient_environment")]
		public System.Nullable<System.Boolean> Transient_environment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Check_runOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="annotations_count")]
		public int Annotations_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="annotations_url")]
		public string Annotations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="summary")]
		public string Summary { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pull_request_minimal
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="base")]
		public Pull_request_minimalBase Base { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head")]
		public Pull_request_minimalHead Head { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pull_request_minimalBase
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public Pull_request_minimalBaseRepo Repo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
	}
	
	public class Pull_request_minimalBaseRepo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pull_request_minimalHead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public Pull_request_minimalHeadRepo Repo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
	}
	
	public class Pull_request_minimalHeadRepo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Check_runStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		in_progress = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 2,
	}
	
	/// <summary>
	/// A suite of checks performed on the code of a given code change
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Check_suite
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="after")]
		public string After { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app")]
		public Nullable_integration App { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="before")]
		public string Before { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="check_runs_url")]
		public string Check_runs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conclusion")]
		public System.Nullable<Check_suiteConclusion> Conclusion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_branch")]
		public string Head_branch { get; set; }
		
		/// <summary>
		/// A commit.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_commit")]
		public Simple_commit Head_commit { get; set; }
		
		/// <summary>
		/// The SHA of the head commit that is being checked.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_sha")]
		public string Head_sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latest_check_runs_count")]
		public int Latest_check_runs_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_requests")]
		public Pull_request_minimal[] Pull_requests { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Minimal_repository Repository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rerequestable")]
		public System.Nullable<System.Boolean> Rerequestable { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="runs_rerequestable")]
		public System.Nullable<System.Boolean> Runs_rerequestable { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Check_runStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Check_suiteConclusion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		neutral = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cancelled = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		skipped = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		timed_out = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		action_required = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		startup_failure = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stale = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 9,
	}
	
	/// <summary>
	/// A commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Simple_commit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Simple_commitAuthor Author { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public Simple_commitCommitter Committer { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.DateTimeOffset Timestamp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree_id")]
		public string Tree_id { get; set; }
	}
	
	public class Simple_commitAuthor
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Simple_commitCommitter
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Minimal Repository
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Minimal_repository
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		/// <summary>
		/// Code Of Conduct
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code_of_conduct")]
		public Code_of_conduct Code_of_conduct { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public System.Nullable<System.Int32> Forks { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public System.Nullable<System.Int32> Forks_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public System.Nullable<System.Boolean> Has_downloads { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public System.Nullable<System.Boolean> Has_issues { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public System.Nullable<System.Boolean> Has_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public System.Nullable<System.Boolean> Has_projects { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public System.Nullable<System.Boolean> Has_wiki { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Minimal_repositoryLicense License { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network_count")]
		public System.Nullable<System.Int32> Network_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public System.Nullable<System.Int32> Open_issues { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public System.Nullable<System.Int32> Open_issues_count { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Simple_user Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Minimal_repositoryPermissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public System.Nullable<System.DateTimeOffset> Pushed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="role_name")]
		public string Role_name { get; set; }
		
		/// <summary>
		/// The size of the repository. Size is calculated hourly. When a repository is initially created, the size is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public System.Nullable<System.Int32> Stargazers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscribers_count")]
		public System.Nullable<System.Int32> Subscribers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watchers")]
		public System.Nullable<System.Int32> Watchers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public System.Nullable<System.Int32> Watchers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	/// <summary>
	/// Code Of Conduct
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_of_conduct
	{
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Minimal_repositoryLicense
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="spdx_id")]
		public string Spdx_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Minimal_repositoryPermissions
	{
		
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public System.Nullable<System.Boolean> Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public System.Nullable<System.Boolean> Pull { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="push")]
		public System.Nullable<System.Boolean> Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	/// <summary>
	/// Check suite configuration preferences for a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Check_suite_preference
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preferences")]
		public Check_suite_preferencePreferences Preferences { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Minimal_repository Repository { get; set; }
	}
	
	public class Check_suite_preferencePreferences
	{
		
		[System.Runtime.Serialization.DataMember(Name="auto_trigger_checks")]
		public Check_suite_preferencePreferencesAuto_trigger_checks[] Check_suite_preferencePreferencesAuto_trigger_checks { get; set; }
	}
	
	public class Check_suite_preferencePreferencesAuto_trigger_checks
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app_id")]
		public int App_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="setting")]
		public bool Setting { get; set; }
	}
	
	/// <summary>
	/// Code of Conduct Simple
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_of_conduct_simple
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_alert
	{
		
		/// <summary>
		/// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_at")]
		public System.Nullable<System.DateTimeOffset> Dismissed_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_by")]
		public Nullable_simple_user Dismissed_by { get; set; }
		
		/// <summary>
		/// The dismissal comment associated with the dismissal of the alert.
		/// Max length: 280
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismissed_comment")]
		[System.ComponentModel.DataAnnotations.MaxLength(280)]
		public string Dismissed_comment { get; set; }
		
		/// <summary>
		/// **Required when the state is dismissed.** The reason for dismissing or closing the alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_reason")]
		public System.Nullable<Code_scanning_alertDismissed_reason> Dismissed_reason { get; set; }
		
		/// <summary>
		/// The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixed_at")]
		public System.Nullable<System.DateTimeOffset> Fixed_at { get; set; }
		
		/// <summary>
		/// The GitHub URL of the alert resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The REST API URL for fetching the list of instances for an alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instances_url")]
		public string Instances_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="most_recent_instance")]
		public Code_scanning_alert_instance Most_recent_instance { get; set; }
		
		/// <summary>
		/// The security alert number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rule")]
		public Code_scanning_alert_rule Rule { get; set; }
		
		/// <summary>
		/// State of a code scanning alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Code_scanning_alertState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tool")]
		public Code_scanning_analysis_tool Tool { get; set; }
		
		/// <summary>
		/// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The REST API URL of the alert resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alertDismissed_reason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false positive")]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="won't fix")]
		won_t_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="used in tests")]
		used_in_tests = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_alert_instance
	{
		
		/// <summary>
		/// Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="analysis_key")]
		public string Analysis_key { get; set; }
		
		/// <summary>
		/// Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Classifications that have been applied to the file that triggered the alert.
		///For example identifying it as documentation, or a generated file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classifications")]
		public Code_scanning_alert_classification[] Classifications { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="commit_sha")]
		public string Commit_sha { get; set; }
		
		/// <summary>
		/// Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public string Environment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Describe a region within a file for the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Code_scanning_alert_location Location { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public Code_scanning_alert_instanceMessage Message { get; set; }
		
		/// <summary>
		/// The full Git reference, formatted as `refs/heads/<branch name>`,
		///`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// State of a code scanning alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<Code_scanning_alert_instanceState> State { get; set; }
	}
	
	/// <summary>
	/// A classification of the file. For example to identify it as generated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_classification
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		source = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		generated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		test = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		library = 3,
	}
	
	/// <summary>
	/// Describe a region within a file for the alert.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_alert_location
	{
		
		[System.Runtime.Serialization.DataMember(Name="end_column")]
		public System.Nullable<System.Int32> End_column { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="end_line")]
		public System.Nullable<System.Int32> End_line { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start_column")]
		public System.Nullable<System.Int32> Start_column { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public System.Nullable<System.Int32> Start_line { get; set; }
	}
	
	public class Code_scanning_alert_instanceMessage
	{
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_instanceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dismissed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fixed")]
		_fixed = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_alert_rule
	{
		
		/// <summary>
		/// A short description of the rule used to detect the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// description of the rule used to detect the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="full_description")]
		public string Full_description { get; set; }
		
		/// <summary>
		/// Detailed documentation for the rule as GitHub Flavored Markdown.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="help")]
		public string Help { get; set; }
		
		/// <summary>
		/// A link to the documentation for the rule used to detect the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="help_uri")]
		public string Help_uri { get; set; }
		
		/// <summary>
		/// A unique identifier for the rule used to detect the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the rule used to detect the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The security severity of the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security_severity_level")]
		public System.Nullable<Code_scanning_alert_ruleSecurity_severity_level> Security_severity_level { get; set; }
		
		/// <summary>
		/// The severity of the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public System.Nullable<Code_scanning_alert_ruleSeverity> Severity { get; set; }
		
		/// <summary>
		/// A set of tags applicable for the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_ruleSecurity_severity_level
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		low = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		medium = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		high = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		critical = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_ruleSeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		note = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		warning = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		error = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alertState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dismissed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fixed")]
		_fixed = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_analysis_tool
	{
		
		/// <summary>
		/// The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guid")]
		public string Guid { get; set; }
		
		/// <summary>
		/// The name of the tool used to generate the code scanning analysis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The version of the tool used to generate the code scanning analysis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// **Required when the state is dismissed.** The reason for dismissing or closing the alert.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_dismissed_reason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false positive")]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="won't fix")]
		won_t_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="used in tests")]
		used_in_tests = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_alert_items
	{
		
		/// <summary>
		/// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_at")]
		public System.Nullable<System.DateTimeOffset> Dismissed_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_by")]
		public Nullable_simple_user Dismissed_by { get; set; }
		
		/// <summary>
		/// The dismissal comment associated with the dismissal of the alert.
		/// Max length: 280
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismissed_comment")]
		[System.ComponentModel.DataAnnotations.MaxLength(280)]
		public string Dismissed_comment { get; set; }
		
		/// <summary>
		/// **Required when the state is dismissed.** The reason for dismissing or closing the alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_reason")]
		public System.Nullable<Code_scanning_alert_itemsDismissed_reason> Dismissed_reason { get; set; }
		
		/// <summary>
		/// The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixed_at")]
		public System.Nullable<System.DateTimeOffset> Fixed_at { get; set; }
		
		/// <summary>
		/// The GitHub URL of the alert resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The REST API URL for fetching the list of instances for an alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instances_url")]
		public string Instances_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="most_recent_instance")]
		public Code_scanning_alert_instance Most_recent_instance { get; set; }
		
		/// <summary>
		/// The security alert number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rule")]
		public Code_scanning_alert_rule_summary Rule { get; set; }
		
		/// <summary>
		/// State of a code scanning alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Code_scanning_alert_itemsState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tool")]
		public Code_scanning_analysis_tool Tool { get; set; }
		
		/// <summary>
		/// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The REST API URL of the alert resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_itemsDismissed_reason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false positive")]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="won't fix")]
		won_t_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="used in tests")]
		used_in_tests = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_alert_rule_summary
	{
		
		/// <summary>
		/// A short description of the rule used to detect the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A unique identifier for the rule used to detect the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the rule used to detect the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The severity of the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public Code_scanning_alert_ruleSeverity Severity { get; set; }
		
		/// <summary>
		/// A set of tags applicable for the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_itemsState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dismissed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fixed")]
		_fixed = 3,
	}
	
	/// <summary>
	/// Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_set_state
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dismissed = 1,
	}
	
	/// <summary>
	/// State of a code scanning alert.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_alert_state
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dismissed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fixed")]
		_fixed = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_analysis
	{
		
		/// <summary>
		/// Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analysis_key")]
		public string Analysis_key { get; set; }
		
		/// <summary>
		/// Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// The SHA of the commit to which the analysis you are uploading relates.
		/// Required
		/// Max length: 40
		/// Min length: 40
		/// Pattern: ^[0-9a-fA-F]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_sha")]
		[System.ComponentModel.DataAnnotations.MinLength(40)]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[0-9a-fA-F]+$")]
		public string Commit_sha { get; set; }
		
		/// <summary>
		/// The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deletable")]
		public bool Deletable { get; set; }
		
		/// <summary>
		/// Identifies the variable values associated with the environment in which this analysis was performed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public string Environment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		/// <summary>
		/// Unique identifier for this analysis.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The full Git reference, formatted as `refs/heads/<branch name>`,
		///`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// The total number of results in the analysis.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results_count")]
		public int Results_count { get; set; }
		
		/// <summary>
		/// The total number of rules used in the analysis.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules_count")]
		public int Rules_count { get; set; }
		
		/// <summary>
		/// An identifier for the upload.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sarif_id")]
		public string Sarif_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tool")]
		public Code_scanning_analysis_tool Tool { get; set; }
		
		/// <summary>
		/// The REST API URL of the analysis resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Warning generated when processing the analysis
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public string Warning { get; set; }
	}
	
	/// <summary>
	/// Successful deletion of a code scanning analysis
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_analysis_deletion
	{
		
		/// <summary>
		/// Next deletable analysis in chain, with last analysis deletion confirmation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="confirm_delete_url")]
		public string Confirm_delete_url { get; set; }
		
		/// <summary>
		/// Next deletable analysis in chain, without last analysis deletion confirmation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_analysis_url")]
		public string Next_analysis_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_organization_alert_items
	{
		
		/// <summary>
		/// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_at")]
		public System.Nullable<System.DateTimeOffset> Dismissed_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_by")]
		public Nullable_simple_user Dismissed_by { get; set; }
		
		/// <summary>
		/// The dismissal comment associated with the dismissal of the alert.
		/// Max length: 280
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismissed_comment")]
		[System.ComponentModel.DataAnnotations.MaxLength(280)]
		public string Dismissed_comment { get; set; }
		
		/// <summary>
		/// **Required when the state is dismissed.** The reason for dismissing or closing the alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_reason")]
		public System.Nullable<Code_scanning_organization_alert_itemsDismissed_reason> Dismissed_reason { get; set; }
		
		/// <summary>
		/// The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixed_at")]
		public System.Nullable<System.DateTimeOffset> Fixed_at { get; set; }
		
		/// <summary>
		/// The GitHub URL of the alert resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The REST API URL for fetching the list of instances for an alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instances_url")]
		public string Instances_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="most_recent_instance")]
		public Code_scanning_alert_instance Most_recent_instance { get; set; }
		
		/// <summary>
		/// The security alert number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// A GitHub repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Simple_repository Repository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rule")]
		public Code_scanning_alert_rule Rule { get; set; }
		
		/// <summary>
		/// State of a code scanning alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Code_scanning_organization_alert_itemsState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tool")]
		public Code_scanning_analysis_tool Tool { get; set; }
		
		/// <summary>
		/// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The REST API URL of the alert resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_organization_alert_itemsDismissed_reason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false positive")]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="won't fix")]
		won_t_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="used in tests")]
		used_in_tests = 3,
	}
	
	/// <summary>
	/// A GitHub repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Simple_repository
	{
		
		/// <summary>
		/// A template for the API URL to download the repository as an archive.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to list the available assignees for issues in the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to create or retrieve a raw Git blob in the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about branches in the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about collaborators of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about comments on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about commits on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to compare two commits or refs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get the contents of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to list the contributors to the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		/// <summary>
		/// The API URL to list the deployments of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// The repository description.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The API URL to list the downloads on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// The API URL to list the events of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Whether the repository is a fork.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		/// <summary>
		/// The API URL to list the forks of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// The full, globally unique, name of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about Git commits of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about Git refs of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about Git tags of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		/// <summary>
		/// The API URL to list the hooks on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// The URL to view the repository on GitHub.com.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// A unique identifier of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about issue comments on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about issue events on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about issues on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about deploy keys on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about labels of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// The API URL to get information about the languages of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// The API URL to merge branches in the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about milestones of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The GraphQL identifier of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about notifications on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Simple_user Owner { get; set; }
		
		/// <summary>
		/// Whether the repository is private.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about pull requests on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about releases on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		/// <summary>
		/// The API URL to list the stargazers on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to get information about statuses of a commit.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// The API URL to list the subscribers on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// The API URL to subscribe to notifications for this repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// The API URL to get information about tags on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// The API URL to list the teams on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		/// <summary>
		/// A template for the API URL to create or retrieve a raw Git tree of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		/// <summary>
		/// The URL to get more information about the repository from the GitHub API.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_organization_alert_itemsState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dismissed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fixed")]
		_fixed = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_sarifs_receipt
	{
		
		/// <summary>
		/// An identifier for the upload.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The REST API URL for checking the status of the upload.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_scanning_sarifs_status
	{
		
		/// <summary>
		/// The REST API URL for getting the analyses associated with the upload.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="analyses_url")]
		public string Analyses_url { get; set; }
		
		/// <summary>
		/// Any errors that ocurred during processing of the delivery.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public string[] Errors { get; set; }
		
		/// <summary>
		/// `pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="processing_status")]
		public System.Nullable<Code_scanning_sarifs_statusProcessing_status> Processing_status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanning_sarifs_statusProcessing_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		complete = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 2,
	}
	
	/// <summary>
	/// Code Search Result Item
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_search_result_item
	{
		
		[System.Runtime.Serialization.DataMember(Name="file_size")]
		public System.Nullable<System.Int32> File_size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_modified_at")]
		public System.Nullable<System.DateTimeOffset> Last_modified_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="line_numbers")]
		public string[] Line_numbers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Minimal_repository Repository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score")]
		public double Score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text_matches")]
		public Code_search_result_itemText_matches[] Code_search_result_itemText_matches { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Code_search_result_itemText_matches
	{
		
		[System.Runtime.Serialization.DataMember(Name="fragment")]
		public string Fragment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public Code_search_result_itemText_matchesMatches[] Code_search_result_itemText_matchesMatches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_type")]
		public string Object_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_url")]
		public string Object_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="property")]
		public string Property { get; set; }
	}
	
	public class Code_search_result_itemText_matchesMatches
	{
		
		[System.Runtime.Serialization.DataMember(Name="indices")]
		public int[] Indices { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// A list of errors found in a repo's CODEOWNERS file
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Codeowners_errors
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public Codeowners_errorsErrors[] Codeowners_errorsErrors { get; set; }
	}
	
	public class Codeowners_errorsErrors
	{
		
		/// <summary>
		/// The column number where this errors occurs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column")]
		public int Column { get; set; }
		
		/// <summary>
		/// The type of error.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The line number where this errors occurs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="line")]
		public int Line { get; set; }
		
		/// <summary>
		/// A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The path of the file where the error occured.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The contents of the line where the error occurs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suggestion")]
		public string Suggestion { get; set; }
	}
	
	/// <summary>
	/// Collaborator
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Collaborator
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public CollaboratorPermissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="role_name")]
		public string Role_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class CollaboratorPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	/// <summary>
	/// Combined Commit Status
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Combined_commit_status
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Minimal_repository Repository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public Simple_commit_status[] Statuses { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Simple_commit_status
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required")]
		public System.Nullable<System.Boolean> Required { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target_url")]
		public string Target_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Commit Activity
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Commit_activity
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="days")]
		public int[] Days { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="week")]
		public int Week { get; set; }
	}
	
	/// <summary>
	/// Commit Comment
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Commit_comment
	{
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="line")]
		public System.Nullable<System.Int32> Line { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="position")]
		public System.Nullable<System.Int32> Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reaction_rollup
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="+1")]
		public int Plus1 { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="-1")]
		public int _1 { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="confused")]
		public int Confused { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eyes")]
		public int Eyes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="heart")]
		public int Heart { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooray")]
		public int Hooray { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="laugh")]
		public int Laugh { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rocket")]
		public int Rocket { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Commit Comparison
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Commit_comparison
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ahead_by")]
		public int Ahead_by { get; set; }
		
		/// <summary>
		/// Commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="base_commit")]
		public Commit Base_commit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="behind_by")]
		public int Behind_by { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits")]
		public Commit[] Commits { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="diff_url")]
		public string Diff_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="files")]
		public Diff_entry[] Files { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merge_base_commit")]
		public Commit Merge_base_commit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="patch_url")]
		public string Patch_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permalink_url")]
		public string Permalink_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Commit_comparisonStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_commits")]
		public int Total_commits { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Commit_comparisonStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		diverged = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ahead = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		behind = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		identical = 3,
	}
	
	/// <summary>
	/// Commit Search Result Item
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Commit_search_result_item
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Nullable_simple_user Author { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit")]
		public Commit_search_result_itemCommit Commit { get; set; }
		
		/// <summary>
		/// Metaproperties for Git author/committer information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public Nullable_git_user Committer { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parents")]
		public Commit_search_result_itemParents[] Commit_search_result_itemParents { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Minimal_repository Repository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score")]
		public double Score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text_matches")]
		public Commit_search_result_itemText_matches[] Commit_search_result_itemText_matches { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Commit_search_result_itemCommit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Commit_search_result_itemCommitAuthor Author { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment_count")]
		public int Comment_count { get; set; }
		
		/// <summary>
		/// Metaproperties for Git author/committer information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public Nullable_git_user Committer { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree")]
		public Commit_search_result_itemCommitTree Tree { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="verification")]
		public Verification Verification { get; set; }
	}
	
	public class Commit_search_result_itemCommitAuthor
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Commit_search_result_itemCommitTree
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Commit_search_result_itemParents
	{
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Commit_search_result_itemText_matches
	{
		
		[System.Runtime.Serialization.DataMember(Name="fragment")]
		public string Fragment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public Commit_search_result_itemText_matchesMatches[] Commit_search_result_itemText_matchesMatches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_type")]
		public string Object_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_url")]
		public string Object_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="property")]
		public string Property { get; set; }
	}
	
	public class Commit_search_result_itemText_matchesMatches
	{
		
		[System.Runtime.Serialization.DataMember(Name="indices")]
		public int[] Indices { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Configuration_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public Configuration_statusProgress[] Configuration_statusProgress { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class Configuration_statusProgress
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Content_directoryElement
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Content_directoryElement_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Content_directoryElementType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Content_directoryElement_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Content_directoryElementType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dir = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		file = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		submodule = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		symlink = 3,
	}
	
	/// <summary>
	/// Content File
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Content_file
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Content_file_links _links { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encoding")]
		public string Encoding { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="submodule_git_url")]
		public string Submodule_git_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Content_fileType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Content_file_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Content_fileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		file = 0,
	}
	
	/// <summary>
	/// An object describing a submodule
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Content_submodule
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Content_submodule_links _links { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="submodule_git_url")]
		public string Submodule_git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Content_submoduleType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Content_submodule_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Content_submoduleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		submodule = 0,
	}
	
	/// <summary>
	/// An object describing a symlink
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Content_symlink
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Content_symlink_links _links { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Content_symlinkType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Content_symlink_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Content_symlinkType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		symlink = 0,
	}
	
	/// <summary>
	/// Content Tree
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Content_tree
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Content_tree_links _links { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public Content_treeEntries[] Content_treeEntries { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Content_tree_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	public class Content_treeEntries
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Content_treeEntries_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Content_treeEntries_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	/// <summary>
	/// Contributor
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Contributor
	{
		
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributions")]
		public int Contributions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public System.Nullable<System.Boolean> Site_admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Contributor Activity
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Contributor_activity
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Nullable_simple_user Author { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="weeks")]
		public Contributor_activityWeeks[] Contributor_activityWeeks { get; set; }
	}
	
	public class Contributor_activityWeeks
	{
		
		[System.Runtime.Serialization.DataMember(Name="a")]
		public System.Nullable<System.Int32> A { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="c")]
		public System.Nullable<System.Int32> C { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="d")]
		public System.Nullable<System.Int32> D { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="w")]
		public System.Nullable<System.Int32> W { get; set; }
	}
	
	/// <summary>
	/// Converted Note to Issue Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Converted_note_to_issue_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="project_card")]
		public Converted_note_to_issue_issue_eventProject_card Project_card { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Converted_note_to_issue_issue_eventProject_card
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column_name")]
		public string Column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_column_name")]
		public string Previous_column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_id")]
		public int Project_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_url")]
		public string Project_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Demilestoned Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Demilestoned_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public Demilestoned_issue_eventMilestone Milestone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Demilestoned_issue_eventMilestone
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// The public key used for setting Dependabot Secrets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Dependabot_public_key
	{
		
		/// <summary>
		/// The Base64 encoded public key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The identifier for the key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
	}
	
	/// <summary>
	/// Set secrets for Dependabot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Dependabot_secret
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The name of the secret.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Dependency_graph_diffElement
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="change_type")]
		public Dependency_graph_diffElementChange_type Change_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ecosystem")]
		public string Ecosystem { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public string License { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="manifest")]
		public string Manifest { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="package_url")]
		public string Package_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source_repository_url")]
		public string Source_repository_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vulnerabilities")]
		public Dependency_graph_diffElementVulnerabilities[] Dependency_graph_diffElementVulnerabilities { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Dependency_graph_diffElementChange_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		added = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		removed = 1,
	}
	
	public class Dependency_graph_diffElementVulnerabilities
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="advisory_ghsa_id")]
		public string Advisory_ghsa_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="advisory_summary")]
		public string Advisory_summary { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="advisory_url")]
		public string Advisory_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
	}
	
	/// <summary>
	/// An SSH key granting access to a single repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Deploy_key
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="read_only")]
		public bool Read_only { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public bool Verified { get; set; }
	}
	
	/// <summary>
	/// A request for a specific ref(branch,sha,tag) to be deployed
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Deployment
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creator")]
		public Nullable_simple_user Creator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Name for the target deployment environment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public string Environment { get; set; }
		
		/// <summary>
		/// Unique identifier of the deployment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="original_environment")]
		public string Original_environment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public string Payload { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Specifies if the given environment is one that end-users directly interact with. Default: false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="production_environment")]
		public System.Nullable<System.Boolean> Production_environment { get; set; }
		
		/// <summary>
		/// The ref to deploy. This can be a branch, tag, or sha.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// Parameter to specify a task to execute
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="task")]
		public string Task { get; set; }
		
		/// <summary>
		/// Specifies if the given environment is will no longer exist at some point in the future. Default: false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transient_environment")]
		public System.Nullable<System.Boolean> Transient_environment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Details of a deployment branch policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Deployment_branch_policy
	{
		
		/// <summary>
		/// The unique identifier of the branch policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name pattern that branches must match in order to deploy to the environment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Deployment_branch_policy_name_pattern
	{
		
		/// <summary>
		/// The name pattern that branches must match in order to deploy to the environment.
		///
		///Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.
		///For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Deployment_branch_policy_settings
	{
		
		/// <summary>
		/// Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="custom_branch_policies")]
		public bool Custom_branch_policies { get; set; }
		
		/// <summary>
		/// Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protected_branches")]
		public bool Protected_branches { get; set; }
	}
	
	/// <summary>
	/// The type of reviewer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Deployment_reviewer_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Team = 1,
	}
	
	/// <summary>
	/// The status of a deployment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Deployment_status
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creator")]
		public Nullable_simple_user Creator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployment_url")]
		public string Deployment_url { get; set; }
		
		/// <summary>
		/// A short description of the status.
		/// Required
		/// Max length: 140
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(140)]
		public string Description { get; set; } = "";
		
		/// <summary>
		/// The environment of the deployment that the status is for.
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public string Environment { get; set; } = "";
		
		/// <summary>
		/// The URL for accessing your environment.
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="environment_url")]
		public string Environment_url { get; set; } = "";
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The URL to associate with this status.
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="log_url")]
		public string Log_url { get; set; } = "";
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// The state of the status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Deployment_statusState State { get; set; }
		
		/// <summary>
		/// Deprecated: the URL to associate with this status.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target_url")]
		public string Target_url { get; set; } = "";
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Deployment_statusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		error = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inactive = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		in_progress = 6,
	}
	
	/// <summary>
	/// Email
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Email
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email1 { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public bool Primary { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public bool Verified { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
	}
	
	/// <summary>
	/// An object without any properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Empty_object
	{
	}
	
	/// <summary>
	/// The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Enabled_organizations
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	/// <summary>
	/// The policy that controls the repositories in the organization that are allowed to run GitHub Actions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Enabled_repositories
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	/// <summary>
	/// An enterprise on GitHub.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// A short description of the enterprise.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the enterprise
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The name of the enterprise.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The slug url identifier for the enterprise.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The enterprise's website URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website_url")]
		public string Website_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_comment_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_commit_comments")]
		public int Total_commit_comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_gist_comments")]
		public int Total_gist_comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_issue_comments")]
		public int Total_issue_comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_pull_request_comments")]
		public int Total_pull_request_comments { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_gist_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_gists")]
		public int Private_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_gists")]
		public int Public_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_gists")]
		public int Total_gists { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_hook_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="active_hooks")]
		public int Active_hooks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="inactive_hooks")]
		public int Inactive_hooks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_hooks")]
		public int Total_hooks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_issue_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_issues")]
		public int Closed_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_issues")]
		public int Total_issues { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_milestone_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_milestones")]
		public int Closed_milestones { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_milestones")]
		public int Open_milestones { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_milestones")]
		public int Total_milestones { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_organization_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disabled_orgs")]
		public int Disabled_orgs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_orgs")]
		public int Total_orgs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_team_members")]
		public int Total_team_members { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_teams")]
		public int Total_teams { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_overview
	{
		
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public Enterprise_comment_overview Comments { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gists")]
		public Enterprise_gist_overview Gists { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hooks")]
		public Enterprise_hook_overview Hooks { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issues")]
		public Enterprise_issue_overview Issues { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public Enterprise_milestone_overview Milestones { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="orgs")]
		public Enterprise_organization_overview Orgs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public Enterprise_page_overview Pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pulls")]
		public Enterprise_pull_request_overview Pulls { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repos")]
		public Enterprise_repository_overview Repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="users")]
		public Enterprise_user_overview Users { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_page_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_pages")]
		public int Total_pages { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_pull_request_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mergeable_pulls")]
		public int Mergeable_pulls { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merged_pulls")]
		public int Merged_pulls { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_pulls")]
		public int Total_pulls { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unmergeable_pulls")]
		public int Unmergeable_pulls { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_repository_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork_repos")]
		public int Fork_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="org_repos")]
		public int Org_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="root_repos")]
		public int Root_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_pushes")]
		public int Total_pushes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_repos")]
		public int Total_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_wikis")]
		public int Total_wikis { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_user_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin_users")]
		public int Admin_users { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="suspended_users")]
		public int Suspended_users { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_users")]
		public int Total_users { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Enterprise_settings
	{
		
		[System.Runtime.Serialization.DataMember(Name="enterprise")]
		public Enterprise_settingsEnterprise Enterprise { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="run_list")]
		public string[] Run_list { get; set; }
	}
	
	public class Enterprise_settingsEnterprise
	{
		
		[System.Runtime.Serialization.DataMember(Name="admin_password")]
		public string Admin_password { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public string Assets { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="auth_mode")]
		public string Auth_mode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="avatar")]
		public Enterprise_settingsEnterpriseAvatar Avatar { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cas")]
		public Enterprise_settingsEnterpriseCas Cas { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="collectd")]
		public Enterprise_settingsEnterpriseCollectd Collectd { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="configuration_id")]
		public System.Nullable<System.Int32> Configuration_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="configuration_run_count")]
		public System.Nullable<System.Int32> Configuration_run_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="customer")]
		public Enterprise_settingsEnterpriseCustomer Customer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expire_sessions")]
		public System.Nullable<System.Boolean> Expire_sessions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="github_hostname")]
		public string Github_hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="github_oauth")]
		public Enterprise_settingsEnterpriseGithub_oauth Github_oauth { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="github_ssl")]
		public Enterprise_settingsEnterpriseGithub_ssl Github_ssl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http_proxy")]
		public string Http_proxy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="identicons_host")]
		public string Identicons_host { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ldap")]
		public Enterprise_settingsEnterpriseLdap Ldap { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Enterprise_settingsEnterpriseLicense License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="load_balancer")]
		public string Load_balancer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapping")]
		public Enterprise_settingsEnterpriseMapping Mapping { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ntp")]
		public Enterprise_settingsEnterpriseNtp Ntp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public Enterprise_settingsEnterprisePages Pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="private_mode")]
		public System.Nullable<System.Boolean> Private_mode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="public_pages")]
		public System.Nullable<System.Boolean> Public_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="saml")]
		public Enterprise_settingsEnterpriseSaml Saml { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="signup_enabled")]
		public System.Nullable<System.Boolean> Signup_enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="smtp")]
		public Enterprise_settingsEnterpriseSmtp Smtp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snmp")]
		public Enterprise_settingsEnterpriseSnmp Snmp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subdomain_isolation")]
		public System.Nullable<System.Boolean> Subdomain_isolation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="syslog")]
		public Enterprise_settingsEnterpriseSyslog Syslog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseAvatar
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseCas
	{
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseCollectd
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="encryption")]
		public string Encryption { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public string Server { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseCustomer
	{
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="public_key_data")]
		public string Public_key_data { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secret_key_data")]
		public string Secret_key_data { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseGithub_oauth
	{
		
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organization_name")]
		public string Organization_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organization_team")]
		public string Organization_team { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseGithub_ssl
	{
		
		[System.Runtime.Serialization.DataMember(Name="cert")]
		public string Cert { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseLdap
	{
		
		[System.Runtime.Serialization.DataMember(Name="admin_group")]
		public string Admin_group { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="base")]
		public string[] Base { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bind_dn")]
		public string Bind_dn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="posix_support")]
		public System.Nullable<System.Boolean> Posix_support { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public Enterprise_settingsEnterpriseLdapProfile Profile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reconciliation")]
		public Enterprise_settingsEnterpriseLdapReconciliation Reconciliation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recursive_group_search")]
		public System.Nullable<System.Boolean> Recursive_group_search { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="search_strategy")]
		public string Search_strategy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sync_enabled")]
		public System.Nullable<System.Boolean> Sync_enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="team_sync_interval")]
		public System.Nullable<System.Int32> Team_sync_interval { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uid")]
		public string Uid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_groups")]
		public string[] User_groups { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_sync_emails")]
		public System.Nullable<System.Boolean> User_sync_emails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_sync_interval")]
		public System.Nullable<System.Int32> User_sync_interval { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_sync_keys")]
		public System.Nullable<System.Boolean> User_sync_keys { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="virtual_attribute_enabled")]
		public System.Nullable<System.Boolean> Virtual_attribute_enabled { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseLdapProfile
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mail")]
		public string Mail { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uid")]
		public string Uid { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseLdapReconciliation
	{
		
		[System.Runtime.Serialization.DataMember(Name="org")]
		public string Org { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseLicense
	{
		
		[System.Runtime.Serialization.DataMember(Name="cluster_support")]
		public System.Nullable<System.Boolean> Cluster_support { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="evaluation")]
		public System.Nullable<System.Boolean> Evaluation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expire_at")]
		public string Expire_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="perpetual")]
		public System.Nullable<System.Boolean> Perpetual { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seats")]
		public System.Nullable<System.Int32> Seats { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ssh_allowed")]
		public System.Nullable<System.Boolean> Ssh_allowed { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="support_key")]
		public string Support_key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unlimited_seating")]
		public System.Nullable<System.Boolean> Unlimited_seating { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseMapping
	{
		
		[System.Runtime.Serialization.DataMember(Name="basemap")]
		public string Basemap { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tileserver")]
		public string Tileserver { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseNtp
	{
		
		[System.Runtime.Serialization.DataMember(Name="primary_server")]
		public string Primary_server { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secondary_server")]
		public string Secondary_server { get; set; }
	}
	
	public class Enterprise_settingsEnterprisePages
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseSaml
	{
		
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificate_path")]
		public string Certificate_path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disable_admin_demote")]
		public System.Nullable<System.Boolean> Disable_admin_demote { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="idp_initiated_sso")]
		public System.Nullable<System.Boolean> Idp_initiated_sso { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sso_url")]
		public string Sso_url { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseSmtp
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public string Authentication { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="discard-to-noreply-address")]
		public System.Nullable<System.Boolean> Discard_to_noreply_address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enable_starttls_auto")]
		public System.Nullable<System.Boolean> Enable_starttls_auto { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="noreply_address")]
		public string Noreply_address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="support_address")]
		public string Support_address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="support_address_type")]
		public string Support_address_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_name")]
		public string User_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseSnmp
	{
		
		[System.Runtime.Serialization.DataMember(Name="community")]
		public string Community { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class Enterprise_settingsEnterpriseSyslog
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protocol_name")]
		public string Protocol_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public string Server { get; set; }
	}
	
	/// <summary>
	/// Details of a deployment environment
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Environment
	{
		
		/// <summary>
		/// The time that the environment was created, in ISO 8601 format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deployment_branch_policy")]
		public Deployment_branch_policy_settings Deployment_branch_policy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The id of the environment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The name of the environment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protection_rules")]
		public string[] Protection_rules { get; set; }
		
		/// <summary>
		/// The time that the environment was last updated, in ISO 8601 format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// An entry in the reviews log for environment deployments
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Environment_approvals
	{
		
		/// <summary>
		/// The comment submitted with the deployment review
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The list of environments that were approved or rejected
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="environments")]
		public Environment_approvalsEnvironments[] Environment_approvalsEnvironments { get; set; }
		
		/// <summary>
		/// Whether deployment to the environment(s) was approved or rejected or pending (with comments)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Environment_approvalsState State { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Simple_user User { get; set; }
	}
	
	public class Environment_approvalsEnvironments
	{
		
		/// <summary>
		/// The time that the environment was created, in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The id of the environment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name of the environment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The time that the environment was last updated, in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Environment_approvalsState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		approved = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rejected = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 2,
	}
	
	/// <summary>
	/// Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class event_
	{
		
		/// <summary>
		/// Actor
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Actor Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Actor
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="org")]
		public Actor Org { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public event_Payload Payload { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public")]
		public bool Public { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public event_Repo Repo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class event_Payload
	{
		
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		/// <summary>
		/// Comments provide a way for people to collaborate on an issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public Issue_comment Comment { get; set; }
		
		/// <summary>
		/// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issue")]
		public Issue Issue { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public event_PayloadPages[] event_PayloadPages { get; set; }
	}
	
	/// <summary>
	/// Comments provide a way for people to collaborate on an issue.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_comment
	{
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// Contents of the issue comment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the issue comment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_url")]
		public string Issue_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// URL for the issue comment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	/// <summary>
	/// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue
	{
		
		[System.Runtime.Serialization.DataMember(Name="active_lock_reason")]
		public string Active_lock_reason { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Nullable_simple_user Assignee { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assignees")]
		public Simple_user[] Assignees { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// Contents of the issue
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_at")]
		public System.Nullable<System.DateTimeOffset> Closed_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed_by")]
		public Nullable_simple_user Closed_by { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public int Comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public System.Nullable<System.Boolean> Draft { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public bool Locked { get; set; }
		
		/// <summary>
		/// A collection of related issues and pull requests.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public Nullable_milestone Milestone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Number uniquely identifying the issue within its repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pull_request")]
		public IssuePull_request Pull_request { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Repository Repository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// State of the issue; either 'open' or 'closed'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// The reason for the current state
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state_reason")]
		public System.Nullable<IssueState_reason> State_reason { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeline_url")]
		public string Timeline_url { get; set; }
		
		/// <summary>
		/// Title of the issue
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// URL for the issue
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	/// <summary>
	/// A collection of related issues and pull requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_milestone
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_at")]
		public System.Nullable<System.DateTimeOffset> Closed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_issues")]
		public int Closed_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creator")]
		public Nullable_simple_user Creator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="due_on")]
		public System.Nullable<System.DateTimeOffset> Due_on { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The number of the milestone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// The state of the milestone.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(Nullable_milestoneState.open)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Nullable_milestoneState State { get; set; } = Nullable_milestoneState.open;
		
		/// <summary>
		/// The title of the milestone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Nullable_milestoneState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 1,
	}
	
	public class IssuePull_request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="diff_url")]
		public string Diff_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="merged_at")]
		public System.Nullable<System.DateTimeOffset> Merged_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="patch_url")]
		public string Patch_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum IssueState_reason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reopened = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_planned = 2,
	}
	
	public class event_PayloadPages
	{
		
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_name")]
		public string Page_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="summary")]
		public string Summary { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class event_Repo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Information about an external group's usage and its members
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class External_group
	{
		
		/// <summary>
		/// The internal ID of the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="group_id")]
		public int Group_id { get; set; }
		
		/// <summary>
		/// The display name for the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="group_name")]
		public string Group_name { get; set; }
		
		/// <summary>
		/// An array of external members linked to this group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members")]
		public External_groupMembers[] External_groupMembers { get; set; }
		
		/// <summary>
		/// An array of teams linked to this group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public External_groupTeams[] External_groupTeams { get; set; }
		
		/// <summary>
		/// The date when the group was last updated_at
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	public class External_groupMembers
	{
		
		/// <summary>
		/// An email attached to a user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="member_email")]
		public string Member_email { get; set; }
		
		/// <summary>
		/// The internal user ID of the identity
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="member_id")]
		public int Member_id { get; set; }
		
		/// <summary>
		/// The handle/login for the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="member_login")]
		public string Member_login { get; set; }
		
		/// <summary>
		/// The user display name/profile name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="member_name")]
		public string Member_name { get; set; }
	}
	
	public class External_groupTeams
	{
		
		/// <summary>
		/// The id for a team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="team_id")]
		public int Team_id { get; set; }
		
		/// <summary>
		/// The name of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="team_name")]
		public string Team_name { get; set; }
	}
	
	/// <summary>
	/// A list of external groups available to be connected to a team
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class External_groups
	{
		
		/// <summary>
		/// An array of external groups available to be mapped to a team
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public External_groupsGroups[] External_groupsGroups { get; set; }
	}
	
	public class External_groupsGroups
	{
		
		/// <summary>
		/// The internal ID of the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="group_id")]
		public int Group_id { get; set; }
		
		/// <summary>
		/// The display name of the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="group_name")]
		public string Group_name { get; set; }
		
		/// <summary>
		/// The time of the last update for this group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	/// <summary>
	/// Feed
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Feed
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Feed_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="current_user_actor_url")]
		public string Current_user_actor_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="current_user_organization_url")]
		public string Current_user_organization_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="current_user_organization_urls")]
		public string[] Current_user_organization_urls { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="current_user_public_url")]
		public string Current_user_public_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="current_user_url")]
		public string Current_user_url { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_discussions")]
		public Link_with_type Repository_discussions { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_discussions_category")]
		public Link_with_type Repository_discussions_category { get; set; }
		
		/// <summary>
		/// A feed of discussions for a given repository and category.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_discussions_category_url")]
		public string Repository_discussions_category_url { get; set; }
		
		/// <summary>
		/// A feed of discussions for a given repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_discussions_url")]
		public string Repository_discussions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="security_advisories_url")]
		public string Security_advisories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeline_url")]
		public string Timeline_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user_url")]
		public string User_url { get; set; }
	}
	
	public class Feed_links
	{
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="current_user")]
		public Link_with_type Current_user { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="current_user_actor")]
		public Link_with_type Current_user_actor { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="current_user_organization")]
		public Link_with_type Current_user_organization { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="current_user_organizations")]
		public Link_with_type[] Current_user_organizations { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="current_user_public")]
		public Link_with_type Current_user_public { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_discussions")]
		public Link_with_type Repository_discussions { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_discussions_category")]
		public Link_with_type Repository_discussions_category { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security_advisories")]
		public Link_with_type Security_advisories { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeline")]
		public Link_with_type Timeline { get; set; }
		
		/// <summary>
		/// Hypermedia Link with Type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Link_with_type User { get; set; }
	}
	
	/// <summary>
	/// Hypermedia Link with Type
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Link_with_type
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// File Commit
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class File_commit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit")]
		public File_commitCommit Commit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public File_commitContent Content { get; set; }
	}
	
	public class File_commitCommit
	{
		
		[System.Runtime.Serialization.DataMember(Name="author")]
		public File_commitCommitAuthor Author { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public File_commitCommitCommitter Committer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="parents")]
		public File_commitCommitParents[] File_commitCommitParents { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tree")]
		public File_commitCommitTree Tree { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="verification")]
		public File_commitCommitVerification Verification { get; set; }
	}
	
	public class File_commitCommitAuthor
	{
		
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class File_commitCommitCommitter
	{
		
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class File_commitCommitParents
	{
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class File_commitCommitTree
	{
		
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class File_commitCommitVerification
	{
		
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public string Payload { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public System.Nullable<System.Boolean> Verified { get; set; }
	}
	
	public class File_commitContent
	{
		
		[System.Runtime.Serialization.DataMember()]
		public File_commitContent_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class File_commitContent_links
	{
		
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	/// <summary>
	/// Full Repository
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Full_repository
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_update_branch")]
		public System.Nullable<System.Boolean> Allow_update_branch { get; set; }
		
		/// <summary>
		/// Whether anonymous git access is allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="anonymous_access_enabled")]
		public System.Nullable<System.Boolean> Anonymous_access_enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		/// <summary>
		/// Code of Conduct Simple
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code_of_conduct")]
		public Code_of_conduct_simple Code_of_conduct { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Returns whether or not this repository disabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public bool Disabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public int Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public int Forks_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public bool Has_downloads { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public bool Has_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public bool Has_pages { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public bool Has_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public bool Has_wiki { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// License Simple
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Nullable_license_simple License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="master_branch")]
		public string Master_branch { get; set; }
		
		/// <summary>
		/// The default value for a merge commit message.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `PR_BODY` - default to the pull request's body.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_message")]
		public RepositoryMerge_commit_message Merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a merge commit title.
		///
		///  - `PR_TITLE` - default to the pull request's title.
		///  - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_title")]
		public RepositoryMerge_commit_title Merge_commit_title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_count")]
		public int Network_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public int Open_issues_count { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public Nullable_simple_user Organization { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Simple_user Owner { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public Repository Parent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Full_repositoryPermissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public System.DateTimeOffset Pushed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="security_and_analysis")]
		public Security_and_analysis Security_and_analysis { get; set; }
		
		/// <summary>
		/// The size of the repository. Size is calculated hourly. When a repository is initially created, the size is 0.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Repository Source { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit message:
		///
		///- `PR_BODY` - default to the pull request's body.
		///- `COMMIT_MESSAGES` - default to the branch's commit messages.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_message")]
		public RepositorySquash_merge_commit_message Squash_merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit title:
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_title")]
		public RepositorySquash_merge_commit_title Squash_merge_commit_title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public int Stargazers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_count")]
		public int Subscribers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template_repository")]
		public Nullable_repository Template_repository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="use_squash_pr_title_as_default")]
		public System.Nullable<System.Boolean> Use_squash_pr_title_as_default { get; set; }
		
		/// <summary>
		/// The repository visibility: public, private, or internal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers")]
		public int Watchers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public int Watchers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	public class Full_repositoryPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Security_and_analysis
	{
		
		[System.Runtime.Serialization.DataMember(Name="advanced_security")]
		public Security_and_analysisAdvanced_security Advanced_security { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secret_scanning")]
		public Security_and_analysisSecret_scanning Secret_scanning { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secret_scanning_push_protection")]
		public Security_and_analysisSecret_scanning_push_protection Secret_scanning_push_protection { get; set; }
	}
	
	public class Security_and_analysisAdvanced_security
	{
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<Security_and_analysisAdvanced_securityStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Security_and_analysisAdvanced_securityStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
	}
	
	public class Security_and_analysisSecret_scanning
	{
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Security_and_analysisAdvanced_securityStatus Status { get; set; }
	}
	
	public class Security_and_analysisSecret_scanning_push_protection
	{
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Security_and_analysisAdvanced_securityStatus Status { get; set; }
	}
	
	/// <summary>
	/// A repository on GitHub.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_repository
	{
		
		/// <summary>
		/// Whether to allow Auto-merge to be used on pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		/// <summary>
		/// Whether to allow forking this repo
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		/// <summary>
		/// Whether to allow merge commits for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		/// <summary>
		/// Whether to allow rebase merges for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		/// <summary>
		/// Whether to allow squash merges for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_update_branch")]
		public System.Nullable<System.Boolean> Allow_update_branch { get; set; }
		
		/// <summary>
		/// Whether anonymous git access is enabled for this repository
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="anonymous_access_enabled")]
		public System.Nullable<System.Boolean> Anonymous_access_enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// Whether the repository is archived.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; } = false;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The default branch of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		/// <summary>
		/// Whether to delete head branches when pull requests are merged
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Returns whether or not this repository disabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public bool Disabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public int Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public int Forks_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Whether downloads are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public bool Has_downloads { get; set; } = true;
		
		/// <summary>
		/// Whether issues are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public bool Has_issues { get; set; } = true;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public bool Has_pages { get; set; }
		
		/// <summary>
		/// Whether projects are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public bool Has_projects { get; set; } = true;
		
		/// <summary>
		/// Whether the wiki is enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public bool Has_wiki { get; set; } = true;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Whether this repository acts as a template that can be used to generate new repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// License Simple
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Nullable_license_simple License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="master_branch")]
		public string Master_branch { get; set; }
		
		/// <summary>
		/// The default value for a merge commit message.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `PR_BODY` - default to the pull request's body.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_message")]
		public RepositoryMerge_commit_message Merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a merge commit title.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_title")]
		public RepositoryMerge_commit_title Merge_commit_title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network_count")]
		public System.Nullable<System.Int32> Network_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public int Open_issues_count { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public Nullable_simple_user Organization { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Simple_user Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Nullable_repositoryPermissions Permissions { get; set; }
		
		/// <summary>
		/// Whether the repository is private or public.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; } = false;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public System.Nullable<System.DateTimeOffset> Pushed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		/// <summary>
		/// The size of the repository. Size is calculated hourly. When a repository is initially created, the size is 0.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit message:
		///
		///- `PR_BODY` - default to the pull request's body.
		///- `COMMIT_MESSAGES` - default to the branch's commit messages.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_message")]
		public RepositorySquash_merge_commit_message Squash_merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit title:
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_title")]
		public RepositorySquash_merge_commit_title Squash_merge_commit_title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public int Stargazers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_at")]
		public string Starred_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscribers_count")]
		public System.Nullable<System.Int32> Subscribers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="template_repository")]
		public Nullable_repositoryTemplate_repository Template_repository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Whether a squash merge commit can use the pull request title as default. **This property has been deprecated. Please use `squash_merge_commit_title` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_squash_pr_title_as_default")]
		public System.Nullable<System.Boolean> Use_squash_pr_title_as_default { get; set; }
		
		/// <summary>
		/// The repository visibility: public, private, or internal.
		/// </summary>
		[System.ComponentModel.DefaultValue("public")]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; } = "public";
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers")]
		public int Watchers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public int Watchers_count { get; set; }
		
		/// <summary>
		/// Whether to require contributors to sign off on web-based commits
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	public class Nullable_repositoryPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	public class Nullable_repositoryTemplate_repository
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_update_branch")]
		public System.Nullable<System.Boolean> Allow_update_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public System.Nullable<System.Boolean> Fork { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public System.Nullable<System.Int32> Forks_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public System.Nullable<System.Boolean> Has_downloads { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public System.Nullable<System.Boolean> Has_issues { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public System.Nullable<System.Boolean> Has_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public System.Nullable<System.Boolean> Has_projects { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public System.Nullable<System.Boolean> Has_wiki { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// The default value for a merge commit message.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `PR_BODY` - default to the pull request's body.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_message")]
		public RepositoryMerge_commit_message Merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a merge commit title.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_title")]
		public RepositoryMerge_commit_title Merge_commit_title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network_count")]
		public System.Nullable<System.Int32> Network_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public System.Nullable<System.Int32> Open_issues_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Nullable_repositoryTemplate_repositoryOwner Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Nullable_repositoryTemplate_repositoryPermissions Permissions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public string Pushed_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit message:
		///
		///- `PR_BODY` - default to the pull request's body.
		///- `COMMIT_MESSAGES` - default to the branch's commit messages.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_message")]
		public RepositorySquash_merge_commit_message Squash_merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit title:
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_title")]
		public RepositorySquash_merge_commit_title Squash_merge_commit_title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public System.Nullable<System.Int32> Stargazers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscribers_count")]
		public System.Nullable<System.Int32> Subscribers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="use_squash_pr_title_as_default")]
		public System.Nullable<System.Boolean> Use_squash_pr_title_as_default { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public System.Nullable<System.Int32> Watchers_count { get; set; }
	}
	
	public class Nullable_repositoryTemplate_repositoryOwner
	{
		
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public System.Nullable<System.Boolean> Site_admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Nullable_repositoryTemplate_repositoryPermissions
	{
		
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public System.Nullable<System.Boolean> Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public System.Nullable<System.Boolean> Pull { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="push")]
		public System.Nullable<System.Boolean> Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	/// <summary>
	/// A comment made to a gist.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Gist_comment
	{
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// The comment text.
		/// Required
		/// Max length: 65535
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	/// <summary>
	/// Gist Commit
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Gist_commit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="change_status")]
		public Gist_commitChange_status Change_status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committed_at")]
		public System.DateTimeOffset Committed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class Gist_commitChange_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="additions")]
		public System.Nullable<System.Int32> Additions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deletions")]
		public System.Nullable<System.Int32> Deletions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Gist History
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Gist_history
	{
		
		[System.Runtime.Serialization.DataMember(Name="change_status")]
		public Gist_historyChange_status Change_status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="committed_at")]
		public System.Nullable<System.DateTimeOffset> Committed_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class Gist_historyChange_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="additions")]
		public System.Nullable<System.Int32> Additions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deletions")]
		public System.Nullable<System.Int32> Deletions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Gist Simple
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Gist_simple
	{
		
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public System.Nullable<System.Int32> Comments { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="files")]
		public System.Collections.Generic.Dictionary<string, Gist_simpleFiles> Files { get; set; }
		
		/// <summary>
		/// Gist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fork_of")]
		public Gist_simpleFork_of Fork_of { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public Gist_simpleForks[] Gist_simpleForks { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_pull_url")]
		public string Git_pull_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="git_push_url")]
		public string Git_push_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="history")]
		public Gist_history[] History { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Simple_user Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="public")]
		public System.Nullable<System.Boolean> Public { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truncated")]
		public System.Nullable<System.Boolean> Truncated { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
	}
	
	public class Gist_simpleFiles
	{
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="raw_url")]
		public string Raw_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truncated")]
		public System.Nullable<System.Boolean> Truncated { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Gist_simpleFork_of
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public int Comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="files")]
		public System.Collections.Generic.Dictionary<string, Gist_simpleFork_ofFiles> Files { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public string[] Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_pull_url")]
		public string Git_pull_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_push_url")]
		public string Git_push_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="history")]
		public string[] History { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Nullable_simple_user Owner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public")]
		public bool Public { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truncated")]
		public System.Nullable<System.Boolean> Truncated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Gist_simpleFork_ofFiles
	{
		
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="raw_url")]
		public string Raw_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Gist_simpleForks
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Public User
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Public_user User { get; set; }
	}
	
	/// <summary>
	/// Public User
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Public_user
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bio")]
		public string Bio { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blog")]
		public string Blog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="collaborators")]
		public System.Nullable<System.Int32> Collaborators { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="company")]
		public string Company { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disk_usage")]
		public System.Nullable<System.Int32> Disk_usage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers")]
		public int Followers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following")]
		public int Following { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hireable")]
		public System.Nullable<System.Boolean> Hireable { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owned_private_repos")]
		public System.Nullable<System.Int32> Owned_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Public_userPlan Plan { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="private_gists")]
		public System.Nullable<System.Int32> Private_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_gists")]
		public int Public_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_repos")]
		public int Public_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suspended_at")]
		public System.Nullable<System.DateTimeOffset> Suspended_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total_private_repos")]
		public System.Nullable<System.Int32> Total_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Public_userPlan
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators")]
		public int Collaborators { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_repos")]
		public int Private_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="space")]
		public int Space { get; set; }
	}
	
	/// <summary>
	/// Low-level Git commit operations within a repository
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Git_commit
	{
		
		/// <summary>
		/// Identifying information for the git-user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Git_commitAuthor Author { get; set; }
		
		/// <summary>
		/// Identifying information for the git-user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public Git_commitCommitter Committer { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Message describing the purpose of the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parents")]
		public Git_commitParents[] Git_commitParents { get; set; }
		
		/// <summary>
		/// SHA for the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree")]
		public Git_commitTree Tree { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verification")]
		public Git_commitVerification Verification { get; set; }
	}
	
	public class Git_commitAuthor
	{
		
		/// <summary>
		/// Timestamp of the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// Git email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Name of the git user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Git_commitCommitter
	{
		
		/// <summary>
		/// Timestamp of the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// Git email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Name of the git user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Git_commitParents
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// SHA for the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Git_commitTree
	{
		
		/// <summary>
		/// SHA for the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Git_commitVerification
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public string Payload { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public bool Verified { get; set; }
	}
	
	/// <summary>
	/// Git references within a repository
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Git_ref
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="object")]
		public Git_refObject Object { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Git_refObject
	{
		
		/// <summary>
		/// SHA for the reference
		/// Required
		/// Max length: 40
		/// Min length: 40
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		[System.ComponentModel.DataAnnotations.MinLength(40)]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Metadata for a Git tag
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Git_tag
	{
		
		/// <summary>
		/// Message describing the purpose of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="object")]
		public Git_tagObject Object { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagger")]
		public Git_tagTagger Tagger { get; set; }
		
		/// <summary>
		/// URL for the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="verification")]
		public Verification Verification { get; set; }
	}
	
	public class Git_tagObject
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Git_tagTagger
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The hierarchy between files in a Git repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Git_tree
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Objects specifying a tree structure
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree")]
		public Git_treeTree[] Git_treeTree { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="truncated")]
		public bool Truncated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Git_treeTree
	{
		
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public string Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Gitignore Template
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Gitignore_template
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Global_hook
	{
		
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="config")]
		public Global_hookConfig Config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ping_url")]
		public string Ping_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Global_hookConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public string Insecure_ssl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Global_hook_2
	{
		
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="config")]
		public Global_hook_2Config Config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ping_url")]
		public string Ping_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Global_hook_2Config
	{
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public string Insecure_ssl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A unique encryption key
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Gpg_key
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="can_certify")]
		public bool Can_certify { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="can_encrypt_comms")]
		public bool Can_encrypt_comms { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="can_encrypt_storage")]
		public bool Can_encrypt_storage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="can_sign")]
		public bool Can_sign { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public Gpg_keyEmails[] Gpg_keyEmails { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public System.Nullable<System.DateTimeOffset> Expires_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_key_id")]
		public System.Nullable<System.Int32> Primary_key_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_key")]
		public string Public_key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="raw_key")]
		public string Raw_key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="revoked")]
		public bool Revoked { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subkeys")]
		public Gpg_keySubkeys[] Gpg_keySubkeys { get; set; }
	}
	
	public class Gpg_keyEmails
	{
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public System.Nullable<System.Boolean> Verified { get; set; }
	}
	
	public class Gpg_keySubkeys
	{
		
		[System.Runtime.Serialization.DataMember(Name="can_certify")]
		public System.Nullable<System.Boolean> Can_certify { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="can_encrypt_comms")]
		public System.Nullable<System.Boolean> Can_encrypt_comms { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="can_encrypt_storage")]
		public System.Nullable<System.Boolean> Can_encrypt_storage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="can_sign")]
		public System.Nullable<System.Boolean> Can_sign { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public string Expires_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="primary_key_id")]
		public System.Nullable<System.Int32> Primary_key_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="public_key")]
		public string Public_key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="raw_key")]
		public string Raw_key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="revoked")]
		public System.Nullable<System.Boolean> Revoked { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subkeys")]
		public string[] Subkeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Group
	{
		
		/// <summary>
		/// A human-readable name for a security group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// A unique identifier for the resource as defined by the provisioning client.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="externalId")]
		public string ExternalId { get; set; }
		
		/// <summary>
		/// The group members.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members")]
		public GroupMembers[] GroupMembers { get; set; }
		
		/// <summary>
		/// The URIs that are used to indicate the namespaces of the SCIM schemas.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemas")]
		public string[] Schemas { get; set; }
	}
	
	public class GroupMembers
	{
		
		/// <summary>
		/// The display name associated with the member
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The local unique identifier for the member
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Group_response
	{
		
		/// <summary>
		/// A human-readable name for a security group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// A unique identifier for the resource as defined by the provisioning client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalId")]
		public string ExternalId { get; set; }
		
		/// <summary>
		/// The group members.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members")]
		public Group_responseMembers[] Group_responseMembers { get; set; }
		
		/// <summary>
		/// The URIs that are used to indicate the namespaces of the SCIM schemas.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemas")]
		public string[] Schemas { get; set; }
	}
	
	public class Group_responseMembers
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="$ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// The display name associated with the member
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display")]
		public string Display { get; set; }
		
		/// <summary>
		/// The local unique identifier for the member
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Webhooks for repositories.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Hook
	{
		
		/// <summary>
		/// Determines whether the hook is actually triggered on pushes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="active")]
		public bool Active { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public HookConfig Config { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deliveries_url")]
		public string Deliveries_url { get; set; }
		
		/// <summary>
		/// Determines what events the hook is triggered for. Default: ['push'].
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		/// <summary>
		/// Unique identifier of the webhook.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_response")]
		public Hook_response Last_response { get; set; }
		
		/// <summary>
		/// The name of a valid service, use 'web' for a webhook.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ping_url")]
		public string Ping_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="test_url")]
		public string Test_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class HookConfig
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="room")]
		public string Room { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subdomain")]
		public string Subdomain { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Hook_response
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	/// <summary>
	/// Delivery made by a webhook.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Hook_delivery
	{
		
		/// <summary>
		/// The type of activity for the event that triggered the delivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		/// <summary>
		/// Time when the delivery was delivered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delivered_at")]
		public System.DateTimeOffset Delivered_at { get; set; }
		
		/// <summary>
		/// Time spent delivering.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public double Duration { get; set; }
		
		/// <summary>
		/// The event that triggered the delivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="guid")]
		public string Guid { get; set; }
		
		/// <summary>
		/// Unique identifier of the delivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The id of the GitHub App installation associated with this event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="installation_id")]
		public System.Nullable<System.Int32> Installation_id { get; set; }
		
		/// <summary>
		/// Whether the delivery is a redelivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="redelivery")]
		public bool Redelivery { get; set; }
		
		/// <summary>
		/// The id of the repository associated with this event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_id")]
		public System.Nullable<System.Int32> Repository_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="request")]
		public Hook_deliveryRequest Request { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="response")]
		public Hook_deliveryResponse Response { get; set; }
		
		/// <summary>
		/// Description of the status of the attempted delivery
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Status code received when delivery was made.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status_code")]
		public int Status_code { get; set; }
		
		/// <summary>
		/// The URL target of the delivery.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Hook_deliveryRequest
	{
		
		/// <summary>
		/// The request headers sent with the webhook delivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public string Headers { get; set; }
		
		/// <summary>
		/// The webhook payload.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public string Payload { get; set; }
	}
	
	public class Hook_deliveryResponse
	{
		
		/// <summary>
		/// The response headers received when the delivery was made.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public string Headers { get; set; }
		
		/// <summary>
		/// The response payload received.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public string Payload { get; set; }
	}
	
	/// <summary>
	/// Delivery made by a webhook, without request and response information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Hook_delivery_item
	{
		
		/// <summary>
		/// The type of activity for the event that triggered the delivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		/// <summary>
		/// Time when the webhook delivery occurred.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delivered_at")]
		public System.DateTimeOffset Delivered_at { get; set; }
		
		/// <summary>
		/// Time spent delivering.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public double Duration { get; set; }
		
		/// <summary>
		/// The event that triggered the delivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="guid")]
		public string Guid { get; set; }
		
		/// <summary>
		/// Unique identifier of the webhook delivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The id of the GitHub App installation associated with this event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="installation_id")]
		public System.Nullable<System.Int32> Installation_id { get; set; }
		
		/// <summary>
		/// Whether the webhook delivery is a redelivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="redelivery")]
		public bool Redelivery { get; set; }
		
		/// <summary>
		/// The id of the repository associated with this event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_id")]
		public System.Nullable<System.Int32> Repository_id { get; set; }
		
		/// <summary>
		/// Describes the response returned after attempting the delivery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Status code received when delivery was made.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status_code")]
		public int Status_code { get; set; }
	}
	
	/// <summary>
	/// Hovercard
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Hovercard
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contexts")]
		public HovercardContexts[] HovercardContexts { get; set; }
	}
	
	public class HovercardContexts
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="octicon")]
		public string Octicon { get; set; }
	}
	
	/// <summary>
	/// Installation
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Installation
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access_tokens_url")]
		public string Access_tokens_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="account")]
		public Simple_user Account { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app_id")]
		public int App_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app_slug")]
		public string App_slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contact_email")]
		public string Contact_email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_multiple_single_files")]
		public System.Nullable<System.Boolean> Has_multiple_single_files { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The ID of the installation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The permissions granted to the user-to-server access token.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public App_permissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories_url")]
		public string Repositories_url { get; set; }
		
		/// <summary>
		/// Describe whether all repositories have been selected or there's a selection involved
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_selection")]
		public Authentication_tokenRepository_selection Repository_selection { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="single_file_name")]
		public string Single_file_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="single_file_paths")]
		public string[] Single_file_paths { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="suspended_at")]
		public System.Nullable<System.DateTimeOffset> Suspended_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="suspended_by")]
		public Nullable_simple_user Suspended_by { get; set; }
		
		/// <summary>
		/// The ID of the user or organization this token is being scoped to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target_id")]
		public int Target_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target_type")]
		public string Target_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
	}
	
	/// <summary>
	/// Authentication token for a GitHub App installed on a user or org.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Installation_token
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public string Expires_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="has_multiple_single_files")]
		public System.Nullable<System.Boolean> Has_multiple_single_files { get; set; }
		
		/// <summary>
		/// The permissions granted to the user-to-server access token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public App_permissions Permissions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Repository[] Repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repository_selection")]
		public Authentication_tokenRepository_selection Repository_selection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="single_file")]
		public string Single_file { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="single_file_paths")]
		public string[] Single_file_paths { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Nullable_simple_user Actor { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Nullable_simple_user Assignee { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assigner")]
		public Nullable_simple_user Assigner { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dismissed_review")]
		public Issue_event_dismissed_review Dismissed_review { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issue")]
		public Nullable_issue Issue { get; set; }
		
		/// <summary>
		/// Issue Event Label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Issue_event_label Label { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lock_reason")]
		public string Lock_reason { get; set; }
		
		/// <summary>
		/// Issue Event Milestone
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public Issue_event_milestone Milestone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Issue Event Project Card
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="project_card")]
		public Issue_event_project_card Project_card { get; set; }
		
		/// <summary>
		/// Issue Event Rename
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rename")]
		public Issue_event_rename Rename { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requested_reviewer")]
		public Nullable_simple_user Requested_reviewer { get; set; }
		
		/// <summary>
		/// Groups of organization members that gives permissions on specified repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requested_team")]
		public Team Requested_team { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="review_requester")]
		public Nullable_simple_user Review_requester { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_event_dismissed_review
	{
		
		[System.Runtime.Serialization.DataMember(Name="dismissal_commit_id")]
		public string Dismissal_commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissal_message")]
		public string Dismissal_message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_id")]
		public int Review_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
	}
	
	/// <summary>
	/// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_issue
	{
		
		[System.Runtime.Serialization.DataMember(Name="active_lock_reason")]
		public string Active_lock_reason { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Nullable_simple_user Assignee { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assignees")]
		public Simple_user[] Assignees { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// Contents of the issue
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_at")]
		public System.Nullable<System.DateTimeOffset> Closed_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed_by")]
		public Nullable_simple_user Closed_by { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public int Comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public System.Nullable<System.Boolean> Draft { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public bool Locked { get; set; }
		
		/// <summary>
		/// A collection of related issues and pull requests.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public Nullable_milestone Milestone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Number uniquely identifying the issue within its repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pull_request")]
		public Nullable_issuePull_request Pull_request { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Repository Repository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// State of the issue; either 'open' or 'closed'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// The reason for the current state
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state_reason")]
		public IssueState_reason State_reason { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeline_url")]
		public string Timeline_url { get; set; }
		
		/// <summary>
		/// Title of the issue
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// URL for the issue
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Nullable_issuePull_request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="diff_url")]
		public string Diff_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="merged_at")]
		public System.Nullable<System.DateTimeOffset> Merged_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="patch_url")]
		public string Patch_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Issue Event Label
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_event_label
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Issue Event Milestone
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_event_milestone
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// Issue Event Project Card
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_event_project_card
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column_name")]
		public string Column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_column_name")]
		public string Previous_column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_id")]
		public int Project_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_url")]
		public string Project_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Issue Event Rename
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_event_rename
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	/// <summary>
	/// Issue Event for Issue
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_event_for_issue
	{
	}
	
	/// <summary>
	/// Issue Search Result Item
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Issue_search_result_item
	{
		
		[System.Runtime.Serialization.DataMember(Name="active_lock_reason")]
		public string Active_lock_reason { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Nullable_simple_user Assignee { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assignees")]
		public Simple_user[] Assignees { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_at")]
		public System.Nullable<System.DateTimeOffset> Closed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public int Comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public System.Nullable<System.Boolean> Draft { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Issue_search_result_itemLabels[] Issue_search_result_itemLabels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public bool Locked { get; set; }
		
		/// <summary>
		/// A collection of related issues and pull requests.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public Nullable_milestone Milestone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pull_request")]
		public Issue_search_result_itemPull_request Pull_request { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Repository Repository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score")]
		public double Score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state_reason")]
		public string State_reason { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text_matches")]
		public Issue_search_result_itemText_matches[] Issue_search_result_itemText_matches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeline_url")]
		public string Timeline_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Issue_search_result_itemLabels
	{
		
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default")]
		public System.Nullable<System.Boolean> Default { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int64> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Issue_search_result_itemPull_request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="diff_url")]
		public string Diff_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="merged_at")]
		public System.Nullable<System.DateTimeOffset> Merged_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="patch_url")]
		public string Patch_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Issue_search_result_itemText_matches
	{
		
		[System.Runtime.Serialization.DataMember(Name="fragment")]
		public string Fragment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public Issue_search_result_itemText_matchesMatches[] Issue_search_result_itemText_matchesMatches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_type")]
		public string Object_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_url")]
		public string Object_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="property")]
		public string Property { get; set; }
	}
	
	public class Issue_search_result_itemText_matchesMatches
	{
		
		[System.Runtime.Serialization.DataMember(Name="indices")]
		public int[] Indices { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Information of a job execution in a workflow run
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Job
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="check_run_url")]
		public string Check_run_url { get; set; }
		
		/// <summary>
		/// The time that the job finished, in ISO 8601 format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="completed_at")]
		public System.Nullable<System.DateTimeOffset> Completed_at { get; set; }
		
		/// <summary>
		/// The outcome of the job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conclusion")]
		public Check_runConclusion Conclusion { get; set; }
		
		/// <summary>
		/// The SHA of the commit that is being run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_sha")]
		public string Head_sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The id of the job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Labels for the workflow job. Specified by the "runs_on" attribute in the action's workflow file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		/// <summary>
		/// The name of the job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="run_attempt")]
		public System.Nullable<System.Int32> Run_attempt { get; set; }
		
		/// <summary>
		/// The id of the associated workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="run_id")]
		public int Run_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="run_url")]
		public string Run_url { get; set; }
		
		/// <summary>
		/// The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runner_group_id")]
		public System.Nullable<System.Int32> Runner_group_id { get; set; }
		
		/// <summary>
		/// The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runner_group_name")]
		public string Runner_group_name { get; set; }
		
		/// <summary>
		/// The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runner_id")]
		public System.Nullable<System.Int32> Runner_id { get; set; }
		
		/// <summary>
		/// The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runner_name")]
		public string Runner_name { get; set; }
		
		/// <summary>
		/// The time that the job started, in ISO 8601 format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started_at")]
		public System.DateTimeOffset Started_at { get; set; }
		
		/// <summary>
		/// The phase of the lifecycle that the job is currently in.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Check_runStatus Status { get; set; }
		
		/// <summary>
		/// Steps in this job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="steps")]
		public JobSteps[] JobSteps { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class JobSteps
	{
		
		/// <summary>
		/// The time that the job finished, in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completed_at")]
		public System.Nullable<System.DateTimeOffset> Completed_at { get; set; }
		
		/// <summary>
		/// The outcome of the job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conclusion")]
		public string Conclusion { get; set; }
		
		/// <summary>
		/// The name of the job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// The time that the step started, in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="started_at")]
		public System.Nullable<System.DateTimeOffset> Started_at { get; set; }
		
		/// <summary>
		/// The phase of the lifecycle that the job is currently in.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Check_runStatus Status { get; set; }
	}
	
	/// <summary>
	/// Key
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Key
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key1 { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="read_only")]
		public bool Read_only { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public bool Verified { get; set; }
	}
	
	/// <summary>
	/// Key Simple
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Key_simple
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
	}
	
	/// <summary>
	/// Color-coded labels help you categorize and filter your issues (just like labels in Gmail).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Label
	{
		
		/// <summary>
		/// 6-character hex code, without the leading #, identifying the color
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default")]
		public bool Default { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public long Id { get; set; }
		
		/// <summary>
		/// The name of the label.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// URL for the label
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Label Search Result Item
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Label_search_result_item
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default")]
		public bool Default { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score")]
		public double Score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text_matches")]
		public Label_search_result_itemText_matches[] Label_search_result_itemText_matches { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Label_search_result_itemText_matches
	{
		
		[System.Runtime.Serialization.DataMember(Name="fragment")]
		public string Fragment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public Label_search_result_itemText_matchesMatches[] Label_search_result_itemText_matchesMatches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_type")]
		public string Object_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_url")]
		public string Object_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="property")]
		public string Property { get; set; }
	}
	
	public class Label_search_result_itemText_matchesMatches
	{
		
		[System.Runtime.Serialization.DataMember(Name="indices")]
		public int[] Indices { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Labeled Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Labeled_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Labeled_issue_eventLabel Label { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Labeled_issue_eventLabel
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Language
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Language
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Ldap_mapping_team
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public object Parent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public string Privacy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repositories_url")]
		public string Repositories_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Ldap Private User
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Ldap_mapping_user
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bio")]
		public string Bio { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blog")]
		public string Blog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="business_plus")]
		public System.Nullable<System.Boolean> Business_plus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators")]
		public int Collaborators { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="company")]
		public string Company { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk_usage")]
		public int Disk_usage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers")]
		public int Followers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following")]
		public int Following { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hireable")]
		public System.Nullable<System.Boolean> Hireable { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owned_private_repos")]
		public int Owned_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Ldap_mapping_userPlan Plan { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_gists")]
		public int Private_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_gists")]
		public int Public_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_repos")]
		public int Public_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suspended_at")]
		public System.Nullable<System.DateTimeOffset> Suspended_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_private_repos")]
		public int Total_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="two_factor_authentication")]
		public bool Two_factor_authentication { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Ldap_mapping_userPlan
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators")]
		public int Collaborators { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_repos")]
		public int Private_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="space")]
		public int Space { get; set; }
	}
	
	/// <summary>
	/// License
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class License
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conditions")]
		public string[] Conditions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="featured")]
		public bool Featured { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="implementation")]
		public string Implementation { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="limitations")]
		public string[] Limitations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string[] Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spdx_id")]
		public string Spdx_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// License Content
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class License_content
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public License_content_links _links { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encoding")]
		public string Encoding { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// License Simple
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Nullable_license_simple License { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class License_content_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class License_info
	{
		
		[System.Runtime.Serialization.DataMember(Name="days_until_expiration")]
		public System.Nullable<System.Int32> Days_until_expiration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expire_at")]
		public string Expire_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seats")]
		public string Seats { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seats_available")]
		public string Seats_available { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seats_used")]
		public System.Nullable<System.Int32> Seats_used { get; set; }
	}
	
	/// <summary>
	/// License Simple
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class License_simple
	{
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spdx_id")]
		public string Spdx_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Hypermedia Link
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Link
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	/// <summary>
	/// Locked Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Locked_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lock_reason")]
		public string Lock_reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Maintenance_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="connection_services")]
		public Maintenance_statusConnection_services[] Maintenance_statusConnection_services { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scheduled_time")]
		public string Scheduled_time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class Maintenance_statusConnection_services
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
	}
	
	/// <summary>
	/// Results of a successful merge upstream request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Merged_upstream
	{
		
		[System.Runtime.Serialization.DataMember(Name="base_branch")]
		public string Base_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="merge_type")]
		public System.Nullable<Merged_upstreamMerge_type> Merge_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Merged_upstreamMerge_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		merge = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fast-forward")]
		fastMinusforward = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
	}
	
	/// <summary>
	/// The metadata associated with the creation/updates to the user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Meta
	{
		
		/// <summary>
		/// A date and time when the user was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// A data and time when the user was last modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModified")]
		public string LastModified { get; set; }
		
		/// <summary>
		/// A URL location of an object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// A type of a resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public MetaResourceType ResourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MetaResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Group = 1,
	}
	
	/// <summary>
	/// A migration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Migration
	{
		
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exclude")]
		public string[] Exclude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exclude_attachments")]
		public bool Exclude_attachments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exclude_git_data")]
		public bool Exclude_git_data { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exclude_metadata")]
		public bool Exclude_metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exclude_owner_projects")]
		public bool Exclude_owner_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exclude_releases")]
		public bool Exclude_releases { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="guid")]
		public string Guid { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lock_repositories")]
		public bool Lock_repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="org_metadata_only")]
		public bool Org_metadata_only { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Nullable_simple_user Owner { get; set; }
		
		/// <summary>
		/// The repositories included in the migration. Only returned for export migrations.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Repository[] Repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A collection of related issues and pull requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Milestone
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_at")]
		public System.Nullable<System.DateTimeOffset> Closed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_issues")]
		public int Closed_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creator")]
		public Nullable_simple_user Creator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="due_on")]
		public System.Nullable<System.DateTimeOffset> Due_on { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The number of the milestone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// The state of the milestone.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(Nullable_milestoneState.open)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Nullable_milestoneState State { get; set; } = Nullable_milestoneState.open;
		
		/// <summary>
		/// The title of the milestone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Milestoned Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Milestoned_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public Milestoned_issue_eventMilestone Milestone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Milestoned_issue_eventMilestone
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// Moved Column in Project Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Moved_column_in_project_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="project_card")]
		public Moved_column_in_project_issue_eventProject_card Project_card { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Moved_column_in_project_issue_eventProject_card
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column_name")]
		public string Column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_column_name")]
		public string Previous_column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_id")]
		public int Project_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_url")]
		public string Project_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Collaborator
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_collaborator
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Nullable_collaboratorPermissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="role_name")]
		public string Role_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Nullable_collaboratorPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	/// <summary>
	/// A commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Nullable_simple_commit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Nullable_simple_commitAuthor Author { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public Nullable_simple_commitCommitter Committer { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.DateTimeOffset Timestamp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree_id")]
		public string Tree_id { get; set; }
	}
	
	public class Nullable_simple_commitAuthor
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Nullable_simple_commitCommitter
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Org Hook
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Org_hook
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="active")]
		public bool Active { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public Org_hookConfig Config { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deliveries_url")]
		public string Deliveries_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ping_url")]
		public string Ping_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Org_hookConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public string Insecure_ssl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Org Membership
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Org_membership
	{
		
		/// <summary>
		/// A GitHub organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public Organization_simple Organization { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organization_url")]
		public string Organization_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Org_membershipPermissions Permissions { get; set; }
		
		/// <summary>
		/// The user's membership type in the organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public Org_membershipRole Role { get; set; }
		
		/// <summary>
		/// The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Org_membershipState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	/// <summary>
	/// A GitHub organization.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Organization_simple
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_members_url")]
		public string Public_members_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Org_membershipPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="can_create_repository")]
		public bool Can_create_repository { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Org_membershipRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		member = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		billing_manager = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Org_membershipState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Org_pre_receive_hook
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_downstream_configuration")]
		public System.Nullable<System.Boolean> Allow_downstream_configuration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="configuration_url")]
		public string Configuration_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enforcement")]
		public string Enforcement { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Secrets for GitHub Actions for an organization.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Organization_actions_secret
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The name of the secret.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="selected_repositories_url")]
		public string Selected_repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Visibility of a secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public Organization_actions_secretVisibility Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Organization_actions_secretVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	/// <summary>
	/// Custom repository roles created by organization administrators
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Organization_custom_repository_role
	{
		
		/// <summary>
		/// The unique identifier of the custom role.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The name of the custom role.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Secrets for GitHub Dependabot for an organization.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Organization_dependabot_secret
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The name of the secret.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="selected_repositories_url")]
		public string Selected_repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Visibility of a secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public Organization_dependabot_secretVisibility Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Organization_dependabot_secretVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	/// <summary>
	/// Organization Full
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Organization_full
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="billing_email")]
		public string Billing_email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blog")]
		public string Blog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="collaborators")]
		public System.Nullable<System.Int32> Collaborators { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="company")]
		public string Company { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_repository_permission")]
		public string Default_repository_permission { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disk_usage")]
		public System.Nullable<System.Int32> Disk_usage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers")]
		public int Followers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following")]
		public int Following { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_organization_projects")]
		public bool Has_organization_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_repository_projects")]
		public bool Has_repository_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_verified")]
		public System.Nullable<System.Boolean> Is_verified { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_allowed_repository_creation_type")]
		public string Members_allowed_repository_creation_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_internal_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_internal_repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_pages")]
		public System.Nullable<System.Boolean> Members_can_create_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_private_pages")]
		public System.Nullable<System.Boolean> Members_can_create_private_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_private_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_private_repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_public_pages")]
		public System.Nullable<System.Boolean> Members_can_create_public_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_public_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_public_repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_fork_private_repositories")]
		public System.Nullable<System.Boolean> Members_can_fork_private_repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owned_private_repos")]
		public System.Nullable<System.Int32> Owned_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Organization_fullPlan Plan { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="private_gists")]
		public System.Nullable<System.Int32> Private_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_gists")]
		public int Public_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_members_url")]
		public string Public_members_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_repos")]
		public int Public_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total_private_repos")]
		public System.Nullable<System.Int32> Total_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="two_factor_requirement_enabled")]
		public System.Nullable<System.Boolean> Two_factor_requirement_enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	public class Organization_fullPlan
	{
		
		[System.Runtime.Serialization.DataMember(Name="filled_seats")]
		public System.Nullable<System.Int32> Filled_seats { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_repos")]
		public int Private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seats")]
		public System.Nullable<System.Int32> Seats { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="space")]
		public int Space { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Organization_secret_scanning_alert
	{
		
		/// <summary>
		/// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The GitHub URL of the alert resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The REST API URL of the code locations for this alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations_url")]
		public string Locations_url { get; set; }
		
		/// <summary>
		/// The security alert number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// Whether push protection was bypassed for the detected secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="push_protection_bypassed")]
		public System.Nullable<System.Boolean> Push_protection_bypassed { get; set; }
		
		/// <summary>
		/// The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="push_protection_bypassed_at")]
		public System.Nullable<System.DateTimeOffset> Push_protection_bypassed_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="push_protection_bypassed_by")]
		public Nullable_simple_user Push_protection_bypassed_by { get; set; }
		
		/// <summary>
		/// A GitHub repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Simple_repository Repository { get; set; }
		
		/// <summary>
		/// **Required when the `state` is `resolved`.** The reason for resolving the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public System.Nullable<Organization_secret_scanning_alertResolution> Resolution { get; set; }
		
		/// <summary>
		/// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolved_at")]
		public System.Nullable<System.DateTimeOffset> Resolved_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolved_by")]
		public Nullable_simple_user Resolved_by { get; set; }
		
		/// <summary>
		/// The secret that was detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The type of secret that secret scanning detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret_type")]
		public string Secret_type { get; set; }
		
		/// <summary>
		/// User-friendly name for the detected secret, matching the `secret_type`.
		///For a list of built-in patterns, see "[Secret scanning patterns](https://docs.github.com/enterprise-server@3.6/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret_type_display_name")]
		public string Secret_type_display_name { get; set; }
		
		/// <summary>
		/// Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<Organization_secret_scanning_alertState> State { get; set; }
		
		/// <summary>
		/// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The REST API URL of the alert resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Organization_secret_scanning_alertResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wont_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		revoked = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		used_in_tests = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Organization_secret_scanning_alertState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		resolved = 1,
	}
	
	/// <summary>
	/// The configuration for GitHub Pages for a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Page
	{
		
		/// <summary>
		/// The process in which the Page will be built.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="build_type")]
		public System.Nullable<PageBuild_type> Build_type { get; set; }
		
		/// <summary>
		/// The Pages site's custom domain
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cname")]
		public string Cname { get; set; }
		
		/// <summary>
		/// Whether the Page has a custom 404 page.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="custom_404")]
		public bool Custom_404 { get; set; } = false;
		
		/// <summary>
		/// The web address the Page can be accessed from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="https_certificate")]
		public Pages_https_certificate Https_certificate { get; set; }
		
		/// <summary>
		/// Whether https is enabled on the domain
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="https_enforced")]
		public System.Nullable<System.Boolean> Https_enforced { get; set; }
		
		/// <summary>
		/// The timestamp when a pending domain becomes unverified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pending_domain_unverified_at")]
		public System.Nullable<System.DateTimeOffset> Pending_domain_unverified_at { get; set; }
		
		/// <summary>
		/// The state if the domain is verified
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protected_domain_state")]
		public System.Nullable<PageProtected_domain_state> Protected_domain_state { get; set; }
		
		/// <summary>
		/// Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public")]
		public bool Public { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Pages_source_hash Source { get; set; }
		
		/// <summary>
		/// The status of the most recent build of the Page.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<PageStatus> Status { get; set; }
		
		/// <summary>
		/// The API address for accessing this Page resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PageBuild_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		legacy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		workflow = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pages_https_certificate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Array of the domain set and its alternate name (if it is configured)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public System.Nullable<System.DateOnly> Expires_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Pages_https_certificateState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Pages_https_certificateState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="new")]
		_new = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		authorization_created = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		authorization_pending = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		authorized = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		authorization_revoked = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		issued = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		uploaded = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		approved = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		errored = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		bad_authz = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		destroy_pending = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dns_changed = 11,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PageProtected_domain_state
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		verified = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unverified = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pages_source_hash
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branch")]
		public string Branch { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PageStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		built = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		building = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		errored = 2,
	}
	
	/// <summary>
	/// Page Build
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Page_build
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit")]
		public string Commit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public int Duration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Page_buildError Error { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pusher")]
		public Nullable_simple_user Pusher { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Page_buildError
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Page Build Status
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Page_build_status
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Participation_stats
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="all")]
		public int[] All { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public int[] Owner { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Patch_schema
	{
		
		/// <summary>
		/// patch operations list
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Patch_schemaOperations[] Patch_schemaOperations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemas")]
		public string[] Schemas { get; set; }
	}
	
	public class Patch_schemaOperations
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public Patch_schemaOperationsOp Op { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Corresponding 'value' of that field specified by 'path'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Patch_schemaOperationsOp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		add = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replace = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		remove = 2,
	}
	
	/// <summary>
	/// Details of a deployment that is waiting for protection rules to pass
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pending_deployment
	{
		
		/// <summary>
		/// Whether the currently authenticated user can approve the deployment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="current_user_can_approve")]
		public bool Current_user_can_approve { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public Pending_deploymentEnvironment Environment { get; set; }
		
		/// <summary>
		/// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reviewers")]
		public Pending_deploymentReviewers[] Pending_deploymentReviewers { get; set; }
		
		/// <summary>
		/// The set duration of the wait timer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="wait_timer")]
		public int Wait_timer { get; set; }
		
		/// <summary>
		/// The time that the wait timer began.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="wait_timer_started_at")]
		public System.Nullable<System.DateTimeOffset> Wait_timer_started_at { get; set; }
	}
	
	public class Pending_deploymentEnvironment
	{
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The id of the environment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name of the environment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pending_deploymentReviewers
	{
		
		[System.Runtime.Serialization.DataMember(Name="reviewer")]
		public Simple_user Reviewer { get; set; }
		
		/// <summary>
		/// The type of reviewer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Deployment_reviewer_type Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pre_receive_environment
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_environment")]
		public System.Nullable<System.Boolean> Default_environment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="download")]
		public Pre_receive_environmentDownload Download { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hooks_count")]
		public System.Nullable<System.Int32> Hooks_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pre_receive_environmentDownload
	{
		
		[System.Runtime.Serialization.DataMember(Name="downloaded_at")]
		public string Downloaded_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pre_receive_environment_download_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="downloaded_at")]
		public string Downloaded_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pre_receive_hook
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_downstream_configuration")]
		public System.Nullable<System.Boolean> Allow_downstream_configuration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enforcement")]
		public string Enforcement { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public Pre_receive_hookEnvironment Environment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="script")]
		public string Script { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="script_repository")]
		public Pre_receive_hookScript_repository Script_repository { get; set; }
	}
	
	public class Pre_receive_hookEnvironment
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_environment")]
		public System.Nullable<System.Boolean> Default_environment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="download")]
		public Pre_receive_hookEnvironmentDownload Download { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hooks_count")]
		public System.Nullable<System.Int32> Hooks_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pre_receive_hookEnvironmentDownload
	{
		
		[System.Runtime.Serialization.DataMember(Name="downloaded_at")]
		public string Downloaded_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pre_receive_hookScript_repository
	{
		
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Private User
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Private_user
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bio")]
		public string Bio { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blog")]
		public string Blog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="business_plus")]
		public System.Nullable<System.Boolean> Business_plus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators")]
		public int Collaborators { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="company")]
		public string Company { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk_usage")]
		public int Disk_usage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers")]
		public int Followers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following")]
		public int Following { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hireable")]
		public System.Nullable<System.Boolean> Hireable { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owned_private_repos")]
		public int Owned_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Private_userPlan Plan { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_gists")]
		public int Private_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_gists")]
		public int Public_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_repos")]
		public int Public_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suspended_at")]
		public System.Nullable<System.DateTimeOffset> Suspended_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_private_repos")]
		public int Total_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="two_factor_authentication")]
		public bool Two_factor_authentication { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Private_userPlan
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators")]
		public int Collaborators { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_repos")]
		public int Private_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="space")]
		public int Space { get; set; }
	}
	
	/// <summary>
	/// Projects are a way to organize columns and cards of work.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project
	{
		
		/// <summary>
		/// Body of the project
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="columns_url")]
		public string Columns_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creator")]
		public Nullable_simple_user Creator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Name of the project
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// The baseline permission that all organization members have on this project. Only present if owner is an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_permission")]
		public System.Nullable<ProjectOrganization_permission> Organization_permission { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner_url")]
		public string Owner_url { get; set; }
		
		/// <summary>
		/// Whether or not this project can be seen by everyone. Only present if owner is an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		/// <summary>
		/// State of the project; either 'open' or 'closed'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ProjectOrganization_permission
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		write = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 3,
	}
	
	/// <summary>
	/// Project cards represent a scope of work.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project_card
	{
		
		/// <summary>
		/// Whether or not the card is archived
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="column_name")]
		public string Column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column_url")]
		public string Column_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content_url")]
		public string Content_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creator")]
		public Nullable_simple_user Creator { get; set; }
		
		/// <summary>
		/// The project card's ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="project_id")]
		public string Project_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_url")]
		public string Project_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Project Collaborator Permission
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project_collaborator_permission
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	/// <summary>
	/// Project columns contain cards of work.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project_column
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cards_url")]
		public string Cards_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The unique identifier of the project column
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Name of the project column
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_url")]
		public string Project_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Branch protections protect branches
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Protected_branch
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_deletions")]
		public Protected_branchAllow_deletions Allow_deletions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_force_pushes")]
		public Protected_branchAllow_force_pushes Allow_force_pushes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="block_creations")]
		public Protected_branchBlock_creations Block_creations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enforce_admins")]
		public Protected_branchEnforce_admins Enforce_admins { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_conversation_resolution")]
		public Protected_branchRequired_conversation_resolution Required_conversation_resolution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_linear_history")]
		public Protected_branchRequired_linear_history Required_linear_history { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_pull_request_reviews")]
		public Protected_branchRequired_pull_request_reviews Required_pull_request_reviews { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_signatures")]
		public Protected_branchRequired_signatures Required_signatures { get; set; }
		
		/// <summary>
		/// Status Check Policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_status_checks")]
		public Status_check_policy Required_status_checks { get; set; }
		
		/// <summary>
		/// Branch Restriction Policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restrictions")]
		public Branch_restriction_policy Restrictions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Protected_branchAllow_deletions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class Protected_branchAllow_force_pushes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class Protected_branchBlock_creations
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class Protected_branchEnforce_admins
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Protected_branchRequired_conversation_resolution
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class Protected_branchRequired_linear_history
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class Protected_branchRequired_pull_request_reviews
	{
		
		[System.Runtime.Serialization.DataMember(Name="bypass_pull_request_allowances")]
		public Protected_branchRequired_pull_request_reviewsBypass_pull_request_allowances Bypass_pull_request_allowances { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dismiss_stale_reviews")]
		public System.Nullable<System.Boolean> Dismiss_stale_reviews { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dismissal_restrictions")]
		public Protected_branchRequired_pull_request_reviewsDismissal_restrictions Dismissal_restrictions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="require_code_owner_reviews")]
		public System.Nullable<System.Boolean> Require_code_owner_reviews { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="required_approving_review_count")]
		public System.Nullable<System.Int32> Required_approving_review_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Protected_branchRequired_pull_request_reviewsBypass_pull_request_allowances
	{
		
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public Integration[] Apps { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public Team[] Teams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users")]
		public Simple_user[] Users { get; set; }
	}
	
	public class Protected_branchRequired_pull_request_reviewsDismissal_restrictions
	{
		
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public Integration[] Apps { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public Team[] Teams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users")]
		public Simple_user[] Users { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users_url")]
		public string Users_url { get; set; }
	}
	
	public class Protected_branchRequired_signatures
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Status Check Policy
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Status_check_policy
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="checks")]
		public Status_check_policyChecks[] Status_check_policyChecks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contexts")]
		public string[] Contexts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contexts_url")]
		public string Contexts_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="strict")]
		public bool Strict { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Status_check_policyChecks
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app_id")]
		public System.Nullable<System.Int32> App_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Public_key_full
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="read_only")]
		public bool Read_only { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_id")]
		public System.Nullable<System.Int32> Repository_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user_id")]
		public System.Nullable<System.Int32> User_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public bool Verified { get; set; }
	}
	
	/// <summary>
	/// Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pull_request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Pull_request_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="active_lock_reason")]
		public string Active_lock_reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="additions")]
		public int Additions { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Nullable_simple_user Assignee { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assignees")]
		public Simple_user[] Assignees { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// The status of auto merging a pull request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="auto_merge")]
		public Auto_merge Auto_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="base")]
		public Pull_requestBase Base { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="changed_files")]
		public int Changed_files { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_at")]
		public System.Nullable<System.DateTimeOffset> Closed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public int Comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits")]
		public int Commits { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deletions")]
		public int Deletions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="diff_url")]
		public string Diff_url { get; set; }
		
		/// <summary>
		/// Indicates whether or not the pull request is a draft.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public System.Nullable<System.Boolean> Draft { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head")]
		public Pull_requestHead Head { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_url")]
		public string Issue_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Pull_requestLabels[] Pull_requestLabels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public bool Locked { get; set; }
		
		/// <summary>
		/// Indicates whether maintainers can modify the pull request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maintainer_can_modify")]
		public bool Maintainer_can_modify { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merge_commit_sha")]
		public string Merge_commit_sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mergeable")]
		public System.Nullable<System.Boolean> Mergeable { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mergeable_state")]
		public string Mergeable_state { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merged")]
		public bool Merged { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merged_at")]
		public System.Nullable<System.DateTimeOffset> Merged_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merged_by")]
		public Nullable_simple_user Merged_by { get; set; }
		
		/// <summary>
		/// A collection of related issues and pull requests.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public Nullable_milestone Milestone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Number uniquely identifying the pull request within its repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="patch_url")]
		public string Patch_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rebaseable")]
		public System.Nullable<System.Boolean> Rebaseable { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requested_reviewers")]
		public Simple_user[] Requested_reviewers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requested_teams")]
		public Team_simple[] Requested_teams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comment_url")]
		public string Review_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comments")]
		public int Review_comments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comments_url")]
		public string Review_comments_url { get; set; }
		
		/// <summary>
		/// State of this Pull Request. Either `open` or `closed`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Nullable_milestoneState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// The title of the pull request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Pull_request_links
	{
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public Link Comments { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits")]
		public Link Commits { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public Link Html { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue")]
		public Link Issue { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comment")]
		public Link Review_comment { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comments")]
		public Link Review_comments { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Link Self { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public Link Statuses { get; set; }
	}
	
	public class Pull_requestBase
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public Pull_requestBaseRepo Repo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Pull_requestBaseUser User { get; set; }
	}
	
	public class Pull_requestBaseRepo
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public bool Disabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public int Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public int Forks_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_discussions")]
		public bool Has_discussions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public bool Has_downloads { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public bool Has_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public bool Has_pages { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public bool Has_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public bool Has_wiki { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// License Simple
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Nullable_license_simple License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="master_branch")]
		public string Master_branch { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public int Open_issues_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Pull_requestBaseRepoOwner Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Pull_requestBaseRepoPermissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public System.DateTimeOffset Pushed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public int Stargazers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The repository visibility: public, private, or internal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers")]
		public int Watchers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public int Watchers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	public class Pull_requestBaseRepoOwner
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pull_requestBaseRepoPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	public class Pull_requestBaseUser
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pull_requestHead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public Pull_requestHeadRepo Repo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Pull_requestHeadUser User { get; set; }
	}
	
	public class Pull_requestHeadRepo
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public bool Disabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public int Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public int Forks_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_discussions")]
		public bool Has_discussions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public bool Has_downloads { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public bool Has_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public bool Has_pages { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public bool Has_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public bool Has_wiki { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Pull_requestHeadRepoLicense License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="master_branch")]
		public string Master_branch { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public int Open_issues_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Pull_requestHeadRepoOwner Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Pull_requestHeadRepoPermissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public System.DateTimeOffset Pushed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public int Stargazers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The repository visibility: public, private, or internal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers")]
		public int Watchers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public int Watchers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	public class Pull_requestHeadRepoLicense
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spdx_id")]
		public string Spdx_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pull_requestHeadRepoOwner
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pull_requestHeadRepoPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	public class Pull_requestHeadUser
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Pull_requestLabels
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default")]
		public bool Default { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public long Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Groups of organization members that gives permissions on specified repositories.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team_simple
	{
		
		/// <summary>
		/// Description of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Distinguished Name (DN) that team maps to within LDAP environment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		/// <summary>
		/// Name of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Permission that the team will have for its repositories
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; }
		
		/// <summary>
		/// The level of privacy this team should have
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public string Privacy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories_url")]
		public string Repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// URL for the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Pull Request Merge Result
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pull_request_merge_result
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merged")]
		public bool Merged { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
	}
	
	/// <summary>
	/// Pull Request Reviews are reviews on pull requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pull_request_review
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Pull_request_review_links _links { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// The text of the review.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// A commit SHA for the review. If the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the review
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request_url")]
		public string Pull_request_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="submitted_at")]
		public System.Nullable<System.DateTimeOffset> Submitted_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Pull_request_review_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public Pull_request_review_linksHtml Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request")]
		public Pull_request_review_linksPull_request Pull_request { get; set; }
	}
	
	public class Pull_request_review_linksHtml
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	public class Pull_request_review_linksPull_request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	/// <summary>
	/// Pull Request Review Comments are comments on a portion of the Pull Request's diff.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pull_request_review_comment
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Pull_request_review_comment_links _links { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// The text of the comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// The SHA of the commit to which the comment applies.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The diff of the line that the comment refers to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="diff_hunk")]
		public string Diff_hunk { get; set; }
		
		/// <summary>
		/// HTML URL for the pull request review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The ID of the pull request review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The comment ID to reply to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in_reply_to_id")]
		public System.Nullable<System.Int32> In_reply_to_id { get; set; }
		
		/// <summary>
		/// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="line")]
		public System.Nullable<System.Int32> Line { get; set; }
		
		/// <summary>
		/// The node ID of the pull request review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The SHA of the original commit to which the comment applies.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="original_commit_id")]
		public string Original_commit_id { get; set; }
		
		/// <summary>
		/// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="original_line")]
		public System.Nullable<System.Int32> Original_line { get; set; }
		
		/// <summary>
		/// The index of the original line in the diff to which the comment applies. This field is deprecated; use `original_line` instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="original_position")]
		public int Original_position { get; set; }
		
		/// <summary>
		/// The first line of the range for a multi-line comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="original_start_line")]
		public System.Nullable<System.Int32> Original_start_line { get; set; }
		
		/// <summary>
		/// The relative path of the file to which the comment applies.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The line index in the diff to which the comment applies. This field is deprecated; use `line` instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="position")]
		public int Position { get; set; }
		
		/// <summary>
		/// The ID of the pull request review to which the comment belongs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request_review_id")]
		public System.Nullable<System.Int32> Pull_request_review_id { get; set; }
		
		/// <summary>
		/// URL for the pull request that the review comment belongs to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request_url")]
		public string Pull_request_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="side")]
		public System.Nullable<Pull_request_review_commentSide> Side { get; set; }
		
		/// <summary>
		/// The first line of the range for a multi-line comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public System.Nullable<System.Int32> Start_line { get; set; }
		
		/// <summary>
		/// The side of the first line of the range for a multi-line comment.
		/// </summary>
		[System.ComponentModel.DefaultValue(Pull_request_review_commentSide.RIGHT)]
		[System.Runtime.Serialization.DataMember(Name="start_side")]
		public Pull_request_review_commentSide Start_side { get; set; } = Pull_request_review_commentSide.RIGHT;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// URL for the pull request review comment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Simple_user User { get; set; }
	}
	
	public class Pull_request_review_comment_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public Pull_request_review_comment_linksHtml Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request")]
		public Pull_request_review_comment_linksPull_request Pull_request { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Pull_request_review_comment_linksSelf Self { get; set; }
	}
	
	public class Pull_request_review_comment_linksHtml
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	public class Pull_request_review_comment_linksPull_request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	public class Pull_request_review_comment_linksSelf
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Pull_request_review_commentSide
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LEFT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RIGHT = 1,
	}
	
	/// <summary>
	/// Pull Request Review Request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pull_request_review_request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public Team[] Teams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users")]
		public Simple_user[] Users { get; set; }
	}
	
	/// <summary>
	/// Pull Request Simple
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pull_request_simple
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Pull_request_simple_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="active_lock_reason")]
		public string Active_lock_reason { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Nullable_simple_user Assignee { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assignees")]
		public Simple_user[] Assignees { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// The status of auto merging a pull request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="auto_merge")]
		public Auto_merge Auto_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="base")]
		public Pull_request_simpleBase Base { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="closed_at")]
		public System.Nullable<System.DateTimeOffset> Closed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="diff_url")]
		public string Diff_url { get; set; }
		
		/// <summary>
		/// Indicates whether or not the pull request is a draft.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public System.Nullable<System.Boolean> Draft { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head")]
		public Pull_request_simpleHead Head { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_url")]
		public string Issue_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Pull_request_simpleLabels[] Pull_request_simpleLabels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public bool Locked { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merge_commit_sha")]
		public string Merge_commit_sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merged_at")]
		public System.Nullable<System.DateTimeOffset> Merged_at { get; set; }
		
		/// <summary>
		/// A collection of related issues and pull requests.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public Nullable_milestone Milestone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="patch_url")]
		public string Patch_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requested_reviewers")]
		public Simple_user[] Requested_reviewers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requested_teams")]
		public Team[] Requested_teams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comment_url")]
		public string Review_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comments_url")]
		public string Review_comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Pull_request_simple_links
	{
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public Link Comments { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits")]
		public Link Commits { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public Link Html { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue")]
		public Link Issue { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comment")]
		public Link Review_comment { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_comments")]
		public Link Review_comments { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Link Self { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public Link Statuses { get; set; }
	}
	
	public class Pull_request_simpleBase
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public Repository Repo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Pull_request_simpleHead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public Repository Repo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Pull_request_simpleLabels
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default")]
		public bool Default { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public long Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Rate_limit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="limit")]
		public int Limit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remaining")]
		public int Remaining { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reset")]
		public int Reset { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="used")]
		public int Used { get; set; }
	}
	
	/// <summary>
	/// Rate Limit Overview
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Rate_limit_overview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rate")]
		public Rate_limit Rate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Rate_limit_overviewResources Resources { get; set; }
	}
	
	public class Rate_limit_overviewResources
	{
		
		[System.Runtime.Serialization.DataMember(Name="actions_runner_registration")]
		public Rate_limit Actions_runner_registration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code_scanning_upload")]
		public Rate_limit Code_scanning_upload { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="core")]
		public Rate_limit Core { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="graphql")]
		public Rate_limit Graphql { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="integration_manifest")]
		public Rate_limit Integration_manifest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scim")]
		public Rate_limit Scim { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="search")]
		public Rate_limit Search { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source_import")]
		public Rate_limit Source_import { get; set; }
	}
	
	/// <summary>
	/// Reactions to conversations provide a way to help people express their feelings more simply and effectively.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reaction
	{
		
		/// <summary>
		/// The reaction to use
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionContent Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	/// <summary>
	/// A workflow referenced/reused by the initial caller workflow
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Referenced_workflow
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
	}
	
	/// <summary>
	/// A release.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Release
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public Release_asset[] Assets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets_url")]
		public string Assets_url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Simple_user Author { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// true to create a draft (unpublished) release, false to create a published one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public bool Draft { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mentions_count")]
		public System.Nullable<System.Int32> Mentions_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Whether to identify the release as a prerelease or a full release.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prerelease")]
		public bool Prerelease { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="published_at")]
		public System.Nullable<System.DateTimeOffset> Published_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// The name of the tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag_name")]
		public string Tag_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tarball_url")]
		public string Tarball_url { get; set; }
		
		/// <summary>
		/// Specifies the commitish value that determines where the Git tag is created from.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target_commitish")]
		public string Target_commitish { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="upload_url")]
		public string Upload_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="zipball_url")]
		public string Zipball_url { get; set; }
	}
	
	/// <summary>
	/// Data related to a release.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Release_asset
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="browser_download_url")]
		public string Browser_download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_count")]
		public int Download_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The file name of the asset.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// State of the release asset.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Release_assetState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uploader")]
		public Nullable_simple_user Uploader { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Release_assetState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		uploaded = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 1,
	}
	
	/// <summary>
	/// Generated name and body describing a release
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Release_notes_content
	{
		
		/// <summary>
		/// The generated body describing the contents of the release supporting markdown formatting
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The generated name of the release
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Removed from Project Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Removed_from_project_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="project_card")]
		public Removed_from_project_issue_eventProject_card Project_card { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Removed_from_project_issue_eventProject_card
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column_name")]
		public string Column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_column_name")]
		public string Previous_column_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_id")]
		public int Project_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="project_url")]
		public string Project_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Renamed Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Renamed_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rename")]
		public Renamed_issue_eventRename Rename { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Renamed_issue_eventRename
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	/// <summary>
	/// Repo Search Result Item
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Repo_search_result_item
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Returns whether or not this repository disabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public bool Disabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public int Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public int Forks_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public bool Has_downloads { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public bool Has_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public bool Has_pages { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public bool Has_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public bool Has_wiki { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// License Simple
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Nullable_license_simple License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="master_branch")]
		public string Master_branch { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public int Open_issues_count { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Nullable_simple_user Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Repo_search_result_itemPermissions Permissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public System.DateTimeOffset Pushed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score")]
		public double Score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public int Stargazers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text_matches")]
		public Repo_search_result_itemText_matches[] Repo_search_result_itemText_matches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The repository visibility: public, private, or internal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers")]
		public int Watchers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public int Watchers_count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	public class Repo_search_result_itemPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	public class Repo_search_result_itemText_matches
	{
		
		[System.Runtime.Serialization.DataMember(Name="fragment")]
		public string Fragment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public Repo_search_result_itemText_matchesMatches[] Repo_search_result_itemText_matchesMatches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_type")]
		public string Object_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_url")]
		public string Object_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="property")]
		public string Property { get; set; }
	}
	
	public class Repo_search_result_itemText_matchesMatches
	{
		
		[System.Runtime.Serialization.DataMember(Name="indices")]
		public int[] Indices { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Repository Collaborator Permission
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Repository_collaborator_permission
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role_name")]
		public string Role_name { get; set; }
		
		/// <summary>
		/// Collaborator
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_collaborator User { get; set; }
	}
	
	/// <summary>
	/// Repository invitations let you manage who you collaborate with.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Repository_invitation
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Whether or not the invitation has expired
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expired")]
		public System.Nullable<System.Boolean> Expired { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the repository invitation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="invitee")]
		public Nullable_simple_user Invitee { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="inviter")]
		public Nullable_simple_user Inviter { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The permission associated with the invitation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Repository_invitationPermissions Permissions { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Minimal_repository Repository { get; set; }
		
		/// <summary>
		/// URL for the repository invitation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Repository_invitationPermissions
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		write = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		triage = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		maintain = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Repository_pre_receive_hook
	{
		
		[System.Runtime.Serialization.DataMember(Name="configuration_url")]
		public string Configuration_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enforcement")]
		public string Enforcement { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Repository invitations let you manage who you collaborate with.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Repository_subscription
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Determines if all notifications should be blocked from this repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ignored")]
		public bool Ignored { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// Determines if notifications should be received from this repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribed")]
		public bool Subscribed { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Legacy Review Comment
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Review_comment
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Review_comment_links _links { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="diff_hunk")]
		public string Diff_hunk { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="in_reply_to_id")]
		public System.Nullable<System.Int32> In_reply_to_id { get; set; }
		
		/// <summary>
		/// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="line")]
		public System.Nullable<System.Int32> Line { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="original_commit_id")]
		public string Original_commit_id { get; set; }
		
		/// <summary>
		/// The original line of the blob to which the comment applies. The last line of the range for a multi-line comment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="original_line")]
		public System.Nullable<System.Int32> Original_line { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="original_position")]
		public int Original_position { get; set; }
		
		/// <summary>
		/// The original first line of the range for a multi-line comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="original_start_line")]
		public System.Nullable<System.Int32> Original_start_line { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="position")]
		public System.Nullable<System.Int32> Position { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request_review_id")]
		public System.Nullable<System.Int32> Pull_request_review_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request_url")]
		public string Pull_request_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// The side of the first line of the range for a multi-line comment.
		/// </summary>
		[System.ComponentModel.DefaultValue(Pull_request_review_commentSide.RIGHT)]
		[System.Runtime.Serialization.DataMember(Name="side")]
		public Pull_request_review_commentSide Side { get; set; } = Pull_request_review_commentSide.RIGHT;
		
		/// <summary>
		/// The first line of the range for a multi-line comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public System.Nullable<System.Int32> Start_line { get; set; }
		
		/// <summary>
		/// The side of the first line of the range for a multi-line comment.
		/// </summary>
		[System.ComponentModel.DefaultValue(Pull_request_review_commentSide.RIGHT)]
		[System.Runtime.Serialization.DataMember(Name="start_side")]
		public Pull_request_review_commentSide Start_side { get; set; } = Pull_request_review_commentSide.RIGHT;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	public class Review_comment_links
	{
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public Link Html { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request")]
		public Link Pull_request { get; set; }
		
		/// <summary>
		/// Hypermedia Link
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Link Self { get; set; }
	}
	
	/// <summary>
	/// Review Dismissed Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Review_dismissed_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissed_review")]
		public Review_dismissed_issue_eventDismissed_review Dismissed_review { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Review_dismissed_issue_eventDismissed_review
	{
		
		[System.Runtime.Serialization.DataMember(Name="dismissal_commit_id")]
		public string Dismissal_commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dismissal_message")]
		public string Dismissal_message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_id")]
		public int Review_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
	}
	
	/// <summary>
	/// Review Request Removed Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Review_request_removed_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requested_reviewer")]
		public Simple_user Requested_reviewer { get; set; }
		
		/// <summary>
		/// Groups of organization members that gives permissions on specified repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requested_team")]
		public Team Requested_team { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_requester")]
		public Simple_user Review_requester { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Review Requested Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Review_requested_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requested_reviewer")]
		public Simple_user Requested_reviewer { get; set; }
		
		/// <summary>
		/// Groups of organization members that gives permissions on specified repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requested_team")]
		public Team Requested_team { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="review_requester")]
		public Simple_user Review_requester { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Root
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizations_url")]
		public string Authorizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code_search_url")]
		public string Code_search_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_search_url")]
		public string Commit_search_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="current_user_authorizations_html_url")]
		public string Current_user_authorizations_html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="current_user_repositories_url")]
		public string Current_user_repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="current_user_url")]
		public string Current_user_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emails_url")]
		public string Emails_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emojis_url")]
		public string Emojis_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="feeds_url")]
		public string Feeds_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hub_url")]
		public string Hub_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_search_url")]
		public string Issue_search_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label_search_url")]
		public string Label_search_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organization_repositories_url")]
		public string Organization_repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organization_teams_url")]
		public string Organization_teams_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organization_url")]
		public string Organization_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_gists_url")]
		public string Public_gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rate_limit_url")]
		public string Rate_limit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_search_url")]
		public string Repository_search_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_gists_url")]
		public string Starred_gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topic_search_url")]
		public string Topic_search_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user_organizations_url")]
		public string User_organizations_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user_repositories_url")]
		public string User_repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user_search_url")]
		public string User_search_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user_url")]
		public string User_url { get; set; }
	}
	
	/// <summary>
	/// A self hosted runner
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Runner
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="busy")]
		public bool Busy { get; set; }
		
		/// <summary>
		/// The id of the runner.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// The name of the runner.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Operating System of the runner.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os")]
		public string Os { get; set; }
		
		/// <summary>
		/// The status of the runner.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	/// <summary>
	/// A label for a self hosted runner
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Runner_label
	{
		
		/// <summary>
		/// Unique identifier of the label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Name of the label.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The type of label. Read-only labels are applied automatically when the runner is configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<Runner_labelType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Runner_labelType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 1,
	}
	
	/// <summary>
	/// Runner Application
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Runner_application
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public string Architecture { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os")]
		public string Os { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sha256_checksum")]
		public string Sha256_checksum { get; set; }
		
		/// <summary>
		/// A short lived bearer token used to download the runner, if needed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temp_download_token")]
		public string Temp_download_token { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Runner_groups_enterprise
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allows_public_repositories")]
		public bool Allows_public_repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default")]
		public bool Default { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted_to_workflows")]
		public System.Nullable<System.Boolean> Restricted_to_workflows { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runners_url")]
		public string Runners_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="selected_organizations_url")]
		public string Selected_organizations_url { get; set; }
		
		/// <summary>
		/// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_workflows")]
		public string[] Selected_workflows { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		/// <summary>
		/// If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workflow_restrictions_read_only")]
		public System.Nullable<System.Boolean> Workflow_restrictions_read_only { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Runner_groups_org
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allows_public_repositories")]
		public bool Allows_public_repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default")]
		public bool Default { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="inherited")]
		public bool Inherited { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="inherited_allows_public_repositories")]
		public System.Nullable<System.Boolean> Inherited_allows_public_repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted_to_workflows")]
		public System.Nullable<System.Boolean> Restricted_to_workflows { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runners_url")]
		public string Runners_url { get; set; }
		
		/// <summary>
		/// Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_repositories_url")]
		public string Selected_repositories_url { get; set; }
		
		/// <summary>
		/// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_workflows")]
		public string[] Selected_workflows { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
		
		/// <summary>
		/// If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workflow_restrictions_read_only")]
		public System.Nullable<System.Boolean> Workflow_restrictions_read_only { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Scim_enterprise_group_list
	{
		
		/// <summary>
		/// Information about each provisioned group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Scim_enterprise_group_response[] Resources { get; set; }
		
		/// <summary>
		/// Number of objects per page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="itemsPerPage")]
		public int ItemsPerPage { get; set; }
		
		/// <summary>
		/// The URIs that are used to indicate the namespaces of the list SCIM schemas.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemas")]
		public string[] Schemas { get; set; }
		
		/// <summary>
		/// A starting index for the returned page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startIndex")]
		public int StartIndex { get; set; }
		
		/// <summary>
		/// Number of results found
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="totalResults")]
		public int TotalResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Scim_enterprise_group_response : Group_response
	{
		
		/// <summary>
		/// The internally generated id for the group object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The security group members.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members")]
		public Scim_enterprise_group_responseMembers[] Scim_enterprise_group_responseMembers { get; set; }
		
		/// <summary>
		/// The metadata associated with the creation/updates to the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Meta Meta { get; set; }
	}
	
	public class Scim_enterprise_group_responseMembers
	{
		
		[System.Runtime.Serialization.DataMember(Name="$ref")]
		public string Ref { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="display")]
		public string Display { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Scim_enterprise_user_list
	{
		
		/// <summary>
		/// Information about each provisioned account.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Scim_enterprise_user_response[] Resources { get; set; }
		
		/// <summary>
		/// Number of objects per page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="itemsPerPage")]
		public int ItemsPerPage { get; set; }
		
		/// <summary>
		/// The URIs that are used to indicate the namespaces of the list SCIM schemas.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemas")]
		public string[] Schemas { get; set; }
		
		/// <summary>
		/// A starting index for the returned page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startIndex")]
		public int StartIndex { get; set; }
		
		/// <summary>
		/// Number of results found
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="totalResults")]
		public int TotalResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Scim_enterprise_user_response : User_response
	{
		
		/// <summary>
		/// Provisioned SCIM groups that the user is a member of.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public Scim_enterprise_user_responseGroups[] Scim_enterprise_user_responseGroups { get; set; }
		
		/// <summary>
		/// The internally generated id for the user object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The metadata associated with the creation/updates to the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Meta Meta { get; set; }
	}
	
	public class Scim_enterprise_user_responseGroups
	{
		
		[System.Runtime.Serialization.DataMember(Name="$ref")]
		public string Ref { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="display")]
		public string Display { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Scim Error
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Scim_error
	{
		
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="documentation_url")]
		public string Documentation_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="schemas")]
		public string[] Schemas { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scimType")]
		public string ScimType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Search_result_text_matchesElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="fragment")]
		public string Fragment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public Search_result_text_matchesElementMatches[] Search_result_text_matchesElementMatches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_type")]
		public string Object_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_url")]
		public string Object_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="property")]
		public string Property { get; set; }
	}
	
	public class Search_result_text_matchesElementMatches
	{
		
		[System.Runtime.Serialization.DataMember(Name="indices")]
		public int[] Indices { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Secret_scanning_alert
	{
		
		/// <summary>
		/// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The GitHub URL of the alert resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The REST API URL of the code locations for this alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations_url")]
		public string Locations_url { get; set; }
		
		/// <summary>
		/// The security alert number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// Whether push protection was bypassed for the detected secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="push_protection_bypassed")]
		public System.Nullable<System.Boolean> Push_protection_bypassed { get; set; }
		
		/// <summary>
		/// The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="push_protection_bypassed_at")]
		public System.Nullable<System.DateTimeOffset> Push_protection_bypassed_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="push_protection_bypassed_by")]
		public Nullable_simple_user Push_protection_bypassed_by { get; set; }
		
		/// <summary>
		/// **Required when the `state` is `resolved`.** The reason for resolving the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public System.Nullable<Secret_scanning_alertResolution> Resolution { get; set; }
		
		/// <summary>
		/// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolved_at")]
		public System.Nullable<System.DateTimeOffset> Resolved_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolved_by")]
		public Nullable_simple_user Resolved_by { get; set; }
		
		/// <summary>
		/// The secret that was detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The type of secret that secret scanning detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret_type")]
		public string Secret_type { get; set; }
		
		/// <summary>
		/// User-friendly name for the detected secret, matching the `secret_type`.
		///For a list of built-in patterns, see "[Secret scanning patterns](https://docs.github.com/enterprise-server@3.6/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret_type_display_name")]
		public string Secret_type_display_name { get; set; }
		
		/// <summary>
		/// Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Organization_secret_scanning_alertState State { get; set; }
		
		/// <summary>
		/// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The REST API URL of the alert resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Secret_scanning_alertResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wont_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		revoked = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		used_in_tests = 4,
	}
	
	/// <summary>
	/// **Required when the `state` is `resolved`.** The reason for resolving the alert.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Secret_scanning_alert_resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wont_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		revoked = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		used_in_tests = 4,
	}
	
	/// <summary>
	/// Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Secret_scanning_alert_state
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		resolved = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Secret_scanning_location
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="details")]
		public Secret_scanning_location_commit Details { get; set; }
		
		/// <summary>
		/// The location type. Because secrets may be found in different types of resources (ie. code, comments, issues), this field identifies the type of resource where the secret was found.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Secret_scanning_locationType Type { get; set; }
	}
	
	/// <summary>
	/// Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Secret_scanning_location_commit
	{
		
		/// <summary>
		/// SHA-1 hash ID of the associated blob
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blob_sha")]
		public string Blob_sha { get; set; }
		
		/// <summary>
		/// The API URL to get the associated blob resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blob_url")]
		public string Blob_url { get; set; }
		
		/// <summary>
		/// SHA-1 hash ID of the associated commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_sha")]
		public string Commit_sha { get; set; }
		
		/// <summary>
		/// The API URL to get the associated commit resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// The column at which the secret ends within the end line when the file is interpreted as 8BIT ASCII
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end_column")]
		public double End_column { get; set; }
		
		/// <summary>
		/// Line number at which the secret ends in the file
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end_line")]
		public double End_line { get; set; }
		
		/// <summary>
		/// The file path in the repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The column at which the secret starts within the start line when the file is interpreted as 8BIT ASCII
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start_column")]
		public double Start_column { get; set; }
		
		/// <summary>
		/// Line number at which the secret starts in the file
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public double Start_line { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Secret_scanning_locationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		commit = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Selected_actions
	{
		
		/// <summary>
		/// Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="github_owned_allowed")]
		public bool Github_owned_allowed { get; set; }
		
		/// <summary>
		/// Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="patterns_allowed")]
		public string[] Patterns_allowed { get; set; }
	}
	
	/// <summary>
	/// Short Blob
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Short_blob
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Short Branch
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Short_branch
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit")]
		public Short_branchCommit Commit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protected")]
		public bool Protected { get; set; }
		
		/// <summary>
		/// Branch Protection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Branch_protection Protection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protection_url")]
		public string Protection_url { get; set; }
	}
	
	public class Short_branchCommit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Ssh_key
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pretty-print")]
		public string Pretty_print { get; set; }
	}
	
	/// <summary>
	/// Stargazer
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Stargazer
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_at")]
		public System.DateTimeOffset Starred_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Nullable_simple_user User { get; set; }
	}
	
	/// <summary>
	/// Starred Repository
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Starred_repository
	{
		
		/// <summary>
		/// A repository on GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public Repository Repo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_at")]
		public System.DateTimeOffset Starred_at { get; set; }
	}
	
	/// <summary>
	/// State Change Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class State_change_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state_reason")]
		public string State_reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The status of a commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Status
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creator")]
		public Nullable_simple_user Creator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target_url")]
		public string Target_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Tag
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit")]
		public TagCommit Commit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tarball_url")]
		public string Tarball_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="zipball_url")]
		public string Zipball_url { get; set; }
	}
	
	public class TagCommit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Tag protection
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag_protection
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pattern")]
		public string Pattern { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	/// <summary>
	/// A team discussion is a persistent record of a free-form conversation within a team.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team_discussion
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Nullable_simple_user Author { get; set; }
		
		/// <summary>
		/// The main text of the discussion.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		/// <summary>
		/// The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body_version")]
		public string Body_version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_count")]
		public int Comments_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_edited_at")]
		public System.Nullable<System.DateTimeOffset> Last_edited_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The unique sequence number of a team discussion.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// Whether or not this discussion should be pinned for easy retrieval.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pinned")]
		public bool Pinned { get; set; }
		
		/// <summary>
		/// Whether or not this discussion should be restricted to team members and organization administrators.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="team_url")]
		public string Team_url { get; set; }
		
		/// <summary>
		/// The title of the discussion.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A reply to a discussion within a team.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team_discussion_comment
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Nullable_simple_user Author { get; set; }
		
		/// <summary>
		/// The main text of the comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		/// <summary>
		/// The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body_version")]
		public string Body_version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="discussion_url")]
		public string Discussion_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_edited_at")]
		public System.Nullable<System.DateTimeOffset> Last_edited_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The unique sequence number of a team discussion comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Groups of organization members that gives permissions on specified repositories.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team_full
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Distinguished Name (DN) that team maps to within LDAP environment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members_count")]
		public int Members_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		/// <summary>
		/// Name of the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Team Organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public Team_organization Organization { get; set; }
		
		/// <summary>
		/// Groups of organization members that gives permissions on specified repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public Nullable_team_simple Parent { get; set; }
		
		/// <summary>
		/// Permission that the team will have for its repositories
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; }
		
		/// <summary>
		/// The level of privacy this team should have
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public System.Nullable<Team_fullPrivacy> Privacy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_count")]
		public int Repos_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories_url")]
		public string Repositories_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// URL for the team
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Team Organization
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team_organization
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="billing_email")]
		public string Billing_email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blog")]
		public string Blog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="collaborators")]
		public System.Nullable<System.Int32> Collaborators { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="company")]
		public string Company { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_repository_permission")]
		public string Default_repository_permission { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disk_usage")]
		public System.Nullable<System.Int32> Disk_usage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers")]
		public int Followers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following")]
		public int Following { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_organization_projects")]
		public bool Has_organization_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_repository_projects")]
		public bool Has_repository_projects { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_verified")]
		public System.Nullable<System.Boolean> Is_verified { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_allowed_repository_creation_type")]
		public string Members_allowed_repository_creation_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_internal_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_internal_repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_pages")]
		public System.Nullable<System.Boolean> Members_can_create_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_private_pages")]
		public System.Nullable<System.Boolean> Members_can_create_private_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_private_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_private_repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_public_pages")]
		public System.Nullable<System.Boolean> Members_can_create_public_pages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_public_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_public_repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_create_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="members_can_fork_private_repositories")]
		public System.Nullable<System.Boolean> Members_can_fork_private_repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="members_url")]
		public string Members_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owned_private_repos")]
		public System.Nullable<System.Int32> Owned_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Team_organizationPlan Plan { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="private_gists")]
		public System.Nullable<System.Int32> Private_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_gists")]
		public int Public_gists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_members_url")]
		public string Public_members_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_repos")]
		public int Public_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total_private_repos")]
		public System.Nullable<System.Int32> Total_private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="two_factor_requirement_enabled")]
		public System.Nullable<System.Boolean> Two_factor_requirement_enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	public class Team_organizationPlan
	{
		
		[System.Runtime.Serialization.DataMember(Name="filled_seats")]
		public System.Nullable<System.Int32> Filled_seats { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_repos")]
		public int Private_repos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seats")]
		public System.Nullable<System.Int32> Seats { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="space")]
		public int Space { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Team_fullPrivacy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		secret = 1,
	}
	
	/// <summary>
	/// Team Membership
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team_membership
	{
		
		/// <summary>
		/// The role of the user in the team.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(Team_membershipRole.member)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public Team_membershipRole Role { get; set; } = Team_membershipRole.member;
		
		/// <summary>
		/// The state of the user's membership in the team.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Org_membershipState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Team_membershipRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		member = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		maintainer = 1,
	}
	
	/// <summary>
	/// A team's access to a project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team_project
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="columns_url")]
		public string Columns_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creator")]
		public Simple_user Creator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public int Number { get; set; }
		
		/// <summary>
		/// The organization permission for this project. Only present when owner is an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_permission")]
		public string Organization_permission { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner_url")]
		public string Owner_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Team_projectPermissions Permissions { get; set; }
		
		/// <summary>
		/// Whether the project is private or not. Only present when owner is an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Team_projectPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="read")]
		public bool Read { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="write")]
		public bool Write { get; set; }
	}
	
	/// <summary>
	/// A team's access to a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Team_repository
	{
		
		/// <summary>
		/// Whether to allow Auto-merge to be used on pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		/// <summary>
		/// Whether to allow forking this repo
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		/// <summary>
		/// Whether to allow merge commits for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		/// <summary>
		/// Whether to allow rebase merges for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		/// <summary>
		/// Whether to allow squash merges for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archive_url")]
		public string Archive_url { get; set; }
		
		/// <summary>
		/// Whether the repository is archived.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; } = false;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignees_url")]
		public string Assignees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobs_url")]
		public string Blobs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branches_url")]
		public string Branches_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clone_url")]
		public string Clone_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="collaborators_url")]
		public string Collaborators_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comments_url")]
		public string Comments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commits_url")]
		public string Commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compare_url")]
		public string Compare_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents_url")]
		public string Contents_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contributors_url")]
		public string Contributors_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The default branch of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		/// <summary>
		/// Whether to delete head branches when pull requests are merged
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deployments_url")]
		public string Deployments_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Returns whether or not this repository disabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public bool Disabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloads_url")]
		public string Downloads_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fork")]
		public bool Fork { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks")]
		public int Forks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_count")]
		public int Forks_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forks_url")]
		public string Forks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_commits_url")]
		public string Git_commits_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_refs_url")]
		public string Git_refs_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_tags_url")]
		public string Git_tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Whether downloads are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public bool Has_downloads { get; set; } = true;
		
		/// <summary>
		/// Whether issues are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public bool Has_issues { get; set; } = true;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_pages")]
		public bool Has_pages { get; set; }
		
		/// <summary>
		/// Whether projects are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public bool Has_projects { get; set; } = true;
		
		/// <summary>
		/// Whether the wiki is enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public bool Has_wiki { get; set; } = true;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hooks_url")]
		public string Hooks_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Whether this repository acts as a template that can be used to generate new repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_comment_url")]
		public string Issue_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_events_url")]
		public string Issue_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issues_url")]
		public string Issues_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keys_url")]
		public string Keys_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels_url")]
		public string Labels_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages_url")]
		public string Languages_url { get; set; }
		
		/// <summary>
		/// License Simple
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public Nullable_license_simple License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="master_branch")]
		public string Master_branch { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="merges_url")]
		public string Merges_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="milestones_url")]
		public string Milestones_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mirror_url")]
		public string Mirror_url { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network_count")]
		public System.Nullable<System.Int32> Network_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifications_url")]
		public string Notifications_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues")]
		public int Open_issues { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open_issues_count")]
		public int Open_issues_count { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public Nullable_simple_user Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public Team_repositoryPermissions Permissions { get; set; }
		
		/// <summary>
		/// Whether the repository is private or public.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private")]
		public bool Private { get; set; } = false;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pulls_url")]
		public string Pulls_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pushed_at")]
		public System.Nullable<System.DateTimeOffset> Pushed_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="releases_url")]
		public string Releases_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="role_name")]
		public string Role_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_url")]
		public string Ssh_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_count")]
		public int Stargazers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stargazers_url")]
		public string Stargazers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses_url")]
		public string Statuses_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscribers_count")]
		public System.Nullable<System.Int32> Subscribers_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribers_url")]
		public string Subscribers_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="svn_url")]
		public string Svn_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags_url")]
		public string Tags_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams_url")]
		public string Teams_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="temp_clone_token")]
		public string Temp_clone_token { get; set; }
		
		/// <summary>
		/// A repository on GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template_repository")]
		public Nullable_repository Template_repository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topics")]
		public string[] Topics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trees_url")]
		public string Trees_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The repository visibility: public, private, or internal.
		/// </summary>
		[System.ComponentModel.DefaultValue("public")]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; } = "public";
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers")]
		public int Watchers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="watchers_count")]
		public int Watchers_count { get; set; }
		
		/// <summary>
		/// Whether to require contributors to sign off on web-based commits
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	public class Team_repositoryPermissions
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public bool Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintain")]
		public System.Nullable<System.Boolean> Maintain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull")]
		public bool Pull { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="push")]
		public bool Push { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triage")]
		public System.Nullable<System.Boolean> Triage { get; set; }
	}
	
	/// <summary>
	/// Thread
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Thread
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_read_at")]
		public string Last_read_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Minimal_repository Repository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public ThreadSubject Subject { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription_url")]
		public string Subscription_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unread")]
		public bool Unread { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ThreadSubject
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latest_comment_url")]
		public string Latest_comment_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Thread Subscription
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Thread_subscription
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ignored")]
		public bool Ignored { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repository_url")]
		public string Repository_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscribed")]
		public bool Subscribed { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="thread_url")]
		public string Thread_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Timeline Assigned Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_assigned_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Simple_user Assignee { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Timeline Comment Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_comment_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// Contents of the issue comment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the issue comment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue_url")]
		public string Issue_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reactions")]
		public Reaction_rollup Reactions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// URL for the issue comment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Simple_user User { get; set; }
	}
	
	/// <summary>
	/// Timeline Commit Commented Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_commit_commented_event
	{
		
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public Commit_comment[] Comments { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
	}
	
	/// <summary>
	/// Timeline Committed Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_committed_event
	{
		
		/// <summary>
		/// Identifying information for the git-user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author")]
		public Timeline_committed_eventAuthor Author { get; set; }
		
		/// <summary>
		/// Identifying information for the git-user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public Timeline_committed_eventCommitter Committer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Message describing the purpose of the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parents")]
		public Timeline_committed_eventParents[] Timeline_committed_eventParents { get; set; }
		
		/// <summary>
		/// SHA for the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree")]
		public Timeline_committed_eventTree Tree { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verification")]
		public Timeline_committed_eventVerification Verification { get; set; }
	}
	
	public class Timeline_committed_eventAuthor
	{
		
		/// <summary>
		/// Timestamp of the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// Git email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Name of the git user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Timeline_committed_eventCommitter
	{
		
		/// <summary>
		/// Timestamp of the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// Git email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Name of the git user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Timeline_committed_eventParents
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// SHA for the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Timeline_committed_eventTree
	{
		
		/// <summary>
		/// SHA for the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Timeline_committed_eventVerification
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public string Payload { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verified")]
		public bool Verified { get; set; }
	}
	
	/// <summary>
	/// Timeline Cross Referenced Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_cross_referenced_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Timeline_cross_referenced_eventSource Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
	}
	
	public class Timeline_cross_referenced_eventSource
	{
		
		/// <summary>
		/// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issue")]
		public Issue Issue { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Timeline Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_issue_events
	{
	}
	
	/// <summary>
	/// Timeline Line Commented Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_line_commented_event
	{
		
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public Pull_request_review_comment[] Comments { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
	}
	
	/// <summary>
	/// Timeline Reviewed Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_reviewed_event
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Timeline_reviewed_event_links _links { get; set; }
		
		/// <summary>
		/// How the author is associated with the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="author_association")]
		public Author_association Author_association { get; set; }
		
		/// <summary>
		/// The text of the review.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_html")]
		public string Body_html { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="body_text")]
		public string Body_text { get; set; }
		
		/// <summary>
		/// A commit SHA for the review.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Unique identifier of the review
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request_url")]
		public string Pull_request_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="submitted_at")]
		public System.Nullable<System.DateTimeOffset> Submitted_at { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public Simple_user User { get; set; }
	}
	
	public class Timeline_reviewed_event_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public Timeline_reviewed_event_linksHtml Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_request")]
		public Timeline_reviewed_event_linksPull_request Pull_request { get; set; }
	}
	
	public class Timeline_reviewed_event_linksHtml
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	public class Timeline_reviewed_event_linksPull_request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	/// <summary>
	/// Timeline Unassigned Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Timeline_unassigned_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Simple_user Assignee { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A topic aggregates entities that are related to a subject.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Topic
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="names")]
		public string[] Names { get; set; }
	}
	
	/// <summary>
	/// Topic Search Result Item
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Topic_search_result_item
	{
		
		[System.Runtime.Serialization.DataMember(Name="aliases")]
		public Topic_search_result_itemAliases[] Topic_search_result_itemAliases { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_by")]
		public string Created_by { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="curated")]
		public bool Curated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="display_name")]
		public string Display_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="featured")]
		public bool Featured { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logo_url")]
		public string Logo_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="related")]
		public Topic_search_result_itemRelated[] Topic_search_result_itemRelated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="released")]
		public string Released { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repository_count")]
		public System.Nullable<System.Int32> Repository_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score")]
		public double Score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="short_description")]
		public string Short_description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text_matches")]
		public Search_result_text_matchesElement[] Text_matches { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
	}
	
	public class Topic_search_result_itemAliases
	{
		
		[System.Runtime.Serialization.DataMember(Name="topic_relation")]
		public Topic_search_result_itemAliasesTopic_relation Topic_relation { get; set; }
	}
	
	public class Topic_search_result_itemAliasesTopic_relation
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relation_type")]
		public string Relation_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topic_id")]
		public System.Nullable<System.Int32> Topic_id { get; set; }
	}
	
	public class Topic_search_result_itemRelated
	{
		
		[System.Runtime.Serialization.DataMember(Name="topic_relation")]
		public Topic_search_result_itemRelatedTopic_relation Topic_relation { get; set; }
	}
	
	public class Topic_search_result_itemRelatedTopic_relation
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relation_type")]
		public string Relation_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="topic_id")]
		public System.Nullable<System.Int32> Topic_id { get; set; }
	}
	
	/// <summary>
	/// Unassigned Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Unassigned_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public Simple_user Assignee { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assigner")]
		public Simple_user Assigner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Unlabeled Issue Event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Unlabeled_issue_event
	{
		
		/// <summary>
		/// A GitHub user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_url")]
		public string Commit_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Unlabeled_issue_eventLabel Label { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="performed_via_github_app")]
		public Nullable_integration Performed_via_github_app { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Unlabeled_issue_eventLabel
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User
	{
		
		/// <summary>
		/// Whether the user active in the IdP.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="active")]
		public bool Active { get; set; }
		
		/// <summary>
		/// A human-readable name for the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The emails for the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public UserEmails[] UserEmails { get; set; }
		
		/// <summary>
		/// A unique identifier for the resource as defined by the provisioning client.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="externalId")]
		public string ExternalId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public User_name Name { get; set; }
		
		/// <summary>
		/// The roles assigned to the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public UserRoles[] UserRoles { get; set; }
		
		/// <summary>
		/// The URIs that are used to indicate the namespaces of the SCIM schemas.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemas")]
		public string[] Schemas { get; set; }
		
		/// <summary>
		/// The username for the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="userName")]
		public string UserName { get; set; }
	}
	
	public class UserEmails
	{
		
		/// <summary>
		/// Whether this email address is the primary address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public bool Primary { get; set; }
		
		/// <summary>
		/// The type of email address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The email address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User_name
	{
		
		/// <summary>
		/// The family name of the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="familyName")]
		public string FamilyName { get; set; }
		
		/// <summary>
		/// The full name, including all middle names, titles, and suffixes as appropriate, formatted for display.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formatted")]
		public string Formatted { get; set; }
		
		/// <summary>
		/// The given name of the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="givenName")]
		public string GivenName { get; set; }
		
		/// <summary>
		/// The middle name(s) of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="middleName")]
		public string MiddleName { get; set; }
	}
	
	public class UserRoles
	{
		
		[System.Runtime.Serialization.DataMember(Name="display")]
		public string Display { get; set; }
		
		/// <summary>
		/// Is the role a primary role for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The role value representing a user role in GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public UserRolesValue Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UserRolesValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="27d9891d-2c17-4f45-a262-781a0e55c80a")]
		_27d9891dMinus2c17Minus4f45Minusa262Minus781a0e55c80a = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Restricted User")]
		Restricted_User = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restricted_user = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1ebc4a02-e56c-43a6-92a5-02ee09b90824")]
		_1ebc4a02Minuse56cMinus43a6Minus92a5Minus02ee09b90824 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Enterprise Owner")]
		Enterprise_Owner = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise_owner = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="981df190-8801-4618-a08a-d91f6206c954")]
		_981df190Minus8801Minus4618Minusa08aMinusd91f6206c954 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ba4987ab-a1c3-412a-b58c-360fc407cb10")]
		ba4987abMinusa1c3Minus412aMinusb58cMinus360fc407cb10 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Billing Manager")]
		Billing_Manager = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		billing_manager = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0e338b8c-cc7f-498a-928d-ea3470d7e7e3")]
		_0e338b8cMinuscc7fMinus498aMinus928dMinusea3470d7e7e3 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="e6be2762-e4ad-4108-b72d-1bbe884a0f91")]
		e6be2762Minuse4adMinus4108Minusb72dMinus1bbe884a0f91 = 13,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User_emailsElement
	{
		
		/// <summary>
		/// Whether this email address is the primary address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public bool Primary { get; set; }
		
		/// <summary>
		/// The type of email address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The email address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User_emails_responseElement
	{
		
		/// <summary>
		/// Whether this email address is the primary address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
		
		/// <summary>
		/// The type of email address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The email address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User_name_response
	{
		
		/// <summary>
		/// The family name of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="familyName")]
		public string FamilyName { get; set; }
		
		/// <summary>
		/// The full name, including all middle names, titles, and suffixes as appropriate, formatted for display.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formatted")]
		public string Formatted { get; set; }
		
		/// <summary>
		/// The given name of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="givenName")]
		public string GivenName { get; set; }
		
		/// <summary>
		/// The middle name(s) of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="middleName")]
		public string MiddleName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User_response
	{
		
		/// <summary>
		/// Whether the user active in the IdP.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="active")]
		public bool Active { get; set; }
		
		/// <summary>
		/// A human-readable name for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The emails for the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public User_emails_responseElement[] Emails { get; set; }
		
		/// <summary>
		/// A unique identifier for the resource as defined by the provisioning client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalId")]
		public string ExternalId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public User_name_response Name { get; set; }
		
		/// <summary>
		/// The roles assigned to the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public User_responseRoles[] User_responseRoles { get; set; }
		
		/// <summary>
		/// The URIs that are used to indicate the namespaces of the SCIM schemas.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemas")]
		public string[] Schemas { get; set; }
		
		/// <summary>
		/// The username for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userName")]
		public string UserName { get; set; }
	}
	
	public class User_responseRoles
	{
		
		[System.Runtime.Serialization.DataMember(Name="display")]
		public string Display { get; set; }
		
		/// <summary>
		/// Is the role a primary role for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The role value representing a user role in GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public User_responseRolesValue Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum User_responseRolesValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="27d9891d-2c17-4f45-a262-781a0e55c80a")]
		_27d9891dMinus2c17Minus4f45Minusa262Minus781a0e55c80a = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Restricted User")]
		Restricted_User = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restricted_user = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1ebc4a02-e56c-43a6-92a5-02ee09b90824")]
		_1ebc4a02Minuse56cMinus43a6Minus92a5Minus02ee09b90824 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Enterprise Owner")]
		Enterprise_Owner = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise_owner = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="981df190-8801-4618-a08a-d91f6206c954")]
		_981df190Minus8801Minus4618Minusa08aMinusd91f6206c954 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ba4987ab-a1c3-412a-b58c-360fc407cb10")]
		ba4987abMinusa1c3Minus412aMinusb58cMinus360fc407cb10 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Billing Manager")]
		Billing_Manager = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		billing_manager = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0e338b8c-cc7f-498a-928d-ea3470d7e7e3")]
		_0e338b8cMinuscc7fMinus498aMinus928dMinusea3470d7e7e3 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="e6be2762-e4ad-4108-b72d-1bbe884a0f91")]
		e6be2762Minuse4adMinus4108Minusb72dMinus1bbe884a0f91 = 13,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User_roleElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="display")]
		public string Display { get; set; }
		
		/// <summary>
		/// Is the role a primary role for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The role value representing a user role in GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public User_roleElementValue Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum User_roleElementValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="27d9891d-2c17-4f45-a262-781a0e55c80a")]
		_27d9891dMinus2c17Minus4f45Minusa262Minus781a0e55c80a = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Restricted User")]
		Restricted_User = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restricted_user = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1ebc4a02-e56c-43a6-92a5-02ee09b90824")]
		_1ebc4a02Minuse56cMinus43a6Minus92a5Minus02ee09b90824 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Enterprise Owner")]
		Enterprise_Owner = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise_owner = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="981df190-8801-4618-a08a-d91f6206c954")]
		_981df190Minus8801Minus4618Minusa08aMinusd91f6206c954 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ba4987ab-a1c3-412a-b58c-360fc407cb10")]
		ba4987abMinusa1c3Minus412aMinusb58cMinus360fc407cb10 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Billing Manager")]
		Billing_Manager = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		billing_manager = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0e338b8c-cc7f-498a-928d-ea3470d7e7e3")]
		_0e338b8cMinuscc7fMinus498aMinus928dMinusea3470d7e7e3 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="e6be2762-e4ad-4108-b72d-1bbe884a0f91")]
		e6be2762Minuse4adMinus4108Minusb72dMinus1bbe884a0f91 = 13,
	}
	
	/// <summary>
	/// User Search Result Item
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User_search_result_item
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bio")]
		public string Bio { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blog")]
		public string Blog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="company")]
		public string Company { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events_url")]
		public string Events_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="followers")]
		public System.Nullable<System.Int32> Followers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followers_url")]
		public string Followers_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="following")]
		public System.Nullable<System.Int32> Following { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following_url")]
		public string Following_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gists_url")]
		public string Gists_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hireable")]
		public System.Nullable<System.Boolean> Hireable { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations_url")]
		public string Organizations_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="public_gists")]
		public System.Nullable<System.Int32> Public_gists { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="public_repos")]
		public System.Nullable<System.Int32> Public_repos { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="received_events_url")]
		public string Received_events_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repos_url")]
		public string Repos_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score")]
		public double Score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="site_admin")]
		public bool Site_admin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="starred_url")]
		public string Starred_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions_url")]
		public string Subscriptions_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suspended_at")]
		public System.Nullable<System.DateTimeOffset> Suspended_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text_matches")]
		public Search_result_text_matchesElement[] Text_matches { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Validation Error
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Validation_error
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="documentation_url")]
		public string Documentation_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public Validation_errorErrors[] Validation_errorErrors { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Validation_errorErrors
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Int32> Index { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Validation Error Simple
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Validation_error_simple
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="documentation_url")]
		public string Documentation_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public string[] Errors { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Configuration object of the webhook
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Webhook_config
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Webhook_config_insecure_ssl
	{
	}
	
	/// <summary>
	/// A GitHub Actions workflow
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Workflow
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="badge_url")]
		public string Badge_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deleted_at")]
		public System.Nullable<System.DateTimeOffset> Deleted_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public WorkflowState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum WorkflowState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled_fork = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled_inactivity = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled_manually = 4,
	}
	
	/// <summary>
	/// An invocation of a workflow
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Workflow_run
	{
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actor")]
		public Simple_user Actor { get; set; }
		
		/// <summary>
		/// The URL to the artifacts for the workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="artifacts_url")]
		public string Artifacts_url { get; set; }
		
		/// <summary>
		/// The URL to cancel the workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cancel_url")]
		public string Cancel_url { get; set; }
		
		/// <summary>
		/// The ID of the associated check suite.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check_suite_id")]
		public System.Nullable<System.Int32> Check_suite_id { get; set; }
		
		/// <summary>
		/// The node ID of the associated check suite.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check_suite_node_id")]
		public string Check_suite_node_id { get; set; }
		
		/// <summary>
		/// The URL to the associated check suite.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="check_suite_url")]
		public string Check_suite_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conclusion")]
		public string Conclusion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_branch")]
		public string Head_branch { get; set; }
		
		/// <summary>
		/// A commit.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_commit")]
		public Nullable_simple_commit Head_commit { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_repository")]
		public Minimal_repository Head_repository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="head_repository_id")]
		public System.Nullable<System.Int32> Head_repository_id { get; set; }
		
		/// <summary>
		/// The SHA of the head commit that points to the version of the workflow being run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_sha")]
		public string Head_sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// The ID of the workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The URL to the jobs for the workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobs_url")]
		public string Jobs_url { get; set; }
		
		/// <summary>
		/// The URL to download the logs for the workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logs_url")]
		public string Logs_url { get; set; }
		
		/// <summary>
		/// The name of the workflow run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_id")]
		public string Node_id { get; set; }
		
		/// <summary>
		/// The full path of the workflow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The URL to the previous attempted run of this workflow, if one exists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previous_attempt_url")]
		public string Previous_attempt_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pull_requests")]
		public Pull_request_minimal[] Pull_requests { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="referenced_workflows")]
		public Referenced_workflow[] Referenced_workflows { get; set; }
		
		/// <summary>
		/// Minimal Repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public Minimal_repository Repository { get; set; }
		
		/// <summary>
		/// The URL to rerun the workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rerun_url")]
		public string Rerun_url { get; set; }
		
		/// <summary>
		/// Attempt number of the run, 1 for first attempt and higher if the workflow was re-run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="run_attempt")]
		public System.Nullable<System.Int32> Run_attempt { get; set; }
		
		/// <summary>
		/// The auto incrementing run number for the workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="run_number")]
		public int Run_number { get; set; }
		
		/// <summary>
		/// The start time of the latest run. Resets on re-run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="run_started_at")]
		public System.Nullable<System.DateTimeOffset> Run_started_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A GitHub user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="triggering_actor")]
		public Simple_user Triggering_actor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.DateTimeOffset Updated_at { get; set; }
		
		/// <summary>
		/// The URL to the workflow run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The ID of the parent workflow.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workflow_id")]
		public int Workflow_id { get; set; }
		
		/// <summary>
		/// The URL to the workflow.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workflow_url")]
		public string Workflow_url { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// GitHub API Root
		/// Get Hypermedia links to resources accessible in GitHub's REST API
		/// MetaSlashroot 
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Root> MetaSlashrootAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Root>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List global webhooks
		/// Enterprise_adminSlashlist_global_webhooks admin/hooks
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Global_hook[]> Enterprise_adminSlashlist_global_webhooksAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/hooks?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Global_hook[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a global webhook
		/// Enterprise_adminSlashcreate_global_webhook admin/hooks
		/// </summary>
		public async Task Enterprise_adminSlashcreate_global_webhookAsync(Enterprise_adminSlashcreate_global_webhookPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/hooks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a global webhook
		/// Enterprise_adminSlashdelete_global_webhook admin/hooks/{hook_id}
		/// </summary>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task Enterprise_adminSlashdelete_global_webhookAsync(int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a global webhook
		/// Enterprise_adminSlashget_global_webhook admin/hooks/{hook_id}
		/// </summary>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Global_hook> Enterprise_adminSlashget_global_webhookAsync(int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Global_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a global webhook
		/// Parameters that are not provided will be overwritten with the default value or removed if no default exists.
		/// Enterprise_adminSlashupdate_global_webhook admin/hooks/{hook_id}
		/// </summary>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Global_hook_2> Enterprise_adminSlashupdate_global_webhookAsync(int hook_id, Enterprise_adminSlashupdate_global_webhookPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Global_hook_2>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Ping a global webhook
		/// This will trigger a [ping event](https://docs.github.com/enterprise-server@3.6/webhooks/#ping-event) to be sent to the webhook.
		/// Enterprise_adminSlashping_global_webhook admin/hooks/{hook_id}/pings
		/// </summary>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task Enterprise_adminSlashping_global_webhookAsync(int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/hooks/"+hook_id+"/pings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List public keys
		/// Enterprise_adminSlashlist_public_keys admin/keys
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="since">Only show public keys accessed after the given time.</param>
		/// <returns>Response</returns>
		public async Task<Public_key_full[]> Enterprise_adminSlashlist_public_keysAsync(int per_page, int page, Enterprise_adminSlashlist_public_keysDirection direction, Enterprise_adminSlashlist_public_keysSort sort, string since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/keys?per_page="+per_page+"&page="+page+"&direction=" + direction+"&sort=" + sort+"&since=" + (since==null? "" : System.Uri.EscapeDataString(since));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Public_key_full[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a public key
		/// Enterprise_adminSlashdelete_public_key admin/keys/{key_ids}
		/// </summary>
		/// <param name="key_ids">The unique identifier of the key.</param>
		public async Task Enterprise_adminSlashdelete_public_keyAsync(string key_ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/keys/"+ (key_ids==null? "" : System.Uri.EscapeDataString(key_ids));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update LDAP mapping for a team
		/// Updates the [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team. [LDAP synchronization](https://docs.github.com/enterprise-server@3.6/admin/identity-and-access-management/using-ldap-for-enterprise-iam/using-ldap#enabling-ldap-sync) must be enabled to map LDAP entries to a team. Use the [Create a team](https://docs.github.com/enterprise-server@3.6/rest/reference/teams/#create-a-team) endpoint to create a team with LDAP mapping.
		/// Enterprise_adminSlashupdate_ldap_mapping_for_team admin/ldap/teams/{team_id}/mapping
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <returns>Response</returns>
		public async Task<Ldap_mapping_team> Enterprise_adminSlashupdate_ldap_mapping_for_teamAsync(int team_id, Enterprise_adminSlashupdate_ldap_mapping_for_teamPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/ldap/teams/"+team_id+"/mapping";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ldap_mapping_team>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sync LDAP mapping for a team
		/// Note that this API call does not automatically initiate an LDAP sync. Rather, if a `201` is returned, the sync job is queued successfully, and is performed when the instance is ready.
		/// Enterprise_adminSlashsync_ldap_mapping_for_team admin/ldap/teams/{team_id}/sync
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		public async Task Enterprise_adminSlashsync_ldap_mapping_for_teamAsync(int team_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/ldap/teams/"+team_id+"/sync";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update LDAP mapping for a user
		/// Enterprise_adminSlashupdate_ldap_mapping_for_user admin/ldap/users/{username}/mapping
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Ldap_mapping_user> Enterprise_adminSlashupdate_ldap_mapping_for_userAsync(string username, Enterprise_adminSlashupdate_ldap_mapping_for_userPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/ldap/users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/mapping";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ldap_mapping_user>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sync LDAP mapping for a user
		/// Note that this API call does not automatically initiate an LDAP sync. Rather, if a `201` is returned, the sync job is queued successfully, and is performed when the instance is ready.
		/// Enterprise_adminSlashsync_ldap_mapping_for_user admin/ldap/users/{username}/sync
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task Enterprise_adminSlashsync_ldap_mapping_for_userAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/ldap/users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/sync";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an organization
		/// Enterprise_adminSlashcreate_org admin/organizations
		/// </summary>
		public async Task Enterprise_adminSlashcreate_orgAsync(Enterprise_adminSlashcreate_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/organizations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update an organization name
		/// Enterprise_adminSlashupdate_org_name admin/organizations/{org}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task Enterprise_adminSlashupdate_org_nameAsync(string org, Enterprise_adminSlashupdate_org_namePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/organizations/"+ (org==null? "" : System.Uri.EscapeDataString(org));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List pre-receive environments
		/// Enterprise_adminSlashlist_pre_receive_environments admin/pre-receive-environments
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <returns>Response</returns>
		public async Task<Pre_receive_environment[]> Enterprise_adminSlashlist_pre_receive_environmentsAsync(int per_page, int page, Enterprise_adminSlashlist_public_keysDirection direction, Enterprise_adminSlashlist_pre_receive_environmentsSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-environments?per_page="+per_page+"&page="+page+"&direction=" + direction+"&sort=" + sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pre_receive_environment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a pre-receive environment
		/// Enterprise_adminSlashcreate_pre_receive_environment admin/pre-receive-environments
		/// </summary>
		public async Task Enterprise_adminSlashcreate_pre_receive_environmentAsync(Enterprise_adminSlashcreate_pre_receive_environmentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-environments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a pre-receive environment
		/// If you attempt to delete an environment that cannot be deleted, you will receive a `422 Unprocessable Entity` response.
		/// 
		/// The possible error messages are:
		/// 
		/// *   _Cannot modify or delete the default environment_
		/// *   _Cannot delete environment that has hooks_
		/// *   _Cannot delete environment when download is in progress_
		/// Enterprise_adminSlashdelete_pre_receive_environment admin/pre-receive-environments/{pre_receive_environment_id}
		/// </summary>
		/// <param name="pre_receive_environment_id">The unique identifier of the pre-receive environment.</param>
		public async Task Enterprise_adminSlashdelete_pre_receive_environmentAsync(int pre_receive_environment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-environments/"+pre_receive_environment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a pre-receive environment
		/// Enterprise_adminSlashget_pre_receive_environment admin/pre-receive-environments/{pre_receive_environment_id}
		/// </summary>
		/// <param name="pre_receive_environment_id">The unique identifier of the pre-receive environment.</param>
		/// <returns>Response</returns>
		public async Task<Pre_receive_environment> Enterprise_adminSlashget_pre_receive_environmentAsync(int pre_receive_environment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-environments/"+pre_receive_environment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pre_receive_environment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a pre-receive environment
		/// You cannot modify the default environment. If you attempt to modify the default environment, you will receive a `422 Unprocessable Entity` response.
		/// Enterprise_adminSlashupdate_pre_receive_environment admin/pre-receive-environments/{pre_receive_environment_id}
		/// </summary>
		/// <param name="pre_receive_environment_id">The unique identifier of the pre-receive environment.</param>
		/// <returns>Response</returns>
		public async Task<Pre_receive_environment> Enterprise_adminSlashupdate_pre_receive_environmentAsync(int pre_receive_environment_id, Enterprise_adminSlashupdate_pre_receive_environmentPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-environments/"+pre_receive_environment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pre_receive_environment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Start a pre-receive environment download
		/// Triggers a new download of the environment tarball from the environment's `image_url`. When the download is finished, the newly downloaded tarball will overwrite the existing environment.
		/// 
		/// If a download cannot be triggered, you will receive a `422 Unprocessable Entity` response.
		/// 
		/// The possible error messages are:
		/// 
		/// * _Cannot modify or delete the default environment_
		/// * _Can not start a new download when a download is in progress_
		/// Enterprise_adminSlashstart_pre_receive_environment_download admin/pre-receive-environments/{pre_receive_environment_id}/downloads
		/// </summary>
		/// <param name="pre_receive_environment_id">The unique identifier of the pre-receive environment.</param>
		public async Task Enterprise_adminSlashstart_pre_receive_environment_downloadAsync(int pre_receive_environment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-environments/"+pre_receive_environment_id+"/downloads";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the download status for a pre-receive environment
		/// In addition to seeing the download status at the "[Get a pre-receive environment](#get-a-pre-receive-environment)" endpoint, there is also this separate endpoint for just the download status.
		/// Enterprise_adminSlashget_download_status_for_pre_receive_environment admin/pre-receive-environments/{pre_receive_environment_id}/downloads/latest
		/// </summary>
		/// <param name="pre_receive_environment_id">The unique identifier of the pre-receive environment.</param>
		/// <returns>Response</returns>
		public async Task<Pre_receive_environment_download_status> Enterprise_adminSlashget_download_status_for_pre_receive_environmentAsync(int pre_receive_environment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-environments/"+pre_receive_environment_id+"/downloads/latest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pre_receive_environment_download_status>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List pre-receive hooks
		/// Enterprise_adminSlashlist_pre_receive_hooks admin/pre-receive-hooks
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="sort">The property to sort the results by.</param>
		/// <returns>Response</returns>
		public async Task<Pre_receive_hook[]> Enterprise_adminSlashlist_pre_receive_hooksAsync(int per_page, int page, Enterprise_adminSlashlist_public_keysDirection direction, Enterprise_adminSlashlist_pre_receive_environmentsSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-hooks?per_page="+per_page+"&page="+page+"&direction=" + direction+"&sort=" + sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pre_receive_hook[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a pre-receive hook
		/// Enterprise_adminSlashcreate_pre_receive_hook admin/pre-receive-hooks
		/// </summary>
		public async Task Enterprise_adminSlashcreate_pre_receive_hookAsync(Enterprise_adminSlashcreate_pre_receive_hookPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-hooks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a pre-receive hook
		/// Enterprise_adminSlashdelete_pre_receive_hook admin/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		public async Task Enterprise_adminSlashdelete_pre_receive_hookAsync(int pre_receive_hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a pre-receive hook
		/// Enterprise_adminSlashget_pre_receive_hook admin/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		/// <returns>Response</returns>
		public async Task<Pre_receive_hook> Enterprise_adminSlashget_pre_receive_hookAsync(int pre_receive_hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pre_receive_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a pre-receive hook
		/// Enterprise_adminSlashupdate_pre_receive_hook admin/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		/// <returns>Response</returns>
		public async Task<Pre_receive_hook> Enterprise_adminSlashupdate_pre_receive_hookAsync(int pre_receive_hook_id, Enterprise_adminSlashupdate_pre_receive_hookPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pre_receive_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List personal access tokens
		/// Lists personal access tokens for all users, including admin users.
		/// Enterprise_adminSlashlist_personal_access_tokens admin/tokens
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Authorization[]> Enterprise_adminSlashlist_personal_access_tokensAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/tokens?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a personal access token
		/// Deletes a personal access token. Returns a `403 - Forbidden` status when a personal access token is in use. For example, if you access this endpoint with the same personal access token that you are trying to delete, you will receive this error.
		/// Enterprise_adminSlashdelete_personal_access_token admin/tokens/{token_id}
		/// </summary>
		/// <param name="token_id">The unique identifier of the token.</param>
		public async Task Enterprise_adminSlashdelete_personal_access_tokenAsync(int token_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/tokens/"+token_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a user
		/// If an external authentication mechanism is used, the login name should match the login name in the external system. If you are using LDAP authentication, you should also [update the LDAP mapping](https://docs.github.com/enterprise-server@3.6/rest/reference/enterprise-admin#update-ldap-mapping-for-a-user) for the user.
		/// 
		/// The login name will be normalized to only contain alphanumeric characters or single hyphens. For example, if you send `"octo_cat"` as the login, a user named `"octo-cat"` will be created.
		/// 
		/// If the login name or email address is already associated with an account, the server will return a `422` response.
		/// Enterprise_adminSlashcreate_user admin/users
		/// </summary>
		public async Task Enterprise_adminSlashcreate_userAsync(Enterprise_adminSlashcreate_userPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a user
		/// Deleting a user will delete all their repositories, gists, applications, and personal settings. [Suspending a user](https://docs.github.com/enterprise-server@3.6/rest/reference/enterprise-admin#suspend-a-user) is often a better option.
		/// 
		/// You can delete any user account except your own.
		/// Enterprise_adminSlashdelete_user admin/users/{username}
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task Enterprise_adminSlashdelete_userAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/users/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the username for a user
		/// Enterprise_adminSlashupdate_username_for_user admin/users/{username}
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task Enterprise_adminSlashupdate_username_for_userAsync(string username, Enterprise_adminSlashupdate_username_for_userPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/users/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an impersonation OAuth token
		/// Enterprise_adminSlashdelete_impersonation_o_auth_token admin/users/{username}/authorizations
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task Enterprise_adminSlashdelete_impersonation_o_auth_tokenAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/authorizations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an impersonation OAuth token
		/// Enterprise_adminSlashcreate_impersonation_o_auth_token admin/users/{username}/authorizations
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response when getting an existing impersonation OAuth token</returns>
		public async Task<Authorization> Enterprise_adminSlashcreate_impersonation_o_auth_tokenAsync(string username, Enterprise_adminSlashcreate_impersonation_o_auth_tokenPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/authorizations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the authenticated app
		/// Returns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this GitHub App, see the `installations_count` in the response. For more details about your app's installations, see the "[List installations for the authenticated app](https://docs.github.com/enterprise-server@3.6/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashget_authenticated app
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Integration> AppsSlashget_authenticatedAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Integration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a GitHub App from a manifest
		/// Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest flow](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/creating-github-apps-from-a-manifest/). When you create a GitHub App with the manifest flow, you receive a temporary `code` used to retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
		/// AppsSlashcreate_from_manifest app-manifests/{code}/conversions
		/// </summary>
		public async Task AppsSlashcreate_from_manifestAsync(string code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app-manifests/"+ (code==null? "" : System.Uri.EscapeDataString(code))+"/conversions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a webhook configuration for an app
		/// Returns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashget_webhook_config_for_app app/hook/config
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Webhook_config> AppsSlashget_webhook_config_for_appAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/hook/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Webhook_config>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a webhook configuration for an app
		/// Updates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashupdate_webhook_config_for_app app/hook/config
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Webhook_config> AppsSlashupdate_webhook_config_for_appAsync(AppsSlashupdate_webhook_config_for_appPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/hook/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Webhook_config>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List deliveries for an app webhook
		/// Returns a list of webhook deliveries for the webhook configured for a GitHub App.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashlist_webhook_deliveries app/hook/deliveries
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="cursor">Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.</param>
		/// <returns>Response</returns>
		public async Task<Hook_delivery_item[]> AppsSlashlist_webhook_deliveriesAsync(int per_page, string cursor, bool redelivery, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/hook/deliveries?per_page="+per_page+"&cursor=" + (cursor==null? "" : System.Uri.EscapeDataString(cursor))+"&redelivery="+redelivery;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook_delivery_item[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a delivery for an app webhook
		/// Returns a delivery for the webhook configured for a GitHub App.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashget_webhook_delivery app/hook/deliveries/{delivery_id}
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Hook_delivery> AppsSlashget_webhook_deliveryAsync(int delivery_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/hook/deliveries/"+delivery_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook_delivery>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Redeliver a delivery for an app webhook
		/// Redeliver a delivery for the webhook configured for a GitHub App.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashredeliver_webhook_delivery app/hook/deliveries/{delivery_id}/attempts
		/// </summary>
		public async Task AppsSlashredeliver_webhook_deliveryAsync(int delivery_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/hook/deliveries/"+delivery_id+"/attempts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List installations for the authenticated app
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// 
		/// The permissions the installation has are included under the `permissions` key.
		/// AppsSlashlist_installations app/installations
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <returns>The permissions the installation has are included under the `permissions` key.</returns>
		public async Task<Installation[]> AppsSlashlist_installationsAsync(int per_page, int page, System.DateTimeOffset since, string outdated, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/installations?per_page="+per_page+"&page="+page+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&outdated=" + (outdated==null? "" : System.Uri.EscapeDataString(outdated));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Installation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an installation for the authenticated app
		/// Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily suspend an app's access to your account's resources, then we recommend the "[Suspend an app installation](https://docs.github.com/enterprise-server@3.6/rest/reference/apps/#suspend-an-app-installation)" endpoint.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashdelete_installation app/installations/{installation_id}
		/// </summary>
		/// <param name="installation_id">The unique identifier of the installation.</param>
		public async Task AppsSlashdelete_installationAsync(int installation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/installations/"+installation_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an installation for the authenticated app
		/// Enables an authenticated GitHub App to find an installation's information using the installation id.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashget_installation app/installations/{installation_id}
		/// </summary>
		/// <param name="installation_id">The unique identifier of the installation.</param>
		/// <returns>Response</returns>
		public async Task<Installation> AppsSlashget_installationAsync(int installation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/installations/"+installation_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Installation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an installation access token for an app
		/// Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashcreate_installation_access_token app/installations/{installation_id}/access_tokens
		/// </summary>
		/// <param name="installation_id">The unique identifier of the installation.</param>
		public async Task AppsSlashcreate_installation_access_tokenAsync(int installation_id, AppsSlashcreate_installation_access_tokenPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/installations/"+installation_id+"/access_tokens";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Unsuspend an app installation
		/// Removes a GitHub App installation suspension.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashunsuspend_installation app/installations/{installation_id}/suspended
		/// </summary>
		/// <param name="installation_id">The unique identifier of the installation.</param>
		public async Task AppsSlashunsuspend_installationAsync(int installation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/installations/"+installation_id+"/suspended";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Suspend an app installation
		/// Suspends a GitHub App on a user, organization, or business account, which blocks the app from accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub Enterprise Server API or webhook events is blocked for that account.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashsuspend_installation app/installations/{installation_id}/suspended
		/// </summary>
		/// <param name="installation_id">The unique identifier of the installation.</param>
		public async Task AppsSlashsuspend_installationAsync(int installation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app/installations/"+installation_id+"/suspended";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List your grants
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// 
		/// You can use this API to list the set of OAuth applications that have been granted access to your account. Unlike the [list your authorizations](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations#list-your-authorizations) API, this API does not manage individual tokens. This API will return one entry for each OAuth application that has been granted access to your account, regardless of the number of tokens an application has generated for your user. The list of OAuth applications returned matches what is shown on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized). The `scopes` returned are the union of scopes authorized for the application. For example, if an application has one token with `repo` scope and another token with `user` scope, the grant will return `["repo", "user"]`.
		/// Oauth_authorizationsSlashlist_grants applications/grants
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="client_id">The client ID of your GitHub app.</param>
		/// <returns>Response</returns>
		public async Task<Application_grant[]> Oauth_authorizationsSlashlist_grantsAsync(int per_page, int page, string client_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applications/grants?per_page="+per_page+"&page="+page+"&client_id=" + (client_id==null? "" : System.Uri.EscapeDataString(client_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Application_grant[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a grant
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations/) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// 
		/// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for your user. Once deleted, the application has no access to your account and is no longer listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
		/// Oauth_authorizationsSlashdelete_grant applications/grants/{grant_id}
		/// </summary>
		/// <param name="grant_id">The unique identifier of the grant.</param>
		public async Task Oauth_authorizationsSlashdelete_grantAsync(int grant_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applications/grants/"+grant_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a single grant
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// Oauth_authorizationsSlashget_grant applications/grants/{grant_id}
		/// </summary>
		/// <param name="grant_id">The unique identifier of the grant.</param>
		/// <returns>Response</returns>
		public async Task<Application_grant> Oauth_authorizationsSlashget_grantAsync(int grant_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applications/grants/"+grant_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Application_grant>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an app authorization
		/// OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's owner will be deleted.
		/// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
		/// AppsSlashdelete_authorization applications/{client_id}/grant
		/// </summary>
		/// <param name="client_id">The client ID of the GitHub app.</param>
		public async Task AppsSlashdelete_authorizationAsync(string client_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applications/"+ (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"/grant";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an app token
		/// OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
		/// AppsSlashdelete_token applications/{client_id}/token
		/// </summary>
		/// <param name="client_id">The client ID of the GitHub app.</param>
		public async Task AppsSlashdelete_tokenAsync(string client_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applications/"+ (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"/token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset a token
		/// OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
		/// AppsSlashreset_token applications/{client_id}/token
		/// </summary>
		/// <param name="client_id">The client ID of the GitHub app.</param>
		/// <returns>Response</returns>
		public async Task<Authorization> AppsSlashreset_tokenAsync(string client_id, AppsSlashreset_tokenPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applications/"+ (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"/token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Check a token
		/// OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`.
		/// AppsSlashcheck_token applications/{client_id}/token
		/// </summary>
		/// <param name="client_id">The client ID of the GitHub app.</param>
		/// <returns>Response</returns>
		public async Task<Authorization> AppsSlashcheck_tokenAsync(string client_id, AppsSlashcheck_tokenPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applications/"+ (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"/token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a scoped access token
		/// Use a non-scoped user-to-server access token to create a repository scoped and/or permission scoped user-to-server access token. You can specify which repositories the token can access and which permissions are granted to the token. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the `client_id` and `client_secret` of the GitHub App as the username and password. Invalid tokens will return `404 NOT FOUND`.
		/// AppsSlashscope_token applications/{client_id}/token/scoped
		/// </summary>
		/// <param name="client_id">The client ID of the GitHub app.</param>
		/// <returns>Response</returns>
		public async Task<Authorization> AppsSlashscope_tokenAsync(string client_id, AppsSlashscope_tokenPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "applications/"+ (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"/token/scoped";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an app
		/// **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
		/// 
		/// If the GitHub App you specify is public, you can access this endpoint without authenticating. If the GitHub App you specify is private, you must authenticate with a [personal access token](https://docs.github.com/enterprise-server@3.6/articles/creating-a-personal-access-token-for-the-command-line/) or an [installation access token](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
		/// AppsSlashget_by_slug apps/{app_slug}
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Integration> AppsSlashget_by_slugAsync(string app_slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_slug==null? "" : System.Uri.EscapeDataString(app_slug));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Integration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List your authorizations
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// Oauth_authorizationsSlashlist_authorizations authorizations
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="client_id">The client ID of your GitHub app.</param>
		/// <returns>Response</returns>
		public async Task<Authorization[]> Oauth_authorizationsSlashlist_authorizationsAsync(int per_page, int page, string client_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "authorizations?per_page="+per_page+"&page="+page+"&client_id=" + (client_id==null? "" : System.Uri.EscapeDataString(client_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new authorization
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// 
		/// **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
		/// 
		/// Creates OAuth tokens using [Basic Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
		/// 
		/// To create tokens for a particular OAuth application using this endpoint, you must authenticate as the user you want to create an authorization for and provide the app's client ID and secret, found on your OAuth application's settings page. If your OAuth application intends to create multiple tokens for one user, use `fingerprint` to differentiate between them.
		/// 
		/// You can also create tokens on GitHub Enterprise Server from the [personal access tokens settings](https://github.com/settings/tokens) page. Read more about these tokens in [the GitHub Help documentation](https://docs.github.com/enterprise-server@3.6/articles/creating-an-access-token-for-command-line-use).
		/// 
		/// Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about allowing tokens in [the GitHub Help documentation](https://docs.github.com/enterprise-server@3.6/articles/about-identity-and-access-management-with-saml-single-sign-on).
		/// Oauth_authorizationsSlashcreate_authorization authorizations
		/// </summary>
		public async Task Oauth_authorizationsSlashcreate_authorizationAsync(Oauth_authorizationsSlashcreate_authorizationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "authorizations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get-or-create an authorization for a specific app
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// 
		/// **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
		/// 
		/// Creates a new authorization for the specified OAuth application, only if an authorization for that application doesn't already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
		/// 
		/// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
		/// 
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// Oauth_authorizationsSlashget_or_create_authorization_for_app authorizations/clients/{client_id}
		/// </summary>
		/// <param name="client_id">The client ID of the OAuth app.</param>
		/// <returns>if returning an existing token</returns>
		public async Task<Authorization> Oauth_authorizationsSlashget_or_create_authorization_for_appAsync(string client_id, Oauth_authorizationsSlashget_or_create_authorization_for_appPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "authorizations/clients/"+ (client_id==null? "" : System.Uri.EscapeDataString(client_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get-or-create an authorization for a specific app and fingerprint
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// 
		/// **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
		/// 
		/// This method will create a new authorization for the specified OAuth application, only if an authorization for that application and fingerprint do not already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint` is a unique string to distinguish an authorization from others created for the same client ID and user. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
		/// 
		/// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
		/// Oauth_authorizationsSlashget_or_create_authorization_for_app_and_fingerprint authorizations/clients/{client_id}/{fingerprint}
		/// </summary>
		/// <param name="client_id">The client ID of the OAuth app.</param>
		/// <returns>if returning an existing token</returns>
		public async Task<Authorization> Oauth_authorizationsSlashget_or_create_authorization_for_app_and_fingerprintAsync(string client_id, string fingerprint, Oauth_authorizationsSlashget_or_create_authorization_for_app_and_fingerprintPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "authorizations/clients/"+ (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"/"+ (fingerprint==null? "" : System.Uri.EscapeDataString(fingerprint));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an authorization
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// Oauth_authorizationsSlashdelete_authorization authorizations/{authorization_id}
		/// </summary>
		/// <param name="authorization_id">The unique identifier of the authorization.</param>
		public async Task Oauth_authorizationsSlashdelete_authorizationAsync(int authorization_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "authorizations/"+authorization_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a single authorization
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// Oauth_authorizationsSlashget_authorization authorizations/{authorization_id}
		/// </summary>
		/// <param name="authorization_id">The unique identifier of the authorization.</param>
		/// <returns>Response</returns>
		public async Task<Authorization> Oauth_authorizationsSlashget_authorizationAsync(int authorization_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "authorizations/"+authorization_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing authorization
		/// **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.6/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.6/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
		/// 
		/// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
		/// 
		/// You can only send one of these scope keys at a time.
		/// Oauth_authorizationsSlashupdate_authorization authorizations/{authorization_id}
		/// </summary>
		/// <param name="authorization_id">The unique identifier of the authorization.</param>
		/// <returns>Response</returns>
		public async Task<Authorization> Oauth_authorizationsSlashupdate_authorizationAsync(int authorization_id, Oauth_authorizationsSlashupdate_authorizationPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "authorizations/"+authorization_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Authorization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all codes of conduct
		/// Codes_of_conductSlashget_all_codes_of_conduct codes_of_conduct
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Code_of_conduct[]> Codes_of_conductSlashget_all_codes_of_conductAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "codes_of_conduct";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_of_conduct[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a code of conduct
		/// Codes_of_conductSlashget_conduct_code codes_of_conduct/{key}
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Code_of_conduct> Codes_of_conductSlashget_conduct_codeAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "codes_of_conduct/"+ (key==null? "" : System.Uri.EscapeDataString(key));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_of_conduct>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get emojis
		/// Lists all the emojis available to use on GitHub Enterprise Server.
		/// EmojisSlashget emojis
		/// </summary>
		/// <returns>Response</returns>
		public async Task<System.Collections.Generic.Dictionary<string, string>> EmojisSlashgetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "emojis";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<System.Collections.Generic.Dictionary<string, string>>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove the global announcement banner
		/// Removes the global announcement banner in your enterprise.
		/// Enterprise_adminSlashremove_announcement enterprise/announcement
		/// </summary>
		public async Task Enterprise_adminSlashremove_announcementAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/announcement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the global announcement banner
		/// Gets the current message and expiration date of the global announcement banner in your enterprise.
		/// Enterprise_adminSlashget_announcement enterprise/announcement
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Announcement> Enterprise_adminSlashget_announcementAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/announcement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Announcement>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the global announcement banner
		/// Sets the message and expiration time for the global announcement banner in your enterprise.
		/// Enterprise_adminSlashset_announcement enterprise/announcement
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Announcement> Enterprise_adminSlashset_announcementAsync(Announcement requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/announcement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Announcement>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get license information
		/// Enterprise_adminSlashget_license_information enterprise/settings/license
		/// </summary>
		/// <returns>Response</returns>
		public async Task<License_info> Enterprise_adminSlashget_license_informationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/settings/license";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<License_info>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all statistics
		/// Enterprise_adminSlashget_all_stats enterprise/stats/all
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_overview> Enterprise_adminSlashget_all_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get comment statistics
		/// Enterprise_adminSlashget_comment_stats enterprise/stats/comments
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_comment_overview> Enterprise_adminSlashget_comment_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/comments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_comment_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get gist statistics
		/// Enterprise_adminSlashget_gist_stats enterprise/stats/gists
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_gist_overview> Enterprise_adminSlashget_gist_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/gists";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_gist_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get hooks statistics
		/// Enterprise_adminSlashget_hooks_stats enterprise/stats/hooks
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_hook_overview> Enterprise_adminSlashget_hooks_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/hooks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_hook_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get issue statistics
		/// Enterprise_adminSlashget_issue_stats enterprise/stats/issues
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_issue_overview> Enterprise_adminSlashget_issue_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/issues";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_issue_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get milestone statistics
		/// Enterprise_adminSlashget_milestone_stats enterprise/stats/milestones
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_milestone_overview> Enterprise_adminSlashget_milestone_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/milestones";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_milestone_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get organization statistics
		/// Enterprise_adminSlashget_org_stats enterprise/stats/orgs
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_organization_overview> Enterprise_adminSlashget_org_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/orgs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_organization_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get pages statistics
		/// Enterprise_adminSlashget_pages_stats enterprise/stats/pages
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_page_overview> Enterprise_adminSlashget_pages_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/pages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_page_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get pull request statistics
		/// Enterprise_adminSlashget_pull_request_stats enterprise/stats/pulls
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_pull_request_overview> Enterprise_adminSlashget_pull_request_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/pulls";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_pull_request_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get repository statistics
		/// Enterprise_adminSlashget_repo_stats enterprise/stats/repos
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_repository_overview> Enterprise_adminSlashget_repo_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/repos";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_repository_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get users statistics
		/// Enterprise_adminSlashget_user_stats enterprise/stats/users
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_user_overview> Enterprise_adminSlashget_user_statsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprise/stats/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_user_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Actions cache usage for an enterprise
		/// Gets the total GitHub Actions cache usage for an enterprise.
		/// The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// ActionsSlashget_actions_cache_usage_for_enterprise enterprises/{enterprise}/actions/cache/usage
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <returns>Response</returns>
		public async Task<Actions_cache_usage_org_enterprise> ActionsSlashget_actions_cache_usage_for_enterpriseAsync(string enterprise, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/cache/usage";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_cache_usage_org_enterprise>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Actions cache usage policy for an enterprise
		/// Gets the GitHub Actions cache usage policy for an enterprise.
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.
		/// ActionsSlashget_actions_cache_usage_policy_for_enterprise enterprises/{enterprise}/actions/cache/usage-policy
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <returns>Response</returns>
		public async Task<Actions_cache_usage_policy_enterprise> ActionsSlashget_actions_cache_usage_policy_for_enterpriseAsync(string enterprise, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/cache/usage-policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_cache_usage_policy_enterprise>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set GitHub Actions cache usage policy for an enterprise
		/// Sets the GitHub Actions cache usage policy for an enterprise.
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.
		/// ActionsSlashset_actions_cache_usage_policy_for_enterprise enterprises/{enterprise}/actions/cache/usage-policy
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		public async Task ActionsSlashset_actions_cache_usage_policy_for_enterpriseAsync(string enterprise, Actions_cache_usage_policy_enterprise requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/cache/usage-policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Actions permissions for an enterprise
		/// Gets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashget_github_actions_permissions_enterprise enterprises/{enterprise}/actions/permissions
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <returns>Response</returns>
		public async Task<Actions_enterprise_permissions> Enterprise_adminSlashget_github_actions_permissions_enterpriseAsync(string enterprise, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_enterprise_permissions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set GitHub Actions permissions for an enterprise
		/// Sets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashset_github_actions_permissions_enterprise enterprises/{enterprise}/actions/permissions
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		public async Task Enterprise_adminSlashset_github_actions_permissions_enterpriseAsync(string enterprise, Enterprise_adminSlashset_github_actions_permissions_enterprisePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List selected organizations enabled for GitHub Actions in an enterprise
		/// Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashlist_selected_organizations_enabled_github_actions_enterprise enterprises/{enterprise}/actions/permissions/organizations
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashlist_selected_organizations_enabled_github_actions_enterpriseReturn> Enterprise_adminSlashlist_selected_organizations_enabled_github_actions_enterpriseAsync(string enterprise, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions/organizations&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashlist_selected_organizations_enabled_github_actions_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set selected organizations enabled for GitHub Actions in an enterprise
		/// Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashset_selected_organizations_enabled_github_actions_enterprise enterprises/{enterprise}/actions/permissions/organizations
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		public async Task Enterprise_adminSlashset_selected_organizations_enabled_github_actions_enterpriseAsync(string enterprise, Enterprise_adminSlashset_selected_organizations_enabled_github_actions_enterprisePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions/organizations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Disable a selected organization for GitHub Actions in an enterprise
		/// Removes an organization from the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashdisable_selected_organization_github_actions_enterprise enterprises/{enterprise}/actions/permissions/organizations/{org_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="org_id">The unique identifier of the organization.</param>
		public async Task Enterprise_adminSlashdisable_selected_organization_github_actions_enterpriseAsync(string enterprise, int org_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions/organizations/"+org_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable a selected organization for GitHub Actions in an enterprise
		/// Adds an organization to the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashenable_selected_organization_github_actions_enterprise enterprises/{enterprise}/actions/permissions/organizations/{org_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="org_id">The unique identifier of the organization.</param>
		public async Task Enterprise_adminSlashenable_selected_organization_github_actions_enterpriseAsync(string enterprise, int org_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions/organizations/"+org_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get allowed actions for an enterprise
		/// Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashget_allowed_actions_enterprise enterprises/{enterprise}/actions/permissions/selected-actions
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <returns>Response</returns>
		public async Task<Selected_actions> Enterprise_adminSlashget_allowed_actions_enterpriseAsync(string enterprise, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions/selected-actions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Selected_actions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set allowed actions for an enterprise
		/// Sets the actions that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashset_allowed_actions_enterprise enterprises/{enterprise}/actions/permissions/selected-actions
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		public async Task Enterprise_adminSlashset_allowed_actions_enterpriseAsync(string enterprise, Selected_actions requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions/selected-actions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get default workflow permissions for an enterprise
		/// Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an enterprise,
		/// as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
		/// "[Enforcing a policy for workflow permissions in your enterprise](https://docs.github.com/enterprise-server@3.6/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-workflow-permissions-in-your-enterprise)."
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.
		/// ActionsSlashget_github_actions_default_workflow_permissions_enterprise enterprises/{enterprise}/actions/permissions/workflow
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <returns>Success response</returns>
		public async Task<Actions_get_default_workflow_permissions> ActionsSlashget_github_actions_default_workflow_permissions_enterpriseAsync(string enterprise, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions/workflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_get_default_workflow_permissions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set default workflow permissions for an enterprise
		/// Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an enterprise, and sets
		/// whether GitHub Actions can submit approving pull request reviews. For more information, see
		/// "[Enforcing a policy for workflow permissions in your enterprise](https://docs.github.com/enterprise-server@3.6/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-workflow-permissions-in-your-enterprise)."
		/// 
		/// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
		/// GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.
		/// ActionsSlashset_github_actions_default_workflow_permissions_enterprise enterprises/{enterprise}/actions/permissions/workflow
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		public async Task ActionsSlashset_github_actions_default_workflow_permissions_enterpriseAsync(string enterprise, Actions_set_default_workflow_permissions requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/permissions/workflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List self-hosted runner groups for an enterprise
		/// Lists all self-hosted runner groups for an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashlist_self_hosted_runner_groups_for_enterprise enterprises/{enterprise}/actions/runner-groups
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="visible_to_organization">Only return runner groups that are allowed to be used by this organization.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashlist_self_hosted_runner_groups_for_enterpriseReturn> Enterprise_adminSlashlist_self_hosted_runner_groups_for_enterpriseAsync(string enterprise, int per_page, int page, string visible_to_organization, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups&per_page="+per_page+"&page="+page+"&visible_to_organization=" + (visible_to_organization==null? "" : System.Uri.EscapeDataString(visible_to_organization));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashlist_self_hosted_runner_groups_for_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a self-hosted runner group for an enterprise
		/// Creates a new self-hosted runner group for an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterprise enterprises/{enterprise}/actions/runner-groups
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		public async Task Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterpriseAsync(string enterprise, Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterprisePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a self-hosted runner group from an enterprise
		/// Deletes a self-hosted runner group for an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashdelete_self_hosted_runner_group_from_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		public async Task Enterprise_adminSlashdelete_self_hosted_runner_group_from_enterpriseAsync(string enterprise, int runner_group_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a self-hosted runner group for an enterprise
		/// Gets a specific self-hosted runner group for an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashget_self_hosted_runner_group_for_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <returns>Response</returns>
		public async Task<Runner_groups_enterprise> Enterprise_adminSlashget_self_hosted_runner_group_for_enterpriseAsync(string enterprise, int runner_group_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner_groups_enterprise>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a self-hosted runner group for an enterprise
		/// Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashupdate_self_hosted_runner_group_for_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <returns>Response</returns>
		public async Task<Runner_groups_enterprise> Enterprise_adminSlashupdate_self_hosted_runner_group_for_enterpriseAsync(string enterprise, int runner_group_id, Enterprise_adminSlashupdate_self_hosted_runner_group_for_enterprisePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner_groups_enterprise>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List organization access to a self-hosted runner group in an enterprise
		/// Lists the organizations with access to a self-hosted runner group.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashlist_org_access_to_self_hosted_runner_group_in_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashlist_org_access_to_self_hosted_runner_group_in_enterpriseReturn> Enterprise_adminSlashlist_org_access_to_self_hosted_runner_group_in_enterpriseAsync(string enterprise, int runner_group_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id+"/organizations&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashlist_org_access_to_self_hosted_runner_group_in_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set organization access for a self-hosted runner group in an enterprise
		/// Replaces the list of organizations that have access to a self-hosted runner configured in an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashset_org_access_to_self_hosted_runner_group_in_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		public async Task Enterprise_adminSlashset_org_access_to_self_hosted_runner_group_in_enterpriseAsync(string enterprise, int runner_group_id, Enterprise_adminSlashset_org_access_to_self_hosted_runner_group_in_enterprisePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id+"/organizations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove organization access to a self-hosted runner group in an enterprise
		/// Removes an organization from the list of selected organizations that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashremove_org_access_to_self_hosted_runner_group_in_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="org_id">The unique identifier of the organization.</param>
		public async Task Enterprise_adminSlashremove_org_access_to_self_hosted_runner_group_in_enterpriseAsync(string enterprise, int runner_group_id, int org_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id+"/organizations/"+org_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add organization access to a self-hosted runner group in an enterprise
		/// Adds an organization to the list of selected organizations that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashadd_org_access_to_self_hosted_runner_group_in_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="org_id">The unique identifier of the organization.</param>
		public async Task Enterprise_adminSlashadd_org_access_to_self_hosted_runner_group_in_enterpriseAsync(string enterprise, int runner_group_id, int org_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id+"/organizations/"+org_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List self-hosted runners in a group for an enterprise
		/// Lists the self-hosted runners that are in a specific enterprise group.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashlist_self_hosted_runners_in_group_for_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashlist_self_hosted_runners_in_group_for_enterpriseReturn> Enterprise_adminSlashlist_self_hosted_runners_in_group_for_enterpriseAsync(string enterprise, int runner_group_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id+"/runners&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashlist_self_hosted_runners_in_group_for_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set self-hosted runners in a group for an enterprise
		/// Replaces the list of self-hosted runners that are part of an enterprise runner group.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashset_self_hosted_runners_in_group_for_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		public async Task Enterprise_adminSlashset_self_hosted_runners_in_group_for_enterpriseAsync(string enterprise, int runner_group_id, Enterprise_adminSlashset_self_hosted_runners_in_group_for_enterprisePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id+"/runners";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a self-hosted runner from a group for an enterprise
		/// Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned to the default group.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashremove_self_hosted_runner_from_group_for_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		public async Task Enterprise_adminSlashremove_self_hosted_runner_from_group_for_enterpriseAsync(string enterprise, int runner_group_id, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id+"/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a self-hosted runner to a group for an enterprise
		/// Adds a self-hosted runner to a runner group configured in an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise`
		/// scope to use this endpoint.
		/// Enterprise_adminSlashadd_self_hosted_runner_to_group_for_enterprise enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		public async Task Enterprise_adminSlashadd_self_hosted_runner_to_group_for_enterpriseAsync(string enterprise, int runner_group_id, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runner-groups/"+runner_group_id+"/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List self-hosted runners for an enterprise
		/// Lists all self-hosted runners configured for an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashlist_self_hosted_runners_for_enterprise enterprises/{enterprise}/actions/runners
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashlist_self_hosted_runners_for_enterpriseReturn> Enterprise_adminSlashlist_self_hosted_runners_for_enterpriseAsync(string enterprise, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashlist_self_hosted_runners_for_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List runner applications for an enterprise
		/// Lists binaries for the runner application that you can download and run.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashlist_runner_applications_for_enterprise enterprises/{enterprise}/actions/runners/downloads
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <returns>Response</returns>
		public async Task<Runner_application[]> Enterprise_adminSlashlist_runner_applications_for_enterpriseAsync(string enterprise, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/downloads";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner_application[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a registration token for an enterprise
		/// Returns a token that you can pass to the `config` script. The token expires after one hour.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// 
		/// #### Example using registration token
		/// 
		/// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
		/// 
		/// ```
		/// ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
		/// ```
		/// Enterprise_adminSlashcreate_registration_token_for_enterprise enterprises/{enterprise}/actions/runners/registration-token
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		public async Task Enterprise_adminSlashcreate_registration_token_for_enterpriseAsync(string enterprise, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/registration-token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a remove token for an enterprise
		/// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an enterprise. The token expires after one hour.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// 
		/// #### Example using remove token
		/// 
		/// To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token provided by this
		/// endpoint.
		/// 
		/// ```
		/// ./config.sh remove --token TOKEN
		/// ```
		/// Enterprise_adminSlashcreate_remove_token_for_enterprise enterprises/{enterprise}/actions/runners/remove-token
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		public async Task Enterprise_adminSlashcreate_remove_token_for_enterpriseAsync(string enterprise, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/remove-token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a self-hosted runner from an enterprise
		/// Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashdelete_self_hosted_runner_from_enterprise enterprises/{enterprise}/actions/runners/{runner_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		public async Task Enterprise_adminSlashdelete_self_hosted_runner_from_enterpriseAsync(string enterprise, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a self-hosted runner for an enterprise
		/// Gets a specific self-hosted runner configured in an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashget_self_hosted_runner_for_enterprise enterprises/{enterprise}/actions/runners/{runner_id}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<Runner> Enterprise_adminSlashget_self_hosted_runner_for_enterpriseAsync(string enterprise, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove all custom labels from a self-hosted runner for an enterprise
		/// Remove all custom labels from a self-hosted runner configured in an
		/// enterprise. Returns the remaining read-only labels from the runner.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashremove_all_custom_labels_from_self_hosted_runner_for_enterprise enterprises/{enterprise}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashremove_all_custom_labels_from_self_hosted_runner_for_enterpriseReturn> Enterprise_adminSlashremove_all_custom_labels_from_self_hosted_runner_for_enterpriseAsync(string enterprise, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashremove_all_custom_labels_from_self_hosted_runner_for_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List labels for a self-hosted runner for an enterprise
		/// Lists all labels for a self-hosted runner configured in an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashlist_labels_for_self_hosted_runner_for_enterprise enterprises/{enterprise}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashlist_labels_for_self_hosted_runner_for_enterpriseReturn> Enterprise_adminSlashlist_labels_for_self_hosted_runner_for_enterpriseAsync(string enterprise, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashlist_labels_for_self_hosted_runner_for_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add custom labels to a self-hosted runner for an enterprise
		/// Add custom labels to a self-hosted runner configured in an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashadd_custom_labels_to_self_hosted_runner_for_enterprise enterprises/{enterprise}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashadd_custom_labels_to_self_hosted_runner_for_enterpriseReturn> Enterprise_adminSlashadd_custom_labels_to_self_hosted_runner_for_enterpriseAsync(string enterprise, int runner_id, Enterprise_adminSlashadd_custom_labels_to_self_hosted_runner_for_enterprisePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashadd_custom_labels_to_self_hosted_runner_for_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set custom labels for a self-hosted runner for an enterprise
		/// Remove all previous custom labels and set the new custom labels for a specific
		/// self-hosted runner configured in an enterprise.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashset_custom_labels_for_self_hosted_runner_for_enterprise enterprises/{enterprise}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashset_custom_labels_for_self_hosted_runner_for_enterpriseReturn> Enterprise_adminSlashset_custom_labels_for_self_hosted_runner_for_enterpriseAsync(string enterprise, int runner_id, Enterprise_adminSlashset_custom_labels_for_self_hosted_runner_for_enterprisePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashset_custom_labels_for_self_hosted_runner_for_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a custom label from a self-hosted runner for an enterprise
		/// Remove a custom label from a self-hosted runner configured
		/// in an enterprise. Returns the remaining labels from the runner.
		/// 
		/// This endpoint returns a `404 Not Found` status if the custom label is not
		/// present on the runner.
		/// 
		/// You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
		/// Enterprise_adminSlashremove_custom_label_from_self_hosted_runner_for_enterprise enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <param name="name">The name of a self-hosted runner's custom label.</param>
		/// <returns>Response</returns>
		public async Task<Enterprise_adminSlashremove_custom_label_from_self_hosted_runner_for_enterpriseReturn> Enterprise_adminSlashremove_custom_label_from_self_hosted_runner_for_enterpriseAsync(string enterprise, int runner_id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/actions/runners/"+runner_id+"/labels/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_adminSlashremove_custom_label_from_self_hosted_runner_for_enterpriseReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the audit log for an enterprise
		/// Gets the audit log for an enterprise. To use this endpoint, you must be an enterprise admin, and you must use an access token with the `admin:enterprise` scope.
		/// Enterprise_adminSlashget_audit_log enterprises/{enterprise}/audit-log
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="phrase">A search phrase. For more information, see [Searching the audit log](https://docs.github.com/enterprise-server@3.6/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/searching-the-audit-log-for-your-enterprise#searching-the-audit-log).</param>
		/// <param name="include">The event types to include:
		///
		///- `web` - returns web (non-Git) events.
		///- `git` - returns Git events.
		///- `all` - returns both web and Git events.
		///
		///The default is `web`.</param>
		/// <param name="after">A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for events after this cursor.</param>
		/// <param name="before">A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for events before this cursor.</param>
		/// <param name="order">The order of audit log events. To list newest events first, specify `desc`. To list oldest events first, specify `asc`.
		///
		///The default is `desc`.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<Audit_log_event[]> Enterprise_adminSlashget_audit_logAsync(string enterprise, string phrase, Enterprise_adminSlashget_audit_logInclude include, string after, string before, Enterprise_adminSlashget_audit_logOrder order, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/audit-log&phrase=" + (phrase==null? "" : System.Uri.EscapeDataString(phrase))+"&include=" + include+"&after=" + (after==null? "" : System.Uri.EscapeDataString(after))+"&before=" + (before==null? "" : System.Uri.EscapeDataString(before))+"&order=" + order+"&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Audit_log_event[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List secret scanning alerts for an enterprise
		/// Lists secret scanning alerts for eligible repositories in an enterprise, from newest to oldest.
		/// To use this endpoint, you must be a member of the enterprise, and you must use an access token with the `repo` scope or `security_events` scope. Alerts are only returned for organizations in the enterprise for which you are an organization owner or a [security manager](https://docs.github.com/enterprise-server@3.6/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).
		/// Secret_scanningSlashlist_alerts_for_enterprise enterprises/{enterprise}/secret-scanning/alerts
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="state">Set to `open` or `resolved` to only list secret scanning alerts in a specific state.</param>
		/// <param name="secret_type">A comma-separated list of secret types to return. By default all secret types are returned.
		///See "[Secret scanning patterns](https://docs.github.com/enterprise-server@3.6/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)"
		///for a complete list of secret types.</param>
		/// <param name="resolution">A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.</param>
		/// <param name="sort">The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="before">A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for results before this cursor.</param>
		/// <param name="after">A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for results after this cursor.</param>
		/// <returns>Response</returns>
		public async Task<Organization_secret_scanning_alert[]> Secret_scanningSlashlist_alerts_for_enterpriseAsync(string enterprise, Organization_secret_scanning_alertState state, string secret_type, string resolution, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, string before, string after, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/secret-scanning/alerts&state=" + state+"&secret_type=" + (secret_type==null? "" : System.Uri.EscapeDataString(secret_type))+"&resolution=" + (resolution==null? "" : System.Uri.EscapeDataString(resolution))+"&sort=" + sort+"&direction=" + direction+"&per_page="+per_page+"&before=" + (before==null? "" : System.Uri.EscapeDataString(before))+"&after=" + (after==null? "" : System.Uri.EscapeDataString(after));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_secret_scanning_alert[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Advanced Security active committers for an enterprise
		/// Gets the GitHub Advanced Security active committers for an enterprise per repository.
		/// 
		/// Each distinct user login across all repositories is counted as a single Advanced Security seat, so the `total_advanced_security_committers` is not the sum of active_users for each repository.
		/// 
		/// The total number of repositories with committer information is tracked by the `total_count` field.
		/// BillingSlashget_github_advanced_security_billing_ghe enterprises/{enterprise}/settings/billing/advanced-security
		/// </summary>
		/// <param name="enterprise">The slug version of the enterprise name. You can also substitute this value with the enterprise id.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Success</returns>
		public async Task<Advanced_security_active_committers> BillingSlashget_github_advanced_security_billing_gheAsync(string enterprise, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "enterprises/"+ (enterprise==null? "" : System.Uri.EscapeDataString(enterprise))+"/settings/billing/advanced-security&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Advanced_security_active_committers>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List public events
		/// We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago.
		/// ActivitySlashlist_public_events events
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_public_eventsAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get feeds
		/// GitHub Enterprise Server provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the feeds available to the authenticated user:
		/// 
		/// *   **Timeline**: The GitHub Enterprise Server global public timeline
		/// *   **User**: The public timeline for any user, using [URI template](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#hypermedia)
		/// *   **Current user public**: The public timeline for the authenticated user
		/// *   **Current user**: The private timeline for the authenticated user
		/// *   **Current user actor**: The private timeline for activity created by the authenticated user
		/// *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
		/// *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub Enterprise Server.
		/// 
		/// **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use the older, non revocable auth tokens.
		/// ActivitySlashget_feeds feeds
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Feed> ActivitySlashget_feedsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "feeds";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Feed>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List gists for the authenticated user
		/// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:
		/// GistsSlashlist gists
		/// </summary>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Base_gist[]> GistsSlashlistAsync(System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists?since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Base_gist[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a gist
		/// Allows you to add a new gist with one or more files.
		/// 
		/// **Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
		/// GistsSlashcreate gists
		/// </summary>
		public async Task GistsSlashcreateAsync(GistsSlashcreatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List public gists
		/// List public gists sorted by most recently updated to least recently updated.
		/// 
		/// Note: With [pagination](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
		/// GistsSlashlist_public gists/public
		/// </summary>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Base_gist[]> GistsSlashlist_publicAsync(System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/public?since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Base_gist[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List starred gists
		/// List the authenticated user's starred gists:
		/// GistsSlashlist_starred gists/starred
		/// </summary>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Base_gist[]> GistsSlashlist_starredAsync(System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/starred?since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Base_gist[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a gist
		/// GistsSlashdelete gists/{gist_id}
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		public async Task GistsSlashdeleteAsync(string gist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a gist
		/// GistsSlashget gists/{gist_id}
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <returns>Response</returns>
		public async Task<Gist_simple> GistsSlashgetAsync(string gist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gist_simple>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a gist
		/// Allows you to update a gist's description and to update, delete, or rename gist files. Files from the previous version of the gist that aren't explicitly changed during an edit are unchanged.
		/// GistsSlashupdate gists/{gist_id}
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <returns>Response</returns>
		public async Task<Gist_simple> GistsSlashupdateAsync(string gist_id, GistsSlashupdatePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gist_simple>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List gist comments
		/// GistsSlashlist_comments gists/{gist_id}/comments
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Gist_comment[]> GistsSlashlist_commentsAsync(string gist_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/comments&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gist_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a gist comment
		/// GistsSlashcreate_comment gists/{gist_id}/comments
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		public async Task GistsSlashcreate_commentAsync(string gist_id, GistsSlashcreate_commentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/comments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a gist comment
		/// GistsSlashdelete_comment gists/{gist_id}/comments/{comment_id}
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		public async Task GistsSlashdelete_commentAsync(string gist_id, int comment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a gist comment
		/// GistsSlashget_comment gists/{gist_id}/comments/{comment_id}
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Response</returns>
		public async Task<Gist_comment> GistsSlashget_commentAsync(string gist_id, int comment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gist_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a gist comment
		/// GistsSlashupdate_comment gists/{gist_id}/comments/{comment_id}
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Response</returns>
		public async Task<Gist_comment> GistsSlashupdate_commentAsync(string gist_id, int comment_id, GistsSlashupdate_commentPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gist_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List gist commits
		/// GistsSlashlist_commits gists/{gist_id}/commits
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Gist_commit[]> GistsSlashlist_commitsAsync(string gist_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/commits&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gist_commit[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List gist forks
		/// GistsSlashlist_forks gists/{gist_id}/forks
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Gist_simple[]> GistsSlashlist_forksAsync(string gist_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/forks&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gist_simple[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fork a gist
		/// GistsSlashfork gists/{gist_id}/forks
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		public async Task GistsSlashforkAsync(string gist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/forks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unstar a gist
		/// GistsSlashunstar gists/{gist_id}/star
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		public async Task GistsSlashunstarAsync(string gist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/star";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if a gist is starred
		/// GistsSlashcheck_is_starred gists/{gist_id}/star
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		public async Task GistsSlashcheck_is_starredAsync(string gist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/star";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Star a gist
		/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// GistsSlashstar gists/{gist_id}/star
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		public async Task GistsSlashstarAsync(string gist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/star";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a gist revision
		/// GistsSlashget_revision gists/{gist_id}/{sha}
		/// </summary>
		/// <param name="gist_id">The unique identifier of the gist.</param>
		/// <returns>Response</returns>
		public async Task<Gist_simple> GistsSlashget_revisionAsync(string gist_id, string sha, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gists/"+ (gist_id==null? "" : System.Uri.EscapeDataString(gist_id))+"/"+ (sha==null? "" : System.Uri.EscapeDataString(sha));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gist_simple>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all gitignore templates
		/// List all templates available to pass as an option when [creating a repository](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#create-a-repository-for-the-authenticated-user).
		/// GitignoreSlashget_all_templates gitignore/templates
		/// </summary>
		/// <returns>Response</returns>
		public async Task<string[]> GitignoreSlashget_all_templatesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gitignore/templates";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a gitignore template
		/// The API also allows fetching the source of a single template.
		/// Use the raw [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/) to get the raw contents.
		/// GitignoreSlashget_template gitignore/templates/{name}
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Gitignore_template> GitignoreSlashget_templateAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gitignore/templates/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gitignore_template>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories accessible to the app installation
		/// List repositories that an app installation can access.
		/// 
		/// You must use an [installation access token](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
		/// AppsSlashlist_repos_accessible_to_installation installation/repositories
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<AppsSlashlist_repos_accessible_to_installationReturn> AppsSlashlist_repos_accessible_to_installationAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "installation/repositories?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AppsSlashlist_repos_accessible_to_installationReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Revoke an installation access token
		/// Revokes the installation token you're using to authenticate as an installation and access this endpoint.
		/// 
		/// Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation token must have a new installation token to work. You can create a new token using the "[Create an installation access token for an app](https://docs.github.com/enterprise-server@3.6/rest/reference/apps#create-an-installation-access-token-for-an-app)" endpoint.
		/// 
		/// You must use an [installation access token](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
		/// AppsSlashrevoke_installation_access_token installation/token
		/// </summary>
		public async Task AppsSlashrevoke_installation_access_tokenAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "installation/token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List issues assigned to the authenticated user
		/// List issues assigned to the authenticated user across all visible repositories including owned repositories, member
		/// repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
		/// necessarily assigned to you.
		/// 
		/// 
		/// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
		/// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
		/// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
		/// request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#list-pull-requests)" endpoint.
		/// IssuesSlashlist issues
		/// </summary>
		/// <param name="filter">Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.</param>
		/// <param name="state">Indicates the state of the issues to return.</param>
		/// <param name="labels">A list of comma separated label names. Example: `bug,ui,@high`</param>
		/// <param name="sort">What to sort results by.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Issue[]> IssuesSlashlistAsync(IssuesSlashlistFilter filter, IssuesSlashlistState state, string labels, IssuesSlashlistSort sort, Enterprise_adminSlashlist_public_keysDirection direction, System.DateTimeOffset since, bool collab, bool orgs, bool owned, bool pulls, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issues?filter=" + filter+"&state=" + state+"&labels=" + (labels==null? "" : System.Uri.EscapeDataString(labels))+"&sort=" + sort+"&direction=" + direction+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&collab="+collab+"&orgs="+orgs+"&owned="+owned+"&pulls="+pulls+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all commonly used licenses
		/// LicensesSlashget_all_commonly_used licenses
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<License_simple[]> LicensesSlashget_all_commonly_usedAsync(bool featured, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "licenses?featured="+featured+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<License_simple[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a license
		/// LicensesSlashget licenses/{license}
		/// </summary>
		/// <returns>Response</returns>
		public async Task<License> LicensesSlashgetAsync(string license, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "licenses/"+ (license==null? "" : System.Uri.EscapeDataString(license));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<License>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Render a Markdown document
		/// MarkdownSlashrender markdown
		/// </summary>
		/// <returns>Response</returns>
		public async Task MarkdownSlashrenderAsync(MarkdownSlashrenderPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "markdown";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Enterprise Server meta information
		/// MetaSlashget meta
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Api_overview> MetaSlashgetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Api_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List public events for a network of repositories
		/// ActivitySlashlist_public_events_for_repo_network networks/{owner}/{repo}/events
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_public_events_for_repo_networkAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/events&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List notifications for the authenticated user
		/// List all notifications for the current user, sorted by most recently updated.
		/// ActivitySlashlist_notifications_for_authenticated_user notifications
		/// </summary>
		/// <param name="all">If `true`, show notifications marked as read.</param>
		/// <param name="participating">If `true`, only shows notifications in which the user is directly participating or mentioned.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="before">Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 50).</param>
		/// <returns>Response</returns>
		public async Task<Thread[]> ActivitySlashlist_notifications_for_authenticated_userAsync(bool all, bool participating, System.DateTimeOffset since, System.DateTimeOffset before, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notifications?all="+all+"&participating="+participating+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before=" + before.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Thread[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Mark notifications as read
		/// Marks all notifications as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub Enterprise Server will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
		/// ActivitySlashmark_notifications_as_read notifications
		/// </summary>
		public async Task ActivitySlashmark_notifications_as_readAsync(ActivitySlashmark_notifications_as_readPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notifications";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a thread
		/// Gets information about a notification thread.
		/// ActivitySlashget_thread notifications/threads/{thread_id}
		/// </summary>
		/// <param name="thread_id">The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#list-notifications-for-the-authenticated-user)).</param>
		/// <returns>Response</returns>
		public async Task<Thread> ActivitySlashget_threadAsync(int thread_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notifications/threads/"+thread_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Thread>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Mark a thread as read
		/// Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification in your notification inbox on GitHub Enterprise Server: https://github.com/notifications.
		/// ActivitySlashmark_thread_as_read notifications/threads/{thread_id}
		/// </summary>
		/// <param name="thread_id">The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#list-notifications-for-the-authenticated-user)).</param>
		public async Task ActivitySlashmark_thread_as_readAsync(int thread_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notifications/threads/"+thread_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a thread subscription
		/// Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#set-a-thread-subscription) endpoint and set `ignore` to `true`.
		/// ActivitySlashdelete_thread_subscription notifications/threads/{thread_id}/subscription
		/// </summary>
		/// <param name="thread_id">The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#list-notifications-for-the-authenticated-user)).</param>
		public async Task ActivitySlashdelete_thread_subscriptionAsync(int thread_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notifications/threads/"+thread_id+"/subscription";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a thread subscription for the authenticated user
		/// This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#get-a-repository-subscription).
		/// 
		/// Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
		/// ActivitySlashget_thread_subscription_for_authenticated_user notifications/threads/{thread_id}/subscription
		/// </summary>
		/// <param name="thread_id">The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#list-notifications-for-the-authenticated-user)).</param>
		/// <returns>Response</returns>
		public async Task<Thread_subscription> ActivitySlashget_thread_subscription_for_authenticated_userAsync(int thread_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notifications/threads/"+thread_id+"/subscription";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Thread_subscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set a thread subscription
		/// If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.
		/// 
		/// You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.
		/// 
		/// Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#delete-a-thread-subscription) endpoint.
		/// ActivitySlashset_thread_subscription notifications/threads/{thread_id}/subscription
		/// </summary>
		/// <param name="thread_id">The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#list-notifications-for-the-authenticated-user)).</param>
		/// <returns>Response</returns>
		public async Task<Thread_subscription> ActivitySlashset_thread_subscriptionAsync(int thread_id, ActivitySlashset_thread_subscriptionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "notifications/threads/"+thread_id+"/subscription";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Thread_subscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Octocat
		/// Get the octocat as ASCII art
		/// MetaSlashget_octocat octocat
		/// </summary>
		/// <param name="s">The words to show in Octocat's speech bubble</param>
		/// <returns>Response</returns>
		public async Task MetaSlashget_octocatAsync(string s, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "octocat?s=" + (s==null? "" : System.Uri.EscapeDataString(s));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organizations
		/// Lists all organizations, in the order that they were created on GitHub Enterprise Server.
		/// 
		/// **Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of organizations.
		/// OrgsSlashlist organizations
		/// </summary>
		/// <param name="since">An organization ID. Only return organizations with an ID greater than this ID.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<Organization_simple[]> OrgsSlashlistAsync(int since, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations?since="+since+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_simple[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List custom repository roles in an organization
		/// List the custom repository roles available in this organization. In order to see custom
		/// repository roles in an organization, the authenticated user must be an organization owner.
		/// 
		/// To use this endpoint the authenticated user must be an administrator for the organization or of an repository of the organization and must use an access token with `admin:org repo` scope.
		/// GitHub Apps must have the `organization_custom_roles:read` organization permission to use this endpoint.
		/// 
		/// For more information on custom repository roles, see "[About custom repository roles](https://docs.github.com/enterprise-server@3.6/organizations/managing-peoples-access-to-your-organization-with-roles/about-custom-repository-roles)."
		/// OrgsSlashlist_custom_roles organizations/{organization_id}/custom_roles
		/// </summary>
		/// <param name="organization_id">The unique identifier of the organization.</param>
		/// <returns>Response - list of custom role names</returns>
		public async Task<OrgsSlashlist_custom_rolesReturn> OrgsSlashlist_custom_rolesAsync(string organization_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organization_id==null? "" : System.Uri.EscapeDataString(organization_id))+"/custom_roles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OrgsSlashlist_custom_rolesReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an organization
		/// To see many of the organization response values, you need to be an authenticated organization owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, and outside collaborators to enable [two-factor authentication](https://docs.github.com/enterprise-server@3.6/articles/securing-your-account-with-two-factor-authentication-2fa/).
		/// 
		/// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information about an organization's GitHub Enterprise Server plan. See "[Authenticating with GitHub Apps](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example response, see 'Response with GitHub Enterprise Server plan information' below."
		/// OrgsSlashget orgs/{org}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Organization_full> OrgsSlashgetAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_full>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an organization
		/// **Parameter Deprecation Notice:** GitHub Enterprise Server will replace and discontinue `members_allowed_repository_creation_type` in favor of more granular permissions. The new input parameters are `members_can_create_public_repositories`, `members_can_create_private_repositories` for all organizations and `members_can_create_internal_repositories` for organizations associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see the [blog post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes).
		/// 
		/// Enables an authenticated organization owner with the `admin:org` scope to update the organization's profile and member privileges.
		/// OrgsSlashupdate orgs/{org}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Organization_full> OrgsSlashupdateAsync(string org, OrgsSlashupdatePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_full>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Actions cache usage for an organization
		/// Gets the total GitHub Actions cache usage for an organization.
		/// The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
		/// You must authenticate using an access token with the `read:org` scope to use this endpoint. GitHub Apps must have the `organization_admistration:read` permission to use this endpoint.
		/// ActionsSlashget_actions_cache_usage_for_org orgs/{org}/actions/cache/usage
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_cache_usage_org_enterprise> ActionsSlashget_actions_cache_usage_for_orgAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/cache/usage";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_cache_usage_org_enterprise>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories with GitHub Actions cache usage for an organization
		/// Lists repositories and their GitHub Actions cache usage for an organization.
		/// The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
		/// You must authenticate using an access token with the `read:org` scope to use this endpoint. GitHub Apps must have the `organization_admistration:read` permission to use this endpoint.
		/// ActionsSlashget_actions_cache_usage_by_repo_for_org orgs/{org}/actions/cache/usage-by-repository
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashget_actions_cache_usage_by_repo_for_orgReturn> ActionsSlashget_actions_cache_usage_by_repo_for_orgAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/cache/usage-by-repository&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashget_actions_cache_usage_by_repo_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Actions permissions for an organization
		/// Gets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashget_github_actions_permissions_organization orgs/{org}/actions/permissions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_organization_permissions> ActionsSlashget_github_actions_permissions_organizationAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_organization_permissions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set GitHub Actions permissions for an organization
		/// Sets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
		/// 
		/// If the organization belongs to an enterprise that has set restrictive permissions at the enterprise level, such as `allowed_actions` to `selected` actions, then you cannot override them for the organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashset_github_actions_permissions_organization orgs/{org}/actions/permissions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ActionsSlashset_github_actions_permissions_organizationAsync(string org, ActionsSlashset_github_actions_permissions_organizationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List selected repositories enabled for GitHub Actions in an organization
		/// Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashlist_selected_repositories_enabled_github_actions_organization orgs/{org}/actions/permissions/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_selected_repositories_enabled_github_actions_organizationReturn> ActionsSlashlist_selected_repositories_enabled_github_actions_organizationAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions/repositories&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_selected_repositories_enabled_github_actions_organizationReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set selected repositories enabled for GitHub Actions in an organization
		/// Replaces the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashset_selected_repositories_enabled_github_actions_organization orgs/{org}/actions/permissions/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ActionsSlashset_selected_repositories_enabled_github_actions_organizationAsync(string org, ActionsSlashset_selected_repositories_enabled_github_actions_organizationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions/repositories";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Disable a selected repository for GitHub Actions in an organization
		/// Removes a repository from the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashdisable_selected_repository_github_actions_organization orgs/{org}/actions/permissions/repositories/{repository_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		public async Task ActionsSlashdisable_selected_repository_github_actions_organizationAsync(string org, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable a selected repository for GitHub Actions in an organization
		/// Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashenable_selected_repository_github_actions_organization orgs/{org}/actions/permissions/repositories/{repository_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		public async Task ActionsSlashenable_selected_repository_github_actions_organizationAsync(string org, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get allowed actions for an organization
		/// Gets the selected actions that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization).""
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashget_allowed_actions_organization orgs/{org}/actions/permissions/selected-actions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Selected_actions> ActionsSlashget_allowed_actions_organizationAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions/selected-actions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Selected_actions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set allowed actions for an organization
		/// Sets the actions that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
		/// 
		/// If the organization belongs to an enterprise that has `selected` actions set at the enterprise level, then you cannot override any of the enterprise's allowed actions settings.
		/// 
		/// To use the `patterns_allowed` setting for private repositories, the organization must belong to an enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories in the organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashset_allowed_actions_organization orgs/{org}/actions/permissions/selected-actions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ActionsSlashset_allowed_actions_organizationAsync(string org, Selected_actions requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions/selected-actions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get default workflow permissions for an organization
		/// Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization,
		/// as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
		/// "[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/enterprise-server@3.6/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashget_github_actions_default_workflow_permissions_organization orgs/{org}/actions/permissions/workflow
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_get_default_workflow_permissions> ActionsSlashget_github_actions_default_workflow_permissions_organizationAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions/workflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_get_default_workflow_permissions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set default workflow permissions for an organization
		/// Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization, and sets if GitHub Actions
		/// can submit approving pull request reviews. For more information, see
		/// "[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/enterprise-server@3.6/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
		/// ActionsSlashset_github_actions_default_workflow_permissions_organization orgs/{org}/actions/permissions/workflow
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ActionsSlashset_github_actions_default_workflow_permissions_organizationAsync(string org, Actions_set_default_workflow_permissions requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/permissions/workflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List self-hosted runner groups for an organization
		/// Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashlist_self_hosted_runner_groups_for_org orgs/{org}/actions/runner-groups
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="visible_to_repository">Only return runner groups that are allowed to be used by this repository.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_self_hosted_runner_groups_for_orgReturn> ActionsSlashlist_self_hosted_runner_groups_for_orgAsync(string org, int per_page, int page, string visible_to_repository, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups&per_page="+per_page+"&page="+page+"&visible_to_repository=" + (visible_to_repository==null? "" : System.Uri.EscapeDataString(visible_to_repository));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_self_hosted_runner_groups_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a self-hosted runner group for an organization
		/// Creates a new self-hosted runner group for an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashcreate_self_hosted_runner_group_for_org orgs/{org}/actions/runner-groups
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ActionsSlashcreate_self_hosted_runner_group_for_orgAsync(string org, ActionsSlashcreate_self_hosted_runner_group_for_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a self-hosted runner group from an organization
		/// Deletes a self-hosted runner group for an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashdelete_self_hosted_runner_group_from_org orgs/{org}/actions/runner-groups/{runner_group_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		public async Task ActionsSlashdelete_self_hosted_runner_group_from_orgAsync(string org, int runner_group_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a self-hosted runner group for an organization
		/// Gets a specific self-hosted runner group for an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashget_self_hosted_runner_group_for_org orgs/{org}/actions/runner-groups/{runner_group_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <returns>Response</returns>
		public async Task<Runner_groups_org> ActionsSlashget_self_hosted_runner_group_for_orgAsync(string org, int runner_group_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner_groups_org>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a self-hosted runner group for an organization
		/// Updates the `name` and `visibility` of a self-hosted runner group in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashupdate_self_hosted_runner_group_for_org orgs/{org}/actions/runner-groups/{runner_group_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <returns>Response</returns>
		public async Task<Runner_groups_org> ActionsSlashupdate_self_hosted_runner_group_for_orgAsync(string org, int runner_group_id, ActionsSlashupdate_self_hosted_runner_group_for_orgPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner_groups_org>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository access to a self-hosted runner group in an organization
		/// Lists the repositories with access to a self-hosted runner group configured in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashlist_repo_access_to_self_hosted_runner_group_in_org orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_repo_access_to_self_hosted_runner_group_in_orgReturn> ActionsSlashlist_repo_access_to_self_hosted_runner_group_in_orgAsync(string org, int runner_group_id, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id+"/repositories&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_repo_access_to_self_hosted_runner_group_in_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set repository access for a self-hosted runner group in an organization
		/// Replaces the list of repositories that have access to a self-hosted runner group configured in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashset_repo_access_to_self_hosted_runner_group_in_org orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		public async Task ActionsSlashset_repo_access_to_self_hosted_runner_group_in_orgAsync(string org, int runner_group_id, ActionsSlashset_repo_access_to_self_hosted_runner_group_in_orgPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id+"/repositories";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove repository access to a self-hosted runner group in an organization
		/// Removes a repository from the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashremove_repo_access_to_self_hosted_runner_group_in_org orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		public async Task ActionsSlashremove_repo_access_to_self_hosted_runner_group_in_orgAsync(string org, int runner_group_id, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id+"/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add repository access to a self-hosted runner group in an organization
		/// Adds a repository to the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."
		/// 
		/// You must authenticate using an access token with the `admin:org`
		/// scope to use this endpoint.
		/// ActionsSlashadd_repo_access_to_self_hosted_runner_group_in_org orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		public async Task ActionsSlashadd_repo_access_to_self_hosted_runner_group_in_orgAsync(string org, int runner_group_id, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id+"/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List self-hosted runners in a group for an organization
		/// Lists self-hosted runners that are in a specific organization group.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashlist_self_hosted_runners_in_group_for_org orgs/{org}/actions/runner-groups/{runner_group_id}/runners
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_self_hosted_runners_in_group_for_orgReturn> ActionsSlashlist_self_hosted_runners_in_group_for_orgAsync(string org, int runner_group_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id+"/runners&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_self_hosted_runners_in_group_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set self-hosted runners in a group for an organization
		/// Replaces the list of self-hosted runners that are part of an organization runner group.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashset_self_hosted_runners_in_group_for_org orgs/{org}/actions/runner-groups/{runner_group_id}/runners
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		public async Task ActionsSlashset_self_hosted_runners_in_group_for_orgAsync(string org, int runner_group_id, ActionsSlashset_self_hosted_runners_in_group_for_orgPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id+"/runners";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a self-hosted runner from a group for an organization
		/// Removes a self-hosted runner from a group configured in an organization. The runner is then returned to the default group.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashremove_self_hosted_runner_from_group_for_org orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		public async Task ActionsSlashremove_self_hosted_runner_from_group_for_orgAsync(string org, int runner_group_id, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id+"/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a self-hosted runner to a group for an organization
		/// Adds a self-hosted runner to a runner group configured in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org`
		/// scope to use this endpoint.
		/// ActionsSlashadd_self_hosted_runner_to_group_for_org orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_group_id">Unique identifier of the self-hosted runner group.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		public async Task ActionsSlashadd_self_hosted_runner_to_group_for_orgAsync(string org, int runner_group_id, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runner-groups/"+runner_group_id+"/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List self-hosted runners for an organization
		/// Lists all self-hosted runners configured in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashlist_self_hosted_runners_for_org orgs/{org}/actions/runners
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_self_hosted_runners_for_orgReturn> ActionsSlashlist_self_hosted_runners_for_orgAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_self_hosted_runners_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List runner applications for an organization
		/// Lists binaries for the runner application that you can download and run.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashlist_runner_applications_for_org orgs/{org}/actions/runners/downloads
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Runner_application[]> ActionsSlashlist_runner_applications_for_orgAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/downloads";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner_application[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a registration token for an organization
		/// Returns a token that you can pass to the `config` script. The token expires after one hour.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// 
		/// #### Example using registration token
		/// 
		/// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
		/// 
		/// ```
		/// ./config.sh --url https://github.com/octo-org --token TOKEN
		/// ```
		/// ActionsSlashcreate_registration_token_for_org orgs/{org}/actions/runners/registration-token
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ActionsSlashcreate_registration_token_for_orgAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/registration-token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a remove token for an organization
		/// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// 
		/// #### Example using remove token
		/// 
		/// To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token provided by this
		/// endpoint.
		/// 
		/// ```
		/// ./config.sh remove --token TOKEN
		/// ```
		/// ActionsSlashcreate_remove_token_for_org orgs/{org}/actions/runners/remove-token
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ActionsSlashcreate_remove_token_for_orgAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/remove-token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a self-hosted runner from an organization
		/// Forces the removal of a self-hosted runner from an organization. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashdelete_self_hosted_runner_from_org orgs/{org}/actions/runners/{runner_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		public async Task ActionsSlashdelete_self_hosted_runner_from_orgAsync(string org, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a self-hosted runner for an organization
		/// Gets a specific self-hosted runner configured in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashget_self_hosted_runner_for_org orgs/{org}/actions/runners/{runner_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<Runner> ActionsSlashget_self_hosted_runner_for_orgAsync(string org, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove all custom labels from a self-hosted runner for an organization
		/// Remove all custom labels from a self-hosted runner configured in an
		/// organization. Returns the remaining read-only labels from the runner.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_org orgs/{org}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_orgReturn> ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_orgAsync(string org, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List labels for a self-hosted runner for an organization
		/// Lists all labels for a self-hosted runner configured in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashlist_labels_for_self_hosted_runner_for_org orgs/{org}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_labels_for_self_hosted_runner_for_orgReturn> ActionsSlashlist_labels_for_self_hosted_runner_for_orgAsync(string org, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_labels_for_self_hosted_runner_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add custom labels to a self-hosted runner for an organization
		/// Add custom labels to a self-hosted runner configured in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashadd_custom_labels_to_self_hosted_runner_for_org orgs/{org}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashadd_custom_labels_to_self_hosted_runner_for_orgReturn> ActionsSlashadd_custom_labels_to_self_hosted_runner_for_orgAsync(string org, int runner_id, ActionsSlashadd_custom_labels_to_self_hosted_runner_for_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashadd_custom_labels_to_self_hosted_runner_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set custom labels for a self-hosted runner for an organization
		/// Remove all previous custom labels and set the new custom labels for a specific
		/// self-hosted runner configured in an organization.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashset_custom_labels_for_self_hosted_runner_for_org orgs/{org}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashset_custom_labels_for_self_hosted_runner_for_orgReturn> ActionsSlashset_custom_labels_for_self_hosted_runner_for_orgAsync(string org, int runner_id, ActionsSlashset_custom_labels_for_self_hosted_runner_for_orgPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashset_custom_labels_for_self_hosted_runner_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a custom label from a self-hosted runner for an organization
		/// Remove a custom label from a self-hosted runner configured
		/// in an organization. Returns the remaining labels from the runner.
		/// 
		/// This endpoint returns a `404 Not Found` status if the custom label is not
		/// present on the runner.
		/// 
		/// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
		/// ActionsSlashremove_custom_label_from_self_hosted_runner_for_org orgs/{org}/actions/runners/{runner_id}/labels/{name}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <param name="name">The name of a self-hosted runner's custom label.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashremove_custom_label_from_self_hosted_runner_for_orgReturn> ActionsSlashremove_custom_label_from_self_hosted_runner_for_orgAsync(string org, int runner_id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/runners/"+runner_id+"/labels/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashremove_custom_label_from_self_hosted_runner_for_orgReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organization secrets
		/// Lists all secrets available in an organization without revealing their encrypted values. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
		/// ActionsSlashlist_org_secrets orgs/{org}/actions/secrets
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_org_secretsReturn> ActionsSlashlist_org_secretsAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_org_secretsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an organization public key
		/// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
		/// ActionsSlashget_org_public_key orgs/{org}/actions/secrets/public-key
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_public_key> ActionsSlashget_org_public_keyAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets/public-key";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_public_key>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an organization secret
		/// Deletes a secret in an organization using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
		/// ActionsSlashdelete_org_secret orgs/{org}/actions/secrets/{secret_name}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashdelete_org_secretAsync(string org, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an organization secret
		/// Gets a single organization secret without revealing its encrypted value. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
		/// ActionsSlashget_org_secret orgs/{org}/actions/secrets/{secret_name}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		/// <returns>Response</returns>
		public async Task<Organization_actions_secret> ActionsSlashget_org_secretAsync(string org, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_actions_secret>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update an organization secret
		/// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
		/// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
		/// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to
		/// use this endpoint.
		/// 
		/// #### Example encrypting a secret using Node.js
		/// 
		/// Encrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.
		/// 
		/// ```
		/// const sodium = require('libsodium-wrappers')
		/// const secret = 'plain-text-secret' // replace with the secret you want to encrypt
		/// const key = 'base64-encoded-public-key' // replace with the Base64 encoded public key
		/// 
		/// //Check if libsodium is ready and then proceed.
		/// sodium.ready.then(() => {
		/// // Convert Secret & Base64 key to Uint8Array.
		/// let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)
		/// let binsec = sodium.from_string(secret)
		/// 
		/// //Encrypt the secret using LibSodium
		/// let encBytes = sodium.crypto_box_seal(binsec, binkey)
		/// 
		/// // Convert encrypted Uint8Array to Base64
		/// let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
		/// 
		/// console.log(output)
		/// });
		/// ```
		/// 
		/// #### Example encrypting a secret using Python
		/// 
		/// Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.
		/// 
		/// ```
		/// from base64 import b64encode
		/// from nacl import encoding, public
		/// 
		/// def encrypt(public_key: str, secret_value: str) -> str:
		/// """Encrypt a Unicode string using the public key."""
		/// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
		/// sealed_box = public.SealedBox(public_key)
		/// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
		/// return b64encode(encrypted).decode("utf-8")
		/// ```
		/// 
		/// #### Example encrypting a secret using C#
		/// 
		/// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
		/// 
		/// ```
		/// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
		/// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
		/// 
		/// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
		/// 
		/// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
		/// ```
		/// 
		/// #### Example encrypting a secret using Ruby
		/// 
		/// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
		/// 
		/// ```ruby
		/// require "rbnacl"
		/// require "base64"
		/// 
		/// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
		/// public_key = RbNaCl::PublicKey.new(key)
		/// 
		/// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
		/// encrypted_secret = box.encrypt("my_secret")
		/// 
		/// # Print the base64 encoded secret
		/// puts Base64.strict_encode64(encrypted_secret)
		/// ```
		/// ActionsSlashcreate_or_update_org_secret orgs/{org}/actions/secrets/{secret_name}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashcreate_or_update_org_secretAsync(string org, string secret_name, ActionsSlashcreate_or_update_org_secretPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List selected repositories for an organization secret
		/// Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
		/// ActionsSlashlist_selected_repos_for_org_secret orgs/{org}/actions/secrets/{secret_name}/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_selected_repos_for_org_secretReturn> ActionsSlashlist_selected_repos_for_org_secretAsync(string org, string secret_name, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name))+"/repositories&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_selected_repos_for_org_secretReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set selected repositories for an organization secret
		/// Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
		/// ActionsSlashset_selected_repos_for_org_secret orgs/{org}/actions/secrets/{secret_name}/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashset_selected_repos_for_org_secretAsync(string org, string secret_name, ActionsSlashset_selected_repos_for_org_secretPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name))+"/repositories";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove selected repository from an organization secret
		/// Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
		/// ActionsSlashremove_selected_repo_from_org_secret orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashremove_selected_repo_from_org_secretAsync(string org, string secret_name, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name))+"/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add selected repository to an organization secret
		/// Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
		/// ActionsSlashadd_selected_repo_to_org_secret orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashadd_selected_repo_to_org_secretAsync(string org, string secret_name, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name))+"/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the audit log for an organization
		/// Gets the audit log for an organization. For more information, see "[Reviewing the audit log for your organization](https://docs.github.com/enterprise-server@3.6/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization)."
		/// 
		/// To use this endpoint, you must be an organization owner, and you must use an access token with the `admin:org` scope. GitHub Apps must have the `organization_administration` read permission to use this endpoint.
		/// 
		/// By default, the response includes up to 30 events from the past three months. Use the `phrase` parameter to filter results and retrieve older events. For example, use the `phrase` parameter with the `created` qualifier to filter events based on when the events occurred. For more information, see "[Reviewing the audit log for your organization](https://docs.github.com/enterprise-server@3.6/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/reviewing-the-audit-log-for-your-organization#searching-the-audit-log)."
		/// 
		/// Use pagination to retrieve fewer or more than 30 events. For more information, see "[Resources in the REST API](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination)."
		/// OrgsSlashget_audit_log orgs/{org}/audit-log
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="phrase">A search phrase. For more information, see [Searching the audit log](https://docs.github.com/enterprise-server@3.6/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization#searching-the-audit-log).</param>
		/// <param name="include">The event types to include:
		///
		///- `web` - returns web (non-Git) events.
		///- `git` - returns Git events.
		///- `all` - returns both web and Git events.
		///
		///The default is `web`.</param>
		/// <param name="after">A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for events after this cursor.</param>
		/// <param name="before">A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for events before this cursor.</param>
		/// <param name="order">The order of audit log events. To list newest events first, specify `desc`. To list oldest events first, specify `asc`.
		///
		///The default is `desc`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Audit_log_event[]> OrgsSlashget_audit_logAsync(string org, string phrase, Enterprise_adminSlashget_audit_logInclude include, string after, string before, Enterprise_adminSlashget_audit_logOrder order, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/audit-log&phrase=" + (phrase==null? "" : System.Uri.EscapeDataString(phrase))+"&include=" + include+"&after=" + (after==null? "" : System.Uri.EscapeDataString(after))+"&before=" + (before==null? "" : System.Uri.EscapeDataString(before))+"&order=" + order+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Audit_log_event[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List code scanning alerts for an organization
		/// Lists code scanning alerts for the default branch for all eligible repositories in an organization. Eligible repositories are repositories that are owned by organizations that you own or for which you are a security manager. For more information, see "[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.6/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
		/// 
		/// To use this endpoint, you must be an owner or security manager for the organization, and you must use an access token with the `repo` scope or `security_events` scope.
		/// 
		/// GitHub Apps must have the `security_events` read permission to use this endpoint.
		/// Code_scanningSlashlist_alerts_for_org orgs/{org}/code-scanning/alerts
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="tool_name">The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.</param>
		/// <param name="tool_guid">The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.</param>
		/// <param name="before">A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for results before this cursor.</param>
		/// <param name="after">A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches for results after this cursor.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="state">If specified, only code scanning alerts with this state will be returned.</param>
		/// <param name="sort">The property by which to sort the results.</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_organization_alert_items[]> Code_scanningSlashlist_alerts_for_orgAsync(string org, string tool_name, string tool_guid, string before, string after, int page, int per_page, Enterprise_adminSlashlist_public_keysDirection direction, Code_scanning_alert_state state, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/code-scanning/alerts&tool_name=" + (tool_name==null? "" : System.Uri.EscapeDataString(tool_name))+"&tool_guid=" + (tool_guid==null? "" : System.Uri.EscapeDataString(tool_guid))+"&before=" + (before==null? "" : System.Uri.EscapeDataString(before))+"&after=" + (after==null? "" : System.Uri.EscapeDataString(after))+"&page="+page+"&per_page="+per_page+"&direction=" + direction+"&state=" + state+"&sort=" + sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_organization_alert_items[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organization secrets
		/// Lists all secrets available in an organization without revealing their encrypted values. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
		/// DependabotSlashlist_org_secrets orgs/{org}/dependabot/secrets
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<DependabotSlashlist_org_secretsReturn> DependabotSlashlist_org_secretsAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DependabotSlashlist_org_secretsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an organization public key
		/// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
		/// DependabotSlashget_org_public_key orgs/{org}/dependabot/secrets/public-key
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Dependabot_public_key> DependabotSlashget_org_public_keyAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets/public-key";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Dependabot_public_key>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an organization secret
		/// Deletes a secret in an organization using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
		/// DependabotSlashdelete_org_secret orgs/{org}/dependabot/secrets/{secret_name}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task DependabotSlashdelete_org_secretAsync(string org, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an organization secret
		/// Gets a single organization secret without revealing its encrypted value. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
		/// DependabotSlashget_org_secret orgs/{org}/dependabot/secrets/{secret_name}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		/// <returns>Response</returns>
		public async Task<Organization_dependabot_secret> DependabotSlashget_org_secretAsync(string org, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_dependabot_secret>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update an organization secret
		/// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
		/// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
		/// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization
		/// permission to use this endpoint.
		/// 
		/// #### Example encrypting a secret using Node.js
		/// 
		/// Encrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.
		/// 
		/// ```
		/// const sodium = require('libsodium-wrappers')
		/// const secret = 'plain-text-secret' // replace with the secret you want to encrypt
		/// const key = 'base64-encoded-public-key' // replace with the Base64 encoded public key
		/// 
		/// //Check if libsodium is ready and then proceed.
		/// sodium.ready.then(() => {
		/// // Convert Secret & Base64 key to Uint8Array.
		/// let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)
		/// let binsec = sodium.from_string(secret)
		/// 
		/// //Encrypt the secret using LibSodium
		/// let encBytes = sodium.crypto_box_seal(binsec, binkey)
		/// 
		/// // Convert encrypted Uint8Array to Base64
		/// let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
		/// 
		/// console.log(output)
		/// });
		/// ```
		/// 
		/// #### Example encrypting a secret using Python
		/// 
		/// Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.
		/// 
		/// ```
		/// from base64 import b64encode
		/// from nacl import encoding, public
		/// 
		/// def encrypt(public_key: str, secret_value: str) -> str:
		/// """Encrypt a Unicode string using the public key."""
		/// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
		/// sealed_box = public.SealedBox(public_key)
		/// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
		/// return b64encode(encrypted).decode("utf-8")
		/// ```
		/// 
		/// #### Example encrypting a secret using C#
		/// 
		/// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
		/// 
		/// ```
		/// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
		/// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
		/// 
		/// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
		/// 
		/// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
		/// ```
		/// 
		/// #### Example encrypting a secret using Ruby
		/// 
		/// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
		/// 
		/// ```ruby
		/// require "rbnacl"
		/// require "base64"
		/// 
		/// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
		/// public_key = RbNaCl::PublicKey.new(key)
		/// 
		/// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
		/// encrypted_secret = box.encrypt("my_secret")
		/// 
		/// # Print the base64 encoded secret
		/// puts Base64.strict_encode64(encrypted_secret)
		/// ```
		/// DependabotSlashcreate_or_update_org_secret orgs/{org}/dependabot/secrets/{secret_name}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task DependabotSlashcreate_or_update_org_secretAsync(string org, string secret_name, DependabotSlashcreate_or_update_org_secretPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List selected repositories for an organization secret
		/// Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
		/// DependabotSlashlist_selected_repos_for_org_secret orgs/{org}/dependabot/secrets/{secret_name}/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<DependabotSlashlist_selected_repos_for_org_secretReturn> DependabotSlashlist_selected_repos_for_org_secretAsync(string org, string secret_name, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name))+"/repositories&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DependabotSlashlist_selected_repos_for_org_secretReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set selected repositories for an organization secret
		/// Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
		/// DependabotSlashset_selected_repos_for_org_secret orgs/{org}/dependabot/secrets/{secret_name}/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task DependabotSlashset_selected_repos_for_org_secretAsync(string org, string secret_name, DependabotSlashset_selected_repos_for_org_secretPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name))+"/repositories";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove selected repository from an organization secret
		/// Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
		/// DependabotSlashremove_selected_repo_from_org_secret orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task DependabotSlashremove_selected_repo_from_org_secretAsync(string org, string secret_name, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name))+"/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add selected repository to an organization secret
		/// Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
		/// DependabotSlashadd_selected_repo_to_org_secret orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task DependabotSlashadd_selected_repo_to_org_secretAsync(string org, string secret_name, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name))+"/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List public organization events
		/// ActivitySlashlist_public_org_events orgs/{org}/events
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_public_org_eventsAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/events&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an external group
		/// Displays information about the specific group's usage.  Provides a list of the group's external members as well as a list of teams that this group is connected to.
		/// 
		/// You can manage team membership with your identity provider using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products)" in the GitHub Help documentation.
		/// TeamsSlashexternal_idp_group_info_for_org orgs/{org}/external-group/{group_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="group_id">The unique identifier of the group.</param>
		/// <returns>Response</returns>
		public async Task<External_group> TeamsSlashexternal_idp_group_info_for_orgAsync(string org, int group_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/external-group/"+group_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<External_group>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List external groups in an organization
		/// Lists external groups available in an organization. You can query the groups using the `display_name` parameter, only groups with a `group_name` containing the text provided in the `display_name` parameter will be returned.  You can also limit your page results using the `per_page` parameter. GitHub Enterprise Server generates a url-encoded `page` token using a cursor value for where the next page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89)."
		/// 
		/// You can manage team membership with your identity provider using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products)" in the GitHub Help documentation.
		/// TeamsSlashlist_external_idp_groups_for_org orgs/{org}/external-groups
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page token</param>
		/// <param name="display_name">Limits the list to groups containing the text in the group name</param>
		/// <returns>Response</returns>
		public async Task<External_groups> TeamsSlashlist_external_idp_groups_for_orgAsync(string org, int per_page, int page, string display_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/external-groups&per_page="+per_page+"&page="+page+"&display_name=" + (display_name==null? "" : System.Uri.EscapeDataString(display_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<External_groups>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organization webhooks
		/// OrgsSlashlist_webhooks orgs/{org}/hooks
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Org_hook[]> OrgsSlashlist_webhooksAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_hook[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an organization webhook
		/// Here's how you can create a hook that posts payloads in JSON format:
		/// OrgsSlashcreate_webhook orgs/{org}/hooks
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task OrgsSlashcreate_webhookAsync(string org, OrgsSlashcreate_webhookPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an organization webhook
		/// OrgsSlashdelete_webhook orgs/{org}/hooks/{hook_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task OrgsSlashdelete_webhookAsync(string org, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an organization webhook
		/// Returns a webhook configured in an organization. To get only the webhook `config` properties, see "[Get a webhook configuration for an organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization)."
		/// OrgsSlashget_webhook orgs/{org}/hooks/{hook_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Org_hook> OrgsSlashget_webhookAsync(string org, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an organization webhook
		/// Updates a webhook configured in an organization. When you update a webhook, the `secret` will be overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for an organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization)."
		/// OrgsSlashupdate_webhook orgs/{org}/hooks/{hook_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Org_hook> OrgsSlashupdate_webhookAsync(string org, int hook_id, OrgsSlashupdate_webhookPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a webhook configuration for an organization
		/// Returns the webhook configuration for an organization. To get more information about the webhook, including the `active` state and `events`, use "[Get an organization webhook ](/rest/reference/orgs#get-an-organization-webhook)."
		/// 
		/// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the `organization_hooks:read` permission.
		/// OrgsSlashget_webhook_config_for_org orgs/{org}/hooks/{hook_id}/config
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Webhook_config> OrgsSlashget_webhook_config_for_orgAsync(string org, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id+"/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Webhook_config>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a webhook configuration for an organization
		/// Updates the webhook configuration for an organization. To update more information about the webhook, including the `active` state and `events`, use "[Update an organization webhook ](/rest/reference/orgs#update-an-organization-webhook)."
		/// 
		/// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the `organization_hooks:write` permission.
		/// OrgsSlashupdate_webhook_config_for_org orgs/{org}/hooks/{hook_id}/config
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Webhook_config> OrgsSlashupdate_webhook_config_for_orgAsync(string org, int hook_id, OrgsSlashupdate_webhook_config_for_orgPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id+"/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Webhook_config>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List deliveries for an organization webhook
		/// Returns a list of webhook deliveries for a webhook configured in an organization.
		/// OrgsSlashlist_webhook_deliveries orgs/{org}/hooks/{hook_id}/deliveries
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="cursor">Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.</param>
		/// <returns>Response</returns>
		public async Task<Hook_delivery_item[]> OrgsSlashlist_webhook_deliveriesAsync(string org, int hook_id, int per_page, string cursor, bool redelivery, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id+"/deliveries&per_page="+per_page+"&cursor=" + (cursor==null? "" : System.Uri.EscapeDataString(cursor))+"&redelivery="+redelivery;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook_delivery_item[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a webhook delivery for an organization webhook
		/// Returns a delivery for a webhook configured in an organization.
		/// OrgsSlashget_webhook_delivery orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Hook_delivery> OrgsSlashget_webhook_deliveryAsync(string org, int hook_id, int delivery_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id+"/deliveries/"+delivery_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook_delivery>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Redeliver a delivery for an organization webhook
		/// Redeliver a delivery for a webhook configured in an organization.
		/// OrgsSlashredeliver_webhook_delivery orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task OrgsSlashredeliver_webhook_deliveryAsync(string org, int hook_id, int delivery_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id+"/deliveries/"+delivery_id+"/attempts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Ping an organization webhook
		/// This will trigger a [ping event](https://docs.github.com/enterprise-server@3.6/webhooks/#ping-event) to be sent to the hook.
		/// OrgsSlashping_webhook orgs/{org}/hooks/{hook_id}/pings
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task OrgsSlashping_webhookAsync(string org, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/hooks/"+hook_id+"/pings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an organization installation for the authenticated app
		/// Enables an authenticated GitHub App to find the organization's installation information.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashget_org_installation orgs/{org}/installation
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Installation> AppsSlashget_org_installationAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/installation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Installation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List app installations for an organization
		/// Lists all GitHub Apps in an organization. The installation count includes all GitHub Apps installed on repositories in the organization. You must be an organization owner with `admin:read` scope to use this endpoint.
		/// OrgsSlashlist_app_installations orgs/{org}/installations
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<OrgsSlashlist_app_installationsReturn> OrgsSlashlist_app_installationsAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/installations&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OrgsSlashlist_app_installationsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organization issues assigned to the authenticated user
		/// List issues in an organization assigned to the authenticated user.
		/// 
		/// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
		/// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
		/// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
		/// request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#list-pull-requests)" endpoint.
		/// IssuesSlashlist_for_org orgs/{org}/issues
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="filter">Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.</param>
		/// <param name="state">Indicates the state of the issues to return.</param>
		/// <param name="labels">A list of comma separated label names. Example: `bug,ui,@high`</param>
		/// <param name="sort">What to sort results by.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Issue[]> IssuesSlashlist_for_orgAsync(string org, IssuesSlashlistFilter filter, IssuesSlashlistState state, string labels, IssuesSlashlistSort sort, Enterprise_adminSlashlist_public_keysDirection direction, System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/issues&filter=" + filter+"&state=" + state+"&labels=" + (labels==null? "" : System.Uri.EscapeDataString(labels))+"&sort=" + sort+"&direction=" + direction+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organization members
		/// List all users who are members of an organization. If the authenticated user is also a member of this organization then both concealed and public members will be returned.
		/// OrgsSlashlist_members orgs/{org}/members
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="filter">Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. This options is only available for organization owners.</param>
		/// <param name="role">Filter members returned by their role.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> OrgsSlashlist_membersAsync(string org, OrgsSlashlist_membersFilter filter, OrgsSlashlist_membersRole role, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/members&filter=" + filter+"&role=" + role+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove an organization member
		/// Removing a user from this list will remove them from all teams and they will no longer have any access to the organization's repositories.
		/// OrgsSlashremove_member orgs/{org}/members/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task OrgsSlashremove_memberAsync(string org, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/members/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check organization membership for a user
		/// Check if a user is, publicly or privately, a member of the organization.
		/// OrgsSlashcheck_membership_for_user orgs/{org}/members/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task OrgsSlashcheck_membership_for_userAsync(string org, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/members/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove organization membership for a user
		/// In order to remove a user's membership with an organization, the authenticated user must be an organization owner.
		/// 
		/// If the specified user is an active member of the organization, this will remove them from the organization. If the specified user has been invited to the organization, this will cancel their invitation. The specified user will receive an email notification in both cases.
		/// OrgsSlashremove_membership_for_user orgs/{org}/memberships/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task OrgsSlashremove_membership_for_userAsync(string org, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get organization membership for a user
		/// In order to get a user's membership with an organization, the authenticated user must be an organization member. The `state` parameter in the response can be used to identify the user's membership status.
		/// OrgsSlashget_membership_for_user orgs/{org}/memberships/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Org_membership> OrgsSlashget_membership_for_userAsync(string org, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_membership>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set organization membership for a user
		/// Only authenticated organization owners can add a member to the organization or update the member's role.
		/// 
		/// *   If the authenticated user is _adding_ a member to the organization, the invited user will receive an email inviting them to the organization. The user's [membership status](https://docs.github.com/enterprise-server@3.6/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until they accept the invitation.
		/// 
		/// *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the authenticated user changes a member's role to `admin`, the affected user will receive an email notifying them that they've been made an organization owner. If the authenticated user changes an owner's role to `member`, no email will be sent.
		/// 
		/// **Rate limits**
		/// 
		/// To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour period. If the organization is more than one month old or on a paid plan, the limit is 500 invitations per 24 hour period.
		/// OrgsSlashset_membership_for_user orgs/{org}/memberships/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Org_membership> OrgsSlashset_membership_for_userAsync(string org, string username, OrgsSlashset_membership_for_userPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_membership>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List organization migrations
		/// Lists the most recent migrations, including both exports (which can be started through the REST API) and imports (which cannot be started using the REST API).
		/// 
		/// A list of `repositories` is only returned for export migrations.
		/// MigrationsSlashlist_for_org orgs/{org}/migrations
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="exclude">Exclude attributes from the API response to improve performance</param>
		/// <returns>Response</returns>
		public async Task<Migration[]> MigrationsSlashlist_for_orgAsync(string org, int per_page, int page, string[] exclude, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/migrations&per_page="+per_page+"&page="+page+"&"+string.Join("&", exclude.Select(z => $"exclude={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Migration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start an organization migration
		/// Initiates the generation of a migration archive.
		/// MigrationsSlashstart_for_org orgs/{org}/migrations
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task MigrationsSlashstart_for_orgAsync(string org, MigrationsSlashstart_for_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/migrations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an organization migration status
		/// Fetches the status of a migration.
		/// 
		/// The `state` of a migration can be one of the following values:
		/// 
		/// *   `pending`, which means the migration hasn't started yet.
		/// *   `exporting`, which means the migration is in progress.
		/// *   `exported`, which means the migration finished successfully.
		/// *   `failed`, which means the migration failed.
		/// MigrationsSlashget_status_for_org orgs/{org}/migrations/{migration_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="migration_id">The unique identifier of the migration.</param>
		/// <param name="exclude">Exclude attributes from the API response to improve performance</param>
		/// <returns>*   `pending`, which means the migration hasn't started yet.
		///*   `exporting`, which means the migration is in progress.
		///*   `exported`, which means the migration finished successfully.
		///*   `failed`, which means the migration failed.</returns>
		public async Task<Migration> MigrationsSlashget_status_for_orgAsync(string org, int migration_id, string[] exclude, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/migrations/"+migration_id+"&"+string.Join("&", exclude.Select(z => $"exclude={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Migration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an organization migration archive
		/// Deletes a previous migration archive. Migration archives are automatically deleted after seven days.
		/// MigrationsSlashdelete_archive_for_org orgs/{org}/migrations/{migration_id}/archive
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="migration_id">The unique identifier of the migration.</param>
		public async Task MigrationsSlashdelete_archive_for_orgAsync(string org, int migration_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/migrations/"+migration_id+"/archive";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download an organization migration archive
		/// Fetches the URL to a migration archive.
		/// MigrationsSlashdownload_archive_for_org orgs/{org}/migrations/{migration_id}/archive
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="migration_id">The unique identifier of the migration.</param>
		public async Task MigrationsSlashdownload_archive_for_orgAsync(string org, int migration_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/migrations/"+migration_id+"/archive";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unlock an organization repository
		/// Unlocks a repository that was locked for migration. You should unlock each migrated repository and [delete them](https://docs.github.com/enterprise-server@3.6/rest/repos/repos#delete-a-repository) when the migration is complete and you no longer need the source data.
		/// MigrationsSlashunlock_repo_for_org orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="migration_id">The unique identifier of the migration.</param>
		/// <param name="repo_name">repo_name parameter</param>
		public async Task MigrationsSlashunlock_repo_for_orgAsync(string org, int migration_id, string repo_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/migrations/"+migration_id+"/repos/"+ (repo_name==null? "" : System.Uri.EscapeDataString(repo_name))+"/lock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories in an organization migration
		/// List all the repositories for this organization migration.
		/// MigrationsSlashlist_repos_for_org orgs/{org}/migrations/{migration_id}/repositories
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="migration_id">The unique identifier of the migration.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> MigrationsSlashlist_repos_for_orgAsync(string org, int migration_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/migrations/"+migration_id+"/repositories&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List outside collaborators for an organization
		/// List all users who are outside collaborators of an organization.
		/// OrgsSlashlist_outside_collaborators orgs/{org}/outside_collaborators
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="filter">Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> OrgsSlashlist_outside_collaboratorsAsync(string org, OrgsSlashlist_outside_collaboratorsFilter filter, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/outside_collaborators&filter=" + filter+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove outside collaborator from an organization
		/// Removing a user from this list will remove them from all the organization's repositories.
		/// OrgsSlashremove_outside_collaborator orgs/{org}/outside_collaborators/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task OrgsSlashremove_outside_collaboratorAsync(string org, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/outside_collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Convert an organization member to outside collaborator
		/// When an organization member is converted to an outside collaborator, they'll only have access to the repositories that their current team membership allows. The user will no longer be a member of the organization. For more information, see "[Converting an organization member to an outside collaborator](https://docs.github.com/enterprise-server@3.6/articles/converting-an-organization-member-to-an-outside-collaborator/)". Converting an organization member to an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/enterprise-server@3.6/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."
		/// OrgsSlashconvert_member_to_outside_collaborator orgs/{org}/outside_collaborators/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task OrgsSlashconvert_member_to_outside_collaboratorAsync(string org, string username, OrgsSlashconvert_member_to_outside_collaboratorPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/outside_collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List pre-receive hooks for an organization
		/// List all pre-receive hooks that are enabled or testing for this organization as well as any disabled hooks that can be configured at the organization level. Globally disabled pre-receive hooks that do not allow downstream configuration are not listed.
		/// Enterprise_adminSlashlist_pre_receive_hooks_for_org orgs/{org}/pre-receive-hooks
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="sort">The sort order for the response collection.</param>
		/// <returns>Response</returns>
		public async Task<Org_pre_receive_hook[]> Enterprise_adminSlashlist_pre_receive_hooks_for_orgAsync(string org, int per_page, int page, Enterprise_adminSlashlist_public_keysDirection direction, Enterprise_adminSlashlist_pre_receive_environmentsSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/pre-receive-hooks&per_page="+per_page+"&page="+page+"&direction=" + direction+"&sort=" + sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_pre_receive_hook[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove pre-receive hook enforcement for an organization
		/// Removes any overrides for this hook at the org level for this org.
		/// Enterprise_adminSlashremove_pre_receive_hook_enforcement_for_org orgs/{org}/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		/// <returns>Response</returns>
		public async Task<Org_pre_receive_hook> Enterprise_adminSlashremove_pre_receive_hook_enforcement_for_orgAsync(string org, int pre_receive_hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_pre_receive_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a pre-receive hook for an organization
		/// Enterprise_adminSlashget_pre_receive_hook_for_org orgs/{org}/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		/// <returns>Response</returns>
		public async Task<Org_pre_receive_hook> Enterprise_adminSlashget_pre_receive_hook_for_orgAsync(string org, int pre_receive_hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_pre_receive_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update pre-receive hook enforcement for an organization
		/// For pre-receive hooks which are allowed to be configured at the org level, you can set `enforcement` and `allow_downstream_configuration`
		/// Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_org orgs/{org}/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		/// <returns>Response</returns>
		public async Task<Org_pre_receive_hook> Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_orgAsync(string org, int pre_receive_hook_id, Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_orgPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_pre_receive_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List organization projects
		/// Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled in the organization. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
		/// ProjectsSlashlist_for_org orgs/{org}/projects
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="state">Indicates the state of the projects to return.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Project[]> ProjectsSlashlist_for_orgAsync(string org, IssuesSlashlistState state, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/projects&state=" + state+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an organization project
		/// Creates an organization project board. Returns a `410 Gone` status if projects are disabled in the organization or if the organization does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
		/// ProjectsSlashcreate_for_org orgs/{org}/projects
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ProjectsSlashcreate_for_orgAsync(string org, ProjectsSlashcreate_for_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/projects";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List public organization members
		/// Members of an organization can choose to have their membership publicized or not.
		/// OrgsSlashlist_public_members orgs/{org}/public_members
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> OrgsSlashlist_public_membersAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/public_members&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove public organization membership for the authenticated user
		/// OrgsSlashremove_public_membership_for_authenticated_user orgs/{org}/public_members/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task OrgsSlashremove_public_membership_for_authenticated_userAsync(string org, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/public_members/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check public organization membership for a user
		/// OrgsSlashcheck_public_membership_for_user orgs/{org}/public_members/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task OrgsSlashcheck_public_membership_for_userAsync(string org, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/public_members/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set public organization membership for the authenticated user
		/// The user can publicize their own membership. (A user cannot publicize the membership for another user.)
		/// 
		/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// OrgsSlashset_public_membership_for_authenticated_user orgs/{org}/public_members/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task OrgsSlashset_public_membership_for_authenticated_userAsync(string org, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/public_members/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organization repositories
		/// Lists repositories for the specified organization.
		/// ReposSlashlist_for_org orgs/{org}/repos
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="type">Specifies the types of repositories you want returned. `internal` is not yet supported when a GitHub App calls this endpoint with an installation access token.</param>
		/// <param name="sort">The property to sort the results by.</param>
		/// <param name="direction">The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> ReposSlashlist_for_orgAsync(string org, ReposSlashlist_for_orgType type, ReposSlashlist_for_orgSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/repos&type=" + type+"&sort=" + sort+"&direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an organization repository
		/// Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
		/// 
		/// **OAuth scope requirements**
		/// 
		/// When using [OAuth](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
		/// 
		/// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
		/// *   `repo` scope to create a private repository
		/// ReposSlashcreate_in_org orgs/{org}/repos
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_in_orgAsync(string org, ReposSlashcreate_in_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/repos";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List secret scanning alerts for an organization
		/// Lists secret scanning alerts for eligible repositories in an organization, from newest to oldest.
		/// To use this endpoint, you must be an administrator or security manager for the organization, and you must use an access token with the `repo` scope or `security_events` scope.
		/// For public repositories, you may instead use the `public_repo` scope.
		/// 
		/// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
		/// Secret_scanningSlashlist_alerts_for_org orgs/{org}/secret-scanning/alerts
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="state">Set to `open` or `resolved` to only list secret scanning alerts in a specific state.</param>
		/// <param name="secret_type">A comma-separated list of secret types to return. By default all secret types are returned.
		///See "[Secret scanning patterns](https://docs.github.com/enterprise-server@3.6/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)"
		///for a complete list of secret types.</param>
		/// <param name="resolution">A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.</param>
		/// <param name="sort">The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<Organization_secret_scanning_alert[]> Secret_scanningSlashlist_alerts_for_orgAsync(string org, Organization_secret_scanning_alertState state, string secret_type, string resolution, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/secret-scanning/alerts&state=" + state+"&secret_type=" + (secret_type==null? "" : System.Uri.EscapeDataString(secret_type))+"&resolution=" + (resolution==null? "" : System.Uri.EscapeDataString(resolution))+"&sort=" + sort+"&direction=" + direction+"&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_secret_scanning_alert[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Advanced Security active committers for an organization
		/// Gets the GitHub Advanced Security active committers for an organization per repository.
		/// 
		/// Each distinct user login across all repositories is counted as a single Advanced Security seat, so the `total_advanced_security_committers` is not the sum of advanced_security_committers for each repository.
		/// 
		/// If this organization defers to an enterprise for billing, the `total_advanced_security_committers` returned from the organization API may include some users that are in more than one organization, so they will only consume a single Advanced Security seat at the enterprise level.
		/// 
		/// The total number of repositories with committer information is tracked by the `total_count` field.
		/// BillingSlashget_github_advanced_security_billing_org orgs/{org}/settings/billing/advanced-security
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Success</returns>
		public async Task<Advanced_security_active_committers> BillingSlashget_github_advanced_security_billing_orgAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/settings/billing/advanced-security&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Advanced_security_active_committers>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List teams
		/// Lists all teams in an organization that are visible to the authenticated user.
		/// TeamsSlashlist orgs/{org}/teams
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Team[]> TeamsSlashlistAsync(string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a team
		/// To create a team, the authenticated user must be a member or owner of `{org}`. By default, organization members can create teams. Organization owners can limit team creation to organization owners. For more information, see "[Setting team creation permissions](https://docs.github.com/enterprise-server@3.6/articles/setting-team-creation-permissions-in-your-organization)."
		/// 
		/// When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of `maintainers`. For more information, see "[About teams](https://docs.github.com/enterprise-server@3.6/github/setting-up-and-managing-organizations-and-teams/about-teams)".
		/// TeamsSlashcreate orgs/{org}/teams
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		public async Task TeamsSlashcreateAsync(string org, TeamsSlashcreatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a team
		/// To delete a team, the authenticated user must be an organization owner or team maintainer.
		/// 
		/// If you are an organization owner, deleting a parent team will delete all of its child teams as well.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}`.
		/// TeamsSlashdelete_in_org orgs/{org}/teams/{team_slug}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		public async Task TeamsSlashdelete_in_orgAsync(string org, string team_slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a team by name
		/// Gets a team using the team's `slug`. To create the `slug`, GitHub Enterprise Server replaces special characters in the `name` string, changes all words to lowercase, and replaces spaces with a `-` separator. For example, `"My TEam Näme"` would become `my-team-name`.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}`.
		/// TeamsSlashget_by_name orgs/{org}/teams/{team_slug}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <returns>Response</returns>
		public async Task<Team_full> TeamsSlashget_by_nameAsync(string org, string team_slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_full>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a team
		/// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}`.
		/// TeamsSlashupdate_in_org orgs/{org}/teams/{team_slug}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <returns>Response when the updated information already exists</returns>
		public async Task<Team_full> TeamsSlashupdate_in_orgAsync(string org, string team_slug, TeamsSlashupdate_in_orgPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_full>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List discussions
		/// List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions`.
		/// TeamsSlashlist_discussions_in_org orgs/{org}/teams/{team_slug}/discussions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="pinned">Pinned discussions only filter</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion[]> TeamsSlashlist_discussions_in_orgAsync(string org, string team_slug, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, string pinned, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions&direction=" + direction+"&per_page="+per_page+"&page="+page+"&pinned=" + (pinned==null? "" : System.Uri.EscapeDataString(pinned));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a discussion
		/// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions`.
		/// TeamsSlashcreate_discussion_in_org orgs/{org}/teams/{team_slug}/discussions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		public async Task TeamsSlashcreate_discussion_in_orgAsync(string org, string team_slug, TeamsSlashcreate_discussion_in_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a discussion
		/// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
		/// TeamsSlashdelete_discussion_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		public async Task TeamsSlashdelete_discussion_in_orgAsync(string org, string team_slug, int discussion_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a discussion
		/// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
		/// TeamsSlashget_discussion_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion> TeamsSlashget_discussion_in_orgAsync(string org, string team_slug, int discussion_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a discussion
		/// Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
		/// TeamsSlashupdate_discussion_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion> TeamsSlashupdate_discussion_in_orgAsync(string org, string team_slug, int discussion_number, TeamsSlashupdate_discussion_in_orgPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List discussion comments
		/// List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
		/// TeamsSlashlist_discussion_comments_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion_comment[]> TeamsSlashlist_discussion_comments_in_orgAsync(string org, string team_slug, int discussion_number, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/comments&direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a discussion comment
		/// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
		/// TeamsSlashcreate_discussion_comment_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		public async Task TeamsSlashcreate_discussion_comment_in_orgAsync(string org, string team_slug, int discussion_number, TeamsSlashcreate_discussion_comment_in_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/comments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a discussion comment
		/// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
		/// TeamsSlashdelete_discussion_comment_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		public async Task TeamsSlashdelete_discussion_comment_in_orgAsync(string org, string team_slug, int discussion_number, int comment_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/comments/"+comment_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a discussion comment
		/// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
		/// TeamsSlashget_discussion_comment_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion_comment> TeamsSlashget_discussion_comment_in_orgAsync(string org, string team_slug, int discussion_number, int comment_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/comments/"+comment_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a discussion comment
		/// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
		/// TeamsSlashupdate_discussion_comment_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion_comment> TeamsSlashupdate_discussion_comment_in_orgAsync(string org, string team_slug, int discussion_number, int comment_number, TeamsSlashupdate_discussion_comment_in_orgPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/comments/"+comment_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List reactions for a team discussion comment
		/// List the reactions to a [team discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
		/// ReactionsSlashlist_for_team_discussion_comment_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_team_discussion_comment_in_orgAsync(string org, string team_slug, int discussion_number, int comment_number, ReactionsSlashlist_for_team_discussion_comment_in_orgContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/comments/"+comment_number+"/reactions&content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for a team discussion comment
		/// Create a reaction to a [team discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
		/// ReactionsSlashcreate_for_team_discussion_comment_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		/// <returns>Response when the reaction type has already been added to this team discussion comment</returns>
		public async Task<Reaction> ReactionsSlashcreate_for_team_discussion_comment_in_orgAsync(string org, string team_slug, int discussion_number, int comment_number, ReactionsSlashcreate_for_team_discussion_comment_in_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/comments/"+comment_number+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete team discussion comment reaction
		/// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
		/// 
		/// Delete a reaction to a [team discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// ReactionsSlashdelete_for_team_discussion_comment orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		/// <param name="reaction_id">The unique identifier of the reaction.</param>
		public async Task ReactionsSlashdelete_for_team_discussion_commentAsync(string org, string team_slug, int discussion_number, int comment_number, int reaction_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/comments/"+comment_number+"/reactions/"+reaction_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List reactions for a team discussion
		/// List the reactions to a [team discussion](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
		/// ReactionsSlashlist_for_team_discussion_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_team_discussion_in_orgAsync(string org, string team_slug, int discussion_number, ReactionsSlashlist_for_team_discussion_in_orgContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/reactions&content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for a team discussion
		/// Create a reaction to a [team discussion](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
		/// ReactionsSlashcreate_for_team_discussion_in_org orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <returns>Response</returns>
		public async Task<Reaction> ReactionsSlashcreate_for_team_discussion_in_orgAsync(string org, string team_slug, int discussion_number, ReactionsSlashcreate_for_team_discussion_in_orgPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete team discussion reaction
		/// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
		/// 
		/// Delete a reaction to a [team discussion](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// ReactionsSlashdelete_for_team_discussion orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="reaction_id">The unique identifier of the reaction.</param>
		public async Task ReactionsSlashdelete_for_team_discussionAsync(string org, string team_slug, int discussion_number, int reaction_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/discussions/"+discussion_number+"/reactions/"+reaction_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove the connection between an external group and a team
		/// Deletes a connection between a team and an external group.
		/// 
		/// You can manage team membership with your IdP using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// TeamsSlashunlink_external_idp_group_from_team_for_org orgs/{org}/teams/{team_slug}/external-groups
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		public async Task TeamsSlashunlink_external_idp_group_from_team_for_orgAsync(string org, string team_slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/external-groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List a connection between an external group and a team
		/// Lists a connection between a team and an external group.
		/// 
		/// You can manage team membership with your identity provider using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products)" in the GitHub Help documentation.
		/// TeamsSlashlist_linked_external_idp_groups_to_team_for_org orgs/{org}/teams/{team_slug}/external-groups
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <returns>Response</returns>
		public async Task<External_groups> TeamsSlashlist_linked_external_idp_groups_to_team_for_orgAsync(string org, string team_slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/external-groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<External_groups>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the connection between an external group and a team
		/// Creates a connection between a team and an external group.  Only one external group can be linked to a team.
		/// 
		/// You can manage team membership with your identity provider using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products)" in the GitHub Help documentation.
		/// TeamsSlashlink_external_idp_group_to_team_for_org orgs/{org}/teams/{team_slug}/external-groups
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <returns>Response</returns>
		public async Task<External_group> TeamsSlashlink_external_idp_group_to_team_for_orgAsync(string org, string team_slug, TeamsSlashlink_external_idp_group_to_team_for_orgPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/external-groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<External_group>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List team members
		/// Team members will include the members of child teams.
		/// 
		/// To list members in a team, the team must be visible to the authenticated user.
		/// TeamsSlashlist_members_in_org orgs/{org}/teams/{team_slug}/members
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="role">Filters members returned by their role in the team.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> TeamsSlashlist_members_in_orgAsync(string org, string team_slug, TeamsSlashlist_members_in_orgRole role, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/members&role=" + role+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove team membership for a user
		/// To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.
		/// 
		/// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub Enterprise Server team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub Enterprise Server](https://docs.github.com/enterprise-server@3.6/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/memberships/{username}`.
		/// TeamsSlashremove_membership_for_user_in_org orgs/{org}/teams/{team_slug}/memberships/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task TeamsSlashremove_membership_for_user_in_orgAsync(string org, string team_slug, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get team membership for a user
		/// Team members will include the members of child teams.
		/// 
		/// To get a user's membership with a team, the team must be visible to the authenticated user.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/memberships/{username}`.
		/// 
		/// **Note:**
		/// The response contains the `state` of the membership and the member's `role`.
		/// 
		/// The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see see [Create a team](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#create-a-team).
		/// TeamsSlashget_membership_for_user_in_org orgs/{org}/teams/{team_slug}/memberships/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Team_membership> TeamsSlashget_membership_for_user_in_orgAsync(string org, string team_slug, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_membership>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add or update team membership for a user
		/// Adds an organization member to a team. An authenticated organization owner or team maintainer can add organization members to a team.
		/// 
		/// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub Enterprise Server team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub Enterprise Server](https://docs.github.com/enterprise-server@3.6/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
		/// 
		/// An organization owner can add someone who is not part of the team's organization to a team. When an organization owner adds someone to a team who is not an organization member, this endpoint will send an invitation to the person via email. This newly-created membership will be in the "pending" state until the person accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team.
		/// 
		/// If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/memberships/{username}`.
		/// TeamsSlashadd_or_update_membership_for_user_in_org orgs/{org}/teams/{team_slug}/memberships/{username}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Team_membership> TeamsSlashadd_or_update_membership_for_user_in_orgAsync(string org, string team_slug, string username, TeamsSlashadd_or_update_membership_for_user_in_orgPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_membership>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List team projects
		/// Lists the organization projects for a team.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects`.
		/// TeamsSlashlist_projects_in_org orgs/{org}/teams/{team_slug}/projects
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Team_project[]> TeamsSlashlist_projects_in_orgAsync(string org, string team_slug, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/projects&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_project[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a project from a team
		/// Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. This endpoint removes the project from the team, but does not delete the project.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
		/// TeamsSlashremove_project_in_org orgs/{org}/teams/{team_slug}/projects/{project_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="project_id">The unique identifier of the project.</param>
		public async Task TeamsSlashremove_project_in_orgAsync(string org, string team_slug, int project_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check team permissions for a project
		/// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
		/// TeamsSlashcheck_permissions_for_project_in_org orgs/{org}/teams/{team_slug}/projects/{project_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <returns>Response</returns>
		public async Task<Team_project> TeamsSlashcheck_permissions_for_project_in_orgAsync(string org, string team_slug, int project_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_project>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add or update team project permissions
		/// Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
		/// TeamsSlashadd_or_update_project_permissions_in_org orgs/{org}/teams/{team_slug}/projects/{project_id}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="project_id">The unique identifier of the project.</param>
		public async Task TeamsSlashadd_or_update_project_permissions_in_orgAsync(string org, string team_slug, int project_id, TeamsSlashadd_or_update_project_permissions_in_orgPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List team repositories
		/// Lists a team's repositories visible to the authenticated user.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.
		/// TeamsSlashlist_repos_in_org orgs/{org}/teams/{team_slug}/repos
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> TeamsSlashlist_repos_in_orgAsync(string org, string team_slug, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/repos&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a repository from a team
		/// If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. This does not delete the repository, it just removes it from the team.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
		/// TeamsSlashremove_repo_in_org orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task TeamsSlashremove_repo_in_orgAsync(string org, string team_slug, string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check team permissions for a repository
		/// Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.
		/// 
		/// You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
		/// 
		/// If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
		/// TeamsSlashcheck_permissions_for_repo_in_org orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Alternative response with repository permissions</returns>
		public async Task<Team_repository> TeamsSlashcheck_permissions_for_repo_in_orgAsync(string org, string team_slug, string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_repository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add or update team repository permissions
		/// To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
		/// 
		/// For more information about the permission levels, see "[Repository permission levels for an organization](https://docs.github.com/enterprise-server@3.6/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
		/// TeamsSlashadd_or_update_repo_permissions_in_org orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task TeamsSlashadd_or_update_repo_permissions_in_orgAsync(string org, string team_slug, string owner, string repo, TeamsSlashadd_or_update_repo_permissions_in_orgPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List child teams
		/// Lists the child teams of the team specified by `{team_slug}`.
		/// 
		/// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/teams`.
		/// TeamsSlashlist_child_in_org orgs/{org}/teams/{team_slug}/teams
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="team_slug">The slug of the team name.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>if child teams exist</returns>
		public async Task<Team[]> TeamsSlashlist_child_in_orgAsync(string org, string team_slug, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/teams/"+ (team_slug==null? "" : System.Uri.EscapeDataString(team_slug))+"/teams&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a project card
		/// ProjectsSlashdelete_card projects/columns/cards/{card_id}
		/// </summary>
		/// <param name="card_id">The unique identifier of the card.</param>
		public async Task ProjectsSlashdelete_cardAsync(int card_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/cards/"+card_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a project card
		/// ProjectsSlashget_card projects/columns/cards/{card_id}
		/// </summary>
		/// <param name="card_id">The unique identifier of the card.</param>
		/// <returns>Response</returns>
		public async Task<Project_card> ProjectsSlashget_cardAsync(int card_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/cards/"+card_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_card>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing project card
		/// ProjectsSlashupdate_card projects/columns/cards/{card_id}
		/// </summary>
		/// <param name="card_id">The unique identifier of the card.</param>
		/// <returns>Response</returns>
		public async Task<Project_card> ProjectsSlashupdate_cardAsync(int card_id, ProjectsSlashupdate_cardPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/cards/"+card_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_card>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Move a project card
		/// ProjectsSlashmove_card projects/columns/cards/{card_id}/moves
		/// </summary>
		/// <param name="card_id">The unique identifier of the card.</param>
		public async Task ProjectsSlashmove_cardAsync(int card_id, ProjectsSlashmove_cardPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/cards/"+card_id+"/moves";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a project column
		/// ProjectsSlashdelete_column projects/columns/{column_id}
		/// </summary>
		/// <param name="column_id">The unique identifier of the column.</param>
		public async Task ProjectsSlashdelete_columnAsync(int column_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/"+column_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a project column
		/// ProjectsSlashget_column projects/columns/{column_id}
		/// </summary>
		/// <param name="column_id">The unique identifier of the column.</param>
		/// <returns>Response</returns>
		public async Task<Project_column> ProjectsSlashget_columnAsync(int column_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/"+column_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_column>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing project column
		/// ProjectsSlashupdate_column projects/columns/{column_id}
		/// </summary>
		/// <param name="column_id">The unique identifier of the column.</param>
		/// <returns>Response</returns>
		public async Task<Project_column> ProjectsSlashupdate_columnAsync(int column_id, ProjectsSlashupdate_columnPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/"+column_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_column>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List project cards
		/// ProjectsSlashlist_cards projects/columns/{column_id}/cards
		/// </summary>
		/// <param name="column_id">The unique identifier of the column.</param>
		/// <param name="archived_state">Filters the project cards that are returned by the card's state.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Project_card[]> ProjectsSlashlist_cardsAsync(int column_id, ProjectsSlashlist_cardsArchived_state archived_state, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/"+column_id+"/cards?archived_state=" + archived_state+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_card[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a project card
		/// ProjectsSlashcreate_card projects/columns/{column_id}/cards
		/// </summary>
		/// <param name="column_id">The unique identifier of the column.</param>
		public async Task ProjectsSlashcreate_cardAsync(int column_id, ProjectsSlashcreate_cardPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/"+column_id+"/cards";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Move a project column
		/// ProjectsSlashmove_column projects/columns/{column_id}/moves
		/// </summary>
		/// <param name="column_id">The unique identifier of the column.</param>
		public async Task ProjectsSlashmove_columnAsync(int column_id, ProjectsSlashmove_columnPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/columns/"+column_id+"/moves";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a project
		/// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
		/// ProjectsSlashdelete projects/{project_id}
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		public async Task ProjectsSlashdeleteAsync(int project_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a project
		/// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
		/// ProjectsSlashget projects/{project_id}
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <returns>Response</returns>
		public async Task<Project> ProjectsSlashgetAsync(int project_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a project
		/// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
		/// ProjectsSlashupdate projects/{project_id}
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <returns>Response</returns>
		public async Task<Project> ProjectsSlashupdateAsync(int project_id, ProjectsSlashupdatePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List project collaborators
		/// Lists the collaborators for an organization project. For a project, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners. You must be an organization owner or a project `admin` to list collaborators.
		/// ProjectsSlashlist_collaborators projects/{project_id}/collaborators
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <param name="affiliation">Filters the collaborators by their affiliation. `outside` means outside collaborators of a project that are not a member of the project's organization. `direct` means collaborators with permissions to a project, regardless of organization membership status. `all` means all collaborators the authenticated user can see.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> ProjectsSlashlist_collaboratorsAsync(int project_id, ProjectsSlashlist_collaboratorsAffiliation affiliation, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id+"/collaborators?affiliation=" + affiliation+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove user as a collaborator
		/// Removes a collaborator from an organization project. You must be an organization owner or a project `admin` to remove a collaborator.
		/// ProjectsSlashremove_collaborator projects/{project_id}/collaborators/{username}
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task ProjectsSlashremove_collaboratorAsync(int project_id, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id+"/collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add project collaborator
		/// Adds a collaborator to an organization project and sets their permission level. You must be an organization owner or a project `admin` to add a collaborator.
		/// ProjectsSlashadd_collaborator projects/{project_id}/collaborators/{username}
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task ProjectsSlashadd_collaboratorAsync(int project_id, string username, ProjectsSlashadd_collaboratorPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id+"/collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get project permission for a user
		/// Returns the collaborator's permission level for an organization project. Possible values for the `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project `admin` to review a user's permission level.
		/// ProjectsSlashget_permission_for_user projects/{project_id}/collaborators/{username}/permission
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Project_collaborator_permission> ProjectsSlashget_permission_for_userAsync(int project_id, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id+"/collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/permission";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_collaborator_permission>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List project columns
		/// ProjectsSlashlist_columns projects/{project_id}/columns
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Project_column[]> ProjectsSlashlist_columnsAsync(int project_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id+"/columns?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_column[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a project column
		/// ProjectsSlashcreate_column projects/{project_id}/columns
		/// </summary>
		/// <param name="project_id">The unique identifier of the project.</param>
		public async Task ProjectsSlashcreate_columnAsync(int project_id, ProjectsSlashcreate_columnPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+project_id+"/columns";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get rate limit status for the authenticated user
		/// **Note:** Accessing this endpoint does not count against your REST API rate limit.
		/// 
		/// **Note:** The `rate` object is deprecated. If you're writing new API client code or updating existing code, you should use the `core` object instead of the `rate` object. The `core` object contains the same information that is present in the `rate` object.
		/// Rate_limitSlashget rate_limit
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Rate_limit_overview> Rate_limitSlashgetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "rate_limit";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Rate_limit_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a repository
		/// Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.
		/// 
		/// If an organization owner has configured the organization to prevent members from deleting organization-owned
		/// repositories, you will get a `403 Forbidden` response.
		/// ReposSlashdelete repos/{owner}/{repo}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashdeleteAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository
		/// The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
		/// 
		/// **Note:** In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.6/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
		/// ReposSlashget repos/{owner}/{repo}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Full_repository> ReposSlashgetAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Full_repository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a repository
		/// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#replace-all-repository-topics) endpoint.
		/// ReposSlashupdate repos/{owner}/{repo}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Full_repository> ReposSlashupdateAsync(string owner, string repo, ReposSlashupdatePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Full_repository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List artifacts for a repository
		/// Lists all artifacts for a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashlist_artifacts_for_repo repos/{owner}/{repo}/actions/artifacts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="name">Filters artifacts by exact match on their name field.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_artifacts_for_repoReturn> ActionsSlashlist_artifacts_for_repoAsync(string owner, string repo, int per_page, int page, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/artifacts&per_page="+per_page+"&page="+page+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_artifacts_for_repoReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an artifact
		/// Deletes an artifact for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
		/// ActionsSlashdelete_artifact repos/{owner}/{repo}/actions/artifacts/{artifact_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="artifact_id">The unique identifier of the artifact.</param>
		public async Task ActionsSlashdelete_artifactAsync(string owner, string repo, int artifact_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/artifacts/"+artifact_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an artifact
		/// Gets a specific artifact for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashget_artifact repos/{owner}/{repo}/actions/artifacts/{artifact_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="artifact_id">The unique identifier of the artifact.</param>
		/// <returns>Response</returns>
		public async Task<Artifact> ActionsSlashget_artifactAsync(string owner, string repo, int artifact_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/artifacts/"+artifact_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Artifact>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download an artifact
		/// Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look for `Location:` in
		/// the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone with read access to
		/// the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
		/// GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashdownload_artifact repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="artifact_id">The unique identifier of the artifact.</param>
		public async Task ActionsSlashdownload_artifactAsync(string owner, string repo, int artifact_id, string archive_format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/artifacts/"+artifact_id+"/"+ (archive_format==null? "" : System.Uri.EscapeDataString(archive_format));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Actions cache usage for a repository
		/// Gets GitHub Actions cache usage for a repository.
		/// The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
		/// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashget_actions_cache_usage repos/{owner}/{repo}/actions/cache/usage
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_cache_usage_by_repository> ActionsSlashget_actions_cache_usageAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/cache/usage";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_cache_usage_by_repository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Actions cache usage policy for a repository
		/// Gets GitHub Actions cache usage policy for a repository.
		/// You must authenticate using an access token with the `repo` scope to use this endpoint.
		/// GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashget_actions_cache_usage_policy repos/{owner}/{repo}/actions/cache/usage-policy
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_cache_usage_policy_for_repository> ActionsSlashget_actions_cache_usage_policyAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/cache/usage-policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_cache_usage_policy_for_repository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set GitHub Actions cache usage policy for a repository
		/// Sets GitHub Actions cache usage policy for a repository.
		/// You must authenticate using an access token with the `repo` scope to use this endpoint.
		/// GitHub Apps must have the `actions:write` permission to use this endpoint.
		/// ActionsSlashset_actions_cache_usage_policy repos/{owner}/{repo}/actions/cache/usage-policy
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActionsSlashset_actions_cache_usage_policyAsync(string owner, string repo, Actions_cache_usage_policy_for_repository requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/cache/usage-policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a job for a workflow run
		/// Gets a specific job in a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashget_job_for_workflow_run repos/{owner}/{repo}/actions/jobs/{job_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="job_id">The unique identifier of the job.</param>
		/// <returns>Response</returns>
		public async Task<Job> ActionsSlashget_job_for_workflow_runAsync(string owner, string repo, int job_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/jobs/"+job_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Job>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download job logs for a workflow run
		/// Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires after 1 minute. Look
		/// for `Location:` in the response header to find the URL for the download. Anyone with read access to the repository can
		/// use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must
		/// have the `actions:read` permission to use this endpoint.
		/// ActionsSlashdownload_job_logs_for_workflow_run repos/{owner}/{repo}/actions/jobs/{job_id}/logs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="job_id">The unique identifier of the job.</param>
		public async Task ActionsSlashdownload_job_logs_for_workflow_runAsync(string owner, string repo, int job_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/jobs/"+job_id+"/logs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Re-run a job from a workflow run
		/// Re-run a job and its dependent jobs in a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
		/// ActionsSlashre_run_job_for_workflow_run repos/{owner}/{repo}/actions/jobs/{job_id}/rerun
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="job_id">The unique identifier of the job.</param>
		public async Task ActionsSlashre_run_job_for_workflow_runAsync(string owner, string repo, int job_id, ActionsSlashre_run_job_for_workflow_runPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/jobs/"+job_id+"/rerun";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Actions permissions for a repository
		/// Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is enabled and the actions allowed to run in the repository.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
		/// ActionsSlashget_github_actions_permissions_repository repos/{owner}/{repo}/actions/permissions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_repository_permissions> ActionsSlashget_github_actions_permissions_repositoryAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/permissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_repository_permissions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set GitHub Actions permissions for a repository
		/// Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions in the repository.
		/// 
		/// If the repository belongs to an organization or enterprise that has set restrictive permissions at the organization or enterprise levels, such as `allowed_actions` to `selected` actions, then you cannot override them for the repository.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
		/// ActionsSlashset_github_actions_permissions_repository repos/{owner}/{repo}/actions/permissions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActionsSlashset_github_actions_permissions_repositoryAsync(string owner, string repo, ActionsSlashset_github_actions_permissions_repositoryPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/permissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the level of access for workflows outside of the repository
		/// Gets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
		/// This endpoint only applies to internal repositories.
		/// For more information, see "[Managing GitHub Actions settings for a repository](https://docs.github.com/enterprise-server@3.6/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-an-internal-repository)."
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
		/// repository `administration` permission to use this endpoint.
		/// ActionsSlashget_workflow_access_to_repository repos/{owner}/{repo}/actions/permissions/access
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_workflow_access_to_repository> ActionsSlashget_workflow_access_to_repositoryAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/permissions/access";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_workflow_access_to_repository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the level of access for workflows outside of the repository
		/// Sets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
		/// This endpoint only applies to internal repositories.
		/// For more information, see "[Managing GitHub Actions settings for a repository](https://docs.github.com/enterprise-server@3.6/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-an-internal-repository)."
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
		/// repository `administration` permission to use this endpoint.
		/// ActionsSlashset_workflow_access_to_repository repos/{owner}/{repo}/actions/permissions/access
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActionsSlashset_workflow_access_to_repositoryAsync(string owner, string repo, Actions_workflow_access_to_repository requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/permissions/access";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get allowed actions for a repository
		/// Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
		/// ActionsSlashget_allowed_actions_repository repos/{owner}/{repo}/actions/permissions/selected-actions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Selected_actions> ActionsSlashget_allowed_actions_repositoryAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/permissions/selected-actions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Selected_actions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set allowed actions for a repository
		/// Sets the actions that are allowed in a repository. To use this endpoint, the repository permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
		/// 
		/// If the repository belongs to an organization or enterprise that has `selected` actions set at the organization or enterprise levels, then you cannot override any of the allowed actions settings.
		/// 
		/// To use the `patterns_allowed` setting for private repositories, the repository must belong to an enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
		/// ActionsSlashset_allowed_actions_repository repos/{owner}/{repo}/actions/permissions/selected-actions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActionsSlashset_allowed_actions_repositoryAsync(string owner, string repo, Selected_actions requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/permissions/selected-actions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get default workflow permissions for a repository
		/// Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository,
		/// as well as if GitHub Actions can submit approving pull request reviews.
		/// For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/enterprise-server@3.6/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the repository `administration` permission to use this API.
		/// ActionsSlashget_github_actions_default_workflow_permissions_repository repos/{owner}/{repo}/actions/permissions/workflow
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_get_default_workflow_permissions> ActionsSlashget_github_actions_default_workflow_permissions_repositoryAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/permissions/workflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_get_default_workflow_permissions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set default workflow permissions for a repository
		/// Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository, and sets if GitHub Actions
		/// can submit approving pull request reviews.
		/// For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/enterprise-server@3.6/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the repository `administration` permission to use this API.
		/// ActionsSlashset_github_actions_default_workflow_permissions_repository repos/{owner}/{repo}/actions/permissions/workflow
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActionsSlashset_github_actions_default_workflow_permissions_repositoryAsync(string owner, string repo, Actions_set_default_workflow_permissions requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/permissions/workflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List self-hosted runners for a repository
		/// Lists all self-hosted runners configured in a repository. You must authenticate using an access token with the `repo` scope to use this endpoint.
		/// ActionsSlashlist_self_hosted_runners_for_repo repos/{owner}/{repo}/actions/runners
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_self_hosted_runners_for_repoReturn> ActionsSlashlist_self_hosted_runners_for_repoAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_self_hosted_runners_for_repoReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List runner applications for a repository
		/// Lists binaries for the runner application that you can download and run.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint.
		/// ActionsSlashlist_runner_applications_for_repo repos/{owner}/{repo}/actions/runners/downloads
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Runner_application[]> ActionsSlashlist_runner_applications_for_repoAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/downloads";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner_application[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a registration token for a repository
		/// Returns a token that you can pass to the `config` script. The token expires after one hour. You must authenticate
		/// using an access token with the `repo` scope to use this endpoint.
		/// 
		/// #### Example using registration token
		/// 
		/// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
		/// 
		/// ```
		/// ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
		/// ```
		/// ActionsSlashcreate_registration_token_for_repo repos/{owner}/{repo}/actions/runners/registration-token
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActionsSlashcreate_registration_token_for_repoAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/registration-token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a remove token for a repository
		/// Returns a token that you can pass to remove a self-hosted runner from a repository. The token expires after one hour.
		/// You must authenticate using an access token with the `repo` scope to use this endpoint.
		/// 
		/// #### Example using remove token
		/// 
		/// To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided by this endpoint.
		/// 
		/// ```
		/// ./config.sh remove --token TOKEN
		/// ```
		/// ActionsSlashcreate_remove_token_for_repo repos/{owner}/{repo}/actions/runners/remove-token
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActionsSlashcreate_remove_token_for_repoAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/remove-token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a self-hosted runner from a repository
		/// Forces the removal of a self-hosted runner from a repository. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
		/// 
		/// You must authenticate using an access token with the `repo`
		/// scope to use this endpoint.
		/// ActionsSlashdelete_self_hosted_runner_from_repo repos/{owner}/{repo}/actions/runners/{runner_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		public async Task ActionsSlashdelete_self_hosted_runner_from_repoAsync(string owner, string repo, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a self-hosted runner for a repository
		/// Gets a specific self-hosted runner configured in a repository.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this
		/// endpoint.
		/// ActionsSlashget_self_hosted_runner_for_repo repos/{owner}/{repo}/actions/runners/{runner_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<Runner> ActionsSlashget_self_hosted_runner_for_repoAsync(string owner, string repo, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/"+runner_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Runner>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove all custom labels from a self-hosted runner for a repository
		/// Remove all custom labels from a self-hosted runner configured in a
		/// repository. Returns the remaining read-only labels from the runner.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this
		/// endpoint.
		/// ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_repo repos/{owner}/{repo}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_repoReturn> ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_repoAsync(string owner, string repo, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_repoReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List labels for a self-hosted runner for a repository
		/// Lists all labels for a self-hosted runner configured in a repository.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this
		/// endpoint.
		/// ActionsSlashlist_labels_for_self_hosted_runner_for_repo repos/{owner}/{repo}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_labels_for_self_hosted_runner_for_repoReturn> ActionsSlashlist_labels_for_self_hosted_runner_for_repoAsync(string owner, string repo, int runner_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_labels_for_self_hosted_runner_for_repoReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add custom labels to a self-hosted runner for a repository
		/// Add custom labels to a self-hosted runner configured in a repository.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this
		/// endpoint.
		/// ActionsSlashadd_custom_labels_to_self_hosted_runner_for_repo repos/{owner}/{repo}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashadd_custom_labels_to_self_hosted_runner_for_repoReturn> ActionsSlashadd_custom_labels_to_self_hosted_runner_for_repoAsync(string owner, string repo, int runner_id, ActionsSlashadd_custom_labels_to_self_hosted_runner_for_repoPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashadd_custom_labels_to_self_hosted_runner_for_repoReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set custom labels for a self-hosted runner for a repository
		/// Remove all previous custom labels and set the new custom labels for a specific
		/// self-hosted runner configured in a repository.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this
		/// endpoint.
		/// ActionsSlashset_custom_labels_for_self_hosted_runner_for_repo repos/{owner}/{repo}/actions/runners/{runner_id}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashset_custom_labels_for_self_hosted_runner_for_repoReturn> ActionsSlashset_custom_labels_for_self_hosted_runner_for_repoAsync(string owner, string repo, int runner_id, ActionsSlashset_custom_labels_for_self_hosted_runner_for_repoPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/"+runner_id+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashset_custom_labels_for_self_hosted_runner_for_repoReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a custom label from a self-hosted runner for a repository
		/// Remove a custom label from a self-hosted runner configured
		/// in a repository. Returns the remaining labels from the runner.
		/// 
		/// This endpoint returns a `404 Not Found` status if the custom label is not
		/// present on the runner.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this
		/// endpoint.
		/// ActionsSlashremove_custom_label_from_self_hosted_runner_for_repo repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="runner_id">Unique identifier of the self-hosted runner.</param>
		/// <param name="name">The name of a self-hosted runner's custom label.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashremove_custom_label_from_self_hosted_runner_for_repoReturn> ActionsSlashremove_custom_label_from_self_hosted_runner_for_repoAsync(string owner, string repo, int runner_id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runners/"+runner_id+"/labels/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashremove_custom_label_from_self_hosted_runner_for_repoReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List workflow runs for a repository
		/// Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#parameters).
		/// 
		/// Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashlist_workflow_runs_for_repo repos/{owner}/{repo}/actions/runs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="actor">Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.</param>
		/// <param name="branch">Returns workflow runs associated with a branch. Use the name of the branch of the `push`.</param>
		/// <param name="_event">Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/enterprise-server@3.6/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."</param>
		/// <param name="status">Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="created">Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/enterprise-server@3.6/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."</param>
		/// <param name="exclude_pull_requests">If `true` pull requests are omitted from the response (empty array).</param>
		/// <param name="check_suite_id">Returns workflow runs with the `check_suite_id` that you specify.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_workflow_runs_for_repoReturn> ActionsSlashlist_workflow_runs_for_repoAsync(string owner, string repo, string actor, string branch, string _event, ActionsSlashlist_workflow_runs_for_repoStatus status, int per_page, int page, System.DateTimeOffset created, bool exclude_pull_requests, int check_suite_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs&actor=" + (actor==null? "" : System.Uri.EscapeDataString(actor))+"&branch=" + (branch==null? "" : System.Uri.EscapeDataString(branch))+"&event=" + (_event==null? "" : System.Uri.EscapeDataString(_event))+"&status=" + status+"&per_page="+per_page+"&page="+page+"&created=" + created.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&exclude_pull_requests="+exclude_pull_requests+"&check_suite_id="+check_suite_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_workflow_runs_for_repoReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a workflow run
		/// Delete a specific workflow run. Anyone with write access to the repository can use this endpoint. If the repository is
		/// private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:write` permission to use
		/// this endpoint.
		/// ActionsSlashdelete_workflow_run repos/{owner}/{repo}/actions/runs/{run_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		public async Task ActionsSlashdelete_workflow_runAsync(string owner, string repo, int run_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a workflow run
		/// Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashget_workflow_run repos/{owner}/{repo}/actions/runs/{run_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <param name="exclude_pull_requests">If `true` pull requests are omitted from the response (empty array).</param>
		/// <returns>Response</returns>
		public async Task<Workflow_run> ActionsSlashget_workflow_runAsync(string owner, string repo, int run_id, bool exclude_pull_requests, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"&exclude_pull_requests="+exclude_pull_requests;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Workflow_run>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the review history for a workflow run
		/// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashget_reviews_for_run repos/{owner}/{repo}/actions/runs/{run_id}/approvals
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <returns>Response</returns>
		public async Task<Environment_approvals[]> ActionsSlashget_reviews_for_runAsync(string owner, string repo, int run_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/approvals";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Environment_approvals[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List workflow run artifacts
		/// Lists artifacts for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashlist_workflow_run_artifacts repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_workflow_run_artifactsReturn> ActionsSlashlist_workflow_run_artifactsAsync(string owner, string repo, int run_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/artifacts&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_workflow_run_artifactsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a workflow run attempt
		/// Gets a specific workflow run attempt. Anyone with read access to the repository
		/// can use this endpoint. If the repository is private you must use an access token
		/// with the `repo` scope. GitHub Apps must have the `actions:read` permission to
		/// use this endpoint.
		/// ActionsSlashget_workflow_run_attempt repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <param name="attempt_number">The attempt number of the workflow run.</param>
		/// <param name="exclude_pull_requests">If `true` pull requests are omitted from the response (empty array).</param>
		/// <returns>Response</returns>
		public async Task<Workflow_run> ActionsSlashget_workflow_run_attemptAsync(string owner, string repo, int run_id, int attempt_number, bool exclude_pull_requests, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/attempts/"+attempt_number+"&exclude_pull_requests="+exclude_pull_requests;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Workflow_run>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List jobs for a workflow run attempt
		/// Lists jobs for a specific workflow run attempt. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#parameters).
		/// ActionsSlashlist_jobs_for_workflow_run_attempt repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <param name="attempt_number">The attempt number of the workflow run.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_jobs_for_workflow_run_attemptReturn> ActionsSlashlist_jobs_for_workflow_run_attemptAsync(string owner, string repo, int run_id, int attempt_number, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/attempts/"+attempt_number+"/jobs&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_jobs_for_workflow_run_attemptReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download workflow run attempt logs
		/// Gets a redirect URL to download an archive of log files for a specific workflow run attempt. This link expires after
		/// 1 minute. Look for `Location:` in the response header to find the URL for the download. Anyone with read access to
		/// the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
		/// GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashdownload_workflow_run_attempt_logs repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <param name="attempt_number">The attempt number of the workflow run.</param>
		public async Task ActionsSlashdownload_workflow_run_attempt_logsAsync(string owner, string repo, int run_id, int attempt_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/attempts/"+attempt_number+"/logs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cancel a workflow run
		/// Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
		/// ActionsSlashcancel_workflow_run repos/{owner}/{repo}/actions/runs/{run_id}/cancel
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		public async Task ActionsSlashcancel_workflow_runAsync(string owner, string repo, int run_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List jobs for a workflow run
		/// Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#parameters).
		/// ActionsSlashlist_jobs_for_workflow_run repos/{owner}/{repo}/actions/runs/{run_id}/jobs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <param name="filter">Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_jobs_for_workflow_runReturn> ActionsSlashlist_jobs_for_workflow_runAsync(string owner, string repo, int run_id, ActionsSlashlist_jobs_for_workflow_runFilter filter, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/jobs&filter=" + filter+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_jobs_for_workflow_runReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete workflow run logs
		/// Deletes all logs for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
		/// ActionsSlashdelete_workflow_run_logs repos/{owner}/{repo}/actions/runs/{run_id}/logs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		public async Task ActionsSlashdelete_workflow_run_logsAsync(string owner, string repo, int run_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/logs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download workflow run logs
		/// Gets a redirect URL to download an archive of log files for a workflow run. This link expires after 1 minute. Look for
		/// `Location:` in the response header to find the URL for the download. Anyone with read access to the repository can use
		/// this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have
		/// the `actions:read` permission to use this endpoint.
		/// ActionsSlashdownload_workflow_run_logs repos/{owner}/{repo}/actions/runs/{run_id}/logs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		public async Task ActionsSlashdownload_workflow_run_logsAsync(string owner, string repo, int run_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/logs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get pending deployments for a workflow run
		/// Get all deployment environments for a workflow run that are waiting for protection rules to pass.
		/// 
		/// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashget_pending_deployments_for_run repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <returns>Response</returns>
		public async Task<Pending_deployment[]> ActionsSlashget_pending_deployments_for_runAsync(string owner, string repo, int run_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/pending_deployments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pending_deployment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Review pending deployments for a workflow run
		/// Approve or reject pending deployments that are waiting on approval by a required reviewer.
		/// 
		/// Required reviewers with read access to the repository contents and deployments can use this endpoint. Required reviewers must authenticate using an access token with the `repo` scope to use this endpoint.
		/// ActionsSlashreview_pending_deployments_for_run repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		/// <returns>Response</returns>
		public async Task<Deployment[]> ActionsSlashreview_pending_deployments_for_runAsync(string owner, string repo, int run_id, ActionsSlashreview_pending_deployments_for_runPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/pending_deployments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Re-run a workflow
		/// Re-runs your workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
		/// ActionsSlashre_run_workflow repos/{owner}/{repo}/actions/runs/{run_id}/rerun
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		public async Task ActionsSlashre_run_workflowAsync(string owner, string repo, int run_id, ActionsSlashre_run_workflowPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/rerun";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Re-run failed jobs from a workflow run
		/// Re-run all of the failed jobs and their dependent jobs in a workflow run using the `id` of the workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint.
		/// ActionsSlashre_run_workflow_failed_jobs repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="run_id">The unique identifier of the workflow run.</param>
		public async Task ActionsSlashre_run_workflow_failed_jobsAsync(string owner, string repo, int run_id, ActionsSlashre_run_workflow_failed_jobsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/runs/"+run_id+"/rerun-failed-jobs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository secrets
		/// Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
		/// ActionsSlashlist_repo_secrets repos/{owner}/{repo}/actions/secrets
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_repo_secretsReturn> ActionsSlashlist_repo_secretsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/secrets&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_repo_secretsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository public key
		/// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
		/// ActionsSlashget_repo_public_key repos/{owner}/{repo}/actions/secrets/public-key
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Actions_public_key> ActionsSlashget_repo_public_keyAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/secrets/public-key";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_public_key>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a repository secret
		/// Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
		/// ActionsSlashdelete_repo_secret repos/{owner}/{repo}/actions/secrets/{secret_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashdelete_repo_secretAsync(string owner, string repo, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository secret
		/// Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
		/// ActionsSlashget_repo_secret repos/{owner}/{repo}/actions/secrets/{secret_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		/// <returns>Response</returns>
		public async Task<Actions_secret> ActionsSlashget_repo_secretAsync(string owner, string repo, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_secret>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a repository secret
		/// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
		/// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
		/// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
		/// this endpoint.
		/// 
		/// #### Example encrypting a secret using Node.js
		/// 
		/// Encrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.
		/// 
		/// ```
		/// const sodium = require('libsodium-wrappers')
		/// const secret = 'plain-text-secret' // replace with the secret you want to encrypt
		/// const key = 'base64-encoded-public-key' // replace with the Base64 encoded public key
		/// 
		/// //Check if libsodium is ready and then proceed.
		/// sodium.ready.then(() => {
		/// // Convert Secret & Base64 key to Uint8Array.
		/// let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)
		/// let binsec = sodium.from_string(secret)
		/// 
		/// //Encrypt the secret using LibSodium
		/// let encBytes = sodium.crypto_box_seal(binsec, binkey)
		/// 
		/// // Convert encrypted Uint8Array to Base64
		/// let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
		/// 
		/// console.log(output)
		/// });
		/// ```
		/// 
		/// #### Example encrypting a secret using Python
		/// 
		/// Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.
		/// 
		/// ```
		/// from base64 import b64encode
		/// from nacl import encoding, public
		/// 
		/// def encrypt(public_key: str, secret_value: str) -> str:
		/// """Encrypt a Unicode string using the public key."""
		/// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
		/// sealed_box = public.SealedBox(public_key)
		/// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
		/// return b64encode(encrypted).decode("utf-8")
		/// ```
		/// 
		/// #### Example encrypting a secret using C#
		/// 
		/// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
		/// 
		/// ```
		/// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
		/// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
		/// 
		/// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
		/// 
		/// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
		/// ```
		/// 
		/// #### Example encrypting a secret using Ruby
		/// 
		/// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
		/// 
		/// ```ruby
		/// require "rbnacl"
		/// require "base64"
		/// 
		/// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
		/// public_key = RbNaCl::PublicKey.new(key)
		/// 
		/// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
		/// encrypted_secret = box.encrypt("my_secret")
		/// 
		/// # Print the base64 encoded secret
		/// puts Base64.strict_encode64(encrypted_secret)
		/// ```
		/// ActionsSlashcreate_or_update_repo_secret repos/{owner}/{repo}/actions/secrets/{secret_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashcreate_or_update_repo_secretAsync(string owner, string repo, string secret_name, ActionsSlashcreate_or_update_repo_secretPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository workflows
		/// Lists the workflows in a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashlist_repo_workflows repos/{owner}/{repo}/actions/workflows
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_repo_workflowsReturn> ActionsSlashlist_repo_workflowsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/workflows&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_repo_workflowsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a workflow
		/// Gets a specific workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ActionsSlashget_workflow repos/{owner}/{repo}/actions/workflows/{workflow_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="workflow_id">The ID of the workflow. You can also pass the workflow file name as a string.</param>
		/// <returns>Response</returns>
		public async Task<Workflow> ActionsSlashget_workflowAsync(string owner, string repo, int workflow_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/workflows/"+workflow_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Workflow>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable a workflow
		/// Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
		/// ActionsSlashdisable_workflow repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="workflow_id">The ID of the workflow. You can also pass the workflow file name as a string.</param>
		public async Task ActionsSlashdisable_workflowAsync(string owner, string repo, int workflow_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/workflows/"+workflow_id+"/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a workflow dispatch event
		/// You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
		/// 
		/// You must configure your GitHub Actions workflow to run when the [`workflow_dispatch` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The `inputs` are configured in the workflow file. For more information about how to configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)."
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. For more information, see "[Creating a personal access token for the command line](https://docs.github.com/enterprise-server@3.6/articles/creating-a-personal-access-token-for-the-command-line)."
		/// ActionsSlashcreate_workflow_dispatch repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="workflow_id">The ID of the workflow. You can also pass the workflow file name as a string.</param>
		public async Task ActionsSlashcreate_workflow_dispatchAsync(string owner, string repo, int workflow_id, ActionsSlashcreate_workflow_dispatchPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/workflows/"+workflow_id+"/dispatches";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Enable a workflow
		/// Enables a workflow and sets the `state` of the workflow to `active`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
		/// ActionsSlashenable_workflow repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="workflow_id">The ID of the workflow. You can also pass the workflow file name as a string.</param>
		public async Task ActionsSlashenable_workflowAsync(string owner, string repo, int workflow_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/workflows/"+workflow_id+"/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List workflow runs for a workflow
		/// List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#parameters).
		/// 
		/// Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
		/// ActionsSlashlist_workflow_runs repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="workflow_id">The ID of the workflow. You can also pass the workflow file name as a string.</param>
		/// <param name="actor">Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.</param>
		/// <param name="branch">Returns workflow runs associated with a branch. Use the name of the branch of the `push`.</param>
		/// <param name="_event">Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/enterprise-server@3.6/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."</param>
		/// <param name="status">Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="created">Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/enterprise-server@3.6/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."</param>
		/// <param name="exclude_pull_requests">If `true` pull requests are omitted from the response (empty array).</param>
		/// <param name="check_suite_id">Returns workflow runs with the `check_suite_id` that you specify.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_workflow_runsReturn> ActionsSlashlist_workflow_runsAsync(string owner, string repo, int workflow_id, string actor, string branch, string _event, ActionsSlashlist_workflow_runs_for_repoStatus status, int per_page, int page, System.DateTimeOffset created, bool exclude_pull_requests, int check_suite_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/actions/workflows/"+workflow_id+"/runs&actor=" + (actor==null? "" : System.Uri.EscapeDataString(actor))+"&branch=" + (branch==null? "" : System.Uri.EscapeDataString(branch))+"&event=" + (_event==null? "" : System.Uri.EscapeDataString(_event))+"&status=" + status+"&per_page="+per_page+"&page="+page+"&created=" + created.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&exclude_pull_requests="+exclude_pull_requests+"&check_suite_id="+check_suite_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_workflow_runsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List assignees
		/// Lists the [available assignees](https://docs.github.com/enterprise-server@3.6/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
		/// IssuesSlashlist_assignees repos/{owner}/{repo}/assignees
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> IssuesSlashlist_assigneesAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/assignees&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if a user can be assigned
		/// Checks if a user has permission to be assigned to an issue in this repository.
		/// 
		/// If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
		/// 
		/// Otherwise a `404` status code is returned.
		/// IssuesSlashcheck_user_can_be_assigned repos/{owner}/{repo}/assignees/{assignee}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task IssuesSlashcheck_user_can_be_assignedAsync(string owner, string repo, string assignee, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/assignees/"+ (assignee==null? "" : System.Uri.EscapeDataString(assignee));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all autolinks of a repository
		/// This returns a list of autolinks configured for the given repository.
		/// 
		/// Information about autolinks are only available to repository administrators.
		/// ReposSlashlist_autolinks repos/{owner}/{repo}/autolinks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Autolink[]> ReposSlashlist_autolinksAsync(string owner, string repo, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/autolinks&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Autolink[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an autolink reference for a repository
		/// Users with admin access to the repository can create an autolink.
		/// ReposSlashcreate_autolink repos/{owner}/{repo}/autolinks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_autolinkAsync(string owner, string repo, ReposSlashcreate_autolinkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/autolinks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an autolink reference from a repository
		/// This deletes a single autolink reference by ID that was configured for the given repository.
		/// 
		/// Information about autolinks are only available to repository administrators.
		/// ReposSlashdelete_autolink repos/{owner}/{repo}/autolinks/{autolink_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="autolink_id">The unique identifier of the autolink.</param>
		public async Task ReposSlashdelete_autolinkAsync(string owner, string repo, int autolink_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/autolinks/"+autolink_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an autolink reference of a repository
		/// This returns a single autolink reference by ID that was configured for the given repository.
		/// 
		/// Information about autolinks are only available to repository administrators.
		/// ReposSlashget_autolink repos/{owner}/{repo}/autolinks/{autolink_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="autolink_id">The unique identifier of the autolink.</param>
		/// <returns>Response</returns>
		public async Task<Autolink> ReposSlashget_autolinkAsync(string owner, string repo, int autolink_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/autolinks/"+autolink_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Autolink>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List branches
		/// ReposSlashlist_branches repos/{owner}/{repo}/branches
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_protected">Setting to `true` returns only protected branches. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Short_branch[]> ReposSlashlist_branchesAsync(string owner, string repo, bool _protected, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches&protected="+_protected+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Short_branch[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a branch
		/// ReposSlashget_branch repos/{owner}/{repo}/branches/{branch}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Branch_with_protection> ReposSlashget_branchAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Branch_with_protection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete branch protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashdelete_branch_protection repos/{owner}/{repo}/branches/{branch}/protection
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		public async Task ReposSlashdelete_branch_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get branch protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashget_branch_protection repos/{owner}/{repo}/branches/{branch}/protection
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Branch_protection> ReposSlashget_branch_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Branch_protection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update branch protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Protecting a branch requires admin or owner permissions to the repository.
		/// 
		/// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
		/// 
		/// **Note**: The list of users, apps, and teams in total is limited to 100 items.
		/// ReposSlashupdate_branch_protection repos/{owner}/{repo}/branches/{branch}/protection
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Protected_branch> ReposSlashupdate_branch_protectionAsync(string owner, string repo, string branch, ReposSlashupdate_branch_protectionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Protected_branch>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete admin branch protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
		/// ReposSlashdelete_admin_branch_protection repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		public async Task ReposSlashdelete_admin_branch_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/enforce_admins";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get admin branch protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashget_admin_branch_protection repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Protected_branch_admin_enforced> ReposSlashget_admin_branch_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/enforce_admins";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Protected_branch_admin_enforced>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set admin branch protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
		/// ReposSlashset_admin_branch_protection repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Protected_branch_admin_enforced> ReposSlashset_admin_branch_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/enforce_admins";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Protected_branch_admin_enforced>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete pull request review protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashdelete_pull_request_review_protection repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		public async Task ReposSlashdelete_pull_request_review_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_pull_request_reviews";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get pull request review protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashget_pull_request_review_protection repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Protected_branch_pull_request_review> ReposSlashget_pull_request_review_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_pull_request_reviews";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Protected_branch_pull_request_review>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update pull request review protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
		/// 
		/// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
		/// ReposSlashupdate_pull_request_review_protection repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Protected_branch_pull_request_review> ReposSlashupdate_pull_request_review_protectionAsync(string owner, string repo, string branch, ReposSlashupdate_pull_request_review_protectionPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_pull_request_reviews";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Protected_branch_pull_request_review>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete commit signature protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
		/// ReposSlashdelete_commit_signature_protection repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		public async Task ReposSlashdelete_commit_signature_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_signatures";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get commit signature protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/enterprise-server@3.6/articles/signing-commits-with-gpg) in GitHub Help.
		/// 
		/// **Note**: You must enable branch protection to require signed commits.
		/// ReposSlashget_commit_signature_protection repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Protected_branch_admin_enforced> ReposSlashget_commit_signature_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_signatures";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Protected_branch_admin_enforced>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create commit signature protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
		/// ReposSlashcreate_commit_signature_protection repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Protected_branch_admin_enforced> ReposSlashcreate_commit_signature_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_signatures";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Protected_branch_admin_enforced>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove status check protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashremove_status_check_protection repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		public async Task ReposSlashremove_status_check_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_status_checks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get status checks protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashget_status_checks_protection repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Status_check_policy> ReposSlashget_status_checks_protectionAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_status_checks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status_check_policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update status check protection
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
		/// ReposSlashupdate_status_check_protection repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Status_check_policy> ReposSlashupdate_status_check_protectionAsync(string owner, string repo, string branch, ReposSlashupdate_status_check_protectionPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_status_checks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status_check_policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove status check contexts
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashremove_status_check_contexts repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<string[]> ReposSlashremove_status_check_contextsAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_status_checks/contexts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all status check contexts
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashget_all_status_check_contexts repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<string[]> ReposSlashget_all_status_check_contextsAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_status_checks/contexts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add status check contexts
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashadd_status_check_contexts repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<string[]> ReposSlashadd_status_check_contextsAsync(string owner, string repo, string branch, string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_status_checks/contexts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set status check contexts
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// ReposSlashset_status_check_contexts repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<string[]> ReposSlashset_status_check_contextsAsync(string owner, string repo, string branch, string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/required_status_checks/contexts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Disables the ability to restrict who can push to this branch.
		/// ReposSlashdelete_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		public async Task ReposSlashdelete_access_restrictionsAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Lists who has access to this protected branch.
		/// 
		/// **Note**: Users, apps, and teams `restrictions` are only available for organization-owned repositories.
		/// ReposSlashget_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Branch_restriction_policy> ReposSlashget_access_restrictionsAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Branch_restriction_policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove app access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
		/// ReposSlashremove_app_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Integration[]> ReposSlashremove_app_access_restrictionsAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/apps";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Integration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get apps with access to the protected branch
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
		/// ReposSlashget_apps_with_access_to_protected_branch repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Integration[]> ReposSlashget_apps_with_access_to_protected_branchAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/apps";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Integration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add app access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Grants the specified apps push access for this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
		/// ReposSlashadd_app_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Integration[]> ReposSlashadd_app_access_restrictionsAsync(string owner, string repo, string branch, ReposSlashadd_app_access_restrictionsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/apps";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Integration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set app access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
		/// ReposSlashset_app_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Integration[]> ReposSlashset_app_access_restrictionsAsync(string owner, string repo, string branch, ReposSlashset_app_access_restrictionsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/apps";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Integration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove team access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Removes the ability of a team to push to this branch. You can also remove push access for child teams.
		/// ReposSlashremove_team_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Team[]> ReposSlashremove_team_access_restrictionsAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/teams";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get teams with access to the protected branch
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Lists the teams who have push access to this branch. The list includes child teams.
		/// ReposSlashget_teams_with_access_to_protected_branch repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Team[]> ReposSlashget_teams_with_access_to_protected_branchAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/teams";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add team access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Grants the specified teams push access for this branch. You can also give push access to child teams.
		/// ReposSlashadd_team_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Team[]> ReposSlashadd_team_access_restrictionsAsync(string owner, string repo, string branch, string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/teams";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set team access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.
		/// ReposSlashset_team_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Team[]> ReposSlashset_team_access_restrictionsAsync(string owner, string repo, string branch, string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/teams";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove user access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Removes the ability of a user to push to this branch.
		/// 
		/// | Type    | Description                                                                                                                                   |
		/// | ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
		/// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
		/// ReposSlashremove_user_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> ReposSlashremove_user_access_restrictionsAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get users with access to the protected branch
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Lists the people who have push access to this branch.
		/// ReposSlashget_users_with_access_to_protected_branch repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> ReposSlashget_users_with_access_to_protected_branchAsync(string owner, string repo, string branch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add user access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Grants the specified people push access for this branch.
		/// 
		/// | Type    | Description                                                                                                                   |
		/// | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
		/// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
		/// ReposSlashadd_user_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> ReposSlashadd_user_access_restrictionsAsync(string owner, string repo, string branch, ReposSlashadd_user_access_restrictionsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set user access restrictions
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.
		/// 
		/// | Type    | Description                                                                                                                   |
		/// | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
		/// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
		/// ReposSlashset_user_access_restrictions repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> ReposSlashset_user_access_restrictionsAsync(string owner, string repo, string branch, ReposSlashset_user_access_restrictionsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/protection/restrictions/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Rename a branch
		/// Renames a branch in a repository.
		/// 
		/// **Note:** Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/enterprise-server@3.6/github/administering-a-repository/renaming-a-branch)".
		/// 
		/// The permissions required to use this endpoint depends on whether you are renaming the default branch.
		/// 
		/// To rename a non-default branch:
		/// 
		/// * Users must have push access.
		/// * GitHub Apps must have the `contents:write` repository permission.
		/// 
		/// To rename the default branch:
		/// 
		/// * Users must have admin or owner permissions.
		/// * GitHub Apps must have the `administration:write` repository permission.
		/// ReposSlashrename_branch repos/{owner}/{repo}/branches/{branch}/rename
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="branch">The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.6/graphql).</param>
		public async Task ReposSlashrename_branchAsync(string owner, string repo, string branch, ReposSlashrename_branchPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/branches/"+ (branch==null? "" : System.Uri.EscapeDataString(branch))+"/rename";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a check run
		/// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
		/// 
		/// Creates a new check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to create check runs.
		/// 
		/// In a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000, GitHub will start to automatically delete older check runs.
		/// ChecksSlashcreate repos/{owner}/{repo}/check-runs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ChecksSlashcreateAsync(string owner, string repo, ChecksSlashcreatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-runs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a check run
		/// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
		/// 
		/// Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
		/// ChecksSlashget repos/{owner}/{repo}/check-runs/{check_run_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="check_run_id">The unique identifier of the check run.</param>
		/// <returns>Response</returns>
		public async Task<Check_run> ChecksSlashgetAsync(string owner, string repo, int check_run_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-runs/"+check_run_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Check_run>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a check run
		/// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
		/// 
		/// Updates a check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to edit check runs.
		/// ChecksSlashupdate repos/{owner}/{repo}/check-runs/{check_run_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="check_run_id">The unique identifier of the check run.</param>
		/// <returns>Response</returns>
		public async Task<Check_run> ChecksSlashupdateAsync(string owner, string repo, int check_run_id, ChecksSlashupdatePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-runs/"+check_run_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Check_run>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List check run annotations
		/// Lists annotations for a check run using the annotation `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get annotations for a check run in a private repository.
		/// ChecksSlashlist_annotations repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="check_run_id">The unique identifier of the check run.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Check_annotation[]> ChecksSlashlist_annotationsAsync(string owner, string repo, int check_run_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-runs/"+check_run_id+"/annotations&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Check_annotation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Rerequest a check run
		/// Triggers GitHub to rerequest an existing check run, without pushing new code to a repository. This endpoint will trigger the [`check_run` webhook](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#check_run) event with the action `rerequested`. When a check run is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
		/// 
		/// To rerequest a check run, your GitHub App must have the `checks:read` permission on a private repository or pull access to a public repository.
		/// ChecksSlashrerequest_run repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="check_run_id">The unique identifier of the check run.</param>
		public async Task ChecksSlashrerequest_runAsync(string owner, string repo, int check_run_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-runs/"+check_run_id+"/rerequest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a check suite
		/// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
		/// 
		/// By default, check suites are automatically created when you create a [check run](https://docs.github.com/enterprise-server@3.6/rest/reference/checks#check-runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using "[Update repository preferences for check suites](https://docs.github.com/enterprise-server@3.6/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must have the `checks:write` permission to create check suites.
		/// ChecksSlashcreate_suite repos/{owner}/{repo}/check-suites
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response when the suite already exists</returns>
		public async Task<Check_suite> ChecksSlashcreate_suiteAsync(string owner, string repo, ChecksSlashcreate_suitePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-suites";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Check_suite>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update repository preferences for check suites
		/// Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/enterprise-server@3.6/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository to set preferences for check suites.
		/// ChecksSlashset_suites_preferences repos/{owner}/{repo}/check-suites/preferences
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Check_suite_preference> ChecksSlashset_suites_preferencesAsync(string owner, string repo, ChecksSlashset_suites_preferencesPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-suites/preferences";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Check_suite_preference>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a check suite
		/// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
		/// 
		/// Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
		/// ChecksSlashget_suite repos/{owner}/{repo}/check-suites/{check_suite_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="check_suite_id">The unique identifier of the check suite.</param>
		/// <returns>Response</returns>
		public async Task<Check_suite> ChecksSlashget_suiteAsync(string owner, string repo, int check_suite_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-suites/"+check_suite_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Check_suite>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List check runs in a check suite
		/// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
		/// 
		/// Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
		/// ChecksSlashlist_for_suite repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="check_suite_id">The unique identifier of the check suite.</param>
		/// <param name="check_name">Returns check runs with the specified `name`.</param>
		/// <param name="status">Returns check runs with the specified `status`.</param>
		/// <param name="filter">Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ChecksSlashlist_for_suiteReturn> ChecksSlashlist_for_suiteAsync(string owner, string repo, int check_suite_id, string check_name, Check_runStatus status, ActionsSlashlist_jobs_for_workflow_runFilter filter, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-suites/"+check_suite_id+"/check-runs&check_name=" + (check_name==null? "" : System.Uri.EscapeDataString(check_name))+"&status=" + status+"&filter=" + filter+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ChecksSlashlist_for_suiteReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Rerequest a check suite
		/// Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository. This endpoint will trigger the [`check_suite` webhook](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
		/// 
		/// To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private repository or pull access to a public repository.
		/// ChecksSlashrerequest_suite repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="check_suite_id">The unique identifier of the check suite.</param>
		public async Task ChecksSlashrerequest_suiteAsync(string owner, string repo, int check_suite_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/check-suites/"+check_suite_id+"/rerequest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List code scanning alerts for a repository
		/// Lists code scanning alerts.
		/// 
		/// To use this endpoint, you must use an access token with the `security_events` scope or, for alerts from public repositories only, an access token with the `public_repo` scope.
		/// 
		/// GitHub Apps must have the `security_events` read
		/// permission to use this endpoint.
		/// 
		/// The response includes a `most_recent_instance` object.
		/// This provides details of the most recent instance of this alert
		/// for the default branch (or for the specified Git reference if you used `ref` in the request).
		/// Code_scanningSlashlist_alerts_for_repo repos/{owner}/{repo}/code-scanning/alerts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="tool_name">The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.</param>
		/// <param name="tool_guid">The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="_ref">The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="sort">The property by which to sort the results.</param>
		/// <param name="state">If specified, only code scanning alerts with this state will be returned.</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_alert_items[]> Code_scanningSlashlist_alerts_for_repoAsync(string owner, string repo, string tool_name, string tool_guid, int page, int per_page, string _ref, Enterprise_adminSlashlist_public_keysDirection direction, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Code_scanning_alert_state state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/alerts&tool_name=" + (tool_name==null? "" : System.Uri.EscapeDataString(tool_name))+"&tool_guid=" + (tool_guid==null? "" : System.Uri.EscapeDataString(tool_guid))+"&page="+page+"&per_page="+per_page+"&ref=" + (_ref==null? "" : System.Uri.EscapeDataString(_ref))+"&direction=" + direction+"&sort=" + sort+"&state=" + state;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_alert_items[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a code scanning alert
		/// Gets a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint with private repos, the `public_repo` scope also grants permission to read security events on public repos only. GitHub Apps must have the `security_events` read permission to use this endpoint.
		/// 
		/// **Deprecation notice**:
		/// The instances field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The same information can now be retrieved via a GET request to the URL specified by `instances_url`.
		/// Code_scanningSlashget_alert repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="alert_number">The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_alert> Code_scanningSlashget_alertAsync(string owner, string repo, int alert_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/alerts/"+alert_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_alert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a code scanning alert
		/// Updates the status of a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint with private repositories. You can also use tokens with the `public_repo` scope for public repositories only. GitHub Apps must have the `security_events` write permission to use this endpoint.
		/// Code_scanningSlashupdate_alert repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="alert_number">The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_alert> Code_scanningSlashupdate_alertAsync(string owner, string repo, int alert_number, Code_scanningSlashupdate_alertPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/alerts/"+alert_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_alert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List instances of a code scanning alert
		/// Lists all instances of the specified code scanning alert.
		/// You must use an access token with the `security_events` scope to use this endpoint with private repos,
		/// the `public_repo` scope also grants permission to read security events on public repos only.
		/// GitHub Apps must have the `security_events` read permission to use this endpoint.
		/// Code_scanningSlashlist_alert_instances repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="alert_number">The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="_ref">The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_alert_instance[]> Code_scanningSlashlist_alert_instancesAsync(string owner, string repo, int alert_number, int page, int per_page, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/alerts/"+alert_number+"/instances&page="+page+"&per_page="+per_page+"&ref=" + (_ref==null? "" : System.Uri.EscapeDataString(_ref));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_alert_instance[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List code scanning analyses for a repository
		/// Lists the details of all code scanning analyses for a repository,
		/// starting with the most recent.
		/// The response is paginated and you can use the `page` and `per_page` parameters
		/// to list the analyses you're interested in.
		/// By default 30 analyses are listed per page.
		/// 
		/// The `rules_count` field in the response give the number of rules
		/// that were run in the analysis.
		/// For very old analyses this data is not available,
		/// and `0` is returned in this field.
		/// 
		/// You must use an access token with the `security_events` scope to use this endpoint with private repos,
		/// the `public_repo` scope also grants permission to read security events on public repos only.
		/// GitHub Apps must have the `security_events` read permission to use this endpoint.
		/// 
		/// **Deprecation notice**:
		/// The `tool_name` field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the `tool` field.
		/// Code_scanningSlashlist_recent_analyses repos/{owner}/{repo}/code-scanning/analyses
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="tool_name">The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.</param>
		/// <param name="tool_guid">The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="_ref">The Git reference for the analyses you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.</param>
		/// <param name="sarif_id">Filter analyses belonging to the same SARIF upload.</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_analysis[]> Code_scanningSlashlist_recent_analysesAsync(string owner, string repo, string tool_name, string tool_guid, int page, int per_page, string _ref, string sarif_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/analyses&tool_name=" + (tool_name==null? "" : System.Uri.EscapeDataString(tool_name))+"&tool_guid=" + (tool_guid==null? "" : System.Uri.EscapeDataString(tool_guid))+"&page="+page+"&per_page="+per_page+"&ref=" + (_ref==null? "" : System.Uri.EscapeDataString(_ref))+"&sarif_id=" + (sarif_id==null? "" : System.Uri.EscapeDataString(sarif_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_analysis[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a code scanning analysis from a repository
		/// Deletes a specified code scanning analysis from a repository. For
		/// private repositories, you must use an access token with the `repo` scope. For public repositories,
		/// you must use an access token with `public_repo` scope.
		/// GitHub Apps must have the `security_events` write permission to use this endpoint.
		/// 
		/// You can delete one analysis at a time.
		/// To delete a series of analyses, start with the most recent analysis and work backwards.
		/// Conceptually, the process is similar to the undo function in a text editor.
		/// 
		/// When you list the analyses for a repository,
		/// one or more will be identified as deletable in the response:
		/// 
		/// ```
		/// "deletable": true
		/// ```
		/// 
		/// An analysis is deletable when it's the most recent in a set of analyses.
		/// Typically, a repository will have multiple sets of analyses
		/// for each enabled code scanning tool,
		/// where a set is determined by a unique combination of analysis values:
		/// 
		/// * `ref`
		/// * `tool`
		/// * `category`
		/// 
		/// If you attempt to delete an analysis that is not the most recent in a set,
		/// you'll get a 400 response with the message:
		/// 
		/// ```
		/// Analysis specified is not deletable.
		/// ```
		/// 
		/// The response from a successful `DELETE` operation provides you with
		/// two alternative URLs for deleting the next analysis in the set:
		/// `next_analysis_url` and `confirm_delete_url`.
		/// Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
		/// in a set. This is a useful option if you want to preserve at least one analysis
		/// for the specified tool in your repository.
		/// Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
		/// When you delete the last analysis in a set, the value of `next_analysis_url` and `confirm_delete_url`
		/// in the 200 response is `null`.
		/// 
		/// As an example of the deletion process,
		/// let's imagine that you added a workflow that configured a particular code scanning tool
		/// to analyze the code in a repository. This tool has added 15 analyses:
		/// 10 on the default branch, and another 5 on a topic branch.
		/// You therefore have two separate sets of analyses for this tool.
		/// You've now decided that you want to remove all of the analyses for the tool.
		/// To do this you must make 15 separate deletion requests.
		/// To start, you must find an analysis that's identified as deletable.
		/// Each set of analyses always has one that's identified as deletable.
		/// Having found the deletable analysis for one of the two sets,
		/// delete this analysis and then continue deleting the next analysis in the set until they're all deleted.
		/// Then repeat the process for the second set.
		/// The procedure therefore consists of a nested loop:
		/// 
		/// **Outer loop**:
		/// * List the analyses for the repository, filtered by tool.
		/// * Parse this list to find a deletable analysis. If found:
		/// 
		/// **Inner loop**:
		/// * Delete the identified analysis.
		/// * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next iteration.
		/// 
		/// The above process assumes that you want to remove all trace of the tool's analyses from the GitHub user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value. Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis in each set undeleted to avoid removing a tool's analysis entirely.
		/// Code_scanningSlashdelete_analysis repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="analysis_id">The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.</param>
		/// <param name="confirm_delete">Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_analysis_deletion> Code_scanningSlashdelete_analysisAsync(string owner, string repo, int analysis_id, string confirm_delete, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/analyses/"+analysis_id+"&confirm_delete=" + (confirm_delete==null? "" : System.Uri.EscapeDataString(confirm_delete));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_analysis_deletion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a code scanning analysis for a repository
		/// Gets a specified code scanning analysis for a repository.
		/// You must use an access token with the `security_events` scope to use this endpoint with private repos,
		/// the `public_repo` scope also grants permission to read security events on public repos only.
		/// GitHub Apps must have the `security_events` read permission to use this endpoint.
		/// 
		/// The default JSON response contains fields that describe the analysis.
		/// This includes the Git reference and commit SHA to which the analysis relates,
		/// the datetime of the analysis, the name of the code scanning tool,
		/// and the number of alerts.
		/// 
		/// The `rules_count` field in the default response give the number of rules
		/// that were run in the analysis.
		/// For very old analyses this data is not available,
		/// and `0` is returned in this field.
		/// 
		/// If you use the Accept header `application/sarif+json`,
		/// the response contains the analysis data that was uploaded.
		/// This is formatted as
		/// [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
		/// Code_scanningSlashget_analysis repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="analysis_id">The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_analysis> Code_scanningSlashget_analysisAsync(string owner, string repo, int analysis_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/analyses/"+analysis_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_analysis>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Upload an analysis as SARIF data
		/// Uploads SARIF data containing the results of a code scanning analysis to make the results available in a repository. You must use an access token with the `security_events` scope to use this endpoint for private repositories. You can also use tokens with the `public_repo` scope for public repositories only. GitHub Apps must have the `security_events` write permission to use this endpoint.
		/// 
		/// There are two places where you can upload code scanning results.
		/// - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref refs/pull/42/head`, then the results appear as alerts in a pull request check. For more information, see "[Triaging code scanning alerts in pull requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
		/// - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in the **Security** tab for your repository. For more information, see "[Managing code scanning alerts for your repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."
		/// 
		/// You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and then encode it as a Base64 format string. For example:
		/// 
		/// ```
		/// gzip -c analysis-data.sarif | base64 -w0
		/// ```
		/// <br>
		/// SARIF upload supports a maximum number of entries per the following data objects, and an analysis will be rejected if any of these objects is above its maximum value. For some objects, there are additional values over which the entries will be ignored while keeping the most important entries whenever applicable.
		/// To get the most out of your analysis when it includes data above the supported limits, try to optimize the analysis configuration. For example, for the CodeQL tool, identify and remove the most noisy queries.
		/// 
		/// 
		/// | **SARIF data**                   | **Maximum values** | **Additional limits**                                                            |
		/// |----------------------------------|:------------------:|----------------------------------------------------------------------------------|
		/// | Runs per file                    |         15         |                                                                                  |
		/// | Results per run                  |       25,000       | Only the top 5,000 results will be included, prioritized by severity.            |
		/// | Rules per run                    |       25,000       |                                                                                  |
		/// | Thread Flow Locations per result |       10,000       | Only the top 1,000 Thread Flow Locations will be included, using prioritization. |
		/// | Location per result	             |       1,000        | Only 100 locations will be included.                                             |
		/// 
		/// The `202 Accepted` response includes an `id` value.
		/// You can use this ID to check the status of the upload by using it in the `/sarifs/{sarif_id}` endpoint.
		/// For more information, see "[Get information about a SARIF upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload)."
		/// Code_scanningSlashupload_sarif repos/{owner}/{repo}/code-scanning/sarifs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task Code_scanningSlashupload_sarifAsync(string owner, string repo, Code_scanningSlashupload_sarifPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/sarifs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get information about a SARIF upload
		/// Gets information about a SARIF upload, including the status and the URL of the analysis that was uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code scanning analysis for a repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You must use an access token with the `security_events` scope to use this endpoint with private repos, the `public_repo` scope also grants permission to read security events on public repos only. GitHub Apps must have the `security_events` read permission to use this endpoint.
		/// Code_scanningSlashget_sarif repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="sarif_id">The SARIF ID obtained after uploading.</param>
		/// <returns>Response</returns>
		public async Task<Code_scanning_sarifs_status> Code_scanningSlashget_sarifAsync(string owner, string repo, string sarif_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/code-scanning/sarifs/"+ (sarif_id==null? "" : System.Uri.EscapeDataString(sarif_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_scanning_sarifs_status>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List CODEOWNERS errors
		/// List any syntax errors that are detected in the CODEOWNERS
		/// file.
		/// 
		/// For more information about the correct CODEOWNERS syntax,
		/// see "[About code owners](https://docs.github.com/enterprise-server@3.6/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)."
		/// ReposSlashcodeowners_errors repos/{owner}/{repo}/codeowners/errors
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)</param>
		/// <returns>Response</returns>
		public async Task<Codeowners_errors> ReposSlashcodeowners_errorsAsync(string owner, string repo, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/codeowners/errors&ref=" + (_ref==null? "" : System.Uri.EscapeDataString(_ref));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Codeowners_errors>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repository collaborators
		/// For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
		/// Organization members with write, maintain, or admin privileges on the organization-owned repository can use this endpoint.
		/// 
		/// Team members will include the members of child teams.
		/// 
		/// You must authenticate using an access token with the `read:org` and `repo` scopes with push access to use this
		/// endpoint. GitHub Apps must have the `members` organization permission and `metadata` repository permission to use this
		/// endpoint.
		/// ReposSlashlist_collaborators repos/{owner}/{repo}/collaborators
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="affiliation">Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Collaborator[]> ReposSlashlist_collaboratorsAsync(string owner, string repo, ProjectsSlashlist_collaboratorsAffiliation affiliation, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/collaborators&affiliation=" + affiliation+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Collaborator[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a repository collaborator
		/// ReposSlashremove_collaborator repos/{owner}/{repo}/collaborators/{username}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task ReposSlashremove_collaboratorAsync(string owner, string repo, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if a user is a repository collaborator
		/// For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
		/// 
		/// Team members will include the members of child teams.
		/// 
		/// You must authenticate using an access token with the `read:org` and `repo` scopes with push access to use this
		/// endpoint. GitHub Apps must have the `members` organization permission and `metadata` repository permission to use this
		/// endpoint.
		/// ReposSlashcheck_collaborator repos/{owner}/{repo}/collaborators/{username}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task ReposSlashcheck_collaboratorAsync(string owner, string repo, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a repository collaborator
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// 
		/// Adding an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/enterprise-server@3.6/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."
		/// 
		/// For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/enterprise-server@3.6/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the permission being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:
		/// 
		/// ```
		/// Cannot assign {member} permission of {role name}
		/// ```
		/// 
		/// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// 
		/// The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [repository invitations API endpoints](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#invitations).
		/// 
		/// **Updating an existing collaborator's permission level**
		/// 
		/// The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.
		/// 
		/// **Rate limits**
		/// 
		/// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
		/// ReposSlashadd_collaborator repos/{owner}/{repo}/collaborators/{username}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task ReposSlashadd_collaboratorAsync(string owner, string repo, string username, ReposSlashadd_collaboratorPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get repository permissions for a user
		/// Checks the repository permission of a collaborator. The possible repository permissions are `admin`, `write`, `read`, and `none`.
		/// ReposSlashget_collaborator_permission_level repos/{owner}/{repo}/collaborators/{username}/permission
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>if user has admin permissions</returns>
		public async Task<Repository_collaborator_permission> ReposSlashget_collaborator_permission_levelAsync(string owner, string repo, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/collaborators/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/permission";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_collaborator_permission>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List commit comments for a repository
		/// Commit Comments use [these custom media types](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#custom-media-types). You can read more about the use of media types in the API [here](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/).
		/// 
		/// Comments are ordered by ascending ID.
		/// ReposSlashlist_commit_comments_for_repo repos/{owner}/{repo}/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Commit_comment[]> ReposSlashlist_commit_comments_for_repoAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/comments&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a commit comment
		/// ReposSlashdelete_commit_comment repos/{owner}/{repo}/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		public async Task ReposSlashdelete_commit_commentAsync(string owner, string repo, int comment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a commit comment
		/// ReposSlashget_commit_comment repos/{owner}/{repo}/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Response</returns>
		public async Task<Commit_comment> ReposSlashget_commit_commentAsync(string owner, string repo, int comment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a commit comment
		/// ReposSlashupdate_commit_comment repos/{owner}/{repo}/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Response</returns>
		public async Task<Commit_comment> ReposSlashupdate_commit_commentAsync(string owner, string repo, int comment_id, ReposSlashupdate_commit_commentPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List reactions for a commit comment
		/// List the reactions to a [commit comment](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#comments).
		/// ReactionsSlashlist_for_commit_comment repos/{owner}/{repo}/comments/{comment_id}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a commit comment.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_commit_commentAsync(string owner, string repo, int comment_id, ReactionsSlashlist_for_commit_commentContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/comments/"+comment_id+"/reactions&content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for a commit comment
		/// Create a reaction to a [commit comment](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#comments). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.
		/// ReactionsSlashcreate_for_commit_comment repos/{owner}/{repo}/comments/{comment_id}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Reaction exists</returns>
		public async Task<Reaction> ReactionsSlashcreate_for_commit_commentAsync(string owner, string repo, int comment_id, ReactionsSlashcreate_for_commit_commentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/comments/"+comment_id+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a commit comment reaction
		/// **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
		/// 
		/// Delete a reaction to a [commit comment](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#comments).
		/// ReactionsSlashdelete_for_commit_comment repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <param name="reaction_id">The unique identifier of the reaction.</param>
		public async Task ReactionsSlashdelete_for_commit_commentAsync(string owner, string repo, int comment_id, int reaction_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/comments/"+comment_id+"/reactions/"+reaction_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List commits
		/// **Signature verification object**
		/// 
		/// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
		/// 
		/// | Name | Type | Description |
		/// | ---- | ---- | ----------- |
		/// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
		/// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
		/// | `signature` | `string` | The signature that was extracted from the commit. |
		/// | `payload` | `string` | The value that was signed. |
		/// 
		/// These are the possible values for `reason` in the `verification` object:
		/// 
		/// | Value | Description |
		/// | ----- | ----------- |
		/// | `expired_key` | The key that made the signature is expired. |
		/// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
		/// | `gpgverify_error` | There was an error communicating with the signature verification service. |
		/// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
		/// | `unsigned` | The object does not include a signature. |
		/// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
		/// | `no_user` | No user was associated with the `committer` email address in the commit. |
		/// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
		/// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
		/// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
		/// | `malformed_signature` | There was an error parsing the signature. |
		/// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
		/// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
		/// ReposSlashlist_commits repos/{owner}/{repo}/commits
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="sha">SHA or branch to start listing commits from. Default: the repository’s default branch (usually `main`).</param>
		/// <param name="path">Only commits containing this file path will be returned.</param>
		/// <param name="author">GitHub login or email address by which to filter by commit author.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="until">Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Commit[]> ReposSlashlist_commitsAsync(string owner, string repo, string sha, string path, string author, System.DateTimeOffset since, System.DateTimeOffset until, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits&sha=" + (sha==null? "" : System.Uri.EscapeDataString(sha))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&author=" + (author==null? "" : System.Uri.EscapeDataString(author))+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&until=" + until.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List branches for HEAD commit
		/// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
		/// ReposSlashlist_branches_for_head_commit repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="commit_sha">The SHA of the commit.</param>
		/// <returns>Response</returns>
		public async Task<Branch_short[]> ReposSlashlist_branches_for_head_commitAsync(string owner, string repo, string commit_sha, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/"+ (commit_sha==null? "" : System.Uri.EscapeDataString(commit_sha))+"/branches-where-head";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Branch_short[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List commit comments
		/// Use the `:commit_sha` to specify the commit that will have its comments listed.
		/// ReposSlashlist_comments_for_commit repos/{owner}/{repo}/commits/{commit_sha}/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="commit_sha">The SHA of the commit.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Commit_comment[]> ReposSlashlist_comments_for_commitAsync(string owner, string repo, string commit_sha, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/"+ (commit_sha==null? "" : System.Uri.EscapeDataString(commit_sha))+"/comments&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a commit comment
		/// Create a comment for a commit using its `:commit_sha`.
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// ReposSlashcreate_commit_comment repos/{owner}/{repo}/commits/{commit_sha}/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="commit_sha">The SHA of the commit.</param>
		public async Task ReposSlashcreate_commit_commentAsync(string owner, string repo, string commit_sha, ReposSlashcreate_commit_commentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/"+ (commit_sha==null? "" : System.Uri.EscapeDataString(commit_sha))+"/comments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List pull requests associated with a commit
		/// Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, will only return open pull requests associated with the commit.
		/// ReposSlashlist_pull_requests_associated_with_commit repos/{owner}/{repo}/commits/{commit_sha}/pulls
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="commit_sha">The SHA of the commit.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_simple[]> ReposSlashlist_pull_requests_associated_with_commitAsync(string owner, string repo, string commit_sha, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/"+ (commit_sha==null? "" : System.Uri.EscapeDataString(commit_sha))+"/pulls&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_simple[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a commit
		/// Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.
		/// 
		/// **Note:** If there are more than 300 files in the commit diff, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.
		/// 
		/// You can pass the appropriate [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and `patch` formats. Diffs with binary data will have no `patch` property.
		/// 
		/// To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
		/// 
		/// **Signature verification object**
		/// 
		/// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
		/// 
		/// | Name | Type | Description |
		/// | ---- | ---- | ----------- |
		/// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
		/// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
		/// | `signature` | `string` | The signature that was extracted from the commit. |
		/// | `payload` | `string` | The value that was signed. |
		/// 
		/// These are the possible values for `reason` in the `verification` object:
		/// 
		/// | Value | Description |
		/// | ----- | ----------- |
		/// | `expired_key` | The key that made the signature is expired. |
		/// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
		/// | `gpgverify_error` | There was an error communicating with the signature verification service. |
		/// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
		/// | `unsigned` | The object does not include a signature. |
		/// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
		/// | `no_user` | No user was associated with the `committer` email address in the commit. |
		/// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
		/// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
		/// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
		/// | `malformed_signature` | There was an error parsing the signature. |
		/// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
		/// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
		/// ReposSlashget_commit repos/{owner}/{repo}/commits/{ref}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="_ref">ref parameter</param>
		/// <returns>Response</returns>
		public async Task<Commit> ReposSlashget_commitAsync(string owner, string repo, int page, int per_page, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/{ref}&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List check runs for a Git reference
		/// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
		/// 
		/// Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
		/// ChecksSlashlist_for_ref repos/{owner}/{repo}/commits/{ref}/check-runs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">ref parameter</param>
		/// <param name="check_name">Returns check runs with the specified `name`.</param>
		/// <param name="status">Returns check runs with the specified `status`.</param>
		/// <param name="filter">Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ChecksSlashlist_for_refReturn> ChecksSlashlist_for_refAsync(string owner, string repo, string _ref, string check_name, Check_runStatus status, ActionsSlashlist_jobs_for_workflow_runFilter filter, int per_page, int page, int app_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/{ref}/check-runs&check_name=" + (check_name==null? "" : System.Uri.EscapeDataString(check_name))+"&status=" + status+"&filter=" + filter+"&per_page="+per_page+"&page="+page+"&app_id="+app_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ChecksSlashlist_for_refReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List check suites for a Git reference
		/// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
		/// 
		/// Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
		/// ChecksSlashlist_suites_for_ref repos/{owner}/{repo}/commits/{ref}/check-suites
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">ref parameter</param>
		/// <param name="app_id">Filters check suites by GitHub App `id`.</param>
		/// <param name="check_name">Returns check runs with the specified `name`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ChecksSlashlist_suites_for_refReturn> ChecksSlashlist_suites_for_refAsync(string owner, string repo, string _ref, int app_id, string check_name, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/{ref}/check-suites&app_id="+app_id+"&check_name=" + (check_name==null? "" : System.Uri.EscapeDataString(check_name))+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ChecksSlashlist_suites_for_refReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the combined status for a specific reference
		/// Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
		/// 
		/// 
		/// Additionally, a combined `state` is returned. The `state` is one of:
		/// 
		/// *   **failure** if any of the contexts report as `error` or `failure`
		/// *   **pending** if there are no statuses or a context is `pending`
		/// *   **success** if the latest status for all contexts is `success`
		/// ReposSlashget_combined_status_for_ref repos/{owner}/{repo}/commits/{ref}/status
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">ref parameter</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Combined_commit_status> ReposSlashget_combined_status_for_refAsync(string owner, string repo, string _ref, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/{ref}/status&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Combined_commit_status>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List commit statuses for a reference
		/// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.
		/// 
		/// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
		/// ReposSlashlist_commit_statuses_for_ref repos/{owner}/{repo}/commits/{ref}/statuses
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">ref parameter</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Status[]> ReposSlashlist_commit_statuses_for_refAsync(string owner, string repo, string _ref, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/commits/{ref}/statuses&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Compare two commits
		/// Compares two commits against one another. You can compare branches in the same repository, or you can compare branches that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/enterprise-server@3.6/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
		/// 
		/// This endpoint is equivalent to running the `git log BASE...HEAD` command, but it returns commits in a different order. The `git log BASE...HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order. You can pass the appropriate [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
		/// 
		/// The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
		/// 
		/// When calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.
		/// 
		/// **Working with large comparisons**
		/// 
		/// To process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:
		/// 
		/// - The list of changed files is only shown on the first page of results, but it includes all changed files for the entire comparison.
		/// - The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.
		/// 
		/// For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.6/rest/guides/using-pagination-in-the-rest-api)."
		/// 
		/// **Signature verification object**
		/// 
		/// The response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:
		/// 
		/// | Name | Type | Description |
		/// | ---- | ---- | ----------- |
		/// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
		/// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
		/// | `signature` | `string` | The signature that was extracted from the commit. |
		/// | `payload` | `string` | The value that was signed. |
		/// 
		/// These are the possible values for `reason` in the `verification` object:
		/// 
		/// | Value | Description |
		/// | ----- | ----------- |
		/// | `expired_key` | The key that made the signature is expired. |
		/// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
		/// | `gpgverify_error` | There was an error communicating with the signature verification service. |
		/// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
		/// | `unsigned` | The object does not include a signature. |
		/// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
		/// | `no_user` | No user was associated with the `committer` email address in the commit. |
		/// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
		/// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
		/// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
		/// | `malformed_signature` | There was an error parsing the signature. |
		/// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
		/// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
		/// ReposSlashcompare_commits repos/{owner}/{repo}/compare/{basehead}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="basehead">The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.</param>
		/// <returns>Response</returns>
		public async Task<Commit_comparison> ReposSlashcompare_commitsAsync(string owner, string repo, int page, int per_page, string basehead, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/compare/"+ (basehead==null? "" : System.Uri.EscapeDataString(basehead))+"&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit_comparison>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a file
		/// Deletes a file in a repository.
		/// 
		/// You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.
		/// 
		/// The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.
		/// 
		/// You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.
		/// 
		/// **Note:** If you use this endpoint and the "[Create or update file contents](https://docs.github.com/enterprise-server@3.6/rest/reference/repos/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
		/// ReposSlashdelete_file repos/{owner}/{repo}/contents/{path}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="path">path parameter</param>
		/// <returns>Response</returns>
		public async Task<File_commit> ReposSlashdelete_fileAsync(string owner, string repo, string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/contents/"+ (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<File_commit>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get repository content
		/// Gets the contents of a file or directory in a repository. Specify the file path or directory in `:path`. If you omit
		/// `:path`, you will receive the contents of the repository's root directory. See the description below regarding what the API response includes for directories.
		/// 
		/// Files and symlinks support [a custom media type](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#custom-media-types) for
		/// retrieving the raw content or rendered HTML (when supported). All content types support [a custom media
		/// type](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#custom-media-types) to ensure the content is returned in a consistent
		/// object format.
		/// 
		/// **Notes**:
		/// *   To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/enterprise-server@3.6/rest/reference/git#trees).
		/// *   This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the [Git Trees
		/// API](https://docs.github.com/enterprise-server@3.6/rest/reference/git#get-a-tree).
		/// *  Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
		/// #### Size limits
		/// If the requested file's size is:
		/// * 1 MB or smaller: All features of this endpoint are supported.
		/// * Between 1-100 MB: Only the `raw` or `object` [custom media types](https://docs.github.com/enterprise-server@3.6/rest/repos/contents#custom-media-types-for-repository-contents) are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty string and the `encoding` field will be `"none"`. To get the contents of these larger files, use the `raw` media type.
		/// * Greater than 100 MB: This endpoint is not supported.
		/// 
		/// #### If the content is a directory
		/// The response will be an array of objects, one object for each item in the directory.
		/// When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value
		/// _should_ be "submodule". This behavior exists in API v3 [for backwards compatibility purposes](https://git.io/v1YCW).
		/// In the next major version of the API, the type will be returned as "submodule".
		/// 
		/// #### If the content is a symlink
		/// If the requested `:path` points to a symlink, and the symlink's target is a normal file in the repository, then the
		/// API responds with the content of the file (in the format shown in the example. Otherwise, the API responds with an object
		/// describing the symlink itself.
		/// 
		/// #### If the content is a submodule
		/// The `submodule_git_url` identifies the location of the submodule repository, and the `sha` identifies a specific
		/// commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out
		/// the submodule at that specific commit.
		/// 
		/// If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the
		/// github.com URLs (`html_url` and `_links["html"]`) will have null values.
		/// ReposSlashget_content repos/{owner}/{repo}/contents/{path}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="path">path parameter</param>
		/// <param name="_ref">The name of the commit/branch/tag. Default: the repository’s default branch (usually `master`)</param>
		/// <returns>Response</returns>
		public async Task<ReposSlashget_contentReturn[]> ReposSlashget_contentAsync(string owner, string repo, string path, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/contents/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&ref=" + (_ref==null? "" : System.Uri.EscapeDataString(_ref));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReposSlashget_contentReturn[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update file contents
		/// Creates a new file or replaces an existing file in a repository. You must authenticate using an access token with the `workflow` scope to use this endpoint.
		/// 
		/// **Note:** If you use this endpoint and the "[Delete a file](https://docs.github.com/enterprise-server@3.6/rest/reference/repos/#delete-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
		/// ReposSlashcreate_or_update_file_contents repos/{owner}/{repo}/contents/{path}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="path">path parameter</param>
		/// <returns>Response</returns>
		public async Task<File_commit> ReposSlashcreate_or_update_file_contentsAsync(string owner, string repo, string path, ReposSlashcreate_or_update_file_contentsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/contents/"+ (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<File_commit>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository contributors
		/// Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.
		/// 
		/// GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
		/// ReposSlashlist_contributors repos/{owner}/{repo}/contributors
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="anon">Set to `1` or `true` to include anonymous contributors in results.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>if repository contains content</returns>
		public async Task<Contributor[]> ReposSlashlist_contributorsAsync(string owner, string repo, string anon, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/contributors&anon=" + (anon==null? "" : System.Uri.EscapeDataString(anon))+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Contributor[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repository secrets
		/// Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.
		/// DependabotSlashlist_repo_secrets repos/{owner}/{repo}/dependabot/secrets
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<DependabotSlashlist_repo_secretsReturn> DependabotSlashlist_repo_secretsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/dependabot/secrets&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DependabotSlashlist_repo_secretsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository public key
		/// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.
		/// DependabotSlashget_repo_public_key repos/{owner}/{repo}/dependabot/secrets/public-key
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Dependabot_public_key> DependabotSlashget_repo_public_keyAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/dependabot/secrets/public-key";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Dependabot_public_key>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a repository secret
		/// Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.
		/// DependabotSlashdelete_repo_secret repos/{owner}/{repo}/dependabot/secrets/{secret_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task DependabotSlashdelete_repo_secretAsync(string owner, string repo, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository secret
		/// Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.
		/// DependabotSlashget_repo_secret repos/{owner}/{repo}/dependabot/secrets/{secret_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		/// <returns>Response</returns>
		public async Task<Dependabot_secret> DependabotSlashget_repo_secretAsync(string owner, string repo, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Dependabot_secret>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a repository secret
		/// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
		/// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
		/// token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository
		/// permission to use this endpoint.
		/// 
		/// #### Example encrypting a secret using Node.js
		/// 
		/// Encrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.
		/// 
		/// ```
		/// const sodium = require('libsodium-wrappers')
		/// const secret = 'plain-text-secret' // replace with the secret you want to encrypt
		/// const key = 'base64-encoded-public-key' // replace with the Base64 encoded public key
		/// 
		/// //Check if libsodium is ready and then proceed.
		/// sodium.ready.then(() => {
		/// // Convert Secret & Base64 key to Uint8Array.
		/// let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)
		/// let binsec = sodium.from_string(secret)
		/// 
		/// //Encrypt the secret using LibSodium
		/// let encBytes = sodium.crypto_box_seal(binsec, binkey)
		/// 
		/// // Convert encrypted Uint8Array to Base64
		/// let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
		/// 
		/// console.log(output)
		/// });
		/// ```
		/// 
		/// #### Example encrypting a secret using Python
		/// 
		/// Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.
		/// 
		/// ```
		/// from base64 import b64encode
		/// from nacl import encoding, public
		/// 
		/// def encrypt(public_key: str, secret_value: str) -> str:
		/// """Encrypt a Unicode string using the public key."""
		/// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
		/// sealed_box = public.SealedBox(public_key)
		/// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
		/// return b64encode(encrypted).decode("utf-8")
		/// ```
		/// 
		/// #### Example encrypting a secret using C#
		/// 
		/// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
		/// 
		/// ```
		/// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
		/// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
		/// 
		/// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
		/// 
		/// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
		/// ```
		/// 
		/// #### Example encrypting a secret using Ruby
		/// 
		/// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
		/// 
		/// ```ruby
		/// require "rbnacl"
		/// require "base64"
		/// 
		/// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
		/// public_key = RbNaCl::PublicKey.new(key)
		/// 
		/// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
		/// encrypted_secret = box.encrypt("my_secret")
		/// 
		/// # Print the base64 encoded secret
		/// puts Base64.strict_encode64(encrypted_secret)
		/// ```
		/// DependabotSlashcreate_or_update_repo_secret repos/{owner}/{repo}/dependabot/secrets/{secret_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task DependabotSlashcreate_or_update_repo_secretAsync(string owner, string repo, string secret_name, DependabotSlashcreate_or_update_repo_secretPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/dependabot/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a diff of the dependencies between commits
		/// Gets the diff of the dependency changes between two commits of a repository, based on the changes to the dependency manifests made in those commits.
		/// Dependency_graphSlashdiff_range repos/{owner}/{repo}/dependency-graph/compare/{basehead}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="basehead">The base and head Git revisions to compare. The Git revisions will be resolved to commit SHAs. Named revisions will be resolved to their corresponding HEAD commits, and an appropriate merge base will be determined. This parameter expects the format `{base}...{head}`.</param>
		/// <param name="name">The full path, relative to the repository root, of the dependency manifest file.</param>
		/// <returns>Response</returns>
		public async Task<Dependency_graphSlashdiff_rangeReturn[]> Dependency_graphSlashdiff_rangeAsync(string owner, string repo, string basehead, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/dependency-graph/compare/"+ (basehead==null? "" : System.Uri.EscapeDataString(basehead))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Dependency_graphSlashdiff_rangeReturn[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List deployments
		/// Simple filtering of deployments is available via query parameters:
		/// ReposSlashlist_deployments repos/{owner}/{repo}/deployments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="sha">The SHA recorded at creation time.</param>
		/// <param name="_ref">The name of the ref. This can be a branch, tag, or SHA.</param>
		/// <param name="task">The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).</param>
		/// <param name="environment">The name of the environment that was deployed to (e.g., `staging` or `production`).</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Deployment[]> ReposSlashlist_deploymentsAsync(string owner, string repo, string sha, string _ref, string task, string environment, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/deployments&sha=" + (sha==null? "" : System.Uri.EscapeDataString(sha))+"&ref=" + (_ref==null? "" : System.Uri.EscapeDataString(_ref))+"&task=" + (task==null? "" : System.Uri.EscapeDataString(task))+"&environment=" + (environment==null? "" : System.Uri.EscapeDataString(environment))+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a deployment
		/// Deployments offer a few configurable parameters with certain defaults.
		/// 
		/// The `ref` parameter can be any named branch, tag, or SHA. At GitHub Enterprise Server we often deploy branches and verify them
		/// before we merge a pull request.
		/// 
		/// The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
		/// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
		/// makes it easier to track which environments have requested deployments. The default environment is `production`.
		/// 
		/// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
		/// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
		/// the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
		/// return a failure response.
		/// 
		/// By default, [commit statuses](https://docs.github.com/enterprise-server@3.6/rest/commits/statuses) for every submitted context must be in a `success`
		/// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
		/// specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
		/// not require any contexts or create any commit statuses, the deployment will always succeed.
		/// 
		/// The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
		/// field that will be passed on when a deployment event is dispatched.
		/// 
		/// The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
		/// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
		/// application with debugging enabled.
		/// 
		/// Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.
		/// 
		/// #### Merged branch response
		/// You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
		/// a deployment. This auto-merge happens when:
		/// *   Auto-merge option is enabled in the repository
		/// *   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
		/// *   There are no merge conflicts
		/// 
		/// If there are no new commits in the base branch, a new request to create a deployment should give a successful
		/// response.
		/// 
		/// #### Merge conflict response
		/// This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
		/// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.
		/// 
		/// #### Failed commit status checks
		/// This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
		/// status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.
		/// ReposSlashcreate_deployment repos/{owner}/{repo}/deployments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_deploymentAsync(string owner, string repo, ReposSlashcreate_deploymentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/deployments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a deployment
		/// If the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment. Anyone with `repo` or `repo_deployment` scopes can delete a deployment.
		/// 
		/// To set a deployment as inactive, you must:
		/// 
		/// *   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
		/// *   Mark the active deployment as inactive by adding any non-successful deployment status.
		/// 
		/// For more information, see "[Create a deployment](https://docs.github.com/enterprise-server@3.6/rest/deployments/deployments/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/enterprise-server@3.6/rest/deployments/deployment-statuses#create-a-deployment-status)."
		/// ReposSlashdelete_deployment repos/{owner}/{repo}/deployments/{deployment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="deployment_id">deployment_id parameter</param>
		public async Task ReposSlashdelete_deploymentAsync(string owner, string repo, int deployment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/deployments/"+deployment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a deployment
		/// ReposSlashget_deployment repos/{owner}/{repo}/deployments/{deployment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="deployment_id">deployment_id parameter</param>
		/// <returns>Response</returns>
		public async Task<Deployment> ReposSlashget_deploymentAsync(string owner, string repo, int deployment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/deployments/"+deployment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List deployment statuses
		/// Users with pull access can view deployment statuses for a deployment:
		/// ReposSlashlist_deployment_statuses repos/{owner}/{repo}/deployments/{deployment_id}/statuses
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="deployment_id">deployment_id parameter</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Deployment_status[]> ReposSlashlist_deployment_statusesAsync(string owner, string repo, int deployment_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/deployments/"+deployment_id+"/statuses&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment_status[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a deployment status
		/// Users with `push` access can create deployment statuses for a given deployment.
		/// 
		/// GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
		/// ReposSlashcreate_deployment_status repos/{owner}/{repo}/deployments/{deployment_id}/statuses
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="deployment_id">deployment_id parameter</param>
		public async Task ReposSlashcreate_deployment_statusAsync(string owner, string repo, int deployment_id, ReposSlashcreate_deployment_statusPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/deployments/"+deployment_id+"/statuses";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a deployment status
		/// Users with pull access can view a deployment status for a deployment:
		/// ReposSlashget_deployment_status repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="deployment_id">deployment_id parameter</param>
		/// <returns>Response</returns>
		public async Task<Deployment_status> ReposSlashget_deployment_statusAsync(string owner, string repo, int deployment_id, int status_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/deployments/"+deployment_id+"/statuses/"+status_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment_status>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a repository dispatch event
		/// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub Enterprise Server to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#repository_dispatch)."
		/// 
		/// The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
		/// 
		/// This endpoint requires write access to the repository by providing either:
		/// 
		/// - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access token for the command line](https://docs.github.com/enterprise-server@3.6/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help documentation.
		/// - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.
		/// 
		/// This input example shows how you can use the `client_payload` as a test to debug your workflow.
		/// ReposSlashcreate_dispatch_event repos/{owner}/{repo}/dispatches
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_dispatch_eventAsync(string owner, string repo, ReposSlashcreate_dispatch_eventPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/dispatches";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List environments
		/// Lists the environments for a repository.
		/// 
		/// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ReposSlashget_all_environments repos/{owner}/{repo}/environments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ReposSlashget_all_environmentsReturn> ReposSlashget_all_environmentsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReposSlashget_all_environmentsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an environment
		/// You must authenticate using an access token with the repo scope to use this endpoint.
		/// ReposSlashdelete_an_environment repos/{owner}/{repo}/environments/{environment_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="environment_name">The name of the environment.</param>
		public async Task ReposSlashdelete_an_environmentAsync(string owner, string repo, string environment_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an environment
		/// **Note:** To get information about name patterns that branches must match in order to deploy to this environment, see "[Get a deployment branch policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)."
		/// 
		/// Anyone with read access to the repository can use this endpoint. If the
		/// repository is private, you must use an access token with the `repo` scope. GitHub
		/// Apps must have the `actions:read` permission to use this endpoint.
		/// ReposSlashget_environment repos/{owner}/{repo}/environments/{environment_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <returns>Response</returns>
		public async Task<Environment> ReposSlashget_environmentAsync(string owner, string repo, string environment_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Environment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update an environment
		/// Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."
		/// 
		/// **Note:** To create or update name patterns that branches must match in order to deploy to this environment, see "[Deployment branch policies](/rest/deployments/branch-policies)."
		/// 
		/// **Note:** To create or update secrets for an environment, see "[Secrets](/rest/reference/actions#secrets)."
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.
		/// ReposSlashcreate_or_update_environment repos/{owner}/{repo}/environments/{environment_name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <returns>Response</returns>
		public async Task<Environment> ReposSlashcreate_or_update_environmentAsync(string owner, string repo, string environment_name, ReposSlashcreate_or_update_environmentPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Environment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List deployment branch policies
		/// Lists the deployment branch policies for an environment.
		/// 
		/// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ReposSlashlist_deployment_branch_policies repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ReposSlashlist_deployment_branch_policiesReturn> ReposSlashlist_deployment_branch_policiesAsync(string owner, string repo, string environment_name, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/deployment-branch-policies&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReposSlashlist_deployment_branch_policiesReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a deployment branch policy
		/// Creates a deployment branch policy for an environment.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.
		/// ReposSlashcreate_deployment_branch_policy repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <returns>Response</returns>
		public async Task<Deployment_branch_policy> ReposSlashcreate_deployment_branch_policyAsync(string owner, string repo, string environment_name, Deployment_branch_policy_name_pattern requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/deployment-branch-policies";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment_branch_policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a deployment branch policy
		/// Deletes a deployment branch policy for an environment.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.
		/// ReposSlashdelete_deployment_branch_policy repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <param name="branch_policy_id">The unique identifier of the branch policy.</param>
		public async Task ReposSlashdelete_deployment_branch_policyAsync(string owner, string repo, string environment_name, int branch_policy_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/deployment-branch-policies/"+branch_policy_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a deployment branch policy
		/// Gets a deployment branch policy for an environment.
		/// 
		/// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
		/// ReposSlashget_deployment_branch_policy repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <param name="branch_policy_id">The unique identifier of the branch policy.</param>
		/// <returns>Response</returns>
		public async Task<Deployment_branch_policy> ReposSlashget_deployment_branch_policyAsync(string owner, string repo, string environment_name, int branch_policy_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/deployment-branch-policies/"+branch_policy_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment_branch_policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a deployment branch policy
		/// Updates a deployment branch policy for an environment.
		/// 
		/// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.
		/// ReposSlashupdate_deployment_branch_policy repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <param name="branch_policy_id">The unique identifier of the branch policy.</param>
		/// <returns>Response</returns>
		public async Task<Deployment_branch_policy> ReposSlashupdate_deployment_branch_policyAsync(string owner, string repo, string environment_name, int branch_policy_id, Deployment_branch_policy_name_pattern requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/deployment-branch-policies/"+branch_policy_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment_branch_policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository events
		/// ActivitySlashlist_repo_events repos/{owner}/{repo}/events
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_repo_eventsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/events&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List forks
		/// ReposSlashlist_forks repos/{owner}/{repo}/forks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="sort">The sort order. `stargazers` will sort by star count.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> ReposSlashlist_forksAsync(string owner, string repo, ReposSlashlist_forksSort sort, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/forks&sort=" + sort+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a fork
		/// Create a fork for the authenticated user.
		/// 
		/// **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Enterprise Server Support](https://support.github.com/contact?tags=dotcom-rest-api).
		/// ReposSlashcreate_fork repos/{owner}/{repo}/forks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_forkAsync(string owner, string repo, ReposSlashcreate_forkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/forks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a blob
		/// GitSlashcreate_blob repos/{owner}/{repo}/git/blobs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task GitSlashcreate_blobAsync(string owner, string repo, GitSlashcreate_blobPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/blobs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a blob
		/// The `content` in the response will always be Base64 encoded.
		/// 
		/// _Note_: This API supports blobs up to 100 megabytes in size.
		/// GitSlashget_blob repos/{owner}/{repo}/git/blobs/{file_sha}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Blob> GitSlashget_blobAsync(string owner, string repo, string file_sha, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/blobs/"+ (file_sha==null? "" : System.Uri.EscapeDataString(file_sha));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Blob>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a commit
		/// Creates a new Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
		/// 
		/// **Signature verification object**
		/// 
		/// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
		/// 
		/// | Name | Type | Description |
		/// | ---- | ---- | ----------- |
		/// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
		/// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |
		/// | `signature` | `string` | The signature that was extracted from the commit. |
		/// | `payload` | `string` | The value that was signed. |
		/// 
		/// These are the possible values for `reason` in the `verification` object:
		/// 
		/// | Value | Description |
		/// | ----- | ----------- |
		/// | `expired_key` | The key that made the signature is expired. |
		/// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
		/// | `gpgverify_error` | There was an error communicating with the signature verification service. |
		/// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
		/// | `unsigned` | The object does not include a signature. |
		/// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
		/// | `no_user` | No user was associated with the `committer` email address in the commit. |
		/// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
		/// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
		/// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
		/// | `malformed_signature` | There was an error parsing the signature. |
		/// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
		/// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
		/// GitSlashcreate_commit repos/{owner}/{repo}/git/commits
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task GitSlashcreate_commitAsync(string owner, string repo, GitSlashcreate_commitPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/commits";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a commit
		/// Gets a Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
		/// 
		/// **Signature verification object**
		/// 
		/// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
		/// 
		/// | Name | Type | Description |
		/// | ---- | ---- | ----------- |
		/// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
		/// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |
		/// | `signature` | `string` | The signature that was extracted from the commit. |
		/// | `payload` | `string` | The value that was signed. |
		/// 
		/// These are the possible values for `reason` in the `verification` object:
		/// 
		/// | Value | Description |
		/// | ----- | ----------- |
		/// | `expired_key` | The key that made the signature is expired. |
		/// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
		/// | `gpgverify_error` | There was an error communicating with the signature verification service. |
		/// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
		/// | `unsigned` | The object does not include a signature. |
		/// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
		/// | `no_user` | No user was associated with the `committer` email address in the commit. |
		/// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
		/// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
		/// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
		/// | `malformed_signature` | There was an error parsing the signature. |
		/// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
		/// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
		/// GitSlashget_commit repos/{owner}/{repo}/git/commits/{commit_sha}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="commit_sha">The SHA of the commit.</param>
		/// <returns>Response</returns>
		public async Task<Git_commit> GitSlashget_commitAsync(string owner, string repo, string commit_sha, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/commits/"+ (commit_sha==null? "" : System.Uri.EscapeDataString(commit_sha));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Git_commit>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List matching references
		/// Returns an array of references from your Git database that match the supplied name. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be returned as an array.
		/// 
		/// When you use this endpoint without providing a `:ref`, it will return an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just `heads` and `tags`.
		/// 
		/// **Note:** You need to explicitly [request a pull request](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/enterprise-server@3.6/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
		/// 
		/// If you request matching references for a branch named `feature` but the branch `feature` doesn't exist, the response can still include other matching head refs that start with the word `feature`, such as `featureA` and `featureB`.
		/// GitSlashlist_matching_refs repos/{owner}/{repo}/git/matching-refs/{ref}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">ref parameter</param>
		/// <returns>Response</returns>
		public async Task<Git_ref[]> GitSlashlist_matching_refsAsync(string owner, string repo, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/matching-refs/{ref}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Git_ref[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a reference
		/// Returns a single reference from your Git database. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an existing ref, a `404` is returned.
		/// 
		/// **Note:** You need to explicitly [request a pull request](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/enterprise-server@3.6/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
		/// GitSlashget_ref repos/{owner}/{repo}/git/ref/{ref}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">ref parameter</param>
		/// <returns>Response</returns>
		public async Task<Git_ref> GitSlashget_refAsync(string owner, string repo, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/ref/{ref}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Git_ref>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a reference
		/// Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
		/// GitSlashcreate_ref repos/{owner}/{repo}/git/refs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task GitSlashcreate_refAsync(string owner, string repo, GitSlashcreate_refPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/refs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a reference
		/// GitSlashdelete_ref repos/{owner}/{repo}/git/refs/{ref}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">ref parameter</param>
		public async Task GitSlashdelete_refAsync(string owner, string repo, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/refs/{ref}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a reference
		/// GitSlashupdate_ref repos/{owner}/{repo}/git/refs/{ref}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">The name of the fully qualified reference to update. For example, `refs/heads/master`. If the value doesn't start with `refs` and have at least two slashes, it will be rejected.</param>
		/// <returns>Response</returns>
		public async Task<Git_ref> GitSlashupdate_refAsync(string owner, string repo, string _ref, GitSlashupdate_refPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/refs/{ref}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Git_ref>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a tag object
		/// Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/enterprise-server@3.6/rest/reference/git#create-a-reference) the `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/enterprise-server@3.6/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.
		/// 
		/// **Signature verification object**
		/// 
		/// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
		/// 
		/// | Name | Type | Description |
		/// | ---- | ---- | ----------- |
		/// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
		/// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
		/// | `signature` | `string` | The signature that was extracted from the commit. |
		/// | `payload` | `string` | The value that was signed. |
		/// 
		/// These are the possible values for `reason` in the `verification` object:
		/// 
		/// | Value | Description |
		/// | ----- | ----------- |
		/// | `expired_key` | The key that made the signature is expired. |
		/// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
		/// | `gpgverify_error` | There was an error communicating with the signature verification service. |
		/// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
		/// | `unsigned` | The object does not include a signature. |
		/// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
		/// | `no_user` | No user was associated with the `committer` email address in the commit. |
		/// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
		/// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
		/// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
		/// | `malformed_signature` | There was an error parsing the signature. |
		/// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
		/// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
		/// GitSlashcreate_tag repos/{owner}/{repo}/git/tags
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task GitSlashcreate_tagAsync(string owner, string repo, GitSlashcreate_tagPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/tags";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a tag
		/// **Signature verification object**
		/// 
		/// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
		/// 
		/// | Name | Type | Description |
		/// | ---- | ---- | ----------- |
		/// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
		/// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
		/// | `signature` | `string` | The signature that was extracted from the commit. |
		/// | `payload` | `string` | The value that was signed. |
		/// 
		/// These are the possible values for `reason` in the `verification` object:
		/// 
		/// | Value | Description |
		/// | ----- | ----------- |
		/// | `expired_key` | The key that made the signature is expired. |
		/// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
		/// | `gpgverify_error` | There was an error communicating with the signature verification service. |
		/// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
		/// | `unsigned` | The object does not include a signature. |
		/// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
		/// | `no_user` | No user was associated with the `committer` email address in the commit. |
		/// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
		/// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
		/// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
		/// | `malformed_signature` | There was an error parsing the signature. |
		/// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
		/// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
		/// GitSlashget_tag repos/{owner}/{repo}/git/tags/{tag_sha}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Git_tag> GitSlashget_tagAsync(string owner, string repo, string tag_sha, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/tags/"+ (tag_sha==null? "" : System.Uri.EscapeDataString(tag_sha));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Git_tag>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a tree
		/// The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.
		/// 
		/// If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see "[Create a commit](https://docs.github.com/enterprise-server@3.6/rest/reference/git#create-a-commit)" and "[Update a reference](https://docs.github.com/enterprise-server@3.6/rest/reference/git#update-a-reference)."
		/// 
		/// Returns an error if you try to delete a file that does not exist.
		/// GitSlashcreate_tree repos/{owner}/{repo}/git/trees
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task GitSlashcreate_treeAsync(string owner, string repo, GitSlashcreate_treePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/trees";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a tree
		/// Returns a single tree using the SHA1 value for that tree.
		/// 
		/// If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree at a time.
		/// 
		/// 
		/// **Note**: The limit for the `tree` array is 100,000 entries with a maximum size of 7 MB when using the `recursive` parameter.
		/// GitSlashget_tree repos/{owner}/{repo}/git/trees/{tree_sha}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="recursive">Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent recursively returning objects or subtrees.</param>
		/// <returns>Response</returns>
		public async Task<Git_tree> GitSlashget_treeAsync(string owner, string repo, string tree_sha, string recursive, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/git/trees/"+ (tree_sha==null? "" : System.Uri.EscapeDataString(tree_sha))+"&recursive=" + (recursive==null? "" : System.Uri.EscapeDataString(recursive));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Git_tree>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repository webhooks
		/// Lists webhooks for a repository. `last response` may return null if there have not been any deliveries within 30 days.
		/// ReposSlashlist_webhooks repos/{owner}/{repo}/hooks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Hook[]> ReposSlashlist_webhooksAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a repository webhook
		/// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
		/// share the same `config` as long as those webhooks do not have any `events` that overlap.
		/// ReposSlashcreate_webhook repos/{owner}/{repo}/hooks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_webhookAsync(string owner, string repo, ReposSlashcreate_webhookPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a repository webhook
		/// ReposSlashdelete_webhook repos/{owner}/{repo}/hooks/{hook_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task ReposSlashdelete_webhookAsync(string owner, string repo, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository webhook
		/// Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository)."
		/// ReposSlashget_webhook repos/{owner}/{repo}/hooks/{hook_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Hook> ReposSlashget_webhookAsync(string owner, string repo, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a repository webhook
		/// Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository)."
		/// ReposSlashupdate_webhook repos/{owner}/{repo}/hooks/{hook_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Hook> ReposSlashupdate_webhookAsync(string owner, string repo, int hook_id, ReposSlashupdate_webhookPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a webhook configuration for a repository
		/// Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/reference/orgs#get-a-repository-webhook)."
		/// 
		/// Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:read` permission.
		/// ReposSlashget_webhook_config_for_repo repos/{owner}/{repo}/hooks/{hook_id}/config
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Webhook_config> ReposSlashget_webhook_config_for_repoAsync(string owner, string repo, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id+"/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Webhook_config>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a webhook configuration for a repository
		/// Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/reference/orgs#update-a-repository-webhook)."
		/// 
		/// Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:write` permission.
		/// ReposSlashupdate_webhook_config_for_repo repos/{owner}/{repo}/hooks/{hook_id}/config
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Webhook_config> ReposSlashupdate_webhook_config_for_repoAsync(string owner, string repo, int hook_id, ReposSlashupdate_webhook_config_for_repoPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id+"/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Webhook_config>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List deliveries for a repository webhook
		/// Returns a list of webhook deliveries for a webhook configured in a repository.
		/// ReposSlashlist_webhook_deliveries repos/{owner}/{repo}/hooks/{hook_id}/deliveries
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="cursor">Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.</param>
		/// <returns>Response</returns>
		public async Task<Hook_delivery_item[]> ReposSlashlist_webhook_deliveriesAsync(string owner, string repo, int hook_id, int per_page, string cursor, bool redelivery, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id+"/deliveries&per_page="+per_page+"&cursor=" + (cursor==null? "" : System.Uri.EscapeDataString(cursor))+"&redelivery="+redelivery;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook_delivery_item[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a delivery for a repository webhook
		/// Returns a delivery for a webhook configured in a repository.
		/// ReposSlashget_webhook_delivery repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		/// <returns>Response</returns>
		public async Task<Hook_delivery> ReposSlashget_webhook_deliveryAsync(string owner, string repo, int hook_id, int delivery_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id+"/deliveries/"+delivery_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hook_delivery>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Redeliver a delivery for a repository webhook
		/// Redeliver a webhook delivery for a webhook configured in a repository.
		/// ReposSlashredeliver_webhook_delivery repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task ReposSlashredeliver_webhook_deliveryAsync(string owner, string repo, int hook_id, int delivery_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id+"/deliveries/"+delivery_id+"/attempts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Ping a repository webhook
		/// This will trigger a [ping event](https://docs.github.com/enterprise-server@3.6/webhooks/#ping-event) to be sent to the hook.
		/// ReposSlashping_webhook repos/{owner}/{repo}/hooks/{hook_id}/pings
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task ReposSlashping_webhookAsync(string owner, string repo, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id+"/pings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Test the push repository webhook
		/// This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.
		/// 
		/// **Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`
		/// ReposSlashtest_push_webhook repos/{owner}/{repo}/hooks/{hook_id}/tests
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="hook_id">The unique identifier of the hook.</param>
		public async Task ReposSlashtest_push_webhookAsync(string owner, string repo, int hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/hooks/"+hook_id+"/tests";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository installation for the authenticated app
		/// Enables an authenticated GitHub App to find the repository's installation information. The installation's account type will be either an organization or a user account, depending which account the repository belongs to.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashget_repo_installation repos/{owner}/{repo}/installation
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Installation> AppsSlashget_repo_installationAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/installation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Installation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repository invitations
		/// When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.
		/// ReposSlashlist_invitations repos/{owner}/{repo}/invitations
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Repository_invitation[]> ReposSlashlist_invitationsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/invitations&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_invitation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a repository invitation
		/// ReposSlashdelete_invitation repos/{owner}/{repo}/invitations/{invitation_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="invitation_id">The unique identifier of the invitation.</param>
		public async Task ReposSlashdelete_invitationAsync(string owner, string repo, int invitation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/invitations/"+invitation_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a repository invitation
		/// ReposSlashupdate_invitation repos/{owner}/{repo}/invitations/{invitation_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="invitation_id">The unique identifier of the invitation.</param>
		/// <returns>Response</returns>
		public async Task<Repository_invitation> ReposSlashupdate_invitationAsync(string owner, string repo, int invitation_id, ReposSlashupdate_invitationPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/invitations/"+invitation_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_invitation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository issues
		/// List issues in a repository. Only open issues will be listed.
		/// 
		/// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
		/// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
		/// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
		/// request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#list-pull-requests)" endpoint.
		/// IssuesSlashlist_for_repo repos/{owner}/{repo}/issues
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="milestone">If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.</param>
		/// <param name="state">Indicates the state of the issues to return.</param>
		/// <param name="assignee">Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.</param>
		/// <param name="creator">The user that created the issue.</param>
		/// <param name="mentioned">A user that's mentioned in the issue.</param>
		/// <param name="labels">A list of comma separated label names. Example: `bug,ui,@high`</param>
		/// <param name="sort">What to sort results by.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Issue[]> IssuesSlashlist_for_repoAsync(string owner, string repo, string milestone, IssuesSlashlistState state, string assignee, string creator, string mentioned, string labels, IssuesSlashlistSort sort, Enterprise_adminSlashlist_public_keysDirection direction, System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues&milestone=" + (milestone==null? "" : System.Uri.EscapeDataString(milestone))+"&state=" + state+"&assignee=" + (assignee==null? "" : System.Uri.EscapeDataString(assignee))+"&creator=" + (creator==null? "" : System.Uri.EscapeDataString(creator))+"&mentioned=" + (mentioned==null? "" : System.Uri.EscapeDataString(mentioned))+"&labels=" + (labels==null? "" : System.Uri.EscapeDataString(labels))+"&sort=" + sort+"&direction=" + direction+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an issue
		/// Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/enterprise-server@3.6/articles/disabling-issues/), the API returns a `410 Gone` status.
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// IssuesSlashcreate repos/{owner}/{repo}/issues
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task IssuesSlashcreateAsync(string owner, string repo, IssuesSlashcreatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List issue comments for a repository
		/// By default, Issue Comments are ordered by ascending ID.
		/// IssuesSlashlist_comments_for_repo repos/{owner}/{repo}/issues/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="sort">The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.</param>
		/// <param name="direction">Either `asc` or `desc`. Ignored without the `sort` parameter.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Issue_comment[]> IssuesSlashlist_comments_for_repoAsync(string owner, string repo, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Enterprise_adminSlashlist_public_keysDirection direction, System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/comments&sort=" + sort+"&direction=" + direction+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an issue comment
		/// IssuesSlashdelete_comment repos/{owner}/{repo}/issues/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		public async Task IssuesSlashdelete_commentAsync(string owner, string repo, int comment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an issue comment
		/// IssuesSlashget_comment repos/{owner}/{repo}/issues/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Response</returns>
		public async Task<Issue_comment> IssuesSlashget_commentAsync(string owner, string repo, int comment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an issue comment
		/// IssuesSlashupdate_comment repos/{owner}/{repo}/issues/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Response</returns>
		public async Task<Issue_comment> IssuesSlashupdate_commentAsync(string owner, string repo, int comment_id, IssuesSlashupdate_commentPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List reactions for an issue comment
		/// List the reactions to an [issue comment](https://docs.github.com/enterprise-server@3.6/rest/reference/issues#comments).
		/// ReactionsSlashlist_for_issue_comment repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue comment.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_issue_commentAsync(string owner, string repo, int comment_id, ReactionsSlashlist_for_issue_commentContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/comments/"+comment_id+"/reactions&content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for an issue comment
		/// Create a reaction to an [issue comment](https://docs.github.com/enterprise-server@3.6/rest/reference/issues#comments). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.
		/// ReactionsSlashcreate_for_issue_comment repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Reaction exists</returns>
		public async Task<Reaction> ReactionsSlashcreate_for_issue_commentAsync(string owner, string repo, int comment_id, ReactionsSlashcreate_for_issue_commentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/comments/"+comment_id+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an issue comment reaction
		/// **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
		/// 
		/// Delete a reaction to an [issue comment](https://docs.github.com/enterprise-server@3.6/rest/reference/issues#comments).
		/// ReactionsSlashdelete_for_issue_comment repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <param name="reaction_id">The unique identifier of the reaction.</param>
		public async Task ReactionsSlashdelete_for_issue_commentAsync(string owner, string repo, int comment_id, int reaction_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/comments/"+comment_id+"/reactions/"+reaction_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List issue events for a repository
		/// IssuesSlashlist_events_for_repo repos/{owner}/{repo}/issues/events
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Issue_event[]> IssuesSlashlist_events_for_repoAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/events&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue_event[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an issue event
		/// IssuesSlashget_event repos/{owner}/{repo}/issues/events/{event_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Issue_event> IssuesSlashget_eventAsync(string owner, string repo, int event_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/events/"+event_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue_event>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an issue
		/// The API returns a [`301 Moved Permanently` status](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
		/// [transferred](https://docs.github.com/enterprise-server@3.6/articles/transferring-an-issue-to-another-repository/) to another repository. If
		/// the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
		/// returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
		/// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
		/// to the [`issues`](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#issues) webhook.
		/// 
		/// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
		/// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
		/// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
		/// request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#list-pull-requests)" endpoint.
		/// IssuesSlashget repos/{owner}/{repo}/issues/{issue_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <returns>Response</returns>
		public async Task<Issue> IssuesSlashgetAsync(string owner, string repo, int issue_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an issue
		/// Issue owners and users with push access can edit an issue.
		/// IssuesSlashupdate repos/{owner}/{repo}/issues/{issue_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <returns>Response</returns>
		public async Task<Issue> IssuesSlashupdateAsync(string owner, string repo, int issue_number, IssuesSlashupdatePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove assignees from an issue
		/// Removes one or more assignees from an issue.
		/// IssuesSlashremove_assignees repos/{owner}/{repo}/issues/{issue_number}/assignees
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <returns>Response</returns>
		public async Task<Issue> IssuesSlashremove_assigneesAsync(string owner, string repo, int issue_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/assignees";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add assignees to an issue
		/// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
		/// IssuesSlashadd_assignees repos/{owner}/{repo}/issues/{issue_number}/assignees
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		public async Task IssuesSlashadd_assigneesAsync(string owner, string repo, int issue_number, IssuesSlashadd_assigneesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/assignees";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Check if a user can be assigned to a issue
		/// Checks if a user has permission to be assigned to a specific issue.
		/// 
		/// If the `assignee` can be assigned to this issue, a `204` status code with no content is returned.
		/// 
		/// Otherwise a `404` status code is returned.
		/// IssuesSlashcheck_user_can_be_assigned_to_issue repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		public async Task IssuesSlashcheck_user_can_be_assigned_to_issueAsync(string owner, string repo, int issue_number, string assignee, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/assignees/"+ (assignee==null? "" : System.Uri.EscapeDataString(assignee));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List issue comments
		/// Issue Comments are ordered by ascending ID.
		/// IssuesSlashlist_comments repos/{owner}/{repo}/issues/{issue_number}/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Issue_comment[]> IssuesSlashlist_commentsAsync(string owner, string repo, int issue_number, System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/comments&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an issue comment
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// IssuesSlashcreate_comment repos/{owner}/{repo}/issues/{issue_number}/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		public async Task IssuesSlashcreate_commentAsync(string owner, string repo, int issue_number, IssuesSlashcreate_commentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/comments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List issue events
		/// IssuesSlashlist_events repos/{owner}/{repo}/issues/{issue_number}/events
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Issue_event_for_issue[]> IssuesSlashlist_eventsAsync(string owner, string repo, int issue_number, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/events&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue_event_for_issue[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove all labels from an issue
		/// IssuesSlashremove_all_labels repos/{owner}/{repo}/issues/{issue_number}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		public async Task IssuesSlashremove_all_labelsAsync(string owner, string repo, int issue_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List labels for an issue
		/// IssuesSlashlist_labels_on_issue repos/{owner}/{repo}/issues/{issue_number}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Label[]> IssuesSlashlist_labels_on_issueAsync(string owner, string repo, int issue_number, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/labels&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Label[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add labels to an issue
		/// IssuesSlashadd_labels repos/{owner}/{repo}/issues/{issue_number}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <returns>Response</returns>
		public async Task<Label[]> IssuesSlashadd_labelsAsync(string owner, string repo, int issue_number, IssuesSlashadd_labelsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Label[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set labels for an issue
		/// Removes any previous labels and sets the new labels for an issue.
		/// IssuesSlashset_labels repos/{owner}/{repo}/issues/{issue_number}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <returns>Response</returns>
		public async Task<Label[]> IssuesSlashset_labelsAsync(string owner, string repo, int issue_number, IssuesSlashset_labelsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Label[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a label from an issue
		/// Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
		/// IssuesSlashremove_label repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <returns>Response</returns>
		public async Task<Label[]> IssuesSlashremove_labelAsync(string owner, string repo, int issue_number, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/labels/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Label[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unlock an issue
		/// Users with push access can unlock an issue's conversation.
		/// IssuesSlashunlock repos/{owner}/{repo}/issues/{issue_number}/lock
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		public async Task IssuesSlashunlockAsync(string owner, string repo, int issue_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/lock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lock an issue
		/// Users with push access can lock an issue or pull request's conversation.
		/// 
		/// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// IssuesSlashlock repos/{owner}/{repo}/issues/{issue_number}/lock
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		public async Task IssuesSlashlockAsync(string owner, string repo, int issue_number, IssuesSlashlockPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/lock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List reactions for an issue
		/// List the reactions to an [issue](https://docs.github.com/enterprise-server@3.6/rest/reference/issues).
		/// ReactionsSlashlist_for_issue repos/{owner}/{repo}/issues/{issue_number}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_issueAsync(string owner, string repo, int issue_number, ReactionsSlashlist_for_issueContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/reactions&content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for an issue
		/// Create a reaction to an [issue](https://docs.github.com/enterprise-server@3.6/rest/reference/issues/). A response with an HTTP `200` status means that you already added the reaction type to this issue.
		/// ReactionsSlashcreate_for_issue repos/{owner}/{repo}/issues/{issue_number}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <returns>Response</returns>
		public async Task<Reaction> ReactionsSlashcreate_for_issueAsync(string owner, string repo, int issue_number, ReactionsSlashcreate_for_issuePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an issue reaction
		/// **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
		/// 
		/// Delete a reaction to an [issue](https://docs.github.com/enterprise-server@3.6/rest/reference/issues/).
		/// ReactionsSlashdelete_for_issue repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <param name="reaction_id">The unique identifier of the reaction.</param>
		public async Task ReactionsSlashdelete_for_issueAsync(string owner, string repo, int issue_number, int reaction_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/reactions/"+reaction_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List timeline events for an issue
		/// IssuesSlashlist_events_for_timeline repos/{owner}/{repo}/issues/{issue_number}/timeline
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="issue_number">The number that identifies the issue.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Timeline_issue_events[]> IssuesSlashlist_events_for_timelineAsync(string owner, string repo, int issue_number, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/issues/"+issue_number+"/timeline&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Timeline_issue_events[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List deploy keys
		/// ReposSlashlist_deploy_keys repos/{owner}/{repo}/keys
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Deploy_key[]> ReposSlashlist_deploy_keysAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/keys&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deploy_key[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a deploy key
		/// You can create a read-only deploy key.
		/// ReposSlashcreate_deploy_key repos/{owner}/{repo}/keys
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_deploy_keyAsync(string owner, string repo, ReposSlashcreate_deploy_keyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a deploy key
		/// Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
		/// ReposSlashdelete_deploy_key repos/{owner}/{repo}/keys/{key_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="key_id">The unique identifier of the key.</param>
		public async Task ReposSlashdelete_deploy_keyAsync(string owner, string repo, int key_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/keys/"+key_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a deploy key
		/// ReposSlashget_deploy_key repos/{owner}/{repo}/keys/{key_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="key_id">The unique identifier of the key.</param>
		/// <returns>Response</returns>
		public async Task<Deploy_key> ReposSlashget_deploy_keyAsync(string owner, string repo, int key_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/keys/"+key_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deploy_key>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List labels for a repository
		/// IssuesSlashlist_labels_for_repo repos/{owner}/{repo}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Label[]> IssuesSlashlist_labels_for_repoAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/labels&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Label[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a label
		/// IssuesSlashcreate_label repos/{owner}/{repo}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task IssuesSlashcreate_labelAsync(string owner, string repo, IssuesSlashcreate_labelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a label
		/// IssuesSlashdelete_label repos/{owner}/{repo}/labels/{name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task IssuesSlashdelete_labelAsync(string owner, string repo, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/labels/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a label
		/// IssuesSlashget_label repos/{owner}/{repo}/labels/{name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Label> IssuesSlashget_labelAsync(string owner, string repo, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/labels/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Label>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a label
		/// IssuesSlashupdate_label repos/{owner}/{repo}/labels/{name}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Label> IssuesSlashupdate_labelAsync(string owner, string repo, string name, IssuesSlashupdate_labelPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/labels/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Label>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository languages
		/// Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.
		/// ReposSlashlist_languages repos/{owner}/{repo}/languages
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Language> ReposSlashlist_languagesAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/languages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Language>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable Git LFS for a repository
		/// Disables Git LFS for a repository. Access tokens must have the `admin:enterprise` scope.
		/// ReposSlashdisable_lfs_for_repo repos/{owner}/{repo}/lfs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashdisable_lfs_for_repoAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/lfs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable Git LFS for a repository
		/// Enables Git LFS for a repository. Access tokens must have the `admin:enterprise` scope.
		/// ReposSlashenable_lfs_for_repo repos/{owner}/{repo}/lfs
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashenable_lfs_for_repoAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/lfs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the license for a repository
		/// This method returns the contents of the repository's license file, if one is detected.
		/// 
		/// Similar to [Get repository content](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#get-repository-content), this method also supports [custom media types](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types) for retrieving the raw license content or rendered license HTML.
		/// LicensesSlashget_for_repo repos/{owner}/{repo}/license
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<License_content> LicensesSlashget_for_repoAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/license";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<License_content>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sync a fork branch with the upstream repository
		/// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
		/// ReposSlashmerge_upstream repos/{owner}/{repo}/merge-upstream
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>The branch has been successfully synced with the upstream repository</returns>
		public async Task<Merged_upstream> ReposSlashmerge_upstreamAsync(string owner, string repo, ReposSlashmerge_upstreamPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/merge-upstream";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Merged_upstream>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Merge a branch
		/// ReposSlashmerge repos/{owner}/{repo}/merges
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashmergeAsync(string owner, string repo, ReposSlashmergePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/merges";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List milestones
		/// IssuesSlashlist_milestones repos/{owner}/{repo}/milestones
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="state">The state of the milestone. Either `open`, `closed`, or `all`.</param>
		/// <param name="sort">What to sort results by. Either `due_on` or `completeness`.</param>
		/// <param name="direction">The direction of the sort. Either `asc` or `desc`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Milestone[]> IssuesSlashlist_milestonesAsync(string owner, string repo, IssuesSlashlistState state, IssuesSlashlist_milestonesSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/milestones&state=" + state+"&sort=" + sort+"&direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Milestone[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a milestone
		/// IssuesSlashcreate_milestone repos/{owner}/{repo}/milestones
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task IssuesSlashcreate_milestoneAsync(string owner, string repo, IssuesSlashcreate_milestonePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/milestones";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a milestone
		/// IssuesSlashdelete_milestone repos/{owner}/{repo}/milestones/{milestone_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="milestone_number">The number that identifies the milestone.</param>
		public async Task IssuesSlashdelete_milestoneAsync(string owner, string repo, int milestone_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/milestones/"+milestone_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a milestone
		/// IssuesSlashget_milestone repos/{owner}/{repo}/milestones/{milestone_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="milestone_number">The number that identifies the milestone.</param>
		/// <returns>Response</returns>
		public async Task<Milestone> IssuesSlashget_milestoneAsync(string owner, string repo, int milestone_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/milestones/"+milestone_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Milestone>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a milestone
		/// IssuesSlashupdate_milestone repos/{owner}/{repo}/milestones/{milestone_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="milestone_number">The number that identifies the milestone.</param>
		/// <returns>Response</returns>
		public async Task<Milestone> IssuesSlashupdate_milestoneAsync(string owner, string repo, int milestone_number, IssuesSlashupdate_milestonePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/milestones/"+milestone_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Milestone>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List labels for issues in a milestone
		/// IssuesSlashlist_labels_for_milestone repos/{owner}/{repo}/milestones/{milestone_number}/labels
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="milestone_number">The number that identifies the milestone.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Label[]> IssuesSlashlist_labels_for_milestoneAsync(string owner, string repo, int milestone_number, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/milestones/"+milestone_number+"/labels&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Label[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repository notifications for the authenticated user
		/// Lists all notifications for the current user in the specified repository.
		/// ActivitySlashlist_repo_notifications_for_authenticated_user repos/{owner}/{repo}/notifications
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="all">If `true`, show notifications marked as read.</param>
		/// <param name="participating">If `true`, only shows notifications in which the user is directly participating or mentioned.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="before">Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Thread[]> ActivitySlashlist_repo_notifications_for_authenticated_userAsync(string owner, string repo, bool all, bool participating, System.DateTimeOffset since, System.DateTimeOffset before, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/notifications&all="+all+"&participating="+participating+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before=" + before.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Thread[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Mark repository notifications as read
		/// Marks all notifications in a repository as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub Enterprise Server will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
		/// ActivitySlashmark_repo_notifications_as_read repos/{owner}/{repo}/notifications
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActivitySlashmark_repo_notifications_as_readAsync(string owner, string repo, ActivitySlashmark_repo_notifications_as_readPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/notifications";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a GitHub Enterprise Server Pages site
		/// Deletes a GitHub Enterprise Server Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
		/// 
		/// To use this endpoint, you must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps must have the `administration:write` and `pages:write` permissions.
		/// ReposSlashdelete_pages_site repos/{owner}/{repo}/pages
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashdelete_pages_siteAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a GitHub Enterprise Server Pages site
		/// ReposSlashget_pages repos/{owner}/{repo}/pages
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Page> ReposSlashget_pagesAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Page>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a GitHub Enterprise Server Pages site
		/// Configures a GitHub Enterprise Server Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."
		/// 
		/// To use this endpoint, you must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps must have the `administration:write` and `pages:write` permissions.
		/// ReposSlashcreate_pages_site repos/{owner}/{repo}/pages
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_pages_siteAsync(string owner, string repo, ReposSlashcreate_pages_sitePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update information about a GitHub Enterprise Server Pages site
		/// Updates information for a GitHub Enterprise Server Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
		/// 
		/// To use this endpoint, you must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps must have the `administration:write` and `pages:write` permissions.
		/// ReposSlashupdate_information_about_pages_site repos/{owner}/{repo}/pages
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashupdate_information_about_pages_siteAsync(string owner, string repo, ReposSlashupdate_information_about_pages_sitePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List GitHub Enterprise Server Pages builds
		/// ReposSlashlist_pages_builds repos/{owner}/{repo}/pages/builds
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Page_build[]> ReposSlashlist_pages_buildsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pages/builds&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Page_build[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request a GitHub Enterprise Server Pages build
		/// You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
		/// 
		/// Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
		/// ReposSlashrequest_pages_build repos/{owner}/{repo}/pages/builds
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashrequest_pages_buildAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pages/builds";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get latest Pages build
		/// ReposSlashget_latest_pages_build repos/{owner}/{repo}/pages/builds/latest
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Page_build> ReposSlashget_latest_pages_buildAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pages/builds/latest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Page_build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get GitHub Enterprise Server Pages build
		/// ReposSlashget_pages_build repos/{owner}/{repo}/pages/builds/{build_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Page_build> ReposSlashget_pages_buildAsync(string owner, string repo, int build_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pages/builds/"+build_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Page_build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List pre-receive hooks for a repository
		/// List all pre-receive hooks that are enabled or testing for this repository as well as any disabled hooks that are allowed to be enabled at the repository level. Pre-receive hooks that are disabled at a higher level and are not configurable will not be listed.
		/// Enterprise_adminSlashlist_pre_receive_hooks_for_repo repos/{owner}/{repo}/pre-receive-hooks
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <returns>Response</returns>
		public async Task<Repository_pre_receive_hook[]> Enterprise_adminSlashlist_pre_receive_hooks_for_repoAsync(string owner, string repo, int per_page, int page, Enterprise_adminSlashlist_public_keysDirection direction, Enterprise_adminSlashlist_pre_receive_environmentsSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pre-receive-hooks&per_page="+per_page+"&page="+page+"&direction=" + direction+"&sort=" + sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_pre_receive_hook[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove pre-receive hook enforcement for a repository
		/// Deletes any overridden enforcement on this repository for the specified hook.
		/// 
		/// Responds with effective values inherited from owner and/or global level.
		/// Enterprise_adminSlashremove_pre_receive_hook_enforcement_for_repo repos/{owner}/{repo}/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		/// <returns>Responds with effective values inherited from owner and/or global level.</returns>
		public async Task<Repository_pre_receive_hook> Enterprise_adminSlashremove_pre_receive_hook_enforcement_for_repoAsync(string owner, string repo, int pre_receive_hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_pre_receive_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a pre-receive hook for a repository
		/// Enterprise_adminSlashget_pre_receive_hook_for_repo repos/{owner}/{repo}/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		/// <returns>Response</returns>
		public async Task<Repository_pre_receive_hook> Enterprise_adminSlashget_pre_receive_hook_for_repoAsync(string owner, string repo, int pre_receive_hook_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_pre_receive_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update pre-receive hook enforcement for a repository
		/// For pre-receive hooks which are allowed to be configured at the repo level, you can set `enforcement`
		/// Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_repo repos/{owner}/{repo}/pre-receive-hooks/{pre_receive_hook_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pre_receive_hook_id">The unique identifier of the pre-receive hook.</param>
		/// <returns>Response</returns>
		public async Task<Repository_pre_receive_hook> Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_repoAsync(string owner, string repo, int pre_receive_hook_id, Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_repoPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pre-receive-hooks/"+pre_receive_hook_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_pre_receive_hook>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository projects
		/// Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in the repository. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
		/// ProjectsSlashlist_for_repo repos/{owner}/{repo}/projects
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="state">Indicates the state of the projects to return.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Project[]> ProjectsSlashlist_for_repoAsync(string owner, string repo, IssuesSlashlistState state, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/projects&state=" + state+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a repository project
		/// Creates a repository project board. Returns a `410 Gone` status if projects are disabled in the repository or if the repository does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
		/// ProjectsSlashcreate_for_repo repos/{owner}/{repo}/projects
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ProjectsSlashcreate_for_repoAsync(string owner, string repo, ProjectsSlashcreate_for_repoPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/projects";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List pull requests
		/// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// PullsSlashlist repos/{owner}/{repo}/pulls
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="state">Either `open`, `closed`, or `all` to filter by state.</param>
		/// <param name="head">Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.</param>
		/// <param name="_base">Filter pulls by base branch name. Example: `gh-pages`.</param>
		/// <param name="sort">What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month.</param>
		/// <param name="direction">The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_simple[]> PullsSlashlistAsync(string owner, string repo, IssuesSlashlistState state, string head, string _base, PullsSlashlistSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls&state=" + state+"&head=" + (head==null? "" : System.Uri.EscapeDataString(head))+"&base=" + (_base==null? "" : System.Uri.EscapeDataString(_base))+"&sort=" + sort+"&direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_simple[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a pull request
		/// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
		/// PullsSlashcreate repos/{owner}/{repo}/pulls
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task PullsSlashcreateAsync(string owner, string repo, PullsSlashcreatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List review comments in a repository
		/// Lists review comments for all pull requests in a repository. By default, review comments are in ascending order by ID.
		/// PullsSlashlist_review_comments_for_repo repos/{owner}/{repo}/pulls/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="direction">The direction to sort results. Ignored without `sort` parameter.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review_comment[]> PullsSlashlist_review_comments_for_repoAsync(string owner, string repo, PullsSlashlist_review_comments_for_repoSort sort, Enterprise_adminSlashlist_public_keysDirection direction, System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/comments&sort=" + sort+"&direction=" + direction+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a review comment for a pull request
		/// Deletes a review comment.
		/// PullsSlashdelete_review_comment repos/{owner}/{repo}/pulls/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		public async Task PullsSlashdelete_review_commentAsync(string owner, string repo, int comment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a review comment for a pull request
		/// Provides details for a review comment.
		/// PullsSlashget_review_comment repos/{owner}/{repo}/pulls/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review_comment> PullsSlashget_review_commentAsync(string owner, string repo, int comment_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a review comment for a pull request
		/// Enables you to edit a review comment.
		/// PullsSlashupdate_review_comment repos/{owner}/{repo}/pulls/comments/{comment_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review_comment> PullsSlashupdate_review_commentAsync(string owner, string repo, int comment_id, PullsSlashupdate_review_commentPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/comments/"+comment_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List reactions for a pull request review comment
		/// List the reactions to a [pull request review comment](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#review-comments).
		/// ReactionsSlashlist_for_pull_request_review_comment repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a pull request review comment.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_pull_request_review_commentAsync(string owner, string repo, int comment_id, ReactionsSlashlist_for_pull_request_review_commentContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/comments/"+comment_id+"/reactions&content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for a pull request review comment
		/// Create a reaction to a [pull request review comment](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.
		/// ReactionsSlashcreate_for_pull_request_review_comment repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <returns>Reaction exists</returns>
		public async Task<Reaction> ReactionsSlashcreate_for_pull_request_review_commentAsync(string owner, string repo, int comment_id, ReactionsSlashcreate_for_pull_request_review_commentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/comments/"+comment_id+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a pull request comment reaction
		/// **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
		/// 
		/// Delete a reaction to a [pull request review comment](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#review-comments).
		/// ReactionsSlashdelete_for_pull_request_comment repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		/// <param name="reaction_id">The unique identifier of the reaction.</param>
		public async Task ReactionsSlashdelete_for_pull_request_commentAsync(string owner, string repo, int comment_id, int reaction_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/comments/"+comment_id+"/reactions/"+reaction_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a pull request
		/// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// Lists details of a pull request by providing its number.
		/// 
		/// When you get, [create](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls/#create-a-pull-request), or [edit](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#update-a-pull-request) a pull request, GitHub Enterprise Server creates a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not added to the base branch or the head branch. You can review the status of the test commit using the `mergeable` key. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/enterprise-server@3.6/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
		/// 
		/// The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`, then GitHub Enterprise Server has started a background job to compute the mergeability. After giving the job time to complete, resubmit the request. When the job finishes, you will see a non-`null` value for the `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be the SHA of the _test_ merge commit.
		/// 
		/// The value of the `merge_commit_sha` attribute changes depending on the state of the pull request. Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how you merged the pull request:
		/// 
		/// *   If merged as a [merge commit](https://docs.github.com/enterprise-server@3.6/articles/about-merge-methods-on-github/), `merge_commit_sha` represents the SHA of the merge commit.
		/// *   If merged via a [squash](https://docs.github.com/enterprise-server@3.6/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha` represents the SHA of the squashed commit on the base branch.
		/// *   If [rebased](https://docs.github.com/enterprise-server@3.6/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha` represents the commit that the base branch was updated to.
		/// 
		/// Pass the appropriate [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
		/// PullsSlashget repos/{owner}/{repo}/pulls/{pull_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <returns>Pass the appropriate [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.</returns>
		public async Task<Pull_request> PullsSlashgetAsync(string owner, string repo, int pull_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a pull request
		/// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
		/// PullsSlashupdate repos/{owner}/{repo}/pulls/{pull_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request> PullsSlashupdateAsync(string owner, string repo, int pull_number, PullsSlashupdatePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List review comments on a pull request
		/// Lists all review comments for a pull request. By default, review comments are in ascending order by ID.
		/// PullsSlashlist_review_comments repos/{owner}/{repo}/pulls/{pull_number}/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="sort">The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.</param>
		/// <param name="direction">The direction to sort results. Ignored without `sort` parameter.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review_comment[]> PullsSlashlist_review_commentsAsync(string owner, string repo, int pull_number, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Enterprise_adminSlashlist_public_keysDirection direction, System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/comments&sort=" + sort+"&direction=" + direction+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a review comment for a pull request
		/// 
		/// Creates a review comment in the pull request diff. To add a regular comment to a pull request timeline, see "[Create an issue comment](https://docs.github.com/enterprise-server@3.6/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than one line in the pull request diff.
		/// 
		/// The `position` parameter is deprecated. If you use `position`, the `line`, `side`, `start_line`, and `start_side` parameters are not required.
		/// 
		/// **Note:** The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// PullsSlashcreate_review_comment repos/{owner}/{repo}/pulls/{pull_number}/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		public async Task PullsSlashcreate_review_commentAsync(string owner, string repo, int pull_number, PullsSlashcreate_review_commentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/comments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a reply for a review comment
		/// Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of the review comment you are replying to. This must be the ID of a _top-level review comment_, not a reply to that comment. Replies to replies are not supported.
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// PullsSlashcreate_reply_for_review_comment repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="comment_id">The unique identifier of the comment.</param>
		public async Task PullsSlashcreate_reply_for_review_commentAsync(string owner, string repo, int pull_number, int comment_id, PullsSlashcreate_reply_for_review_commentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/comments/"+comment_id+"/replies";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List commits on a pull request
		/// Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull requests with more than 250 commits, use the [List commits](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#list-commits) endpoint.
		/// PullsSlashlist_commits repos/{owner}/{repo}/pulls/{pull_number}/commits
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Commit[]> PullsSlashlist_commitsAsync(string owner, string repo, int pull_number, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/commits&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List pull requests files
		/// **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.
		/// PullsSlashlist_files repos/{owner}/{repo}/pulls/{pull_number}/files
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Diff_entry[]> PullsSlashlist_filesAsync(string owner, string repo, int pull_number, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/files&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Diff_entry[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if a pull request has been merged
		/// PullsSlashcheck_if_merged repos/{owner}/{repo}/pulls/{pull_number}/merge
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		public async Task PullsSlashcheck_if_mergedAsync(string owner, string repo, int pull_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/merge";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Merge a pull request
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// PullsSlashmerge repos/{owner}/{repo}/pulls/{pull_number}/merge
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <returns>if merge was successful</returns>
		public async Task<Pull_request_merge_result> PullsSlashmergeAsync(string owner, string repo, int pull_number, PullsSlashmergePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/merge";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_merge_result>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove requested reviewers from a pull request
		/// PullsSlashremove_requested_reviewers repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_simple> PullsSlashremove_requested_reviewersAsync(string owner, string repo, int pull_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/requested_reviewers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_simple>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all requested reviewers for a pull request
		/// Gets the users or teams whose review is requested for a pull request. Once a requested reviewer submits a review, they are no longer considered a requested reviewer. Their review will instead be returned by the [List reviews for a pull request](https://docs.github.com/enterprise-server@3.6/rest/pulls/reviews#list-reviews-for-a-pull-request) operation.
		/// PullsSlashlist_requested_reviewers repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review_request> PullsSlashlist_requested_reviewersAsync(string owner, string repo, int pull_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/requested_reviewers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review_request>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request reviewers for a pull request
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// PullsSlashrequest_reviewers repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		public async Task PullsSlashrequest_reviewersAsync(string owner, string repo, int pull_number, PullsSlashrequest_reviewersPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/requested_reviewers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List reviews for a pull request
		/// The list of reviews returns in chronological order.
		/// PullsSlashlist_reviews repos/{owner}/{repo}/pulls/{pull_number}/reviews
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>The list of reviews returns in chronological order.</returns>
		public async Task<Pull_request_review[]> PullsSlashlist_reviewsAsync(string owner, string repo, int pull_number, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/reviews&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a review for a pull request
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// 
		/// Pull request reviews created in the `PENDING` state are not submitted and therefore do not include the `submitted_at` property in the response. To create a pending review for a pull request, leave the `event` parameter blank. For more information about submitting a `PENDING` review, see "[Submit a review for a pull request](https://docs.github.com/enterprise-server@3.6/rest/pulls#submit-a-review-for-a-pull-request)."
		/// 
		/// **Note:** To comment on a specific line in a file, you need to first determine the _position_ of that line in the diff. The GitHub REST API offers the `application/vnd.github.v3.diff` [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request diff, add this media type to the `Accept` header of a call to the [single pull request](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#get-a-pull-request) endpoint.
		/// 
		/// The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
		/// PullsSlashcreate_review repos/{owner}/{repo}/pulls/{pull_number}/reviews
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review> PullsSlashcreate_reviewAsync(string owner, string repo, int pull_number, PullsSlashcreate_reviewPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/reviews";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a pending review for a pull request
		/// PullsSlashdelete_pending_review repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="review_id">The unique identifier of the review.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review> PullsSlashdelete_pending_reviewAsync(string owner, string repo, int pull_number, int review_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/reviews/"+review_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a review for a pull request
		/// PullsSlashget_review repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="review_id">The unique identifier of the review.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review> PullsSlashget_reviewAsync(string owner, string repo, int pull_number, int review_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/reviews/"+review_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a review for a pull request
		/// Update the review summary comment with new text.
		/// PullsSlashupdate_review repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="review_id">The unique identifier of the review.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review> PullsSlashupdate_reviewAsync(string owner, string repo, int pull_number, int review_id, PullsSlashupdate_reviewPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/reviews/"+review_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List comments for a pull request review
		/// List comments for a specific pull request review.
		/// PullsSlashlist_comments_for_review repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="review_id">The unique identifier of the review.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Review_comment[]> PullsSlashlist_comments_for_reviewAsync(string owner, string repo, int pull_number, int review_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/reviews/"+review_id+"/comments&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Review_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Dismiss a review for a pull request
		/// **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#branches), you must be a repository administrator or be included in the list of people or teams who can dismiss pull request reviews.
		/// PullsSlashdismiss_review repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="review_id">The unique identifier of the review.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review> PullsSlashdismiss_reviewAsync(string owner, string repo, int pull_number, int review_id, PullsSlashdismiss_reviewPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/reviews/"+review_id+"/dismissals";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Submit a review for a pull request
		/// Submits a pending review for a pull request. For more information about creating a pending review for a pull request, see "[Create a review for a pull request](https://docs.github.com/enterprise-server@3.6/rest/pulls#create-a-review-for-a-pull-request)."
		/// PullsSlashsubmit_review repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		/// <param name="review_id">The unique identifier of the review.</param>
		/// <returns>Response</returns>
		public async Task<Pull_request_review> PullsSlashsubmit_reviewAsync(string owner, string repo, int pull_number, int review_id, PullsSlashsubmit_reviewPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/reviews/"+review_id+"/events";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pull_request_review>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a pull request branch
		/// Updates the pull request branch with the latest upstream changes by merging HEAD from the base branch into the pull request branch.
		/// PullsSlashupdate_branch repos/{owner}/{repo}/pulls/{pull_number}/update-branch
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="pull_number">The number that identifies the pull request.</param>
		public async Task PullsSlashupdate_branchAsync(string owner, string repo, int pull_number, PullsSlashupdate_branchPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/pulls/"+pull_number+"/update-branch";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a repository README
		/// Gets the preferred README for a repository.
		/// 
		/// READMEs support [custom media types](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
		/// ReposSlashget_readme repos/{owner}/{repo}/readme
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="_ref">The name of the commit/branch/tag. Default: the repository’s default branch (usually `master`)</param>
		/// <returns>Response</returns>
		public async Task<Content_file> ReposSlashget_readmeAsync(string owner, string repo, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/readme&ref=" + (_ref==null? "" : System.Uri.EscapeDataString(_ref));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Content_file>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository README for a directory
		/// Gets the README from a repository directory.
		/// 
		/// READMEs support [custom media types](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
		/// ReposSlashget_readme_in_directory repos/{owner}/{repo}/readme/{dir}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="dir">The alternate path to look for a README file</param>
		/// <param name="_ref">The name of the commit/branch/tag. Default: the repository’s default branch (usually `master`)</param>
		/// <returns>Response</returns>
		public async Task<Content_file> ReposSlashget_readme_in_directoryAsync(string owner, string repo, string dir, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/readme/"+ (dir==null? "" : System.Uri.EscapeDataString(dir))+"&ref=" + (_ref==null? "" : System.Uri.EscapeDataString(_ref));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Content_file>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List releases
		/// This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#list-repository-tags).
		/// 
		/// Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
		/// ReposSlashlist_releases repos/{owner}/{repo}/releases
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Release[]> ReposSlashlist_releasesAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a release
		/// Users with push access to the repository can create a release.
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// ReposSlashcreate_release repos/{owner}/{repo}/releases
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_releaseAsync(string owner, string repo, ReposSlashcreate_releasePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a release asset
		/// ReposSlashdelete_release_asset repos/{owner}/{repo}/releases/assets/{asset_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="asset_id">The unique identifier of the asset.</param>
		public async Task ReposSlashdelete_release_assetAsync(string owner, string repo, int asset_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/assets/"+asset_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a release asset
		/// To download the asset's binary content, set the `Accept` header of the request to [`application/octet-stream`](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types). The API will either redirect the client to the location, or stream it directly if possible. API clients should handle both a `200` or `302` response.
		/// ReposSlashget_release_asset repos/{owner}/{repo}/releases/assets/{asset_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="asset_id">The unique identifier of the asset.</param>
		/// <returns>Response</returns>
		public async Task<Release_asset> ReposSlashget_release_assetAsync(string owner, string repo, int asset_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/assets/"+asset_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release_asset>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a release asset
		/// Users with push access to the repository can edit a release asset.
		/// ReposSlashupdate_release_asset repos/{owner}/{repo}/releases/assets/{asset_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="asset_id">The unique identifier of the asset.</param>
		/// <returns>Response</returns>
		public async Task<Release_asset> ReposSlashupdate_release_assetAsync(string owner, string repo, int asset_id, ReposSlashupdate_release_assetPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/assets/"+asset_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release_asset>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Generate release notes content for a release
		/// Generate a name and body describing a [release](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#releases). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.
		/// ReposSlashgenerate_release_notes repos/{owner}/{repo}/releases/generate-notes
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Name and body of generated release notes</returns>
		public async Task<Release_notes_content> ReposSlashgenerate_release_notesAsync(string owner, string repo, ReposSlashgenerate_release_notesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/generate-notes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release_notes_content>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the latest release
		/// View the latest published full release for the repository.
		/// 
		/// The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
		/// ReposSlashget_latest_release repos/{owner}/{repo}/releases/latest
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Release> ReposSlashget_latest_releaseAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/latest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a release by tag name
		/// Get a published release with the specified tag.
		/// ReposSlashget_release_by_tag repos/{owner}/{repo}/releases/tags/{tag}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="tag">tag parameter</param>
		/// <returns>Response</returns>
		public async Task<Release> ReposSlashget_release_by_tagAsync(string owner, string repo, string tag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/tags/"+ (tag==null? "" : System.Uri.EscapeDataString(tag));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a release
		/// Users with push access to the repository can delete a release.
		/// ReposSlashdelete_release repos/{owner}/{repo}/releases/{release_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="release_id">The unique identifier of the release.</param>
		public async Task ReposSlashdelete_releaseAsync(string owner, string repo, int release_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/"+release_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a release
		/// **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#hypermedia).
		/// ReposSlashget_release repos/{owner}/{repo}/releases/{release_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="release_id">The unique identifier of the release.</param>
		/// <returns>**Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#hypermedia).</returns>
		public async Task<Release> ReposSlashget_releaseAsync(string owner, string repo, int release_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/"+release_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a release
		/// Users with push access to the repository can edit a release.
		/// ReposSlashupdate_release repos/{owner}/{repo}/releases/{release_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="release_id">The unique identifier of the release.</param>
		/// <returns>Response</returns>
		public async Task<Release> ReposSlashupdate_releaseAsync(string owner, string repo, int release_id, ReposSlashupdate_releasePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/"+release_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List release assets
		/// ReposSlashlist_release_assets repos/{owner}/{repo}/releases/{release_id}/assets
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="release_id">The unique identifier of the release.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Release_asset[]> ReposSlashlist_release_assetsAsync(string owner, string repo, int release_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/"+release_id+"/assets&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release_asset[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List reactions for a release
		/// List the reactions to a [release](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#releases).
		/// ReactionsSlashlist_for_release repos/{owner}/{repo}/releases/{release_id}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="release_id">The unique identifier of the release.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a release.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_releaseAsync(string owner, string repo, int release_id, ReactionsSlashlist_for_releaseContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/"+release_id+"/reactions&content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for a release
		/// Create a reaction to a [release](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#releases). A response with a `Status: 200 OK` means that you already added the reaction type to this release.
		/// ReactionsSlashcreate_for_release repos/{owner}/{repo}/releases/{release_id}/reactions
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="release_id">The unique identifier of the release.</param>
		/// <returns>Reaction exists</returns>
		public async Task<Reaction> ReactionsSlashcreate_for_releaseAsync(string owner, string repo, int release_id, ReactionsSlashcreate_for_releasePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/"+release_id+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a release reaction
		/// **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.
		/// 
		/// Delete a reaction to a [release](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#releases).
		/// ReactionsSlashdelete_for_release repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="release_id">The unique identifier of the release.</param>
		/// <param name="reaction_id">The unique identifier of the reaction.</param>
		public async Task ReactionsSlashdelete_for_releaseAsync(string owner, string repo, int release_id, int reaction_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/releases/"+release_id+"/reactions/"+reaction_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repository cache replication status
		/// Lists the status of each repository cache replica.
		/// ReposSlashlist_cache_info repos/{owner}/{repo}/replicas/caches
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Status information for cache replicas</returns>
		public async Task<ReposSlashlist_cache_infoReturn[]> ReposSlashlist_cache_infoAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/replicas/caches&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReposSlashlist_cache_infoReturn[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List secret scanning alerts for a repository
		/// Lists secret scanning alerts for an eligible repository, from newest to oldest.
		/// To use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.
		/// For public repositories, you may instead use the `public_repo` scope.
		/// 
		/// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
		/// Secret_scanningSlashlist_alerts_for_repo repos/{owner}/{repo}/secret-scanning/alerts
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="state">Set to `open` or `resolved` to only list secret scanning alerts in a specific state.</param>
		/// <param name="secret_type">A comma-separated list of secret types to return. By default all secret types are returned.
		///See "[Secret scanning patterns](https://docs.github.com/enterprise-server@3.6/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)"
		///for a complete list of secret types.</param>
		/// <param name="resolution">A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.</param>
		/// <param name="sort">The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<Secret_scanning_alert[]> Secret_scanningSlashlist_alerts_for_repoAsync(string owner, string repo, Organization_secret_scanning_alertState state, string secret_type, string resolution, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/secret-scanning/alerts&state=" + state+"&secret_type=" + (secret_type==null? "" : System.Uri.EscapeDataString(secret_type))+"&resolution=" + (resolution==null? "" : System.Uri.EscapeDataString(resolution))+"&sort=" + sort+"&direction=" + direction+"&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Secret_scanning_alert[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a secret scanning alert
		/// Gets a single secret scanning alert detected in an eligible repository.
		/// To use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.
		/// For public repositories, you may instead use the `public_repo` scope.
		/// 
		/// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
		/// Secret_scanningSlashget_alert repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="alert_number">The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.</param>
		/// <returns>Response</returns>
		public async Task<Secret_scanning_alert> Secret_scanningSlashget_alertAsync(string owner, string repo, int alert_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/secret-scanning/alerts/"+alert_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Secret_scanning_alert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a secret scanning alert
		/// Updates the status of a secret scanning alert in an eligible repository.
		/// To use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.
		/// For public repositories, you may instead use the `public_repo` scope.
		/// 
		/// GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
		/// Secret_scanningSlashupdate_alert repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="alert_number">The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.</param>
		/// <returns>Response</returns>
		public async Task<Secret_scanning_alert> Secret_scanningSlashupdate_alertAsync(string owner, string repo, int alert_number, Secret_scanningSlashupdate_alertPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/secret-scanning/alerts/"+alert_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Secret_scanning_alert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List locations for a secret scanning alert
		/// Lists all locations for a given secret scanning alert for an eligible repository.
		/// To use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.
		/// For public repositories, you may instead use the `public_repo` scope.
		/// 
		/// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
		/// Secret_scanningSlashlist_locations_for_alert repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="alert_number">The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<Secret_scanning_location[]> Secret_scanningSlashlist_locations_for_alertAsync(string owner, string repo, int alert_number, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/secret-scanning/alerts/"+alert_number+"/locations&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Secret_scanning_location[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List stargazers
		/// Lists the people that have starred the repository.
		/// 
		/// You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.
		/// ActivitySlashlist_stargazers_for_repo repos/{owner}/{repo}/stargazers
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> ActivitySlashlist_stargazers_for_repoAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/stargazers&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the weekly commit activity
		/// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
		/// ReposSlashget_code_frequency_stats repos/{owner}/{repo}/stats/code_frequency
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Returns a weekly aggregate of the number of additions and deletions pushed to a repository.</returns>
		public async Task<Int32[][]> ReposSlashget_code_frequency_statsAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/stats/code_frequency";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Int32[][]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the last year of commit activity
		/// Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`.
		/// ReposSlashget_commit_activity_stats repos/{owner}/{repo}/stats/commit_activity
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Commit_activity[]> ReposSlashget_commit_activity_statsAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/stats/commit_activity";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commit_activity[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all contributor commit activity
		/// 
		/// Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:
		/// 
		/// *   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
		/// *   `a` - Number of additions
		/// *   `d` - Number of deletions
		/// *   `c` - Number of commits
		/// ReposSlashget_contributors_stats repos/{owner}/{repo}/stats/contributors
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Contributor_activity[]> ReposSlashget_contributors_statsAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/stats/contributors";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Contributor_activity[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the weekly commit count
		/// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.
		/// 
		/// The array order is oldest week (index 0) to most recent week.
		/// ReposSlashget_participation_stats repos/{owner}/{repo}/stats/participation
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>The array order is oldest week (index 0) to most recent week.</returns>
		public async Task<Participation_stats> ReposSlashget_participation_statsAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/stats/participation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Participation_stats>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the hourly commit count for each day
		/// Each array contains the day number, hour number, and number of commits:
		/// 
		/// *   `0-6`: Sunday - Saturday
		/// *   `0-23`: Hour of day
		/// *   Number of commits
		/// 
		/// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
		/// ReposSlashget_punch_card_stats repos/{owner}/{repo}/stats/punch_card
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.</returns>
		public async Task<Int32[][]> ReposSlashget_punch_card_statsAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/stats/punch_card";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Int32[][]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a commit status
		/// Users with push access in a repository can create commit statuses for a given SHA.
		/// 
		/// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
		/// ReposSlashcreate_commit_status repos/{owner}/{repo}/statuses/{sha}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_commit_statusAsync(string owner, string repo, string sha, ReposSlashcreate_commit_statusPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/statuses/"+ (sha==null? "" : System.Uri.EscapeDataString(sha));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List watchers
		/// Lists the people watching the specified repository.
		/// ActivitySlashlist_watchers_for_repo repos/{owner}/{repo}/subscribers
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> ActivitySlashlist_watchers_for_repoAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/subscribers&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a repository subscription
		/// This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#set-a-repository-subscription).
		/// ActivitySlashdelete_repo_subscription repos/{owner}/{repo}/subscription
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActivitySlashdelete_repo_subscriptionAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/subscription";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a repository subscription
		/// ActivitySlashget_repo_subscription repos/{owner}/{repo}/subscription
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>if you subscribe to the repository</returns>
		public async Task<Repository_subscription> ActivitySlashget_repo_subscriptionAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/subscription";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_subscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set a repository subscription
		/// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/enterprise-server@3.6/rest/reference/activity#delete-a-repository-subscription) completely.
		/// ActivitySlashset_repo_subscription repos/{owner}/{repo}/subscription
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Repository_subscription> ActivitySlashset_repo_subscriptionAsync(string owner, string repo, ActivitySlashset_repo_subscriptionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/subscription";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_subscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository tags
		/// ReposSlashlist_tags repos/{owner}/{repo}/tags
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Tag[]> ReposSlashlist_tagsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/tags&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Tag[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List tag protection states for a repository
		/// This returns the tag protection states of a repository.
		/// 
		/// This information is only available to repository administrators.
		/// ReposSlashlist_tag_protection repos/{owner}/{repo}/tags/protection
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Tag_protection[]> ReposSlashlist_tag_protectionAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/tags/protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Tag_protection[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a tag protection state for a repository
		/// This creates a tag protection state for a repository.
		/// This endpoint is only available to repository administrators.
		/// ReposSlashcreate_tag_protection repos/{owner}/{repo}/tags/protection
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashcreate_tag_protectionAsync(string owner, string repo, ReposSlashcreate_tag_protectionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/tags/protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a tag protection state for a repository
		/// This deletes a tag protection state for a repository.
		/// This endpoint is only available to repository administrators.
		/// ReposSlashdelete_tag_protection repos/{owner}/{repo}/tags/protection/{tag_protection_id}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="tag_protection_id">The unique identifier of the tag protection.</param>
		public async Task ReposSlashdelete_tag_protectionAsync(string owner, string repo, int tag_protection_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/tags/protection/"+tag_protection_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download a repository archive (tar)
		/// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the repository’s default branch (usually
		/// `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
		/// the `Location` header to make a second `GET` request.
		/// **Note**: For private repositories, these links are temporary and expire after five minutes.
		/// ReposSlashdownload_tarball_archive repos/{owner}/{repo}/tarball/{ref}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashdownload_tarball_archiveAsync(string owner, string repo, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/tarball/{ref}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repository teams
		/// ReposSlashlist_teams repos/{owner}/{repo}/teams
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Team[]> ReposSlashlist_teamsAsync(string owner, string repo, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/teams&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all repository topics
		/// ReposSlashget_all_topics repos/{owner}/{repo}/topics
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<Topic> ReposSlashget_all_topicsAsync(string owner, string repo, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/topics&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Topic>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Replace all repository topics
		/// ReposSlashreplace_all_topics repos/{owner}/{repo}/topics
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Topic> ReposSlashreplace_all_topicsAsync(string owner, string repo, ReposSlashreplace_all_topicsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/topics";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Topic>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Transfer a repository
		/// A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/enterprise-server@3.6/articles/about-repository-transfers/).
		/// ReposSlashtransfer repos/{owner}/{repo}/transfer
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashtransferAsync(string owner, string repo, ReposSlashtransferPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/transfer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Download a repository archive (zip)
		/// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the repository’s default branch (usually
		/// `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
		/// the `Location` header to make a second `GET` request.
		/// 
		/// **Note**: For private repositories, these links are temporary and expire after five minutes. If the repository is empty, you will receive a 404 when you follow the redirect.
		/// ReposSlashdownload_zipball_archive repos/{owner}/{repo}/zipball/{ref}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ReposSlashdownload_zipball_archiveAsync(string owner, string repo, string _ref, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo))+"/zipball/{ref}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a repository using a template
		/// Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
		/// 
		/// **OAuth scope requirements**
		/// 
		/// When using [OAuth](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
		/// 
		/// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
		/// *   `repo` scope to create a private repository
		/// ReposSlashcreate_using_template repos/{template_owner}/{template_repo}/generate
		/// </summary>
		public async Task ReposSlashcreate_using_templateAsync(string template_owner, string template_repo, ReposSlashcreate_using_templatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repos/"+ (template_owner==null? "" : System.Uri.EscapeDataString(template_owner))+"/"+ (template_repo==null? "" : System.Uri.EscapeDataString(template_repo))+"/generate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List public repositories
		/// Lists all public repositories in the order that they were created.
		/// 
		/// Note:
		/// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
		/// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of repositories.
		/// ReposSlashlist_public repositories
		/// </summary>
		/// <param name="since">A repository ID. Only return repositories with an ID greater than this ID.</param>
		/// <param name="visibility">Specifies the types of repositories to return. This endpoint will only list repositories available to all users on the enterprise.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> ReposSlashlist_publicAsync(int since, ReposSlashlist_publicVisibility visibility, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repositories?since="+since+"&visibility=" + visibility;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List environment secrets
		/// Lists all secrets available in an environment without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
		/// ActionsSlashlist_environment_secrets repositories/{repository_id}/environments/{environment_name}/secrets
		/// </summary>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<ActionsSlashlist_environment_secretsReturn> ActionsSlashlist_environment_secretsAsync(int repository_id, string environment_name, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repositories/"+repository_id+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/secrets&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsSlashlist_environment_secretsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an environment public key
		/// Get the public key for an environment, which you need to encrypt environment secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
		/// ActionsSlashget_environment_public_key repositories/{repository_id}/environments/{environment_name}/secrets/public-key
		/// </summary>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <returns>Response</returns>
		public async Task<Actions_public_key> ActionsSlashget_environment_public_keyAsync(int repository_id, string environment_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repositories/"+repository_id+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/secrets/public-key";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_public_key>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an environment secret
		/// Deletes a secret in an environment using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
		/// ActionsSlashdelete_environment_secret repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
		/// </summary>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashdelete_environment_secretAsync(int repository_id, string environment_name, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repositories/"+repository_id+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an environment secret
		/// Gets a single environment secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
		/// ActionsSlashget_environment_secret repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
		/// </summary>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <param name="secret_name">The name of the secret.</param>
		/// <returns>Response</returns>
		public async Task<Actions_secret> ActionsSlashget_environment_secretAsync(int repository_id, string environment_name, string secret_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repositories/"+repository_id+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_secret>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update an environment secret
		/// Creates or updates an environment secret with an encrypted value. Encrypt your secret using
		/// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
		/// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
		/// this endpoint.
		/// 
		/// #### Example encrypting a secret using Node.js
		/// 
		/// Encrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.
		/// 
		/// ```
		/// const sodium = require('libsodium-wrappers')
		/// const secret = 'plain-text-secret' // replace with the secret you want to encrypt
		/// const key = 'base64-encoded-public-key' // replace with the Base64 encoded public key
		/// 
		/// //Check if libsodium is ready and then proceed.
		/// sodium.ready.then(() => {
		/// // Convert Secret & Base64 key to Uint8Array.
		/// let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)
		/// let binsec = sodium.from_string(secret)
		/// 
		/// //Encrypt the secret using LibSodium
		/// let encBytes = sodium.crypto_box_seal(binsec, binkey)
		/// 
		/// // Convert encrypted Uint8Array to Base64
		/// let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
		/// 
		/// console.log(output)
		/// });
		/// ```
		/// 
		/// #### Example encrypting a secret using Python
		/// 
		/// Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.
		/// 
		/// ```
		/// from base64 import b64encode
		/// from nacl import encoding, public
		/// 
		/// def encrypt(public_key: str, secret_value: str) -> str:
		/// """Encrypt a Unicode string using the public key."""
		/// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
		/// sealed_box = public.SealedBox(public_key)
		/// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
		/// return b64encode(encrypted).decode("utf-8")
		/// ```
		/// 
		/// #### Example encrypting a secret using C#
		/// 
		/// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
		/// 
		/// ```
		/// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
		/// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
		/// 
		/// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
		/// 
		/// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
		/// ```
		/// 
		/// #### Example encrypting a secret using Ruby
		/// 
		/// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
		/// 
		/// ```ruby
		/// require "rbnacl"
		/// require "base64"
		/// 
		/// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
		/// public_key = RbNaCl::PublicKey.new(key)
		/// 
		/// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
		/// encrypted_secret = box.encrypt("my_secret")
		/// 
		/// # Print the base64 encoded secret
		/// puts Base64.strict_encode64(encrypted_secret)
		/// ```
		/// ActionsSlashcreate_or_update_environment_secret repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
		/// </summary>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		/// <param name="environment_name">The name of the environment.</param>
		/// <param name="secret_name">The name of the secret.</param>
		public async Task ActionsSlashcreate_or_update_environment_secretAsync(int repository_id, string environment_name, string secret_name, ActionsSlashcreate_or_update_environment_secretPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repositories/"+repository_id+"/environments/"+ (environment_name==null? "" : System.Uri.EscapeDataString(environment_name))+"/secrets/"+ (secret_name==null? "" : System.Uri.EscapeDataString(secret_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List provisioned SCIM groups for an enterprise
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Lists provisioned SCIM groups in an enterprise.
		/// 
		/// You can improve query search time by using the `excludedAttributes` query parameter with a value of `members` to exclude members from the response.
		/// Enterprise_adminSlashlist_provisioned_groups_enterprise scim/v2/Groups
		/// </summary>
		/// <param name="filter">If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are `externalId`, `id`, and `displayName`. For example, `?filter="externalId eq '9138790-10932-109120392-12321'"`.</param>
		/// <param name="excludedAttributes">Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time.</param>
		/// <param name="startIndex">Used for pagination: the starting index of the first result to return when paginating through values.</param>
		/// <param name="count">Used for pagination: the number of results to return per page.</param>
		/// <returns>Success, either groups were found or not found</returns>
		public async Task Enterprise_adminSlashlist_provisioned_groups_enterpriseAsync(string filter, string excludedAttributes, int startIndex, int count, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Groups?filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&excludedAttributes=" + (excludedAttributes==null? "" : System.Uri.EscapeDataString(excludedAttributes))+"&startIndex="+startIndex+"&count="+count;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Provision a SCIM enterprise group
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Creates a SCIM group for an enterprise.
		/// 
		/// If members are included as part of the group provisioning payload, they will be created as external group members. It is up to a provider to store a mapping between the `externalId` and `id` of each user.
		/// Enterprise_adminSlashprovision_enterprise_group scim/v2/Groups
		/// </summary>
		public async Task Enterprise_adminSlashprovision_enterprise_groupAsync(Group requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a SCIM group from an enterprise
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Deletes a SCIM group from an enterprise.
		/// Enterprise_adminSlashdelete_scim_group_from_enterprise scim/v2/Groups/{scim_group_id}
		/// </summary>
		/// <param name="scim_group_id">A unique identifier of the SCIM group.</param>
		public async Task Enterprise_adminSlashdelete_scim_group_from_enterpriseAsync(string scim_group_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Groups/"+ (scim_group_id==null? "" : System.Uri.EscapeDataString(scim_group_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get SCIM provisioning information for an enterprise group
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Gets information about a SCIM group.
		/// Enterprise_adminSlashget_provisioning_information_for_enterprise_group scim/v2/Groups/{scim_group_id}
		/// </summary>
		/// <param name="scim_group_id">A unique identifier of the SCIM group.</param>
		/// <param name="excludedAttributes">Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time.</param>
		/// <returns>Success, a group was found</returns>
		public async Task Enterprise_adminSlashget_provisioning_information_for_enterprise_groupAsync(string scim_group_id, string excludedAttributes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Groups/"+ (scim_group_id==null? "" : System.Uri.EscapeDataString(scim_group_id))+"&excludedAttributes=" + (excludedAttributes==null? "" : System.Uri.EscapeDataString(excludedAttributes));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an attribute for a SCIM enterprise group
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Update a provisioned group’s individual attributes.
		/// 
		/// To change a group’s values, you must provide a specific Operations JSON format that contains at least one of the add, remove, or replace operations. For examples and more information on the SCIM operations format, see the [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).  Update can also be used to add group memberships.
		/// 
		/// Group memberships can be sent one at a time or in batches for faster performance. **Note**: The memberships are referenced through a local user `id`, and the user will need to be created before they are referenced here.
		/// Enterprise_adminSlashupdate_attribute_for_enterprise_group scim/v2/Groups/{scim_group_id}
		/// </summary>
		/// <param name="scim_group_id">A unique identifier of the SCIM group.</param>
		/// <returns>Success, group was updated</returns>
		public async Task Enterprise_adminSlashupdate_attribute_for_enterprise_groupAsync(string scim_group_id, Patch_schema requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Groups/"+ (scim_group_id==null? "" : System.Uri.EscapeDataString(scim_group_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set SCIM information for a provisioned enterprise group
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Replaces an existing provisioned group’s information.
		/// 
		/// You must provide all the information required for the group as if you were provisioning it for the first time. Any existing group information that you don't provide will be removed, including group membership. If you want to only update a specific attribute, use the [Update an attribute for a SCIM enterprise group](#update-an-attribute-for-a-scim-enterprise-group) endpoint instead.
		/// Enterprise_adminSlashset_information_for_provisioned_enterprise_group scim/v2/Groups/{scim_group_id}
		/// </summary>
		/// <param name="scim_group_id">A unique identifier of the SCIM group.</param>
		/// <returns>Group was updated</returns>
		public async Task Enterprise_adminSlashset_information_for_provisioned_enterprise_groupAsync(string scim_group_id, Group requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Groups/"+ (scim_group_id==null? "" : System.Uri.EscapeDataString(scim_group_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List SCIM provisioned identities for an enterprise
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Lists provisioned SCIM enterprise members.
		/// 
		/// When a user with a SCIM-provisioned external identity is removed from an enterprise through a `patch` with `active` flag set to `false`, the account's metadata is preserved to allow the user to re-join the enterprise in the future. However, the user's account will be suspended and the user will not be able to sign-in. In order to permanently suspend the users account with no ability to re-join the enterprise in the future, use the `delete` request. Users that were not permanently deleted will be visible in the returned results.
		/// 
		/// You can improve query search time by using the `excludedAttributes` query parameter with a value of `groups` to exclude groups from the response.
		/// Enterprise_adminSlashlist_provisioned_identities_enterprise scim/v2/Users
		/// </summary>
		/// <param name="filter">If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are `userName`, `externalId`, `id`, and `displayName`. For example, `?filter="externalId eq '9138790-10932-109120392-12321'"`.</param>
		/// <param name="excludedAttributes">Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time.</param>
		/// <param name="startIndex">Used for pagination: the starting index of the first result to return when paginating through values.</param>
		/// <param name="count">Used for pagination: the number of results to return per page.</param>
		/// <returns>Success, either users were found or not found</returns>
		public async Task Enterprise_adminSlashlist_provisioned_identities_enterpriseAsync(string filter, string excludedAttributes, int startIndex, int count, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Users?filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&excludedAttributes=" + (excludedAttributes==null? "" : System.Uri.EscapeDataString(excludedAttributes))+"&startIndex="+startIndex+"&count="+count;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Provision a SCIM enterprise user
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Creates an external identity for a new SCIM enterprise user.
		/// 
		/// SCIM does not authenticate users, it only provisions them. The authentication of users is done by SAML. However, when SCIM is enabled, all users need to be provisioned through SCIM before a user can sign in through SAML. The matching of a user to a SCIM provisioned user is done when the SAML assertion is consumed. The user will be matched on SAML response `NameID` to SCIM `userName`.
		/// 
		/// When converting existing enterprise to use SCIM, the user handle (`userName`) from the SCIM payload will be used to match the provisioned user to an already existing user in the enterprise. Since the new identity record is created for newly provisioned users the matching for those records is done using a user's handle. Currently the matching will be performed to all of the users no matter if they were SAML JIT provisioned or created as local users.
		/// Enterprise_adminSlashprovision_enterprise_user scim/v2/Users
		/// </summary>
		public async Task Enterprise_adminSlashprovision_enterprise_userAsync(User requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a SCIM user from an enterprise
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Permanently suspends a SCIM user from an enterprise, removes all data for the user, obfuscates the login, email, and display name of the user, removes all external-identity SCIM attributes, and deletes the emails, avatar, PATs, SSH keys, OAuth authorizations credentials, GPG keys, and SAML mappings for the user. You will not be able to undo this action.
		/// Enterprise_adminSlashdelete_user_from_enterprise scim/v2/Users/{scim_user_id}
		/// </summary>
		/// <param name="scim_user_id">The unique identifier of the SCIM user.</param>
		public async Task Enterprise_adminSlashdelete_user_from_enterpriseAsync(string scim_user_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Users/"+ (scim_user_id==null? "" : System.Uri.EscapeDataString(scim_user_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get SCIM provisioning information for an enterprise user
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Gets information about a SCIM user.
		/// Enterprise_adminSlashget_provisioning_information_for_enterprise_user scim/v2/Users/{scim_user_id}
		/// </summary>
		/// <param name="scim_user_id">The unique identifier of the SCIM user.</param>
		/// <returns>Success, a user was found</returns>
		public async Task Enterprise_adminSlashget_provisioning_information_for_enterprise_userAsync(string scim_user_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Users/"+ (scim_user_id==null? "" : System.Uri.EscapeDataString(scim_user_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an attribute for a SCIM enterprise user
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Update a provisioned user's individual attributes.
		/// 
		/// To change a user's values, you must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`, or `replace` operations. For examples and more information on the SCIM operations format, see the [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
		/// 
		/// **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
		/// 
		/// **Warning:** Setting `active: false` will suspend a user and obfuscate the user handle and user email. Since the implementation is a generic SCIM implementation and does not differentiate yet between different IdP providers, for Okta, the user GDPR data will not be purged and the credentials will not be removed.
		/// ```
		/// {
		/// "Operations":[{
		/// "op":"replace",
		/// "value":{
		/// "active":false
		/// }
		/// }]
		/// }
		/// ```
		/// Enterprise_adminSlashupdate_attribute_for_enterprise_user scim/v2/Users/{scim_user_id}
		/// </summary>
		/// <param name="scim_user_id">The unique identifier of the SCIM user.</param>
		/// <returns>Success, user was updated</returns>
		public async Task Enterprise_adminSlashupdate_attribute_for_enterprise_userAsync(string scim_user_id, Patch_schema requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Users/"+ (scim_user_id==null? "" : System.Uri.EscapeDataString(scim_user_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set SCIM information for a provisioned enterprise user
		/// **Note:** The SCIM API endpoints for enterprise accounts are currently in *private* beta and are subject to change.
		/// 
		/// Replaces an existing provisioned user's information.
		/// 
		/// You must provide all the information required for the user as if you were provisioning them for the first time. Any existing user information that you don't provide will be removed. If you want to only update a specific attribute, use the [Update an attribute for a SCIM user](#update-an-attribute-for-a-scim-enterprise-user) endpoint instead.
		/// 
		/// **Warning:** Setting `active: false` will suspend a user and obfuscate the user handle and user email. Since the implementation is a generic SCIM implementation and does not differentiate yet between different IdP providers, for Okta, the user GDPR data will not be purged and the credentials will not be removed.
		/// Enterprise_adminSlashset_information_for_provisioned_enterprise_user scim/v2/Users/{scim_user_id}
		/// </summary>
		/// <param name="scim_user_id">The unique identifier of the SCIM user.</param>
		/// <returns>User was updated</returns>
		public async Task Enterprise_adminSlashset_information_for_provisioned_enterprise_userAsync(string scim_user_id, User requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scim/v2/Users/"+ (scim_user_id==null? "" : System.Uri.EscapeDataString(scim_user_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Search code
		/// Searches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination).
		/// 
		/// When searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.6/rest/reference/search#text-match-metadata).
		/// 
		/// For example, if you want to find the definition of the `addClass` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
		/// 
		/// `q=addClass+in:file+language:js+repo:jquery/jquery`
		/// 
		/// This query searches for the keyword `addClass` within a file's contents. The query limits the search to files where the language is JavaScript in the `jquery/jquery` repository.
		/// 
		/// #### Considerations for code search
		/// 
		/// Due to the complexity of searching code, there are a few restrictions on how searches are performed:
		/// 
		/// *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
		/// *   Only files smaller than 384 KB are searchable.
		/// *   You must always include at least one search term when searching source code. For example, searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [`amazing
		/// language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
		/// SearchSlashcode search/code
		/// </summary>
		/// <param name="q">The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub Enterprise Server. The REST API supports the same qualifiers as the web interface for GitHub Enterprise Server. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.6/rest/reference/search#constructing-a-search-query). See "[Searching code](https://docs.github.com/enterprise-server@3.6/search-github/searching-on-github/searching-code)" for a detailed list of qualifiers.</param>
		/// <param name="sort">Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub Enterprise Server search infrastructure. Default: [best match](https://docs.github.com/enterprise-server@3.6/rest/reference/search#ranking-search-results)</param>
		/// <param name="order">Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<SearchSlashcodeReturn> SearchSlashcodeAsync(string q, SearchSlashcodeSort sort, Enterprise_adminSlashget_audit_logOrder order, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/code?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&sort=" + sort+"&order=" + order+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchSlashcodeReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search commits
		/// Find commits via various criteria on the default branch (usually `main`). This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination).
		/// 
		/// When searching for commits, you can get text match metadata for the **message** field when you provide the `text-match` media type. For more details about how to receive highlighted search results, see [Text match
		/// metadata](https://docs.github.com/enterprise-server@3.6/rest/reference/search#text-match-metadata).
		/// 
		/// For example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:
		/// 
		/// `q=repo:octocat/Spoon-Knife+css`
		/// SearchSlashcommits search/commits
		/// </summary>
		/// <param name="q">The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub Enterprise Server. The REST API supports the same qualifiers as the web interface for GitHub Enterprise Server. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.6/rest/reference/search#constructing-a-search-query). See "[Searching commits](https://docs.github.com/enterprise-server@3.6/search-github/searching-on-github/searching-commits)" for a detailed list of qualifiers.</param>
		/// <param name="sort">Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/enterprise-server@3.6/rest/reference/search#ranking-search-results)</param>
		/// <param name="order">Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<SearchSlashcommitsReturn> SearchSlashcommitsAsync(string q, SearchSlashcommitsSort sort, Enterprise_adminSlashget_audit_logOrder order, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/commits?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&sort=" + sort+"&order=" + order+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchSlashcommitsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search issues and pull requests
		/// Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination).
		/// 
		/// When searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted
		/// search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.6/rest/reference/search#text-match-metadata).
		/// 
		/// For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.
		/// 
		/// `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
		/// 
		/// This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.
		/// 
		/// **Note:** For [user-to-server](https://docs.github.com/enterprise-server@3.6/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see "[Searching only issues or pull requests](https://docs.github.com/enterprise-server@3.6/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests)."
		/// SearchSlashissues_and_pull_requests search/issues
		/// </summary>
		/// <param name="q">The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub Enterprise Server. The REST API supports the same qualifiers as the web interface for GitHub Enterprise Server. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.6/rest/reference/search#constructing-a-search-query). See "[Searching issues and pull requests](https://docs.github.com/enterprise-server@3.6/search-github/searching-on-github/searching-issues-and-pull-requests)" for a detailed list of qualifiers.</param>
		/// <param name="sort">Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/enterprise-server@3.6/rest/reference/search#ranking-search-results)</param>
		/// <param name="order">Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<SearchSlashissues_and_pull_requestsReturn> SearchSlashissues_and_pull_requestsAsync(string q, SearchSlashissues_and_pull_requestsSort sort, Enterprise_adminSlashget_audit_logOrder order, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/issues?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&sort=" + sort+"&order=" + order+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchSlashissues_and_pull_requestsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search labels
		/// Find labels in a repository with names or descriptions that match search keywords. Returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination).
		/// 
		/// When searching for labels, you can get text match metadata for the label **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.6/rest/reference/search#text-match-metadata).
		/// 
		/// For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`, or `enhancement`. Your query might look like this:
		/// 
		/// `q=bug+defect+enhancement&repository_id=64778136`
		/// 
		/// The labels that best match the query appear first in the search results.
		/// SearchSlashlabels search/labels
		/// </summary>
		/// <param name="repository_id">The id of the repository.</param>
		/// <param name="q">The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.6/rest/reference/search#constructing-a-search-query).</param>
		/// <param name="sort">Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/enterprise-server@3.6/rest/reference/search#ranking-search-results)</param>
		/// <param name="order">Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<SearchSlashlabelsReturn> SearchSlashlabelsAsync(int repository_id, string q, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Enterprise_adminSlashget_audit_logOrder order, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/labels?repository_id="+repository_id+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&sort=" + sort+"&order=" + order+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchSlashlabelsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search repositories
		/// Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination).
		/// 
		/// When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.6/rest/reference/search#text-match-metadata).
		/// 
		/// For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:
		/// 
		/// `q=tetris+language:assembly&sort=stars&order=desc`
		/// 
		/// This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
		/// SearchSlashrepos search/repositories
		/// </summary>
		/// <param name="q">The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub Enterprise Server. The REST API supports the same qualifiers as the web interface for GitHub Enterprise Server. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.6/rest/reference/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/enterprise-server@3.6/articles/searching-for-repositories/)" for a detailed list of qualifiers.</param>
		/// <param name="sort">Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/enterprise-server@3.6/rest/reference/search#ranking-search-results)</param>
		/// <param name="order">Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<SearchSlashreposReturn> SearchSlashreposAsync(string q, SearchSlashreposSort sort, Enterprise_adminSlashget_audit_logOrder order, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/repositories?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&sort=" + sort+"&order=" + order+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchSlashreposReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search topics
		/// Find topics via various criteria. Results are sorted by best match. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination). See "[Searching topics](https://docs.github.com/enterprise-server@3.6/articles/searching-topics/)" for a detailed list of qualifiers.
		/// 
		/// When searching for topics, you can get text match metadata for the topic's **short\_description**, **description**, **name**, or **display\_name** field when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.6/rest/reference/search#text-match-metadata).
		/// 
		/// For example, if you want to search for topics related to Ruby that are featured on https://github.com/topics. Your query might look like this:
		/// 
		/// `q=ruby+is:featured`
		/// 
		/// This query searches for topics with the keyword `ruby` and limits the results to find only topics that are featured. The topics that are the best match for the query appear first in the search results.
		/// SearchSlashtopics search/topics
		/// </summary>
		/// <param name="q">The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub Enterprise Server. The REST API supports the same qualifiers as the web interface for GitHub Enterprise Server. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.6/rest/reference/search#constructing-a-search-query).</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<SearchSlashtopicsReturn> SearchSlashtopicsAsync(string q, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/topics?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchSlashtopicsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search users
		/// Find users via various criteria. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#pagination).
		/// 
		/// When searching for users, you can get text match metadata for the issue **login**, public **email**, and **name** fields when you pass the `text-match` media type. For more details about highlighting search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.6/rest/reference/search#text-match-metadata). For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.6/rest/reference/search#text-match-metadata).
		/// 
		/// For example, if you're looking for a list of popular users, you might try this query:
		/// 
		/// `q=tom+repos:%3E42+followers:%3E1000`
		/// 
		/// This query searches for users with the name `tom`. The results are restricted to users with more than 42 repositories and over 1,000 followers.
		/// SearchSlashusers search/users
		/// </summary>
		/// <param name="q">The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub Enterprise Server. The REST API supports the same qualifiers as the web interface for GitHub Enterprise Server. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.6/rest/reference/search#constructing-a-search-query). See "[Searching users](https://docs.github.com/enterprise-server@3.6/search-github/searching-on-github/searching-users)" for a detailed list of qualifiers.</param>
		/// <param name="sort">Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub Enterprise Server. Default: [best match](https://docs.github.com/enterprise-server@3.6/rest/reference/search#ranking-search-results)</param>
		/// <param name="order">Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<SearchSlashusersReturn> SearchSlashusersAsync(string q, SearchSlashusersSort sort, Enterprise_adminSlashget_audit_logOrder order, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/users?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&sort=" + sort+"&order=" + order+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchSlashusersReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the configuration status
		/// This endpoint allows you to check the status of the most recent configuration process:
		/// 
		/// Note that you may need to wait several seconds after you start a process before you can check its status.
		/// 
		/// The different statuses are:
		/// 
		/// | Status        | Description                       |
		/// | ------------- | --------------------------------- |
		/// | `PENDING`     | The job has not started yet       |
		/// | `CONFIGURING` | The job is running                |
		/// | `DONE`        | The job has finished correctly    |
		/// | `FAILED`      | The job has finished unexpectedly |
		/// Enterprise_adminSlashget_configuration_status setup/api/configcheck
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Configuration_status> Enterprise_adminSlashget_configuration_statusAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "setup/api/configcheck";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Configuration_status>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start a configuration process
		/// This endpoint allows you to start a configuration process at any time for your updated settings to take effect:
		/// Enterprise_adminSlashstart_configuration_process setup/api/configure
		/// </summary>
		public async Task Enterprise_adminSlashstart_configuration_processAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "setup/api/configure";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the maintenance status
		/// Check your installation's maintenance status:
		/// Enterprise_adminSlashget_maintenance_status setup/api/maintenance
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Maintenance_status> Enterprise_adminSlashget_maintenance_statusAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "setup/api/maintenance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Maintenance_status>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get settings
		/// Gets the settings for your instance. To change settings, see the [Set settings endpoint](https://docs.github.com/enterprise-server@3.6/rest/reference/enterprise-admin#set-settings).
		/// 
		/// **Note:** You cannot retrieve the management console password with the Enterprise administration API.
		/// Enterprise_adminSlashget_settings setup/api/settings
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Enterprise_settings> Enterprise_adminSlashget_settingsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "setup/api/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Enterprise_settings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove an authorized SSH key
		/// **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode).
		/// Enterprise_adminSlashremove_authorized_ssh_key setup/api/settings/authorized-keys
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Ssh_key[]> Enterprise_adminSlashremove_authorized_ssh_keyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "setup/api/settings/authorized-keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ssh_key[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all authorized SSH keys
		/// Enterprise_adminSlashget_all_authorized_ssh_keys setup/api/settings/authorized-keys
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Ssh_key[]> Enterprise_adminSlashget_all_authorized_ssh_keysAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "setup/api/settings/authorized-keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ssh_key[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a team (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a team](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#delete-a-team) endpoint.
		/// 
		/// To delete a team, the authenticated user must be an organization owner or team maintainer.
		/// 
		/// If you are an organization owner, deleting a parent team will delete all of its child teams as well.
		/// TeamsSlashdelete_legacy teams/{team_id}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		public async Task TeamsSlashdelete_legacyAsync(int team_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a team (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the [Get a team by name](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#get-a-team-by-name) endpoint.
		/// TeamsSlashget_legacy teams/{team_id}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <returns>Response</returns>
		public async Task<Team_full> TeamsSlashget_legacyAsync(int team_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_full>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a team (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a team](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#update-a-team) endpoint.
		/// 
		/// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
		/// 
		/// **Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
		/// TeamsSlashupdate_legacy teams/{team_id}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <returns>Response when the updated information already exists</returns>
		public async Task<Team_full> TeamsSlashupdate_legacyAsync(int team_id, TeamsSlashupdate_legacyPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_full>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List discussions (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#list-discussions) endpoint.
		/// 
		/// List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// TeamsSlashlist_discussions_legacy teams/{team_id}/discussions
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion[]> TeamsSlashlist_discussions_legacyAsync(int team_id, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions?direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a discussion (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#create-a-discussion) endpoint.
		/// 
		/// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// TeamsSlashcreate_discussion_legacy teams/{team_id}/discussions
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		public async Task TeamsSlashcreate_discussion_legacyAsync(int team_id, TeamsSlashcreate_discussion_legacyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a discussion (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#delete-a-discussion) endpoint.
		/// 
		/// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// TeamsSlashdelete_discussion_legacy teams/{team_id}/discussions/{discussion_number}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		public async Task TeamsSlashdelete_discussion_legacyAsync(int team_id, int discussion_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a discussion (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#get-a-discussion) endpoint.
		/// 
		/// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// TeamsSlashget_discussion_legacy teams/{team_id}/discussions/{discussion_number}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion> TeamsSlashget_discussion_legacyAsync(int team_id, int discussion_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a discussion (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#update-a-discussion) endpoint.
		/// 
		/// Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// TeamsSlashupdate_discussion_legacy teams/{team_id}/discussions/{discussion_number}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion> TeamsSlashupdate_discussion_legacyAsync(int team_id, int discussion_number, TeamsSlashupdate_discussion_legacyPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List discussion comments (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List discussion comments](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#list-discussion-comments) endpoint.
		/// 
		/// List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// TeamsSlashlist_discussion_comments_legacy teams/{team_id}/discussions/{discussion_number}/comments
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion_comment[]> TeamsSlashlist_discussion_comments_legacyAsync(int team_id, int discussion_number, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/comments?direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion_comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a discussion comment (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Create a discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#create-a-discussion-comment) endpoint.
		/// 
		/// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// 
		/// This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.6/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.6/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
		/// TeamsSlashcreate_discussion_comment_legacy teams/{team_id}/discussions/{discussion_number}/comments
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		public async Task TeamsSlashcreate_discussion_comment_legacyAsync(int team_id, int discussion_number, TeamsSlashcreate_discussion_comment_legacyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/comments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a discussion comment (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#delete-a-discussion-comment) endpoint.
		/// 
		/// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// TeamsSlashdelete_discussion_comment_legacy teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		public async Task TeamsSlashdelete_discussion_comment_legacyAsync(int team_id, int discussion_number, int comment_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/comments/"+comment_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a discussion comment (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#get-a-discussion-comment) endpoint.
		/// 
		/// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// TeamsSlashget_discussion_comment_legacy teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion_comment> TeamsSlashget_discussion_comment_legacyAsync(int team_id, int discussion_number, int comment_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/comments/"+comment_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a discussion comment (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#update-a-discussion-comment) endpoint.
		/// 
		/// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// TeamsSlashupdate_discussion_comment_legacy teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		/// <returns>Response</returns>
		public async Task<Team_discussion_comment> TeamsSlashupdate_discussion_comment_legacyAsync(int team_id, int discussion_number, int comment_number, TeamsSlashupdate_discussion_comment_legacyPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/comments/"+comment_number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_discussion_comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List reactions for a team discussion comment (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
		/// 
		/// List the reactions to a [team discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// ReactionsSlashlist_for_team_discussion_comment_legacy teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_team_discussion_comment_legacyAsync(int team_id, int discussion_number, int comment_number, ReactionsSlashlist_for_team_discussion_comment_legacyContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/comments/"+comment_number+"/reactions?content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for a team discussion comment (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
		/// 
		/// Create a reaction to a [team discussion comment](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
		/// ReactionsSlashcreate_for_team_discussion_comment_legacy teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="comment_number">The number that identifies the comment.</param>
		public async Task ReactionsSlashcreate_for_team_discussion_comment_legacyAsync(int team_id, int discussion_number, int comment_number, ReactionsSlashcreate_for_team_discussion_comment_legacyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/comments/"+comment_number+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List reactions for a team discussion (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.
		/// 
		/// List the reactions to a [team discussion](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// ReactionsSlashlist_for_team_discussion_legacy teams/{team_id}/discussions/{discussion_number}/reactions
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		/// <param name="content">Returns a single [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Reaction[]> ReactionsSlashlist_for_team_discussion_legacyAsync(int team_id, int discussion_number, ReactionsSlashlist_for_team_discussion_legacyContent content, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/reactions?content=" + content+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reaction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create reaction for a team discussion (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.
		/// 
		/// Create a reaction to a [team discussion](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
		/// ReactionsSlashcreate_for_team_discussion_legacy teams/{team_id}/discussions/{discussion_number}/reactions
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="discussion_number">The number that identifies the discussion.</param>
		public async Task ReactionsSlashcreate_for_team_discussion_legacyAsync(int team_id, int discussion_number, ReactionsSlashcreate_for_team_discussion_legacyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/discussions/"+discussion_number+"/reactions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List team members (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team members`](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#list-team-members) endpoint.
		/// 
		/// Team members will include the members of child teams.
		/// TeamsSlashlist_members_legacy teams/{team_id}/members
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="role">Filters members returned by their role in the team.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> TeamsSlashlist_members_legacyAsync(int team_id, TeamsSlashlist_members_in_orgRole role, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/members?role=" + role+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove team member (Legacy)
		/// The "Remove team member" endpoint (described below) is deprecated.
		/// 
		/// We recommend using the [Remove team membership for a user](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to remove both active and pending memberships.
		/// 
		/// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// To remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. Removing a team member does not delete the user, it just removes them from the team.
		/// 
		/// **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub Enterprise Server team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub Enterprise Server](https://docs.github.com/enterprise-server@3.6/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
		/// TeamsSlashremove_member_legacy teams/{team_id}/members/{username}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task TeamsSlashremove_member_legacyAsync(int team_id, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/members/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get team member (Legacy)
		/// The "Get team member" endpoint (described below) is deprecated.
		/// 
		/// We recommend using the [Get team membership for a user](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get both active and pending memberships.
		/// 
		/// To list members in a team, the team must be visible to the authenticated user.
		/// TeamsSlashget_member_legacy teams/{team_id}/members/{username}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task TeamsSlashget_member_legacyAsync(int team_id, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/members/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add team member (Legacy)
		/// The "Add team member" endpoint (described below) is deprecated.
		/// 
		/// We recommend using the [Add or update team membership for a user](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you to invite new organization members to your teams.
		/// 
		/// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// To add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're changing. The person being added to the team must be a member of the team's organization.
		/// 
		/// **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub Enterprise Server team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub Enterprise Server](https://docs.github.com/enterprise-server@3.6/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
		/// 
		/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// TeamsSlashadd_member_legacy teams/{team_id}/members/{username}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task TeamsSlashadd_member_legacyAsync(int team_id, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/members/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove team membership for a user (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove team membership for a user](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#remove-team-membership-for-a-user) endpoint.
		/// 
		/// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.
		/// 
		/// **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub Enterprise Server team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub Enterprise Server](https://docs.github.com/enterprise-server@3.6/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
		/// TeamsSlashremove_membership_for_user_legacy teams/{team_id}/memberships/{username}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task TeamsSlashremove_membership_for_user_legacyAsync(int team_id, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get team membership for a user (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get team membership for a user](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#get-team-membership-for-a-user) endpoint.
		/// 
		/// Team members will include the members of child teams.
		/// 
		/// To get a user's membership with a team, the team must be visible to the authenticated user.
		/// 
		/// **Note:**
		/// The response contains the `state` of the membership and the member's `role`.
		/// 
		/// The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see [Create a team](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#create-a-team).
		/// TeamsSlashget_membership_for_user_legacy teams/{team_id}/memberships/{username}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Team_membership> TeamsSlashget_membership_for_user_legacyAsync(int team_id, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_membership>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add or update team membership for a user (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team membership for a user](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint.
		/// 
		/// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/enterprise-server@3.6/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
		/// 
		/// If the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership between an organization member and a team, the authenticated user must be an organization owner or a team maintainer.
		/// 
		/// **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub Enterprise Server team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub Enterprise Server](https://docs.github.com/enterprise-server@3.6/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
		/// 
		/// If the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email. This newly-created membership will be in the "pending" state until the user accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team. To add a membership between an unaffiliated user and a team, the authenticated user must be an organization owner.
		/// 
		/// If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.
		/// TeamsSlashadd_or_update_membership_for_user_legacy teams/{team_id}/memberships/{username}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Team_membership> TeamsSlashadd_or_update_membership_for_user_legacyAsync(int team_id, string username, TeamsSlashadd_or_update_membership_for_user_legacyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/memberships/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_membership>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List team projects (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team projects`](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#list-team-projects) endpoint.
		/// 
		/// Lists the organization projects for a team.
		/// TeamsSlashlist_projects_legacy teams/{team_id}/projects
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Team_project[]> TeamsSlashlist_projects_legacyAsync(int team_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/projects?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_project[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a project from a team (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a project from a team](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#remove-a-project-from-a-team) endpoint.
		/// 
		/// Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
		/// TeamsSlashremove_project_legacy teams/{team_id}/projects/{project_id}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="project_id">The unique identifier of the project.</param>
		public async Task TeamsSlashremove_project_legacyAsync(int team_id, int project_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check team permissions for a project (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a project](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#check-team-permissions-for-a-project) endpoint.
		/// 
		/// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.
		/// TeamsSlashcheck_permissions_for_project_legacy teams/{team_id}/projects/{project_id}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="project_id">The unique identifier of the project.</param>
		/// <returns>Response</returns>
		public async Task<Team_project> TeamsSlashcheck_permissions_for_project_legacyAsync(int team_id, int project_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_project>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add or update team project permissions (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team project permissions](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#add-or-update-team-project-permissions) endpoint.
		/// 
		/// Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.
		/// TeamsSlashadd_or_update_project_permissions_legacy teams/{team_id}/projects/{project_id}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="project_id">The unique identifier of the project.</param>
		public async Task TeamsSlashadd_or_update_project_permissions_legacyAsync(int team_id, int project_id, TeamsSlashadd_or_update_project_permissions_legacyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/projects/"+project_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List team repositories (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#list-team-repositories) endpoint.
		/// TeamsSlashlist_repos_legacy teams/{team_id}/repos
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> TeamsSlashlist_repos_legacyAsync(int team_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/repos?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a repository from a team (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a repository from a team](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#remove-a-repository-from-a-team) endpoint.
		/// 
		/// If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository, it just removes it from the team.
		/// TeamsSlashremove_repo_legacy teams/{team_id}/repos/{owner}/{repo}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task TeamsSlashremove_repo_legacyAsync(int team_id, string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check team permissions for a repository (Legacy)
		/// **Note**: Repositories inherited through a parent team will also be checked.
		/// 
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.
		/// 
		/// You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/) via the `Accept` header:
		/// TeamsSlashcheck_permissions_for_repo_legacy teams/{team_id}/repos/{owner}/{repo}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		/// <returns>Alternative response with extra repository information</returns>
		public async Task<Team_repository> TeamsSlashcheck_permissions_for_repo_legacyAsync(int team_id, string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_repository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add or update team repository permissions (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Add or update team repository permissions](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.
		/// 
		/// To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization.
		/// 
		/// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// TeamsSlashadd_or_update_repo_permissions_legacy teams/{team_id}/repos/{owner}/{repo}
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task TeamsSlashadd_or_update_repo_permissions_legacyAsync(int team_id, string owner, string repo, TeamsSlashadd_or_update_repo_permissions_legacyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/repos/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List child teams (Legacy)
		/// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.com/enterprise-server@3.6/rest/reference/teams#list-child-teams) endpoint.
		/// TeamsSlashlist_child_legacy teams/{team_id}/teams
		/// </summary>
		/// <param name="team_id">The unique identifier of the team.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>if child teams exist</returns>
		public async Task<Team[]> TeamsSlashlist_child_legacyAsync(int team_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "teams/"+team_id+"/teams?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the authenticated user
		/// If the authenticated user is authenticated through basic authentication or OAuth with the `user` scope, then the response lists public and private profile information.
		/// 
		/// If the authenticated user is authenticated through OAuth without the `user` scope, then the response lists only public profile information.
		/// UsersSlashget_authenticated user
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Private_user> UsersSlashget_authenticatedAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Private_user>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the authenticated user
		/// **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
		/// UsersSlashupdate_authenticated user
		/// </summary>
		/// <returns>Response</returns>
		public async Task<Private_user> UsersSlashupdate_authenticatedAsync(UsersSlashupdate_authenticatedPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Private_user>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an email address for the authenticated user
		/// This endpoint is accessible with the `user` scope.
		/// UsersSlashdelete_email_for_authenticated_user user/emails
		/// </summary>
		public async Task UsersSlashdelete_email_for_authenticated_userAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/emails";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List email addresses for the authenticated user
		/// Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope.
		/// UsersSlashlist_emails_for_authenticated_user user/emails
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Email[]> UsersSlashlist_emails_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/emails?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Email[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add an email address for the authenticated user
		/// This endpoint is accessible with the `user` scope.
		/// UsersSlashadd_email_for_authenticated_user user/emails
		/// </summary>
		public async Task UsersSlashadd_email_for_authenticated_userAsync(UsersSlashadd_email_for_authenticated_userPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/emails";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List followers of the authenticated user
		/// Lists the people following the authenticated user.
		/// UsersSlashlist_followers_for_authenticated_user user/followers
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> UsersSlashlist_followers_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/followers?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the people the authenticated user follows
		/// Lists the people who the authenticated user follows.
		/// UsersSlashlist_followed_by_authenticated_user user/following
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> UsersSlashlist_followed_by_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/following?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unfollow a user
		/// Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
		/// UsersSlashunfollow user/following/{username}
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task UsersSlashunfollowAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/following/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if a person is followed by the authenticated user
		/// UsersSlashcheck_person_is_followed_by_authenticated user/following/{username}
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task UsersSlashcheck_person_is_followed_by_authenticatedAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/following/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Follow a user
		/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// 
		/// Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
		/// UsersSlashfollow user/following/{username}
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task UsersSlashfollowAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/following/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List GPG keys for the authenticated user
		/// Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// UsersSlashlist_gpg_keys_for_authenticated_user user/gpg_keys
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Gpg_key[]> UsersSlashlist_gpg_keys_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/gpg_keys?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gpg_key[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a GPG key for the authenticated user
		/// Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// UsersSlashcreate_gpg_key_for_authenticated_user user/gpg_keys
		/// </summary>
		public async Task UsersSlashcreate_gpg_key_for_authenticated_userAsync(UsersSlashcreate_gpg_key_for_authenticated_userPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/gpg_keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a GPG key for the authenticated user
		/// Removes a GPG key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// UsersSlashdelete_gpg_key_for_authenticated_user user/gpg_keys/{gpg_key_id}
		/// </summary>
		/// <param name="gpg_key_id">The unique identifier of the GPG key.</param>
		public async Task UsersSlashdelete_gpg_key_for_authenticated_userAsync(int gpg_key_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/gpg_keys/"+gpg_key_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a GPG key for the authenticated user
		/// View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// UsersSlashget_gpg_key_for_authenticated_user user/gpg_keys/{gpg_key_id}
		/// </summary>
		/// <param name="gpg_key_id">The unique identifier of the GPG key.</param>
		/// <returns>Response</returns>
		public async Task<Gpg_key> UsersSlashget_gpg_key_for_authenticated_userAsync(int gpg_key_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/gpg_keys/"+gpg_key_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gpg_key>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List app installations accessible to the user access token
		/// Lists installations of your GitHub App that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
		/// 
		/// You must use a [user-to-server OAuth access token](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
		/// 
		/// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
		/// 
		/// You can find the permissions for the installation under the `permissions` key.
		/// AppsSlashlist_installations_for_authenticated_user user/installations
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>You can find the permissions for the installation under the `permissions` key.</returns>
		public async Task<AppsSlashlist_installations_for_authenticated_userReturn> AppsSlashlist_installations_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/installations?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AppsSlashlist_installations_for_authenticated_userReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories accessible to the user access token
		/// List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.
		/// 
		/// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
		/// 
		/// You must use a [user-to-server OAuth access token](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
		/// 
		/// The access the user has to each repository is included in the hash under the `permissions` key.
		/// AppsSlashlist_installation_repos_for_authenticated_user user/installations/{installation_id}/repositories
		/// </summary>
		/// <param name="installation_id">The unique identifier of the installation.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>The access the user has to each repository is included in the hash under the `permissions` key.</returns>
		public async Task<AppsSlashlist_installation_repos_for_authenticated_userReturn> AppsSlashlist_installation_repos_for_authenticated_userAsync(int installation_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/installations/"+installation_id+"/repositories?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AppsSlashlist_installation_repos_for_authenticated_userReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a repository from an app installation
		/// Remove a single repository from an installation. The authenticated user must have admin access to the repository.
		/// 
		/// You must use a personal access token (which you can create via the [command line](https://docs.github.com/enterprise-server@3.6/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
		/// AppsSlashremove_repo_from_installation_for_authenticated_user user/installations/{installation_id}/repositories/{repository_id}
		/// </summary>
		/// <param name="installation_id">The unique identifier of the installation.</param>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		public async Task AppsSlashremove_repo_from_installation_for_authenticated_userAsync(int installation_id, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/installations/"+installation_id+"/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a repository to an app installation
		/// Add a single repository to an installation. The authenticated user must have admin access to the repository.
		/// 
		/// You must use a personal access token (which you can create via the [command line](https://docs.github.com/enterprise-server@3.6/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
		/// AppsSlashadd_repo_to_installation_for_authenticated_user user/installations/{installation_id}/repositories/{repository_id}
		/// </summary>
		/// <param name="installation_id">The unique identifier of the installation.</param>
		/// <param name="repository_id">The unique identifier of the repository.</param>
		public async Task AppsSlashadd_repo_to_installation_for_authenticated_userAsync(int installation_id, int repository_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/installations/"+installation_id+"/repositories/"+repository_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List user account issues assigned to the authenticated user
		/// List issues across owned and member repositories assigned to the authenticated user.
		/// 
		/// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
		/// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
		/// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
		/// request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.6/rest/reference/pulls#list-pull-requests)" endpoint.
		/// IssuesSlashlist_for_authenticated_user user/issues
		/// </summary>
		/// <param name="filter">Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.</param>
		/// <param name="state">Indicates the state of the issues to return.</param>
		/// <param name="labels">A list of comma separated label names. Example: `bug,ui,@high`</param>
		/// <param name="sort">What to sort results by.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Issue[]> IssuesSlashlist_for_authenticated_userAsync(IssuesSlashlistFilter filter, IssuesSlashlistState state, string labels, IssuesSlashlistSort sort, Enterprise_adminSlashlist_public_keysDirection direction, System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/issues?filter=" + filter+"&state=" + state+"&labels=" + (labels==null? "" : System.Uri.EscapeDataString(labels))+"&sort=" + sort+"&direction=" + direction+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Issue[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List public SSH keys for the authenticated user
		/// Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// UsersSlashlist_public_ssh_keys_for_authenticated_user user/keys
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Key[]> UsersSlashlist_public_ssh_keys_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/keys?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Key[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a public SSH key for the authenticated user
		/// Adds a public SSH key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// UsersSlashcreate_public_ssh_key_for_authenticated_user user/keys
		/// </summary>
		public async Task UsersSlashcreate_public_ssh_key_for_authenticated_userAsync(UsersSlashcreate_public_ssh_key_for_authenticated_userPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a public SSH key for the authenticated user
		/// Removes a public SSH key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// UsersSlashdelete_public_ssh_key_for_authenticated_user user/keys/{key_id}
		/// </summary>
		/// <param name="key_id">The unique identifier of the key.</param>
		public async Task UsersSlashdelete_public_ssh_key_for_authenticated_userAsync(int key_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/keys/"+key_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a public SSH key for the authenticated user
		/// View extended details for a single public SSH key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// UsersSlashget_public_ssh_key_for_authenticated_user user/keys/{key_id}
		/// </summary>
		/// <param name="key_id">The unique identifier of the key.</param>
		/// <returns>Response</returns>
		public async Task<Key> UsersSlashget_public_ssh_key_for_authenticated_userAsync(int key_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/keys/"+key_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Key>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organization memberships for the authenticated user
		/// OrgsSlashlist_memberships_for_authenticated_user user/memberships/orgs
		/// </summary>
		/// <param name="state">Indicates the state of the memberships to return. If not specified, the API returns both active and pending memberships.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Org_membership[]> OrgsSlashlist_memberships_for_authenticated_userAsync(Org_membershipState state, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/memberships/orgs?state=" + state+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_membership[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an organization membership for the authenticated user
		/// OrgsSlashget_membership_for_authenticated_user user/memberships/orgs/{org}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Org_membership> OrgsSlashget_membership_for_authenticated_userAsync(string org, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/memberships/orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_membership>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an organization membership for the authenticated user
		/// OrgsSlashupdate_membership_for_authenticated_user user/memberships/orgs/{org}
		/// </summary>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <returns>Response</returns>
		public async Task<Org_membership> OrgsSlashupdate_membership_for_authenticated_userAsync(string org, OrgsSlashupdate_membership_for_authenticated_userPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/memberships/orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Org_membership>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List user migrations
		/// Lists all migrations a user has started.
		/// MigrationsSlashlist_for_authenticated_user user/migrations
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Migration[]> MigrationsSlashlist_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/migrations?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Migration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start a user migration
		/// Initiates the generation of a user migration archive.
		/// MigrationsSlashstart_for_authenticated_user user/migrations
		/// </summary>
		public async Task MigrationsSlashstart_for_authenticated_userAsync(MigrationsSlashstart_for_authenticated_userPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/migrations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Download a user migration archive
		/// Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources your repository uses, the migration archive can contain JSON files with data for these objects:
		/// 
		/// *   attachments
		/// *   bases
		/// *   commit\_comments
		/// *   issue\_comments
		/// *   issue\_events
		/// *   issues
		/// *   milestones
		/// *   organizations
		/// *   projects
		/// *   protected\_branches
		/// *   pull\_request\_reviews
		/// *   pull\_requests
		/// *   releases
		/// *   repositories
		/// *   review\_comments
		/// *   schema
		/// *   users
		/// 
		/// The archive will also contain an `attachments` directory that includes all attachment files uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
		/// MigrationsSlashget_archive_for_authenticated_user user/migrations/{migration_id}/archive
		/// </summary>
		/// <param name="migration_id">The unique identifier of the migration.</param>
		public async Task MigrationsSlashget_archive_for_authenticated_userAsync(int migration_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/migrations/"+migration_id+"/archive";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories for a user migration
		/// Lists all the repositories for this user migration.
		/// MigrationsSlashlist_repos_for_authenticated_user user/migrations/{migration_id}/repositories
		/// </summary>
		/// <param name="migration_id">The unique identifier of the migration.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> MigrationsSlashlist_repos_for_authenticated_userAsync(int migration_id, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/migrations/"+migration_id+"/repositories?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organizations for the authenticated user
		/// List organizations for the authenticated user.
		/// 
		/// **OAuth scope requirements**
		/// 
		/// This only lists organizations that your authorization allows you to operate on in some way (e.g., you can list teams with `read:org` scope, you can publicize your organization membership with `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth requests with insufficient scope receive a `403 Forbidden` response.
		/// OrgsSlashlist_for_authenticated_user user/orgs
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Organization_simple[]> OrgsSlashlist_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/orgs?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_simple[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a user project
		/// Creates a user project board. Returns a `410 Gone` status if the user does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
		/// ProjectsSlashcreate_for_authenticated_user user/projects
		/// </summary>
		public async Task ProjectsSlashcreate_for_authenticated_userAsync(ProjectsSlashcreate_for_authenticated_userPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/projects";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List public email addresses for the authenticated user
		/// Lists your publicly visible email address, which you can set with the [Set primary email visibility for the authenticated user](https://docs.github.com/enterprise-server@3.6/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This endpoint is accessible with the `user:email` scope.
		/// UsersSlashlist_public_emails_for_authenticated_user user/public_emails
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Email[]> UsersSlashlist_public_emails_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/public_emails?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Email[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories for the authenticated user
		/// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
		/// 
		/// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
		/// ReposSlashlist_for_authenticated_user user/repos
		/// </summary>
		/// <param name="visibility">Limit results to repositories with the specified visibility.</param>
		/// <param name="affiliation">Comma-separated list of values. Can include:  
		/// * `owner`: Repositories that are owned by the authenticated user.  
		/// * `collaborator`: Repositories that the user has been added to as a collaborator.  
		/// * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.</param>
		/// <param name="type">Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.</param>
		/// <param name="sort">The property to sort the results by.</param>
		/// <param name="direction">The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="before">Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <returns>Response</returns>
		public async Task<Repository[]> ReposSlashlist_for_authenticated_userAsync(ReposSlashlist_for_authenticated_userVisibility visibility, string affiliation, ReposSlashlist_for_authenticated_userType type, ReposSlashlist_for_orgSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, System.DateTimeOffset since, System.DateTimeOffset before, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/repos?visibility=" + visibility+"&affiliation=" + (affiliation==null? "" : System.Uri.EscapeDataString(affiliation))+"&type=" + type+"&sort=" + sort+"&direction=" + direction+"&per_page="+per_page+"&page="+page+"&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before=" + before.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a repository for the authenticated user
		/// Creates a new repository for the authenticated user.
		/// 
		/// **OAuth scope requirements**
		/// 
		/// When using [OAuth](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
		/// 
		/// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
		/// *   `repo` scope to create a private repository.
		/// ReposSlashcreate_for_authenticated_user user/repos
		/// </summary>
		public async Task ReposSlashcreate_for_authenticated_userAsync(ReposSlashcreate_for_authenticated_userPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/repos";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List repository invitations for the authenticated user
		/// When authenticating as a user, this endpoint will list all currently open repository invitations for that user.
		/// ReposSlashlist_invitations_for_authenticated_user user/repository_invitations
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Repository_invitation[]> ReposSlashlist_invitations_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/repository_invitations?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository_invitation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Decline a repository invitation
		/// ReposSlashdecline_invitation_for_authenticated_user user/repository_invitations/{invitation_id}
		/// </summary>
		/// <param name="invitation_id">The unique identifier of the invitation.</param>
		public async Task ReposSlashdecline_invitation_for_authenticated_userAsync(int invitation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/repository_invitations/"+invitation_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Accept a repository invitation
		/// ReposSlashaccept_invitation_for_authenticated_user user/repository_invitations/{invitation_id}
		/// </summary>
		/// <param name="invitation_id">The unique identifier of the invitation.</param>
		public async Task ReposSlashaccept_invitation_for_authenticated_userAsync(int invitation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/repository_invitations/"+invitation_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories starred by the authenticated user
		/// Lists repositories the authenticated user has starred.
		/// 
		/// You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.
		/// ActivitySlashlist_repos_starred_by_authenticated_user user/starred
		/// </summary>
		/// <param name="sort">The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Repository[]> ActivitySlashlist_repos_starred_by_authenticated_userAsync(Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/starred?sort=" + sort+"&direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unstar a repository for the authenticated user
		/// ActivitySlashunstar_repo_for_authenticated_user user/starred/{owner}/{repo}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActivitySlashunstar_repo_for_authenticated_userAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/starred/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if a repository is starred by the authenticated user
		/// ActivitySlashcheck_repo_is_starred_by_authenticated_user user/starred/{owner}/{repo}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActivitySlashcheck_repo_is_starred_by_authenticated_userAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/starred/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Star a repository for the authenticated user
		/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// ActivitySlashstar_repo_for_authenticated_user user/starred/{owner}/{repo}
		/// </summary>
		/// <param name="owner">The account owner of the repository. The name is not case sensitive.</param>
		/// <param name="repo">The name of the repository. The name is not case sensitive.</param>
		public async Task ActivitySlashstar_repo_for_authenticated_userAsync(string owner, string repo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/starred/"+ (owner==null? "" : System.Uri.EscapeDataString(owner))+"/"+ (repo==null? "" : System.Uri.EscapeDataString(repo));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories watched by the authenticated user
		/// Lists repositories the authenticated user is watching.
		/// ActivitySlashlist_watched_repos_for_authenticated_user user/subscriptions
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> ActivitySlashlist_watched_repos_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/subscriptions?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List teams for the authenticated user
		/// List all of the teams across all of the organizations to which the authenticated user belongs. This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via [OAuth](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/).
		/// TeamsSlashlist_for_authenticated_user user/teams
		/// </summary>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Team_full[]> TeamsSlashlist_for_authenticated_userAsync(int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/teams?per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Team_full[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List users
		/// Lists all users, in the order that they signed up on GitHub Enterprise Server. This list includes personal user accounts and organization accounts.
		/// 
		/// Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of users.
		/// UsersSlashlist users
		/// </summary>
		/// <param name="since">A user ID. Only return users with an ID greater than this ID.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> UsersSlashlistAsync(int since, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users?since="+since+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a user
		/// Provides publicly available information about someone with a GitHub account.
		/// 
		/// GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a user's GitHub Enterprise Server plan. The GitHub App must be authenticated as a user. See "[Identifying and authorizing users for GitHub Apps](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details about authentication. For an example response, see 'Response with GitHub Enterprise Server plan information' below"
		/// 
		/// The `email` key in the following response is the publicly visible email address from your GitHub Enterprise Server [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be “public” which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub Enterprise Server. For more information, see [Authentication](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#authentication).
		/// 
		/// The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/enterprise-server@3.6/rest/reference/users#emails)".
		/// UsersSlashget_by_username users/{username}
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Private_user> UsersSlashget_by_usernameAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Private_user>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List events for the authenticated user
		/// If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
		/// ActivitySlashlist_events_for_authenticated_user users/{username}/events
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_events_for_authenticated_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/events&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organization events for the authenticated user
		/// This is the user's organization dashboard. You must be authenticated as the user to view this.
		/// ActivitySlashlist_org_events_for_authenticated_user users/{username}/events/orgs/{org}
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="org">The organization name. The name is not case sensitive.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_org_events_for_authenticated_userAsync(string username, string org, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/events/orgs/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List public events for a user
		/// ActivitySlashlist_public_events_for_user users/{username}/events/public
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_public_events_for_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/events/public&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List followers of a user
		/// Lists the people following the specified user.
		/// UsersSlashlist_followers_for_user users/{username}/followers
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> UsersSlashlist_followers_for_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/followers&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the people a user follows
		/// Lists the people who the specified user follows.
		/// UsersSlashlist_following_for_user users/{username}/following
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Simple_user[]> UsersSlashlist_following_for_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/following&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Simple_user[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if a user follows another user
		/// UsersSlashcheck_following_for_user users/{username}/following/{target_user}
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task UsersSlashcheck_following_for_userAsync(string username, string target_user, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/following/"+ (target_user==null? "" : System.Uri.EscapeDataString(target_user));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List gists for a user
		/// Lists public gists for the specified user:
		/// GistsSlashlist_for_user users/{username}/gists
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="since">Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Base_gist[]> GistsSlashlist_for_userAsync(string username, System.DateTimeOffset since, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/gists&since=" + since.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Base_gist[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List GPG keys for a user
		/// Lists the GPG keys for a user. This information is accessible by anyone.
		/// UsersSlashlist_gpg_keys_for_user users/{username}/gpg_keys
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Gpg_key[]> UsersSlashlist_gpg_keys_for_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/gpg_keys&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Gpg_key[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get contextual information for a user
		/// Provides hovercard information when authenticated through basic auth or OAuth with the `repo` scope. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.
		/// 
		/// The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
		/// 
		/// ```shell
		/// curl -u username:token
		/// https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
		/// ```
		/// UsersSlashget_context_for_user users/{username}/hovercard
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="subject_type">Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.</param>
		/// <param name="subject_id">Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.</param>
		/// <returns>Response</returns>
		public async Task<Hovercard> UsersSlashget_context_for_userAsync(string username, UsersSlashget_context_for_userSubject_type subject_type, string subject_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/hovercard&subject_type=" + subject_type+"&subject_id=" + (subject_id==null? "" : System.Uri.EscapeDataString(subject_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Hovercard>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a user installation for the authenticated app
		/// Enables an authenticated GitHub App to find the user’s installation information.
		/// 
		/// You must use a [JWT](https://docs.github.com/enterprise-server@3.6/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
		/// AppsSlashget_user_installation users/{username}/installation
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <returns>Response</returns>
		public async Task<Installation> AppsSlashget_user_installationAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/installation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Installation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List public keys for a user
		/// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
		/// UsersSlashlist_public_keys_for_user users/{username}/keys
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Key_simple[]> UsersSlashlist_public_keys_for_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/keys&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Key_simple[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List organizations for a user
		/// List [public organization memberships](https://docs.github.com/enterprise-server@3.6/articles/publicizing-or-concealing-organization-membership) for the specified user.
		/// 
		/// This method only lists _public_ memberships, regardless of authentication. If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the [List organizations for the authenticated user](https://docs.github.com/enterprise-server@3.6/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
		/// OrgsSlashlist_for_user users/{username}/orgs
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Organization_simple[]> OrgsSlashlist_for_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/orgs&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Organization_simple[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List user projects
		/// ProjectsSlashlist_for_user users/{username}/projects
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="state">Indicates the state of the projects to return.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Project[]> ProjectsSlashlist_for_userAsync(string username, IssuesSlashlistState state, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/projects&state=" + state+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List events received by the authenticated user
		/// These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.
		/// ActivitySlashlist_received_events_for_user users/{username}/received_events
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_received_events_for_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/received_events&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List public events received by a user
		/// ActivitySlashlist_received_public_events_for_user users/{username}/received_events/public
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<event_[]> ActivitySlashlist_received_public_events_for_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/received_events/public&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<event_[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories for a user
		/// Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list internal repositories for the specified user.
		/// ReposSlashlist_for_user users/{username}/repos
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="type">Limit results to repositories of the specified type.</param>
		/// <param name="sort">The property to sort the results by.</param>
		/// <param name="direction">The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> ReposSlashlist_for_userAsync(string username, ReposSlashlist_for_userType type, ReposSlashlist_for_orgSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/repos&type=" + type+"&sort=" + sort+"&direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Demote a site administrator
		/// You can demote any user account except your own.
		/// Enterprise_adminSlashdemote_site_administrator users/{username}/site_admin
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task Enterprise_adminSlashdemote_site_administratorAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/site_admin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Promote a user to be a site administrator
		/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// Enterprise_adminSlashpromote_user_to_be_site_administrator users/{username}/site_admin
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task Enterprise_adminSlashpromote_user_to_be_site_administratorAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/site_admin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories starred by a user
		/// Lists repositories a user has starred.
		/// 
		/// You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.6/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.
		/// ActivitySlashlist_repos_starred_by_user users/{username}/starred
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="sort">The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.</param>
		/// <param name="direction">The direction to sort the results by.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Starred_repository[]> ActivitySlashlist_repos_starred_by_userAsync(string username, Secret_scanningSlashlist_alerts_for_enterpriseSort sort, Enterprise_adminSlashlist_public_keysDirection direction, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/starred&sort=" + sort+"&direction=" + direction+"&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Starred_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List repositories watched by a user
		/// Lists repositories a user is watching.
		/// ActivitySlashlist_repos_watched_by_user users/{username}/subscriptions
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		/// <param name="per_page">The number of results per page (max 100).</param>
		/// <param name="page">Page number of the results to fetch.</param>
		/// <returns>Response</returns>
		public async Task<Minimal_repository[]> ActivitySlashlist_repos_watched_by_userAsync(string username, int per_page, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/subscriptions&per_page="+per_page+"&page="+page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Minimal_repository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unsuspend a user
		/// If your GitHub instance uses [LDAP Sync with Active Directory LDAP servers](https://docs.github.com/enterprise-server@3.6/admin/identity-and-access-management/using-ldap-for-enterprise-iam/using-ldap), this API is disabled and will return a `403` response. Active Directory LDAP-authenticated users cannot be unsuspended using the API.
		/// Enterprise_adminSlashunsuspend_user users/{username}/suspended
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task Enterprise_adminSlashunsuspend_userAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/suspended";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Suspend a user
		/// If your GitHub instance uses [LDAP Sync with Active Directory LDAP servers](https://docs.github.com/enterprise-server@3.6/admin/identity-and-access-management/using-ldap-for-enterprise-iam/using-ldap), Active Directory LDAP-authenticated users cannot be suspended through this API. If you attempt to suspend an Active Directory LDAP-authenticated user through this API, it will return a `403` response.
		/// 
		/// You can suspend any user account except your own.
		/// 
		/// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// Enterprise_adminSlashsuspend_user users/{username}/suspended
		/// </summary>
		/// <param name="username">The handle for the GitHub user account.</param>
		public async Task Enterprise_adminSlashsuspend_userAsync(string username, Enterprise_adminSlashsuspend_userPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/suspended";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the Zen of GitHub
		/// Get a random sentence from the Zen of GitHub
		/// MetaSlashget_zen zen
		/// </summary>
		/// <returns>Response</returns>
		public async Task<string> MetaSlashget_zenAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "zen";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(responseMessageStream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class Enterprise_adminSlashcreate_global_webhookPostBody
	{
		
		/// <summary>
		/// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// Key/value pairs to provide settings for this webhook.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public Enterprise_adminSlashcreate_global_webhookPostBodyConfig Config { get; set; }
		
		/// <summary>
		/// The [events](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads) that trigger this webhook. A global webhook can be triggered by `user` and `organization` events. Default: `user` and `organization`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		/// <summary>
		/// Must be passed as "web".
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Enterprise_adminSlashcreate_global_webhookPostBodyConfig
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		/// <summary>
		/// Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public string Insecure_ssl { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value in the [`X-Hub-Signature`](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers) header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Enterprise_adminSlashupdate_global_webhookPatchBody
	{
		
		/// <summary>
		/// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// Key/value pairs to provide settings for this webhook.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config")]
		public Enterprise_adminSlashupdate_global_webhookPatchBodyConfig Config { get; set; }
		
		/// <summary>
		/// The [events](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads) that trigger this webhook. A global webhook can be triggered by `user` and `organization` events. Default: `user` and `organization`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
	}
	
	public class Enterprise_adminSlashupdate_global_webhookPatchBodyConfig
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		/// <summary>
		/// Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public string Insecure_ssl { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value in the [`X-Hub-Signature`](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers) header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public enum Enterprise_adminSlashlist_public_keysDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asc = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		desc = 1,
	}
	
	public enum Enterprise_adminSlashlist_public_keysSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		accessed = 2,
	}
	
	public class Enterprise_adminSlashupdate_ldap_mapping_for_teamPatchBody
	{
		
		/// <summary>
		/// The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
	}
	
	public class Enterprise_adminSlashupdate_ldap_mapping_for_userPatchBody
	{
		
		/// <summary>
		/// The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
	}
	
	public class Enterprise_adminSlashcreate_orgPostBody
	{
		
		/// <summary>
		/// The login of the user who will manage this organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public string Admin { get; set; }
		
		/// <summary>
		/// The organization's username.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// The organization's display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_name")]
		public string Profile_name { get; set; }
	}
	
	public class Enterprise_adminSlashupdate_org_namePatchBody
	{
		
		/// <summary>
		/// The organization's new name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
	}
	
	public enum Enterprise_adminSlashlist_pre_receive_environmentsSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 2,
	}
	
	public class Enterprise_adminSlashcreate_pre_receive_environmentPostBody
	{
		
		/// <summary>
		/// URL from which to download a tarball of this environment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
		
		/// <summary>
		/// The new pre-receive environment's name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Enterprise_adminSlashupdate_pre_receive_environmentPatchBody
	{
		
		/// <summary>
		/// URL from which to download a tarball of this environment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
		
		/// <summary>
		/// This pre-receive environment's new name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Enterprise_adminSlashcreate_pre_receive_hookPostBody
	{
		
		/// <summary>
		/// Whether enforcement can be overridden at the org or repo level. default: `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_downstream_configuration")]
		public System.Nullable<System.Boolean> Allow_downstream_configuration { get; set; }
		
		/// <summary>
		/// The state of enforcement for this hook. default: `disabled`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcement")]
		public string Enforcement { get; set; }
		
		/// <summary>
		/// The pre-receive environment where the script is executed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public string Environment { get; set; }
		
		/// <summary>
		/// The name of the hook.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The script that the hook runs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="script")]
		public string Script { get; set; }
		
		/// <summary>
		/// The GitHub repository where the script is kept.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="script_repository")]
		public string Script_repository { get; set; }
	}
	
	public class Enterprise_adminSlashupdate_pre_receive_hookPatchBody
	{
		
		/// <summary>
		/// Whether enforcement can be overridden at the org or repo level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_downstream_configuration")]
		public System.Nullable<System.Boolean> Allow_downstream_configuration { get; set; }
		
		/// <summary>
		/// The state of enforcement for this hook.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcement")]
		public string Enforcement { get; set; }
		
		/// <summary>
		/// The pre-receive environment where the script is executed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public string Environment { get; set; }
		
		/// <summary>
		/// The name of the hook.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The script that the hook runs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="script")]
		public string Script { get; set; }
		
		/// <summary>
		/// The GitHub repository where the script is kept.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="script_repository")]
		public string Script_repository { get; set; }
	}
	
	public class Enterprise_adminSlashcreate_userPostBody
	{
		
		/// <summary>
		/// **Required for built-in authentication.** The user's email
		///address. This parameter can be omitted when using CAS, LDAP, or SAML.
		///For more information, see "[About authentication for your enterprise](https://docs.github.com/enterprise-server@3.6/admin/identity-and-access-management/managing-iam-for-your-enterprise/about-authentication-for-your-enterprise)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The user's username.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
	}
	
	public class Enterprise_adminSlashupdate_username_for_userPatchBody
	{
		
		/// <summary>
		/// The user's new username.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
	}
	
	public class Enterprise_adminSlashcreate_impersonation_o_auth_tokenPostBody
	{
		
		/// <summary>
		/// A list of [scopes](https://docs.github.com/enterprise-server@3.6/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	public class AppsSlashupdate_webhook_config_for_appPatchBody
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class AppsSlashcreate_installation_access_tokenPostBody
	{
		
		/// <summary>
		/// The permissions granted to the user-to-server access token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public App_permissions Permissions { get; set; }
		
		/// <summary>
		/// List of repository names that the token should have access to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public string[] Repositories { get; set; }
		
		/// <summary>
		/// List of repository IDs that the token should have access to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_ids")]
		public int[] Repository_ids { get; set; }
	}
	
	public class AppsSlashreset_tokenPatchBody
	{
		
		/// <summary>
		/// The access_token of the OAuth application.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access_token")]
		public string Access_token { get; set; }
	}
	
	public class AppsSlashcheck_tokenPostBody
	{
		
		/// <summary>
		/// The access_token of the OAuth application.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access_token")]
		public string Access_token { get; set; }
	}
	
	public class AppsSlashscope_tokenPostBody
	{
		
		/// <summary>
		/// The access token used to authenticate to the GitHub API.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access_token")]
		public string Access_token { get; set; }
		
		/// <summary>
		/// The permissions granted to the user-to-server access token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public App_permissions Permissions { get; set; }
		
		/// <summary>
		/// The list of repository names to scope the user-to-server access token to. `repositories` may not be specified if `repository_ids` is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public string[] Repositories { get; set; }
		
		/// <summary>
		/// The list of repository IDs to scope the user-to-server access token to. `repository_ids` may not be specified if `repositories` is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository_ids")]
		public int[] Repository_ids { get; set; }
		
		/// <summary>
		/// The name of the user or organization to scope the user-to-server access token to. **Required** unless `target_id` is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// The ID of the user or organization to scope the user-to-server access token to. **Required** unless `target` is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_id")]
		public System.Nullable<System.Int32> Target_id { get; set; }
	}
	
	public class Oauth_authorizationsSlashcreate_authorizationPostBody
	{
		
		/// <summary>
		/// The OAuth app client key for which to create the token.
		/// Max length: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public string Client_id { get; set; }
		
		/// <summary>
		/// The OAuth app client secret for which to create the token.
		/// Max length: 40
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		public string Client_secret { get; set; }
		
		/// <summary>
		/// A unique string to distinguish an authorization from others created for the same client ID and user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// A note to remind you what the OAuth token is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// A URL to remind you what app the OAuth token is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note_url")]
		public string Note_url { get; set; }
		
		/// <summary>
		/// A list of scopes that this authorization is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	public class Oauth_authorizationsSlashget_or_create_authorization_for_appPutBody
	{
		
		/// <summary>
		/// The OAuth app client secret for which to create the token.
		/// Required
		/// Max length: 40
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		public string Client_secret { get; set; }
		
		/// <summary>
		/// A unique string to distinguish an authorization from others created for the same client ID and user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// A note to remind you what the OAuth token is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// A URL to remind you what app the OAuth token is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note_url")]
		public string Note_url { get; set; }
		
		/// <summary>
		/// A list of scopes that this authorization is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	public class Oauth_authorizationsSlashget_or_create_authorization_for_app_and_fingerprintPutBody
	{
		
		/// <summary>
		/// The OAuth app client secret for which to create the token.
		/// Required
		/// Max length: 40
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		public string Client_secret { get; set; }
		
		/// <summary>
		/// A note to remind you what the OAuth token is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// A URL to remind you what app the OAuth token is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note_url")]
		public string Note_url { get; set; }
		
		/// <summary>
		/// A list of scopes that this authorization is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	public class Oauth_authorizationsSlashupdate_authorizationPatchBody
	{
		
		/// <summary>
		/// A list of scopes to add to this authorization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_scopes")]
		public string[] Add_scopes { get; set; }
		
		/// <summary>
		/// A unique string to distinguish an authorization from others created for the same client ID and user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// A note to remind you what the OAuth token is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// A URL to remind you what app the OAuth token is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note_url")]
		public string Note_url { get; set; }
		
		/// <summary>
		/// A list of scopes to remove from this authorization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_scopes")]
		public string[] Remove_scopes { get; set; }
		
		/// <summary>
		/// A list of scopes that this authorization is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	public class Enterprise_adminSlashset_github_actions_permissions_enterprisePutBody
	{
		
		/// <summary>
		/// The permissions policy that controls the actions that are allowed to run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed_actions")]
		public Actions_enterprise_permissionsAllowed_actions Allowed_actions { get; set; }
		
		/// <summary>
		/// The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled_organizations")]
		public Actions_enterprise_permissionsEnabled_organizations Enabled_organizations { get; set; }
	}
	
	public class Enterprise_adminSlashlist_selected_organizations_enabled_github_actions_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations")]
		public Organization_simple[] Organizations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public double Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashset_selected_organizations_enabled_github_actions_enterprisePutBody
	{
		
		/// <summary>
		/// List of organization IDs to enable for GitHub Actions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selected_organization_ids")]
		public int[] Selected_organization_ids { get; set; }
	}
	
	public class Enterprise_adminSlashlist_self_hosted_runner_groups_for_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runner_groups")]
		public Runner_groups_enterprise[] Runner_groups { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public double Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterprisePostBody
	{
		
		/// <summary>
		/// Whether the runner group can be used by `public` repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allows_public_repositories")]
		public System.Nullable<System.Boolean> Allows_public_repositories { get; set; }
		
		/// <summary>
		/// Name of the runner group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted_to_workflows")]
		public System.Nullable<System.Boolean> Restricted_to_workflows { get; set; }
		
		/// <summary>
		/// List of runner IDs to add to the runner group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public int[] Runners { get; set; }
		
		/// <summary>
		/// List of organization IDs that can access the runner group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_organization_ids")]
		public int[] Selected_organization_ids { get; set; }
		
		/// <summary>
		/// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_workflows")]
		public string[] Selected_workflows { get; set; }
		
		/// <summary>
		/// Visibility of a runner group. You can select all organizations or select individual organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterprisePostBodyVisibility> Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterprisePostBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 1,
	}
	
	public class Enterprise_adminSlashupdate_self_hosted_runner_group_for_enterprisePatchBody
	{
		
		/// <summary>
		/// Whether the runner group can be used by `public` repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allows_public_repositories")]
		public System.Nullable<System.Boolean> Allows_public_repositories { get; set; }
		
		/// <summary>
		/// Name of the runner group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted_to_workflows")]
		public System.Nullable<System.Boolean> Restricted_to_workflows { get; set; }
		
		/// <summary>
		/// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_workflows")]
		public string[] Selected_workflows { get; set; }
		
		/// <summary>
		/// Visibility of a runner group. You can select all organizations or select individual organizations.
		/// </summary>
		[System.ComponentModel.DefaultValue(Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterprisePostBodyVisibility.all)]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterprisePostBodyVisibility Visibility { get; set; } = Enterprise_adminSlashcreate_self_hosted_runner_group_for_enterprisePostBodyVisibility.all;
	}
	
	public class Enterprise_adminSlashlist_org_access_to_self_hosted_runner_group_in_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizations")]
		public Organization_simple[] Organizations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public double Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashset_org_access_to_self_hosted_runner_group_in_enterprisePutBody
	{
		
		/// <summary>
		/// List of organization IDs that can access the runner group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selected_organization_ids")]
		public int[] Selected_organization_ids { get; set; }
	}
	
	public class Enterprise_adminSlashlist_self_hosted_runners_in_group_for_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public Runner[] Runners { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public double Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashset_self_hosted_runners_in_group_for_enterprisePutBody
	{
		
		/// <summary>
		/// List of runner IDs to add to the runner group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public int[] Runners { get; set; }
	}
	
	public class Enterprise_adminSlashlist_self_hosted_runners_for_enterpriseReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public Runner[] Runners { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public System.Nullable<System.Double> Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashremove_all_custom_labels_from_self_hosted_runner_for_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashlist_labels_for_self_hosted_runner_for_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashadd_custom_labels_to_self_hosted_runner_for_enterprisePostBody
	{
		
		/// <summary>
		/// The names of the custom labels to add to the runner.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string[] Labels { get; set; }
	}
	
	public class Enterprise_adminSlashadd_custom_labels_to_self_hosted_runner_for_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashset_custom_labels_for_self_hosted_runner_for_enterprisePutBody
	{
		
		/// <summary>
		/// The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string[] Labels { get; set; }
	}
	
	public class Enterprise_adminSlashset_custom_labels_for_self_hosted_runner_for_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class Enterprise_adminSlashremove_custom_label_from_self_hosted_runner_for_enterpriseReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum Enterprise_adminSlashget_audit_logInclude
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		web = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		git = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 2,
	}
	
	public enum Enterprise_adminSlashget_audit_logOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		desc = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asc = 1,
	}
	
	public enum Secret_scanningSlashlist_alerts_for_enterpriseSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 1,
	}
	
	public class GistsSlashcreatePostBody
	{
		
		/// <summary>
		/// Description of the gist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Names and content for the files that make up the gist
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="files")]
		public System.Collections.Generic.Dictionary<string, GistsSlashcreatePostBodyFiles> Files { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="public")]
		public System.Nullable<System.Boolean> Public { get; set; }
	}
	
	public class GistsSlashcreatePostBodyFiles
	{
		
		/// <summary>
		/// Content of the file
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
	}
	
	public class GistsSlashupdatePatchBody
	{
		
		/// <summary>
		/// The description of the gist.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The gist files to be updated, renamed, or deleted. Each `key` must match the current filename
		///(including extension) of the targeted gist file. For example: `hello.py`.
		///
		///To delete a file, set the whole file to null. For example: `hello.py : null`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="files")]
		public System.Collections.Generic.Dictionary<string, GistsSlashupdatePatchBodyFiles> Files { get; set; }
	}
	
	public class GistsSlashupdatePatchBodyFiles
	{
		
		/// <summary>
		/// The new content of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// The new filename for the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
	}
	
	public class GistsSlashcreate_commentPostBody
	{
		
		/// <summary>
		/// The comment text.
		/// Required
		/// Max length: 65535
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Body { get; set; }
	}
	
	public class GistsSlashupdate_commentPatchBody
	{
		
		/// <summary>
		/// The comment text.
		/// Required
		/// Max length: 65535
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Body { get; set; }
	}
	
	public class AppsSlashlist_repos_accessible_to_installationReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Repository[] Repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repository_selection")]
		public string Repository_selection { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum IssuesSlashlistFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		assigned = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mentioned = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		subscribed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		repos = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 5,
	}
	
	public enum IssuesSlashlistState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 2,
	}
	
	public enum IssuesSlashlistSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		comments = 2,
	}
	
	public class MarkdownSlashrenderPostBody
	{
		
		/// <summary>
		/// The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
		
		/// <summary>
		/// The rendering mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<MarkdownSlashrenderPostBodyMode> Mode { get; set; }
		
		/// <summary>
		/// The Markdown text to render in HTML.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MarkdownSlashrenderPostBodyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		markdown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		gfm = 1,
	}
	
	public class ActivitySlashmark_notifications_as_readPutBody
	{
		
		/// <summary>
		/// Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_read_at")]
		public System.Nullable<System.DateTimeOffset> Last_read_at { get; set; }
		
		/// <summary>
		/// Whether the notification has been read.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="read")]
		public System.Nullable<System.Boolean> Read { get; set; }
	}
	
	public class ActivitySlashset_thread_subscriptionPutBody
	{
		
		/// <summary>
		/// Whether to block all notifications from a thread.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ignored")]
		public System.Nullable<System.Boolean> Ignored { get; set; }
	}
	
	public class OrgsSlashlist_custom_rolesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="custom_roles")]
		public Organization_custom_repository_role[] Custom_roles { get; set; }
		
		/// <summary>
		/// The number of custom roles in this organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public System.Nullable<System.Int32> Total_count { get; set; }
	}
	
	public class OrgsSlashupdatePatchBody
	{
		
		/// <summary>
		/// Billing email address. This address is not publicized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billing_email")]
		public string Billing_email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blog")]
		public string Blog { get; set; }
		
		/// <summary>
		/// The company name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="company")]
		public string Company { get; set; }
		
		/// <summary>
		/// Default permission level members have for organization repositories.
		/// </summary>
		[System.ComponentModel.DefaultValue(ProjectOrganization_permission.read)]
		[System.Runtime.Serialization.DataMember(Name="default_repository_permission")]
		public ProjectOrganization_permission Default_repository_permission { get; set; } = ProjectOrganization_permission.read;
		
		/// <summary>
		/// The description of the company.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The publicly visible email address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Whether an organization can use organization projects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_organization_projects")]
		public System.Nullable<System.Boolean> Has_organization_projects { get; set; }
		
		/// <summary>
		/// Whether repositories that belong to the organization can use repository projects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_repository_projects")]
		public System.Nullable<System.Boolean> Has_repository_projects { get; set; }
		
		/// <summary>
		/// The location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Specifies which types of repositories non-admin organization members can create. 
		///**Note:** This parameter is deprecated and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members_allowed_repository_creation_type")]
		public System.Nullable<OrgsSlashupdatePatchBodyMembers_allowed_repository_creation_type> Members_allowed_repository_creation_type { get; set; }
		
		/// <summary>
		/// Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/enterprise-server@3.6/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members_can_create_internal_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_internal_repositories { get; set; }
		
		/// <summary>
		/// Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members_can_create_pages")]
		public System.Nullable<System.Boolean> Members_can_create_pages { get; set; }
		
		/// <summary>
		/// Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/enterprise-server@3.6/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members_can_create_private_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_private_repositories { get; set; }
		
		/// <summary>
		/// Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/enterprise-server@3.6/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members_can_create_public_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_public_repositories { get; set; }
		
		/// <summary>
		/// Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members_can_create_repositories")]
		public System.Nullable<System.Boolean> Members_can_create_repositories { get; set; }
		
		/// <summary>
		/// Whether organization members can fork private organization repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members_can_fork_private_repositories")]
		public System.Nullable<System.Boolean> Members_can_fork_private_repositories { get; set; }
		
		/// <summary>
		/// The shorthand name of the company.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Twitter username of the company.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		/// <summary>
		/// Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum OrgsSlashupdatePatchBodyMembers_allowed_repository_creation_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
	}
	
	public class ActionsSlashget_actions_cache_usage_by_repo_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository_cache_usages")]
		public Actions_cache_usage_by_repository[] Repository_cache_usages { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashset_github_actions_permissions_organizationPutBody
	{
		
		/// <summary>
		/// The permissions policy that controls the actions that are allowed to run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed_actions")]
		public Actions_enterprise_permissionsAllowed_actions Allowed_actions { get; set; }
		
		/// <summary>
		/// The policy that controls the repositories in the organization that are allowed to run GitHub Actions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled_repositories")]
		public Actions_enterprise_permissionsEnabled_organizations Enabled_repositories { get; set; }
	}
	
	public class ActionsSlashlist_selected_repositories_enabled_github_actions_organizationReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Repository[] Repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public double Total_count { get; set; }
	}
	
	public class ActionsSlashset_selected_repositories_enabled_github_actions_organizationPutBody
	{
		
		/// <summary>
		/// List of repository IDs to enable for GitHub Actions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selected_repository_ids")]
		public int[] Selected_repository_ids { get; set; }
	}
	
	public class ActionsSlashlist_self_hosted_runner_groups_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runner_groups")]
		public Runner_groups_org[] Runner_groups { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public double Total_count { get; set; }
	}
	
	public class ActionsSlashcreate_self_hosted_runner_group_for_orgPostBody
	{
		
		/// <summary>
		/// Whether the runner group can be used by `public` repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allows_public_repositories")]
		public System.Nullable<System.Boolean> Allows_public_repositories { get; set; }
		
		/// <summary>
		/// Name of the runner group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted_to_workflows")]
		public System.Nullable<System.Boolean> Restricted_to_workflows { get; set; }
		
		/// <summary>
		/// List of runner IDs to add to the runner group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public int[] Runners { get; set; }
		
		/// <summary>
		/// List of repository IDs that can access the runner group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_repository_ids")]
		public int[] Selected_repository_ids { get; set; }
		
		/// <summary>
		/// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_workflows")]
		public string[] Selected_workflows { get; set; }
		
		/// <summary>
		/// Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<ActionsSlashcreate_self_hosted_runner_group_for_orgPostBodyVisibility> Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ActionsSlashcreate_self_hosted_runner_group_for_orgPostBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 2,
	}
	
	public class ActionsSlashupdate_self_hosted_runner_group_for_orgPatchBody
	{
		
		/// <summary>
		/// Whether the runner group can be used by `public` repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allows_public_repositories")]
		public System.Nullable<System.Boolean> Allows_public_repositories { get; set; }
		
		/// <summary>
		/// Name of the runner group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted_to_workflows")]
		public System.Nullable<System.Boolean> Restricted_to_workflows { get; set; }
		
		/// <summary>
		/// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_workflows")]
		public string[] Selected_workflows { get; set; }
		
		/// <summary>
		/// Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<ActionsSlashupdate_self_hosted_runner_group_for_orgPatchBodyVisibility> Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ActionsSlashupdate_self_hosted_runner_group_for_orgPatchBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 2,
	}
	
	public class ActionsSlashlist_repo_access_to_self_hosted_runner_group_in_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Minimal_repository[] Repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public double Total_count { get; set; }
	}
	
	public class ActionsSlashset_repo_access_to_self_hosted_runner_group_in_orgPutBody
	{
		
		/// <summary>
		/// List of repository IDs that can access the runner group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selected_repository_ids")]
		public int[] Selected_repository_ids { get; set; }
	}
	
	public class ActionsSlashlist_self_hosted_runners_in_group_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public Runner[] Runners { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public double Total_count { get; set; }
	}
	
	public class ActionsSlashset_self_hosted_runners_in_group_for_orgPutBody
	{
		
		/// <summary>
		/// List of runner IDs to add to the runner group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public int[] Runners { get; set; }
	}
	
	public class ActionsSlashlist_self_hosted_runners_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public Runner[] Runners { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashlist_labels_for_self_hosted_runner_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashadd_custom_labels_to_self_hosted_runner_for_orgPostBody
	{
		
		/// <summary>
		/// The names of the custom labels to add to the runner.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string[] Labels { get; set; }
	}
	
	public class ActionsSlashadd_custom_labels_to_self_hosted_runner_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashset_custom_labels_for_self_hosted_runner_for_orgPutBody
	{
		
		/// <summary>
		/// The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string[] Labels { get; set; }
	}
	
	public class ActionsSlashset_custom_labels_for_self_hosted_runner_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashremove_custom_label_from_self_hosted_runner_for_orgReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashlist_org_secretsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public Organization_actions_secret[] Secrets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashcreate_or_update_org_secretPutBody
	{
		
		/// <summary>
		/// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#get-an-organization-public-key) endpoint.
		/// Pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted_value")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$")]
		public string Encrypted_value { get; set; }
		
		/// <summary>
		/// ID of the key you used to encrypt the secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
		
		/// <summary>
		/// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#remove-selected-repository-from-an-organization-secret) endpoints.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_repository_ids")]
		public int[] Selected_repository_ids { get; set; }
		
		/// <summary>
		/// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public ActionsSlashcreate_or_update_org_secretPutBodyVisibility Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ActionsSlashcreate_or_update_org_secretPutBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	public class ActionsSlashlist_selected_repos_for_org_secretReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Minimal_repository[] Repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashset_selected_repos_for_org_secretPutBody
	{
		
		/// <summary>
		/// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/enterprise-server@3.6/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#remove-selected-repository-from-an-organization-secret) endpoints.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selected_repository_ids")]
		public int[] Selected_repository_ids { get; set; }
	}
	
	public class DependabotSlashlist_org_secretsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public Organization_dependabot_secret[] Secrets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class DependabotSlashcreate_or_update_org_secretPutBody
	{
		
		/// <summary>
		/// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#get-an-organization-public-key) endpoint.
		/// Pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted_value")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$")]
		public string Encrypted_value { get; set; }
		
		/// <summary>
		/// ID of the key you used to encrypt the secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
		
		/// <summary>
		/// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#remove-selected-repository-from-an-organization-secret) endpoints.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected_repository_ids")]
		public string[] Selected_repository_ids { get; set; }
		
		/// <summary>
		/// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public DependabotSlashcreate_or_update_org_secretPutBodyVisibility Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DependabotSlashcreate_or_update_org_secretPutBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		selected = 2,
	}
	
	public class DependabotSlashlist_selected_repos_for_org_secretReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Minimal_repository[] Repositories { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class DependabotSlashset_selected_repos_for_org_secretPutBody
	{
		
		/// <summary>
		/// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#remove-selected-repository-from-an-organization-secret) endpoints.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selected_repository_ids")]
		public int[] Selected_repository_ids { get; set; }
	}
	
	public class OrgsSlashcreate_webhookPostBody
	{
		
		/// <summary>
		/// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/enterprise-server@3.6/rest/reference/orgs#create-hook-config-params).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public OrgsSlashcreate_webhookPostBodyConfig Config { get; set; }
		
		/// <summary>
		/// Determines what [events](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		/// <summary>
		/// Must be passed as "web".
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class OrgsSlashcreate_webhookPostBodyConfig
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class OrgsSlashupdate_webhookPatchBody
	{
		
		/// <summary>
		/// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/enterprise-server@3.6/rest/reference/orgs#update-hook-config-params).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config")]
		public OrgsSlashupdate_webhookPatchBodyConfig Config { get; set; }
		
		/// <summary>
		/// Determines what [events](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads) the hook is triggered for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class OrgsSlashupdate_webhookPatchBodyConfig
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class OrgsSlashupdate_webhook_config_for_orgPatchBody
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class OrgsSlashlist_app_installationsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="installations")]
		public Installation[] Installations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum OrgsSlashlist_membersFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2fa_disabled")]
		_2fa_disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 1,
	}
	
	public enum OrgsSlashlist_membersRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		member = 2,
	}
	
	public class OrgsSlashset_membership_for_userPutBody
	{
		
		/// <summary>
		/// The role to give the user in the organization. Can be one of:  
		/// * `admin` - The user will become an owner of the organization.  
		/// * `member` - The user will become a non-owner member of the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public System.Nullable<OrgsSlashset_membership_for_userPutBodyRole> Role { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum OrgsSlashset_membership_for_userPutBodyRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		member = 1,
	}
	
	public class MigrationsSlashstart_for_orgPostBody
	{
		
		/// <summary>
		/// Exclude related items from being returned in the response in order to improve performance of the request. The array can include any of: `"repositories"`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude")]
		public string[] Exclude { get; set; }
		
		/// <summary>
		/// Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_attachments")]
		public System.Nullable<System.Boolean> Exclude_attachments { get; set; }
		
		/// <summary>
		/// Indicates whether the repository git data should be excluded from the migration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_git_data")]
		public System.Nullable<System.Boolean> Exclude_git_data { get; set; }
		
		/// <summary>
		/// Indicates whether metadata should be excluded and only git source should be included for the migration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_metadata")]
		public System.Nullable<System.Boolean> Exclude_metadata { get; set; }
		
		/// <summary>
		/// Indicates whether projects owned by the organization or users should be excluded. from the migration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_owner_projects")]
		public System.Nullable<System.Boolean> Exclude_owner_projects { get; set; }
		
		/// <summary>
		/// Indicates whether releases should be excluded from the migration (to reduce migration archive file size).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_releases")]
		public System.Nullable<System.Boolean> Exclude_releases { get; set; }
		
		/// <summary>
		/// Indicates whether repositories should be locked (to prevent manipulation) while migrating data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lock_repositories")]
		public System.Nullable<System.Boolean> Lock_repositories { get; set; }
		
		/// <summary>
		/// Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="org_metadata_only")]
		public System.Nullable<System.Boolean> Org_metadata_only { get; set; }
		
		/// <summary>
		/// A list of arrays indicating which repositories should be migrated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public string[] Repositories { get; set; }
	}
	
	public enum OrgsSlashlist_outside_collaboratorsFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2fa_disabled")]
		_2fa_disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 1,
	}
	
	public class OrgsSlashconvert_member_to_outside_collaboratorPutBody
	{
		
		/// <summary>
		/// When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="async")]
		public System.Nullable<System.Boolean> Async { get; set; }
	}
	
	public class Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_orgPatchBody
	{
		
		/// <summary>
		/// Whether repositories can override enforcement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_downstream_configuration")]
		public System.Nullable<System.Boolean> Allow_downstream_configuration { get; set; }
		
		/// <summary>
		/// The state of enforcement for the hook on this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcement")]
		public string Enforcement { get; set; }
	}
	
	public class ProjectsSlashcreate_for_orgPostBody
	{
		
		/// <summary>
		/// The description of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The name of the project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public enum ReposSlashlist_for_orgType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		forks = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sources = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		member = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="internal")]
		_internal = 6,
	}
	
	public enum ReposSlashlist_for_orgSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pushed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full_name = 3,
	}
	
	public class ReposSlashcreate_in_orgPostBody
	{
		
		/// <summary>
		/// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		/// <summary>
		/// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		/// <summary>
		/// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		/// <summary>
		/// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Pass `true` to create an initial commit with empty README.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auto_init")]
		public System.Nullable<System.Boolean> Auto_init { get; set; }
		
		/// <summary>
		/// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// A short description of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gitignore_template")]
		public string Gitignore_template { get; set; }
		
		/// <summary>
		/// Whether downloads are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public System.Nullable<System.Boolean> Has_downloads { get; set; }
		
		/// <summary>
		/// Either `true` to enable issues for this repository or `false` to disable them.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public System.Nullable<System.Boolean> Has_issues { get; set; }
		
		/// <summary>
		/// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public System.Nullable<System.Boolean> Has_projects { get; set; }
		
		/// <summary>
		/// Either `true` to enable the wiki for this repository or `false` to disable it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public System.Nullable<System.Boolean> Has_wiki { get; set; }
		
		/// <summary>
		/// A URL with more information about the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Either `true` to make this repo available as a template repository or `false` to prevent it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/enterprise-server@3.6/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="license_template")]
		public string License_template { get; set; }
		
		/// <summary>
		/// The default value for a merge commit message.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `PR_BODY` - default to the pull request's body.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_message")]
		public RepositoryMerge_commit_message Merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a merge commit title.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_title")]
		public RepositoryMerge_commit_title Merge_commit_title { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Whether the repository is private.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit message:
		///
		///- `PR_BODY` - default to the pull request's body.
		///- `COMMIT_MESSAGES` - default to the branch's commit messages.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_message")]
		public RepositorySquash_merge_commit_message Squash_merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit title:
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_title")]
		public RepositorySquash_merge_commit_title Squash_merge_commit_title { get; set; }
		
		/// <summary>
		/// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="team_id")]
		public System.Nullable<System.Int32> Team_id { get; set; }
		
		/// <summary>
		/// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_squash_pr_title_as_default")]
		public System.Nullable<System.Boolean> Use_squash_pr_title_as_default { get; set; }
		
		/// <summary>
		/// The visibility of the repository. **Note**: For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://docs.github.com/enterprise-server@3.6/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.  
		///The `visibility` parameter overrides the `private` parameter when you use both parameters with the `nebula-preview` preview header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<ReposSlashcreate_in_orgPostBodyVisibility> Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReposSlashcreate_in_orgPostBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="internal")]
		_internal = 2,
	}
	
	public class TeamsSlashcreatePostBody
	{
		
		/// <summary>
		/// The description of the team.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team. LDAP synchronization must be enabled to map LDAP entries to a team. Use the "[Update LDAP mapping for a team](https://docs.github.com/enterprise-server@3.6/rest/reference/enterprise-admin#update-ldap-mapping-for-a-team)" endpoint to change the LDAP DN. For more information, see "[Using LDAP](https://docs.github.com/enterprise-server@3.6/admin/identity-and-access-management/authenticating-users-for-your-github-enterprise-server-instance/using-ldap#enabling-ldap-sync)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ldap_dn")]
		public string Ldap_dn { get; set; }
		
		/// <summary>
		/// List GitHub IDs for organization members who will become team maintainers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintainers")]
		public string[] Maintainers { get; set; }
		
		/// <summary>
		/// The name of the team.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of a team to set as the parent team.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent_team_id")]
		public System.Nullable<System.Int32> Parent_team_id { get; set; }
		
		/// <summary>
		/// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public System.Nullable<TeamsSlashcreatePostBodyPermission> Permission { get; set; }
		
		/// <summary>
		/// The level of privacy this team should have. The options are:  
		///**For a non-nested team:**  
		/// * `secret` - only visible to organization owners and members of this team.  
		/// * `closed` - visible to all members of this organization.  
		///Default: `secret`  
		///**For a parent or child team:**  
		/// * `closed` - visible to all members of this organization.  
		///Default for child team: `closed`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public System.Nullable<TeamsSlashcreatePostBodyPrivacy> Privacy { get; set; }
		
		/// <summary>
		/// The full name (e.g., "organization-name/repository-name") of repositories to add the team to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repo_names")]
		public string[] Repo_names { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TeamsSlashcreatePostBodyPermission
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pull = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		push = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TeamsSlashcreatePostBodyPrivacy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		secret = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 1,
	}
	
	public class TeamsSlashupdate_in_orgPatchBody
	{
		
		/// <summary>
		/// The description of the team.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the team.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of a team to set as the parent team.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent_team_id")]
		public System.Nullable<System.Int32> Parent_team_id { get; set; }
		
		/// <summary>
		/// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public System.Nullable<TeamsSlashupdate_in_orgPatchBodyPermission> Permission { get; set; }
		
		/// <summary>
		/// The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  
		///**For a non-nested team:**  
		/// * `secret` - only visible to organization owners and members of this team.  
		/// * `closed` - visible to all members of this organization.  
		///**For a parent or child team:**  
		/// * `closed` - visible to all members of this organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public TeamsSlashcreatePostBodyPrivacy Privacy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TeamsSlashupdate_in_orgPatchBodyPermission
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pull = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		push = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 2,
	}
	
	public class TeamsSlashcreate_discussion_in_orgPostBody
	{
		
		/// <summary>
		/// The discussion post's body text.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		/// <summary>
		/// The discussion post's title.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class TeamsSlashupdate_discussion_in_orgPatchBody
	{
		
		/// <summary>
		/// The discussion post's body text.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The discussion post's title.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class TeamsSlashcreate_discussion_comment_in_orgPostBody
	{
		
		/// <summary>
		/// The discussion comment's body text.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class TeamsSlashupdate_discussion_comment_in_orgPatchBody
	{
		
		/// <summary>
		/// The discussion comment's body text.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public enum ReactionsSlashlist_for_team_discussion_comment_in_orgContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReactionsSlashcreate_for_team_discussion_comment_in_orgPostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the team discussion comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_team_discussion_comment_in_orgPostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_team_discussion_comment_in_orgPostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public enum ReactionsSlashlist_for_team_discussion_in_orgContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReactionsSlashcreate_for_team_discussion_in_orgPostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the team discussion.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_team_discussion_in_orgPostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_team_discussion_in_orgPostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class TeamsSlashlink_external_idp_group_to_team_for_orgPatchBody
	{
		
		/// <summary>
		/// External Group Id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="group_id")]
		public int Group_id { get; set; }
	}
	
	public enum TeamsSlashlist_members_in_orgRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		member = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		maintainer = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 2,
	}
	
	public class TeamsSlashadd_or_update_membership_for_user_in_orgPutBody
	{
		
		/// <summary>
		/// The role that this user should have in the team.
		/// </summary>
		[System.ComponentModel.DefaultValue(Team_membershipRole.member)]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public Team_membershipRole Role { get; set; } = Team_membershipRole.member;
	}
	
	public class TeamsSlashadd_or_update_project_permissions_in_orgPutBody
	{
		
		/// <summary>
		/// The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public App_permissionsOrganization_projects Permission { get; set; }
	}
	
	public class TeamsSlashadd_or_update_repo_permissions_in_orgPutBody
	{
		
		/// <summary>
		/// The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
		/// </summary>
		[System.ComponentModel.DefaultValue("push")]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; } = "push";
	}
	
	public class ProjectsSlashupdate_cardPatchBody
	{
		
		/// <summary>
		/// Whether or not the card is archived
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		/// <summary>
		/// The project card's note
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
	}
	
	public class ProjectsSlashmove_cardPostBody
	{
		
		/// <summary>
		/// The unique identifier of the column the card should be moved to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="column_id")]
		public System.Nullable<System.Int32> Column_id { get; set; }
		
		/// <summary>
		/// The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card.
		/// Required
		/// Pattern: ^(?:top|bottom|after:\d+)$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="position")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(?:top|bottom|after:\d+)$")]
		public string Position { get; set; }
	}
	
	public class ProjectsSlashupdate_columnPatchBody
	{
		
		/// <summary>
		/// Name of the project column
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public enum ProjectsSlashlist_cardsArchived_state
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archived = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_archived = 2,
	}
	
	public class ProjectsSlashcreate_cardPostBody
	{
		
		/// <summary>
		/// The project card's note
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
	}
	
	public class ProjectsSlashmove_columnPostBody
	{
		
		/// <summary>
		/// The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.
		/// Required
		/// Pattern: ^(?:first|last|after:\d+)$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="position")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(?:first|last|after:\d+)$")]
		public string Position { get; set; }
	}
	
	public class ProjectsSlashupdatePatchBody
	{
		
		/// <summary>
		/// Body of the project
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Name of the project
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The baseline permission that all organization members have on this project
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_permission")]
		public ProjectOrganization_permission Organization_permission { get; set; }
		
		/// <summary>
		/// Whether or not this project can be seen by everyone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		/// <summary>
		/// State of the project; either 'open' or 'closed'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
	}
	
	public enum ProjectsSlashlist_collaboratorsAffiliation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		outside = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		direct = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 2,
	}
	
	public class ProjectsSlashadd_collaboratorPutBody
	{
		
		/// <summary>
		/// The permission to grant the collaborator.
		/// </summary>
		[System.ComponentModel.DefaultValue(App_permissionsOrganization_projects.write)]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public App_permissionsOrganization_projects Permission { get; set; } = App_permissionsOrganization_projects.write;
	}
	
	public class ProjectsSlashcreate_columnPostBody
	{
		
		/// <summary>
		/// Name of the project column
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ReposSlashupdatePatchBody
	{
		
		/// <summary>
		/// Either `true` to allow private forks, or `false` to prevent private forks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_forking")]
		public System.Nullable<System.Boolean> Allow_forking { get; set; }
		
		/// <summary>
		/// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		/// <summary>
		/// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		/// <summary>
		/// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_update_branch")]
		public System.Nullable<System.Boolean> Allow_update_branch { get; set; }
		
		/// <summary>
		/// Whether to archive this repository. **Note**: You cannot unarchive repositories through the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		/// <summary>
		/// Updates the default branch for this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="default_branch")]
		public string Default_branch { get; set; }
		
		/// <summary>
		/// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// A short description of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Either `true` to enable issues for this repository or `false` to disable them.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public System.Nullable<System.Boolean> Has_issues { get; set; }
		
		/// <summary>
		/// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public System.Nullable<System.Boolean> Has_projects { get; set; }
		
		/// <summary>
		/// Either `true` to enable the wiki for this repository or `false` to disable it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public System.Nullable<System.Boolean> Has_wiki { get; set; }
		
		/// <summary>
		/// A URL with more information about the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Either `true` to make this repo available as a template repository or `false` to prevent it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// The default value for a merge commit message.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `PR_BODY` - default to the pull request's body.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_message")]
		public RepositoryMerge_commit_message Merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a merge commit title.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_title")]
		public RepositoryMerge_commit_title Merge_commit_title { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Either `true` to make the repository private or `false` to make it public. Default: `false`.  
		///**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/enterprise-server@3.6/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit message:
		///
		///- `PR_BODY` - default to the pull request's body.
		///- `COMMIT_MESSAGES` - default to the branch's commit messages.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_message")]
		public RepositorySquash_merge_commit_message Squash_merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit title:
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_title")]
		public RepositorySquash_merge_commit_title Squash_merge_commit_title { get; set; }
		
		/// <summary>
		/// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_squash_pr_title_as_default")]
		public System.Nullable<System.Boolean> Use_squash_pr_title_as_default { get; set; }
		
		/// <summary>
		/// The visibility of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<ReposSlashupdatePatchBodyVisibility> Visibility { get; set; }
		
		/// <summary>
		/// Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="web_commit_signoff_required")]
		public System.Nullable<System.Boolean> Web_commit_signoff_required { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReposSlashupdatePatchBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="internal")]
		_internal = 2,
	}
	
	public class ActionsSlashlist_artifacts_for_repoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="artifacts")]
		public Artifact[] Artifacts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashre_run_job_for_workflow_runPostBody
	{
		
		/// <summary>
		/// Whether to enable debug logging for the re-run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable_debug_logging")]
		public System.Nullable<System.Boolean> Enable_debug_logging { get; set; }
	}
	
	public class ActionsSlashset_github_actions_permissions_repositoryPutBody
	{
		
		/// <summary>
		/// The permissions policy that controls the actions that are allowed to run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed_actions")]
		public Actions_enterprise_permissionsAllowed_actions Allowed_actions { get; set; }
		
		/// <summary>
		/// Whether GitHub Actions is enabled on the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class ActionsSlashlist_self_hosted_runners_for_repoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runners")]
		public Runner[] Runners { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashremove_all_custom_labels_from_self_hosted_runner_for_repoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashlist_labels_for_self_hosted_runner_for_repoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashadd_custom_labels_to_self_hosted_runner_for_repoPostBody
	{
		
		/// <summary>
		/// The names of the custom labels to add to the runner.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string[] Labels { get; set; }
	}
	
	public class ActionsSlashadd_custom_labels_to_self_hosted_runner_for_repoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashset_custom_labels_for_self_hosted_runner_for_repoPutBody
	{
		
		/// <summary>
		/// The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string[] Labels { get; set; }
	}
	
	public class ActionsSlashset_custom_labels_for_self_hosted_runner_for_repoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashremove_custom_label_from_self_hosted_runner_for_repoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Runner_label[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum ActionsSlashlist_workflow_runs_for_repoStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		action_required = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cancelled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		neutral = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		skipped = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stale = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		timed_out = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		in_progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		requested = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		waiting = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 13,
	}
	
	public class ActionsSlashlist_workflow_runs_for_repoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workflow_runs")]
		public Workflow_run[] Workflow_runs { get; set; }
	}
	
	public class ActionsSlashlist_workflow_run_artifactsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="artifacts")]
		public Artifact[] Artifacts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashlist_jobs_for_workflow_run_attemptReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobs")]
		public Job[] Jobs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum ActionsSlashlist_jobs_for_workflow_runFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		latest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 1,
	}
	
	public class ActionsSlashlist_jobs_for_workflow_runReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobs")]
		public Job[] Jobs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashreview_pending_deployments_for_runPostBody
	{
		
		/// <summary>
		/// A comment to accompany the deployment review
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The list of environment ids to approve or reject
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="environment_ids")]
		public int[] Environment_ids { get; set; }
		
		/// <summary>
		/// Whether to approve or reject deployment to the specified environments.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ActionsSlashreview_pending_deployments_for_runPostBodyState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ActionsSlashreview_pending_deployments_for_runPostBodyState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		approved = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rejected = 1,
	}
	
	public class ActionsSlashre_run_workflowPostBody
	{
		
		/// <summary>
		/// Whether to enable debug logging for the re-run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable_debug_logging")]
		public System.Nullable<System.Boolean> Enable_debug_logging { get; set; }
	}
	
	public class ActionsSlashre_run_workflow_failed_jobsPostBody
	{
		
		/// <summary>
		/// Whether to enable debug logging for the re-run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable_debug_logging")]
		public System.Nullable<System.Boolean> Enable_debug_logging { get; set; }
	}
	
	public class ActionsSlashlist_repo_secretsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public Actions_secret[] Secrets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashcreate_or_update_repo_secretPutBody
	{
		
		/// <summary>
		/// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#get-a-repository-public-key) endpoint.
		/// Pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted_value")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$")]
		public string Encrypted_value { get; set; }
		
		/// <summary>
		/// ID of the key you used to encrypt the secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
	}
	
	public class ActionsSlashlist_repo_workflowsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workflows")]
		public Workflow[] Workflows { get; set; }
	}
	
	public class ActionsSlashcreate_workflow_dispatchPostBody
	{
		
		/// <summary>
		/// Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputs")]
		public System.Collections.Generic.Dictionary<string, string> Inputs { get; set; }
		
		/// <summary>
		/// The git reference for the workflow. The reference can be a branch or tag name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
	}
	
	public class ActionsSlashlist_workflow_runsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workflow_runs")]
		public Workflow_run[] Workflow_runs { get; set; }
	}
	
	public class ReposSlashcreate_autolinkPostBody
	{
		
		/// <summary>
		/// Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_alphanumeric")]
		public System.Nullable<System.Boolean> Is_alphanumeric { get; set; }
		
		/// <summary>
		/// The prefix appended by a number will generate a link any time it is found in an issue, pull request, or commit.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key_prefix")]
		public string Key_prefix { get; set; }
		
		/// <summary>
		/// The URL must contain `<num>` for the reference number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url_template")]
		public string Url_template { get; set; }
	}
	
	public class ReposSlashupdate_branch_protectionPutBody
	{
		
		/// <summary>
		/// Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/enterprise-server@3.6/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_deletions")]
		public System.Nullable<System.Boolean> Allow_deletions { get; set; }
		
		/// <summary>
		/// Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/enterprise-server@3.6/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_force_pushes")]
		public System.Nullable<System.Boolean> Allow_force_pushes { get; set; }
		
		/// <summary>
		/// If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="block_creations")]
		public System.Nullable<System.Boolean> Block_creations { get; set; }
		
		/// <summary>
		/// Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enforce_admins")]
		public System.Nullable<System.Boolean> Enforce_admins { get; set; }
		
		/// <summary>
		/// Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_conversation_resolution")]
		public System.Nullable<System.Boolean> Required_conversation_resolution { get; set; }
		
		/// <summary>
		/// Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/enterprise-server@3.6/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_linear_history")]
		public System.Nullable<System.Boolean> Required_linear_history { get; set; }
		
		/// <summary>
		/// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="required_pull_request_reviews")]
		public ReposSlashupdate_branch_protectionPutBodyRequired_pull_request_reviews Required_pull_request_reviews { get; set; }
		
		/// <summary>
		/// Require status checks to pass before merging. Set to `null` to disable.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="required_status_checks")]
		public ReposSlashupdate_branch_protectionPutBodyRequired_status_checks Required_status_checks { get; set; }
		
		/// <summary>
		/// Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restrictions")]
		public ReposSlashupdate_branch_protectionPutBodyRestrictions Restrictions { get; set; }
	}
	
	public class ReposSlashupdate_branch_protectionPutBodyRequired_pull_request_reviews
	{
		
		/// <summary>
		/// Allow specific users, teams, or apps to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bypass_pull_request_allowances")]
		public ReposSlashupdate_branch_protectionPutBodyRequired_pull_request_reviewsBypass_pull_request_allowances Bypass_pull_request_allowances { get; set; }
		
		/// <summary>
		/// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismiss_stale_reviews")]
		public System.Nullable<System.Boolean> Dismiss_stale_reviews { get; set; }
		
		/// <summary>
		/// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismissal_restrictions")]
		public ReposSlashupdate_branch_protectionPutBodyRequired_pull_request_reviewsDismissal_restrictions Dismissal_restrictions { get; set; }
		
		/// <summary>
		/// Blocks merging pull requests until [code owners](https://docs.github.com/enterprise-server@3.6/articles/about-code-owners/) review them.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="require_code_owner_reviews")]
		public System.Nullable<System.Boolean> Require_code_owner_reviews { get; set; }
		
		/// <summary>
		/// Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_approving_review_count")]
		public System.Nullable<System.Int32> Required_approving_review_count { get; set; }
	}
	
	public class ReposSlashupdate_branch_protectionPutBodyRequired_pull_request_reviewsBypass_pull_request_allowances
	{
		
		/// <summary>
		/// The list of app `slug`s allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public string[] Apps { get; set; }
		
		/// <summary>
		/// The list of team `slug`s allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public string[] Teams { get; set; }
		
		/// <summary>
		/// The list of user `login`s allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
	}
	
	public class ReposSlashupdate_branch_protectionPutBodyRequired_pull_request_reviewsDismissal_restrictions
	{
		
		/// <summary>
		/// The list of app `slug`s with dismissal access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public string[] Apps { get; set; }
		
		/// <summary>
		/// The list of team `slug`s with dismissal access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public string[] Teams { get; set; }
		
		/// <summary>
		/// The list of user `login`s with dismissal access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
	}
	
	public class ReposSlashupdate_branch_protectionPutBodyRequired_status_checks
	{
		
		/// <summary>
		/// The list of status checks to require in order to merge into this branch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checks")]
		public ReposSlashupdate_branch_protectionPutBodyRequired_status_checksChecks[] ReposSlashupdate_branch_protectionPutBodyRequired_status_checksChecks { get; set; }
		
		/// <summary>
		/// **Deprecated**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contexts")]
		public string[] Contexts { get; set; }
		
		/// <summary>
		/// Require branches to be up to date before merging.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="strict")]
		public bool Strict { get; set; }
	}
	
	public class ReposSlashupdate_branch_protectionPutBodyRequired_status_checksChecks
	{
		
		/// <summary>
		/// The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="app_id")]
		public System.Nullable<System.Int32> App_id { get; set; }
		
		/// <summary>
		/// The name of the required check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
	}
	
	public class ReposSlashupdate_branch_protectionPutBodyRestrictions
	{
		
		/// <summary>
		/// The list of app `slug`s with push access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public string[] Apps { get; set; }
		
		/// <summary>
		/// The list of team `slug`s with push access
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public string[] Teams { get; set; }
		
		/// <summary>
		/// The list of user `login`s with push access
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
	}
	
	public class ReposSlashupdate_pull_request_review_protectionPatchBody
	{
		
		/// <summary>
		/// Allow specific users, teams, or apps to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bypass_pull_request_allowances")]
		public ReposSlashupdate_pull_request_review_protectionPatchBodyBypass_pull_request_allowances Bypass_pull_request_allowances { get; set; }
		
		/// <summary>
		/// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismiss_stale_reviews")]
		public System.Nullable<System.Boolean> Dismiss_stale_reviews { get; set; }
		
		/// <summary>
		/// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismissal_restrictions")]
		public ReposSlashupdate_pull_request_review_protectionPatchBodyDismissal_restrictions Dismissal_restrictions { get; set; }
		
		/// <summary>
		/// Blocks merging pull requests until [code owners](https://docs.github.com/enterprise-server@3.6/articles/about-code-owners/) have reviewed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="require_code_owner_reviews")]
		public System.Nullable<System.Boolean> Require_code_owner_reviews { get; set; }
		
		/// <summary>
		/// Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_approving_review_count")]
		public System.Nullable<System.Int32> Required_approving_review_count { get; set; }
	}
	
	public class ReposSlashupdate_pull_request_review_protectionPatchBodyBypass_pull_request_allowances
	{
		
		/// <summary>
		/// The list of app `slug`s allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public string[] Apps { get; set; }
		
		/// <summary>
		/// The list of team `slug`s allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public string[] Teams { get; set; }
		
		/// <summary>
		/// The list of user `login`s allowed to bypass pull request requirements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
	}
	
	public class ReposSlashupdate_pull_request_review_protectionPatchBodyDismissal_restrictions
	{
		
		/// <summary>
		/// The list of app `slug`s with dismissal access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public string[] Apps { get; set; }
		
		/// <summary>
		/// The list of team `slug`s with dismissal access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public string[] Teams { get; set; }
		
		/// <summary>
		/// The list of user `login`s with dismissal access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
	}
	
	public class ReposSlashupdate_status_check_protectionPatchBody
	{
		
		/// <summary>
		/// The list of status checks to require in order to merge into this branch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checks")]
		public ReposSlashupdate_status_check_protectionPatchBodyChecks[] ReposSlashupdate_status_check_protectionPatchBodyChecks { get; set; }
		
		/// <summary>
		/// **Deprecated**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contexts")]
		public string[] Contexts { get; set; }
		
		/// <summary>
		/// Require branches to be up to date before merging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="strict")]
		public System.Nullable<System.Boolean> Strict { get; set; }
	}
	
	public class ReposSlashupdate_status_check_protectionPatchBodyChecks
	{
		
		/// <summary>
		/// The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="app_id")]
		public System.Nullable<System.Int32> App_id { get; set; }
		
		/// <summary>
		/// The name of the required check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
	}
	
	public class ReposSlashadd_app_access_restrictionsPostBody
	{
		
		/// <summary>
		/// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public string[] Apps { get; set; }
	}
	
	public class ReposSlashset_app_access_restrictionsPutBody
	{
		
		/// <summary>
		/// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public string[] Apps { get; set; }
	}
	
	public class ReposSlashadd_user_access_restrictionsPostBody
	{
		
		/// <summary>
		/// The username for users
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
	}
	
	public class ReposSlashset_user_access_restrictionsPutBody
	{
		
		/// <summary>
		/// The username for users
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
	}
	
	public class ReposSlashrename_branchPostBody
	{
		
		/// <summary>
		/// The new name of the branch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="new_name")]
		public string New_name { get; set; }
	}
	
	public class ChecksSlashcreatePostBody
	{
		
		/// <summary>
		/// Displays a button on GitHub that can be clicked to alert your app to do additional tasks. For example, a code linting app can display a button that automatically fixes detected errors. The button created in this object is displayed after the check run completes. When a user clicks the button, GitHub sends the [`check_run.requested_action` webhook](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#check_run) to your app. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/enterprise-server@3.6/rest/reference/checks#check-runs-and-requested-actions)."
		/// Maximum items: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actions")]
		[System.ComponentModel.DataAnnotations.MaxLength(3)]
		public ChecksSlashcreatePostBodyActions[] ChecksSlashcreatePostBodyActions { get; set; }
		
		/// <summary>
		/// The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completed_at")]
		public System.Nullable<System.DateTimeOffset> Completed_at { get; set; }
		
		/// <summary>
		/// **Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. 
		///**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conclusion")]
		public System.Nullable<ChecksSlashcreatePostBodyConclusion> Conclusion { get; set; }
		
		/// <summary>
		/// The URL of the integrator's site that has the full details of the check. If the integrator does not provide this, then the homepage of the GitHub app is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details_url")]
		public string Details_url { get; set; }
		
		/// <summary>
		/// A reference for the run on the integrator's system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="external_id")]
		public string External_id { get; set; }
		
		/// <summary>
		/// The SHA of the commit.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_sha")]
		public string Head_sha { get; set; }
		
		/// <summary>
		/// The name of the check. For example, "code-coverage".
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="output")]
		public ChecksSlashcreatePostBodyOutput Output { get; set; }
		
		/// <summary>
		/// The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="started_at")]
		public System.Nullable<System.DateTimeOffset> Started_at { get; set; }
		
		/// <summary>
		/// The current status.
		/// </summary>
		[System.ComponentModel.DefaultValue(Check_runStatus.queued)]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Check_runStatus Status { get; set; } = Check_runStatus.queued;
	}
	
	public class ChecksSlashcreatePostBodyActions
	{
		
		/// <summary>
		/// A short explanation of what this action would do. The maximum size is 40 characters.
		/// Required
		/// Max length: 40
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		public string Description { get; set; }
		
		/// <summary>
		/// A reference for the action on the integrator's system. The maximum size is 20 characters.
		/// Required
		/// Max length: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="identifier")]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public string Identifier { get; set; }
		
		/// <summary>
		/// The text to be displayed on a button in the web UI. The maximum size is 20 characters.
		/// Required
		/// Max length: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public string Label { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ChecksSlashcreatePostBodyConclusion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		action_required = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cancelled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		neutral = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		skipped = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stale = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		timed_out = 7,
	}
	
	public class ChecksSlashcreatePostBodyOutput
	{
		
		/// <summary>
		/// Adds information from your analysis to specific lines of code. Annotations are visible on GitHub in the **Checks** and **Files changed** tab of the pull request. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/enterprise-server@3.6/rest/reference/checks#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. For details about how you can view annotations on GitHub, see "[About status checks](https://docs.github.com/enterprise-server@3.6/articles/about-status-checks#checks)".
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public ChecksSlashcreatePostBodyOutputAnnotations[] ChecksSlashcreatePostBodyOutputAnnotations { get; set; }
		
		/// <summary>
		/// Adds images to the output displayed in the GitHub pull request UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="images")]
		public ChecksSlashcreatePostBodyOutputImages[] ChecksSlashcreatePostBodyOutputImages { get; set; }
		
		/// <summary>
		/// The summary of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.
		/// Required
		/// Max length: 65535
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="summary")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Summary { get; set; }
		
		/// <summary>
		/// The details of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.
		/// Max length: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Text { get; set; }
		
		/// <summary>
		/// The title of the check run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class ChecksSlashcreatePostBodyOutputAnnotations
	{
		
		/// <summary>
		/// The level of the annotation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="annotation_level")]
		public ChecksSlashcreatePostBodyOutputAnnotationsAnnotation_level Annotation_level { get; set; }
		
		/// <summary>
		/// The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_column")]
		public System.Nullable<System.Int32> End_column { get; set; }
		
		/// <summary>
		/// The end line of the annotation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end_line")]
		public int End_line { get; set; }
		
		/// <summary>
		/// A short description of the feedback for these lines of code. The maximum size is 64 KB.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The path of the file to add an annotation to. For example, `assets/css/main.css`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Details about this annotation. The maximum size is 64 KB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="raw_details")]
		public string Raw_details { get; set; }
		
		/// <summary>
		/// The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_column")]
		public System.Nullable<System.Int32> Start_column { get; set; }
		
		/// <summary>
		/// The start line of the annotation. Line numbers start at 1.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public int Start_line { get; set; }
		
		/// <summary>
		/// The title that represents the annotation. The maximum size is 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ChecksSlashcreatePostBodyOutputAnnotationsAnnotation_level
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		notice = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		warning = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 2,
	}
	
	public class ChecksSlashcreatePostBodyOutputImages
	{
		
		/// <summary>
		/// The alternative text for the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alt")]
		public string Alt { get; set; }
		
		/// <summary>
		/// A short image description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caption")]
		public string Caption { get; set; }
		
		/// <summary>
		/// The full URL of the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
	}
	
	public class ChecksSlashupdatePatchBody
	{
		
		/// <summary>
		/// Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. See the [`actions` object](https://docs.github.com/enterprise-server@3.6/rest/reference/checks#actions-object) description. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/enterprise-server@3.6/rest/reference/checks#check-runs-and-requested-actions)."
		/// Maximum items: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actions")]
		[System.ComponentModel.DataAnnotations.MaxLength(3)]
		public ChecksSlashupdatePatchBodyActions[] ChecksSlashupdatePatchBodyActions { get; set; }
		
		/// <summary>
		/// The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completed_at")]
		public System.Nullable<System.DateTimeOffset> Completed_at { get; set; }
		
		/// <summary>
		/// **Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. 
		///**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conclusion")]
		public ChecksSlashcreatePostBodyConclusion Conclusion { get; set; }
		
		/// <summary>
		/// The URL of the integrator's site that has the full details of the check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details_url")]
		public string Details_url { get; set; }
		
		/// <summary>
		/// A reference for the run on the integrator's system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="external_id")]
		public string External_id { get; set; }
		
		/// <summary>
		/// The name of the check. For example, "code-coverage".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="output")]
		public ChecksSlashupdatePatchBodyOutput Output { get; set; }
		
		/// <summary>
		/// This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="started_at")]
		public System.Nullable<System.DateTimeOffset> Started_at { get; set; }
		
		/// <summary>
		/// The current status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Check_runStatus Status { get; set; }
	}
	
	public class ChecksSlashupdatePatchBodyActions
	{
		
		/// <summary>
		/// A short explanation of what this action would do. The maximum size is 40 characters.
		/// Required
		/// Max length: 40
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		public string Description { get; set; }
		
		/// <summary>
		/// A reference for the action on the integrator's system. The maximum size is 20 characters.
		/// Required
		/// Max length: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="identifier")]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public string Identifier { get; set; }
		
		/// <summary>
		/// The text to be displayed on a button in the web UI. The maximum size is 20 characters.
		/// Required
		/// Max length: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public string Label { get; set; }
	}
	
	public class ChecksSlashupdatePatchBodyOutput
	{
		
		/// <summary>
		/// Adds information from your analysis to specific lines of code. Annotations are visible in GitHub's pull request UI. Annotations are visible in GitHub's pull request UI. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/enterprise-server@3.6/rest/reference/checks#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. For details about annotations in the UI, see "[About status checks](https://docs.github.com/enterprise-server@3.6/articles/about-status-checks#checks)".
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public ChecksSlashupdatePatchBodyOutputAnnotations[] ChecksSlashupdatePatchBodyOutputAnnotations { get; set; }
		
		/// <summary>
		/// Adds images to the output displayed in the GitHub pull request UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="images")]
		public ChecksSlashupdatePatchBodyOutputImages[] ChecksSlashupdatePatchBodyOutputImages { get; set; }
		
		/// <summary>
		/// Can contain Markdown.
		/// Required
		/// Max length: 65535
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="summary")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Summary { get; set; }
		
		/// <summary>
		/// Can contain Markdown.
		/// Max length: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Text { get; set; }
		
		/// <summary>
		/// **Required**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class ChecksSlashupdatePatchBodyOutputAnnotations
	{
		
		/// <summary>
		/// The level of the annotation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="annotation_level")]
		public ChecksSlashcreatePostBodyOutputAnnotationsAnnotation_level Annotation_level { get; set; }
		
		/// <summary>
		/// The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_column")]
		public System.Nullable<System.Int32> End_column { get; set; }
		
		/// <summary>
		/// The end line of the annotation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end_line")]
		public int End_line { get; set; }
		
		/// <summary>
		/// A short description of the feedback for these lines of code. The maximum size is 64 KB.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The path of the file to add an annotation to. For example, `assets/css/main.css`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Details about this annotation. The maximum size is 64 KB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="raw_details")]
		public string Raw_details { get; set; }
		
		/// <summary>
		/// The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_column")]
		public System.Nullable<System.Int32> Start_column { get; set; }
		
		/// <summary>
		/// The start line of the annotation. Line numbers start at 1.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public int Start_line { get; set; }
		
		/// <summary>
		/// The title that represents the annotation. The maximum size is 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class ChecksSlashupdatePatchBodyOutputImages
	{
		
		/// <summary>
		/// The alternative text for the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alt")]
		public string Alt { get; set; }
		
		/// <summary>
		/// A short image description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caption")]
		public string Caption { get; set; }
		
		/// <summary>
		/// The full URL of the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
	}
	
	public class ChecksSlashcreate_suitePostBody
	{
		
		/// <summary>
		/// The sha of the head commit.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head_sha")]
		public string Head_sha { get; set; }
	}
	
	public class ChecksSlashset_suites_preferencesPatchBody
	{
		
		/// <summary>
		/// Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auto_trigger_checks")]
		public ChecksSlashset_suites_preferencesPatchBodyAuto_trigger_checks[] ChecksSlashset_suites_preferencesPatchBodyAuto_trigger_checks { get; set; }
	}
	
	public class ChecksSlashset_suites_preferencesPatchBodyAuto_trigger_checks
	{
		
		/// <summary>
		/// The `id` of the GitHub App.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="app_id")]
		public int App_id { get; set; }
		
		/// <summary>
		/// Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="setting")]
		public bool Setting { get; set; } = true;
	}
	
	public class ChecksSlashlist_for_suiteReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="check_runs")]
		public Check_run[] Check_runs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class Code_scanningSlashupdate_alertPatchBody
	{
		
		/// <summary>
		/// The dismissal comment associated with the dismissal of the alert.
		/// Max length: 280
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismissed_comment")]
		[System.ComponentModel.DataAnnotations.MaxLength(280)]
		public string Dismissed_comment { get; set; }
		
		/// <summary>
		/// **Required when the state is dismissed.** The reason for dismissing or closing the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dismissed_reason")]
		public System.Nullable<Code_scanningSlashupdate_alertPatchBodyDismissed_reason> Dismissed_reason { get; set; }
		
		/// <summary>
		/// Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Code_scanning_alert_set_state State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Code_scanningSlashupdate_alertPatchBodyDismissed_reason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false positive")]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="won't fix")]
		won_t_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="used in tests")]
		used_in_tests = 3,
	}
	
	public class Code_scanningSlashupload_sarifPostBody
	{
		
		/// <summary>
		/// The base directory used in the analysis, as it appears in the SARIF file.
		///This property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checkout_uri")]
		public string Checkout_uri { get; set; }
		
		/// <summary>
		/// The SHA of the commit to which the analysis you are uploading relates.
		/// Required
		/// Max length: 40
		/// Min length: 40
		/// Pattern: ^[0-9a-fA-F]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_sha")]
		[System.ComponentModel.DataAnnotations.MinLength(40)]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[0-9a-fA-F]+$")]
		public string Commit_sha { get; set; }
		
		/// <summary>
		/// The full Git reference, formatted as `refs/heads/<branch name>`,
		///`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/enterprise-server@3.6/code-security/secure-coding/sarif-support-for-code-scanning)."
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sarif")]
		public string Sarif { get; set; }
		
		/// <summary>
		/// The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="started_at")]
		public System.Nullable<System.DateTimeOffset> Started_at { get; set; }
		
		/// <summary>
		/// The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to "API". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tool_name")]
		public string Tool_name { get; set; }
	}
	
	public class ReposSlashadd_collaboratorPutBody
	{
		
		/// <summary>
		/// The permission to grant the collaborator. **Only valid on organization-owned repositories.**
		/// </summary>
		[System.ComponentModel.DefaultValue("push")]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public string Permission { get; set; } = "push";
	}
	
	public class ReposSlashupdate_commit_commentPatchBody
	{
		
		/// <summary>
		/// The contents of the comment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public enum ReactionsSlashlist_for_commit_commentContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReactionsSlashcreate_for_commit_commentPostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the commit comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_commit_commentPostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_commit_commentPostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReposSlashcreate_commit_commentPostBody
	{
		
		/// <summary>
		/// The contents of the comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// **Deprecated**. Use **position** parameter instead. Line number in the file to comment on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="line")]
		public System.Nullable<System.Int32> Line { get; set; }
		
		/// <summary>
		/// Relative path of the file to comment on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Line index in the diff to comment on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="position")]
		public System.Nullable<System.Int32> Position { get; set; }
	}
	
	public class ChecksSlashlist_for_refReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="check_runs")]
		public Check_run[] Check_runs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ChecksSlashlist_suites_for_refReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="check_suites")]
		public Check_suite[] Check_suites { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ReposSlashget_contentReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ReposSlashget_contentReturn_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git_url")]
		public string Git_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html_url")]
		public string Html_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Content_directoryElementType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ReposSlashget_contentReturn_links
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public string Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	public class ReposSlashcreate_or_update_file_contentsPutBody
	{
		
		/// <summary>
		/// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author")]
		public ReposSlashcreate_or_update_file_contentsPutBodyAuthor Author { get; set; }
		
		/// <summary>
		/// The branch name. Default: the repository’s default branch (usually `master`)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="branch")]
		public string Branch { get; set; }
		
		/// <summary>
		/// The person that committed the file. Default: the authenticated user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public ReposSlashcreate_or_update_file_contentsPutBodyCommitter Committer { get; set; }
		
		/// <summary>
		/// The new file content, using Base64 encoding.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// The commit message.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// **Required if you are updating a file**. The blob SHA of the file being replaced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
	}
	
	public class ReposSlashcreate_or_update_file_contentsPutBodyAuthor
	{
		
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		/// <summary>
		/// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ReposSlashcreate_or_update_file_contentsPutBodyCommitter
	{
		
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		/// <summary>
		/// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class DependabotSlashlist_repo_secretsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public Dependabot_secret[] Secrets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class DependabotSlashcreate_or_update_repo_secretPutBody
	{
		
		/// <summary>
		/// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/enterprise-server@3.6/rest/reference/dependabot#get-a-repository-public-key) endpoint.
		/// Pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted_value")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$")]
		public string Encrypted_value { get; set; }
		
		/// <summary>
		/// ID of the key you used to encrypt the secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
	}
	
	public class Dependency_graphSlashdiff_rangeReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="change_type")]
		public Dependency_graph_diffElementChange_type Change_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ecosystem")]
		public string Ecosystem { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="license")]
		public string License { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="manifest")]
		public string Manifest { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="package_url")]
		public string Package_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source_repository_url")]
		public string Source_repository_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vulnerabilities")]
		public Dependency_graphSlashdiff_rangeReturnVulnerabilities[] Dependency_graphSlashdiff_rangeReturnVulnerabilities { get; set; }
	}
	
	public class Dependency_graphSlashdiff_rangeReturnVulnerabilities
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="advisory_ghsa_id")]
		public string Advisory_ghsa_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="advisory_summary")]
		public string Advisory_summary { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="advisory_url")]
		public string Advisory_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
	}
	
	public class ReposSlashcreate_deploymentPostBody
	{
		
		/// <summary>
		/// Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auto_merge")]
		public System.Nullable<System.Boolean> Auto_merge { get; set; }
		
		/// <summary>
		/// Short description of the deployment.
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; } = "";
		
		/// <summary>
		/// Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
		/// </summary>
		[System.ComponentModel.DefaultValue("production")]
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public string Environment { get; set; } = "production";
		
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public string Payload { get; set; }
		
		/// <summary>
		/// Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="production_environment")]
		public System.Nullable<System.Boolean> Production_environment { get; set; }
		
		/// <summary>
		/// The ref to deploy. This can be a branch, tag, or SHA.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// The [status](https://docs.github.com/enterprise-server@3.6/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_contexts")]
		public string[] Required_contexts { get; set; }
		
		/// <summary>
		/// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
		/// </summary>
		[System.ComponentModel.DefaultValue("deploy")]
		[System.Runtime.Serialization.DataMember(Name="task")]
		public string Task { get; set; } = "deploy";
		
		/// <summary>
		/// Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transient_environment")]
		public System.Nullable<System.Boolean> Transient_environment { get; set; }
	}
	
	public class ReposSlashcreate_deployment_statusPostBody
	{
		
		/// <summary>
		/// Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auto_inactive")]
		public System.Nullable<System.Boolean> Auto_inactive { get; set; }
		
		/// <summary>
		/// A short description of the status. The maximum description length is 140 characters.
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; } = "";
		
		/// <summary>
		/// Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public System.Nullable<ReposSlashcreate_deployment_statusPostBodyEnvironment> Environment { get; set; }
		
		/// <summary>
		/// Sets the URL for accessing your environment. Default: `""`
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="environment_url")]
		public string Environment_url { get; set; } = "";
		
		/// <summary>
		/// The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="log_url")]
		public string Log_url { get; set; } = "";
		
		/// <summary>
		/// The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ReposSlashcreate_deployment_statusPostBodyState State { get; set; }
		
		/// <summary>
		/// The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment. **Note:** It's recommended to use the `log_url` parameter, which replaces `target_url`.
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="target_url")]
		public string Target_url { get; set; } = "";
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReposSlashcreate_deployment_statusPostBodyEnvironment
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		production = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		staging = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		qa = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReposSlashcreate_deployment_statusPostBodyState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		error = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inactive = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		in_progress = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 6,
	}
	
	public class ReposSlashcreate_dispatch_eventPostBody
	{
		
		/// <summary>
		/// JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_payload")]
		public string Client_payload { get; set; }
		
		/// <summary>
		/// A custom webhook event name. Must be 100 characters or fewer.
		/// Required
		/// Max length: 100
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event_type")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Event_type { get; set; }
	}
	
	public class ReposSlashget_all_environmentsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="environments")]
		public Environment[] Environments { get; set; }
		
		/// <summary>
		/// The number of environments in this repository
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public System.Nullable<System.Int32> Total_count { get; set; }
	}
	
	public class ReposSlashcreate_or_update_environmentPutBody
	{
		
		/// <summary>
		/// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deployment_branch_policy")]
		public Deployment_branch_policy_settings Deployment_branch_policy { get; set; }
		
		/// <summary>
		/// The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reviewers")]
		public ReposSlashcreate_or_update_environmentPutBodyReviewers[] ReposSlashcreate_or_update_environmentPutBodyReviewers { get; set; }
		
		/// <summary>
		/// The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wait_timer")]
		public System.Nullable<System.Int32> Wait_timer { get; set; }
	}
	
	public class ReposSlashcreate_or_update_environmentPutBodyReviewers
	{
		
		/// <summary>
		/// The id of the user or team who can review the deployment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The type of reviewer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Deployment_reviewer_type Type { get; set; }
	}
	
	public class ReposSlashlist_deployment_branch_policiesReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branch_policies")]
		public Deployment_branch_policy[] Branch_policies { get; set; }
		
		/// <summary>
		/// The number of deployment branch policies for the environment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum ReposSlashlist_forksSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		newest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oldest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stargazers = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		watchers = 3,
	}
	
	public class ReposSlashcreate_forkPostBody
	{
		
		/// <summary>
		/// Optional parameter to specify the organization name if forking into an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public string Organization { get; set; }
	}
	
	public class GitSlashcreate_blobPostBody
	{
		
		/// <summary>
		/// The new blob's content.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.
		/// </summary>
		[System.ComponentModel.DefaultValue("utf-8")]
		[System.Runtime.Serialization.DataMember(Name="encoding")]
		public string Encoding { get; set; } = "utf-8";
	}
	
	public class GitSlashcreate_commitPostBody
	{
		
		/// <summary>
		/// Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author")]
		public GitSlashcreate_commitPostBodyAuthor Author { get; set; }
		
		/// <summary>
		/// Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="committer")]
		public GitSlashcreate_commitPostBodyCommitter Committer { get; set; }
		
		/// <summary>
		/// The commit message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parents")]
		public string[] Parents { get; set; }
		
		/// <summary>
		/// The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
		
		/// <summary>
		/// The SHA of the tree object this commit points to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree")]
		public string Tree { get; set; }
	}
	
	public class GitSlashcreate_commitPostBodyAuthor
	{
		
		/// <summary>
		/// Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// The email of the author (or committer) of the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The name of the author (or committer) of the commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GitSlashcreate_commitPostBodyCommitter
	{
		
		/// <summary>
		/// Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// The email of the author (or committer) of the commit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The name of the author (or committer) of the commit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GitSlashcreate_refPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
		
		/// <summary>
		/// The SHA1 value for this reference.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
	}
	
	public class GitSlashupdate_refPatchBody
	{
		
		/// <summary>
		/// Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="force")]
		public System.Nullable<System.Boolean> Force { get; set; }
		
		/// <summary>
		/// The SHA1 value to set this reference to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
	}
	
	public class GitSlashcreate_tagPostBody
	{
		
		/// <summary>
		/// The tag message.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The SHA of the git object this is tagging.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="object")]
		public string Object { get; set; }
		
		/// <summary>
		/// The tag's name. This is typically a version (e.g., "v0.0.1").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
		
		/// <summary>
		/// An object with information about the individual creating the tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tagger")]
		public GitSlashcreate_tagPostBodyTagger Tagger { get; set; }
		
		/// <summary>
		/// The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GitSlashcreate_tagPostBodyType Type { get; set; }
	}
	
	public class GitSlashcreate_tagPostBodyTagger
	{
		
		/// <summary>
		/// When this object was tagged. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// The email of the author of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The name of the author of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GitSlashcreate_tagPostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		commit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tree = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		blob = 2,
	}
	
	public class GitSlashcreate_treePostBody
	{
		
		/// <summary>
		/// The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.
		///If not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="base_tree")]
		public string Base_tree { get; set; }
		
		/// <summary>
		/// Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tree")]
		public GitSlashcreate_treePostBodyTree[] GitSlashcreate_treePostBodyTree { get; set; }
	}
	
	public class GitSlashcreate_treePostBodyTree
	{
		
		/// <summary>
		/// The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this, or `tree.sha`.  
		///  
		///**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<GitSlashcreate_treePostBodyTreeMode> Mode { get; set; }
		
		/// <summary>
		/// The file referenced in the tree.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the value is `null` then the file will be deleted.  
		///  
		///**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
		
		/// <summary>
		/// Either `blob`, `tree`, or `commit`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<GitSlashcreate_treePostBodyTreeType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GitSlashcreate_treePostBodyTreeMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="100644")]
		_100644 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="100755")]
		_100755 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="040000")]
		_040000 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="160000")]
		_160000 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="120000")]
		_120000 = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GitSlashcreate_treePostBodyTreeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		blob = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tree = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		commit = 2,
	}
	
	public class ReposSlashcreate_webhookPostBody
	{
		
		/// <summary>
		/// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#create-hook-config-params).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config")]
		public ReposSlashcreate_webhookPostBodyConfig Config { get; set; }
		
		/// <summary>
		/// Determines what [events](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads) the hook is triggered for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		/// <summary>
		/// Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ReposSlashcreate_webhookPostBodyConfig
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ReposSlashupdate_webhookPatchBody
	{
		
		/// <summary>
		/// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// Determines a list of events to be added to the list of events that the Hook triggers for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_events")]
		public string[] Add_events { get; set; }
		
		/// <summary>
		/// Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#create-hook-config-params).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config")]
		public ReposSlashupdate_webhookPatchBodyConfig Config { get; set; }
		
		/// <summary>
		/// Determines what [events](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="events")]
		public string[] Events { get; set; }
		
		/// <summary>
		/// Determines a list of events to be removed from the list of events that the Hook triggers for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_events")]
		public string[] Remove_events { get; set; }
	}
	
	public class ReposSlashupdate_webhookPatchBodyConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="room")]
		public string Room { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ReposSlashupdate_webhook_config_for_repoPatchBody
	{
		
		/// <summary>
		/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecure_ssl")]
		public Webhook_config_insecure_ssl Insecure_ssl { get; set; }
		
		/// <summary>
		/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.6/webhooks/event-payloads/#delivery-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The URL to which the payloads will be delivered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ReposSlashupdate_invitationPatchBody
	{
		
		/// <summary>
		/// The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public System.Nullable<ReposSlashupdate_invitationPatchBodyPermissions> Permissions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReposSlashupdate_invitationPatchBodyPermissions
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		write = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		maintain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		triage = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 4,
	}
	
	public class IssuesSlashcreatePostBody
	{
		
		/// <summary>
		/// Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is deprecated.**_
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public string Assignee { get; set; }
		
		/// <summary>
		/// Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignees")]
		public string[] Assignees { get; set; }
		
		/// <summary>
		/// The contents of the issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public string Milestone { get; set; }
		
		/// <summary>
		/// The title of the issue.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class IssuesSlashupdate_commentPatchBody
	{
		
		/// <summary>
		/// The contents of the comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public enum ReactionsSlashlist_for_issue_commentContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReactionsSlashcreate_for_issue_commentPostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the issue comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_issue_commentPostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_issue_commentPostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class IssuesSlashupdatePatchBody
	{
		
		/// <summary>
		/// Username to assign to this issue. **This field is deprecated.**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignee")]
		public string Assignee { get; set; }
		
		/// <summary>
		/// Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignees")]
		public string[] Assignees { get; set; }
		
		/// <summary>
		/// The contents of the issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="milestone")]
		public string Milestone { get; set; }
		
		/// <summary>
		/// The open or closed state of the issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Nullable_milestoneState State { get; set; }
		
		/// <summary>
		/// The reason for the state change. Ignored unless `state` is changed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state_reason")]
		public System.Nullable<IssuesSlashupdatePatchBodyState_reason> State_reason { get; set; }
		
		/// <summary>
		/// The title of the issue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum IssuesSlashupdatePatchBodyState_reason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_planned = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reopened = 2,
	}
	
	public class IssuesSlashadd_assigneesPostBody
	{
		
		/// <summary>
		/// Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignees")]
		public string[] Assignees { get; set; }
	}
	
	public class IssuesSlashcreate_commentPostBody
	{
		
		/// <summary>
		/// The contents of the comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class IssuesSlashadd_labelsPostBody
	{
		
		/// <summary>
		/// The names of the labels to add to the issue's existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also replace all of the labels for an issue. For more information, see "[Set labels for an issue](https://docs.github.com/enterprise-server@3.6/rest/reference/issues#set-labels-for-an-issue)."
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Labels { get; set; }
	}
	
	public class IssuesSlashset_labelsPutBody
	{
		
		/// <summary>
		/// The names of the labels to set for the issue. The labels you set replace any existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also add labels to the existing labels for an issue. For more information, see "[Add labels to an issue](https://docs.github.com/enterprise-server@3.6/rest/reference/issues#add-labels-to-an-issue)."
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Labels { get; set; }
	}
	
	public class IssuesSlashlockPutBody
	{
		
		/// <summary>
		/// The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  
		/// * `off-topic`  
		/// * `too heated`  
		/// * `resolved`  
		/// * `spam`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lock_reason")]
		public System.Nullable<IssuesSlashlockPutBodyLock_reason> Lock_reason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum IssuesSlashlockPutBodyLock_reason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="off-topic")]
		offMinustopic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="too heated")]
		too_heated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		resolved = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		spam = 3,
	}
	
	public enum ReactionsSlashlist_for_issueContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReactionsSlashcreate_for_issuePostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the issue.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_issuePostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_issuePostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReposSlashcreate_deploy_keyPostBody
	{
		
		/// <summary>
		/// The contents of the key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  
		///  
		///Deploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/enterprise-server@3.6/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/enterprise-server@3.6/articles/permission-levels-for-a-user-account-repository/)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="read_only")]
		public System.Nullable<System.Boolean> Read_only { get; set; }
		
		/// <summary>
		/// A name for the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class IssuesSlashcreate_labelPostBody
	{
		
		/// <summary>
		/// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// A short description of the label. Must be 100 characters or fewer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class IssuesSlashupdate_labelPatchBody
	{
		
		/// <summary>
		/// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// A short description of the label. Must be 100 characters or fewer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="new_name")]
		public string New_name { get; set; }
	}
	
	public class ReposSlashmerge_upstreamPostBody
	{
		
		/// <summary>
		/// The name of the branch which should be updated to match upstream.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branch")]
		public string Branch { get; set; }
	}
	
	public class ReposSlashmergePostBody
	{
		
		/// <summary>
		/// The name of the base branch that the head will be merged into.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="base")]
		public string Base { get; set; }
		
		/// <summary>
		/// Commit message to use for the merge commit. If omitted, a default message will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commit_message")]
		public string Commit_message { get; set; }
		
		/// <summary>
		/// The head to merge. This can be a branch name or a commit SHA1.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head")]
		public string Head { get; set; }
	}
	
	public enum IssuesSlashlist_milestonesSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		due_on = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completeness = 1,
	}
	
	public class IssuesSlashcreate_milestonePostBody
	{
		
		/// <summary>
		/// A description of the milestone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="due_on")]
		public System.Nullable<System.DateTimeOffset> Due_on { get; set; }
		
		/// <summary>
		/// The state of the milestone. Either `open` or `closed`.
		/// </summary>
		[System.ComponentModel.DefaultValue(Nullable_milestoneState.open)]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Nullable_milestoneState State { get; set; } = Nullable_milestoneState.open;
		
		/// <summary>
		/// The title of the milestone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class IssuesSlashupdate_milestonePatchBody
	{
		
		/// <summary>
		/// A description of the milestone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="due_on")]
		public System.Nullable<System.DateTimeOffset> Due_on { get; set; }
		
		/// <summary>
		/// The state of the milestone. Either `open` or `closed`.
		/// </summary>
		[System.ComponentModel.DefaultValue(Nullable_milestoneState.open)]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Nullable_milestoneState State { get; set; } = Nullable_milestoneState.open;
		
		/// <summary>
		/// The title of the milestone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class ActivitySlashmark_repo_notifications_as_readPutBody
	{
		
		/// <summary>
		/// Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_read_at")]
		public System.Nullable<System.DateTimeOffset> Last_read_at { get; set; }
	}
	
	public class ReposSlashcreate_pages_sitePostBody
	{
		
		/// <summary>
		/// The process in which the Page will be built. Possible values are `"legacy"` and `"workflow"`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="build_type")]
		public PageBuild_type Build_type { get; set; }
		
		/// <summary>
		/// The source branch and directory used to publish your Pages site.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public ReposSlashcreate_pages_sitePostBodySource Source { get; set; }
	}
	
	public class ReposSlashcreate_pages_sitePostBodySource
	{
		
		/// <summary>
		/// The repository branch used to publish your site's source files.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="branch")]
		public string Branch { get; set; }
		
		/// <summary>
		/// The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`. Default: `/`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public System.Nullable<ReposSlashcreate_pages_sitePostBodySourcePath> Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReposSlashcreate_pages_sitePostBodySourcePath
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="/")]
		_ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="/docs")]
		_docs = 1,
	}
	
	public class ReposSlashupdate_information_about_pages_sitePutBody
	{
		
		/// <summary>
		/// The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="build_type")]
		public PageBuild_type Build_type { get; set; }
		
		/// <summary>
		/// Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see "[Using a custom domain with GitHub Pages](https://docs.github.com/enterprise-server@3.6/articles/using-a-custom-domain-with-github-pages/)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cname")]
		public string Cname { get; set; }
		
		/// <summary>
		/// Specify whether HTTPS should be enforced for the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="https_enforced")]
		public System.Nullable<System.Boolean> Https_enforced { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public ReposSlashupdate_information_about_pages_sitePutBodySource Source { get; set; }
	}
	
	public enum ReposSlashupdate_information_about_pages_sitePutBodySource
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gh-pages")]
		ghMinuspages = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		master = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="master /docs")]
		master__docs = 2,
	}
	
	public class Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_repoPatchBody
	{
		
		/// <summary>
		/// The state of enforcement for the hook on this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcement")]
		public System.Nullable<Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_repoPatchBodyEnforcement> Enforcement { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Enterprise_adminSlashupdate_pre_receive_hook_enforcement_for_repoPatchBodyEnforcement
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 2,
	}
	
	public class ProjectsSlashcreate_for_repoPostBody
	{
		
		/// <summary>
		/// The description of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The name of the project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public enum PullsSlashlistSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		popularity = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="long-running")]
		longMinusrunning = 3,
	}
	
	public class PullsSlashcreatePostBody
	{
		
		/// <summary>
		/// The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="base")]
		public string Base { get; set; }
		
		/// <summary>
		/// The contents of the pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/enterprise-server@3.6/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public System.Nullable<System.Boolean> Draft { get; set; }
		
		/// <summary>
		/// The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="head")]
		public string Head { get; set; }
		
		/// <summary>
		/// An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issue")]
		public System.Nullable<System.Int32> Issue { get; set; }
		
		/// <summary>
		/// Indicates whether [maintainers can modify](https://docs.github.com/enterprise-server@3.6/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintainer_can_modify")]
		public System.Nullable<System.Boolean> Maintainer_can_modify { get; set; }
		
		/// <summary>
		/// The title of the new pull request. Required unless `issue` is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public enum PullsSlashlist_review_comments_for_repoSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created_at = 2,
	}
	
	public class PullsSlashupdate_review_commentPatchBody
	{
		
		/// <summary>
		/// The text of the reply to the review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public enum ReactionsSlashlist_for_pull_request_review_commentContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReactionsSlashcreate_for_pull_request_review_commentPostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the pull request review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_pull_request_review_commentPostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_pull_request_review_commentPostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class PullsSlashupdatePatchBody
	{
		
		/// <summary>
		/// The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="base")]
		public string Base { get; set; }
		
		/// <summary>
		/// The contents of the pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Indicates whether [maintainers can modify](https://docs.github.com/enterprise-server@3.6/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintainer_can_modify")]
		public System.Nullable<System.Boolean> Maintainer_can_modify { get; set; }
		
		/// <summary>
		/// State of this Pull Request. Either `open` or `closed`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Nullable_milestoneState State { get; set; }
		
		/// <summary>
		/// The title of the pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class PullsSlashcreate_review_commentPostBody
	{
		
		/// <summary>
		/// The text of the review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in_reply_to")]
		public System.Nullable<System.Int32> In_reply_to { get; set; }
		
		/// <summary>
		/// The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="line")]
		public int Line { get; set; }
		
		/// <summary>
		/// The relative path to the file that necessitates a comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// **This parameter is deprecated. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. For help finding the position value, read the note above.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="position")]
		public System.Nullable<System.Int32> Position { get; set; }
		
		/// <summary>
		/// In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/enterprise-server@3.6/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="side")]
		public Pull_request_review_commentSide Side { get; set; }
		
		/// <summary>
		/// **Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/enterprise-server@3.6/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public System.Nullable<System.Int32> Start_line { get; set; }
		
		/// <summary>
		/// **Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/enterprise-server@3.6/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_side")]
		public System.Nullable<PullsSlashcreate_review_commentPostBodyStart_side> Start_side { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PullsSlashcreate_review_commentPostBodyStart_side
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LEFT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RIGHT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		side = 2,
	}
	
	public class PullsSlashcreate_reply_for_review_commentPostBody
	{
		
		/// <summary>
		/// The text of the review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class PullsSlashmergePutBody
	{
		
		/// <summary>
		/// Extra detail to append to automatic commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commit_message")]
		public string Commit_message { get; set; }
		
		/// <summary>
		/// Title for the automatic commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commit_title")]
		public string Commit_title { get; set; }
		
		/// <summary>
		/// The merge method to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_method")]
		public Auto_mergeMerge_method Merge_method { get; set; }
		
		/// <summary>
		/// SHA that pull request head must match to allow merge.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sha")]
		public string Sha { get; set; }
	}
	
	public class PullsSlashrequest_reviewersPostBody
	{
		
		/// <summary>
		/// An array of user `login`s that will be requested.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reviewers")]
		public string[] Reviewers { get; set; }
		
		/// <summary>
		/// An array of team `slug`s that will be requested.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="team_reviewers")]
		public string[] Team_reviewers { get; set; }
	}
	
	public class PullsSlashcreate_reviewPostBody
	{
		
		/// <summary>
		/// **Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Use the following table to specify the location, destination, and contents of the draft review comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public PullsSlashcreate_reviewPostBodyComments[] PullsSlashcreate_reviewPostBodyComments { get; set; }
		
		/// <summary>
		/// The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commit_id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/enterprise-server@3.6/rest/pulls#submit-a-review-for-a-pull-request) when you are ready.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="event")]
		public System.Nullable<PullsSlashcreate_reviewPostBodyEvent> Event { get; set; }
	}
	
	public class PullsSlashcreate_reviewPostBodyComments
	{
		
		/// <summary>
		/// Text of the review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="line")]
		public System.Nullable<System.Int32> Line { get; set; }
		
		/// <summary>
		/// The relative path to the file that necessitates a review comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. For help finding the position value, read the note below.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="position")]
		public System.Nullable<System.Int32> Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="side")]
		public string Side { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start_line")]
		public System.Nullable<System.Int32> Start_line { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start_side")]
		public string Start_side { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PullsSlashcreate_reviewPostBodyEvent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPROVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUEST_CHANGES = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMENT = 2,
	}
	
	public class PullsSlashupdate_reviewPutBody
	{
		
		/// <summary>
		/// The body text of the pull request review.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class PullsSlashdismiss_reviewPutBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="event")]
		public System.Nullable<PullsSlashdismiss_reviewPutBodyEvent> Event { get; set; }
		
		/// <summary>
		/// The message for the pull request review dismissal
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PullsSlashdismiss_reviewPutBodyEvent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISMISS = 0,
	}
	
	public class PullsSlashsubmit_reviewPostBody
	{
		
		/// <summary>
		/// The body text of the pull request review
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public PullsSlashcreate_reviewPostBodyEvent Event { get; set; }
	}
	
	public class PullsSlashupdate_branchPutBody
	{
		
		/// <summary>
		/// The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the "[List commits](https://docs.github.com/enterprise-server@3.6/rest/reference/repos#list-commits)" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expected_head_sha")]
		public string Expected_head_sha { get; set; }
	}
	
	public class ReposSlashcreate_releasePostBody
	{
		
		/// <summary>
		/// Text describing the contents of the tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// `true` to create a draft (unpublished) release, `false` to create a published one.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public System.Nullable<System.Boolean> Draft { get; set; }
		
		/// <summary>
		/// Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="generate_release_notes")]
		public System.Nullable<System.Boolean> Generate_release_notes { get; set; }
		
		/// <summary>
		/// The name of the release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// `true` to identify the release as a prerelease. `false` to identify the release as a full release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prerelease")]
		public System.Nullable<System.Boolean> Prerelease { get; set; }
		
		/// <summary>
		/// The name of the tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag_name")]
		public string Tag_name { get; set; }
		
		/// <summary>
		/// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch (usually `master`).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_commitish")]
		public string Target_commitish { get; set; }
	}
	
	public class ReposSlashupdate_release_assetPatchBody
	{
		
		/// <summary>
		/// An alternate short description of the asset. Used in place of the filename.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The file name of the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
	}
	
	public class ReposSlashgenerate_release_notesPostBody
	{
		
		/// <summary>
		/// Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuration_file_path")]
		public string Configuration_file_path { get; set; }
		
		/// <summary>
		/// The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previous_tag_name")]
		public string Previous_tag_name { get; set; }
		
		/// <summary>
		/// The tag name for the release. This can be an existing tag or a new one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag_name")]
		public string Tag_name { get; set; }
		
		/// <summary>
		/// Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_commitish")]
		public string Target_commitish { get; set; }
	}
	
	public class ReposSlashupdate_releasePatchBody
	{
		
		/// <summary>
		/// Text describing the contents of the tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// `true` makes the release a draft, and `false` publishes the release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="draft")]
		public System.Nullable<System.Boolean> Draft { get; set; }
		
		/// <summary>
		/// The name of the release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// `true` to identify the release as a prerelease, `false` to identify the release as a full release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prerelease")]
		public System.Nullable<System.Boolean> Prerelease { get; set; }
		
		/// <summary>
		/// The name of the tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag_name")]
		public string Tag_name { get; set; }
		
		/// <summary>
		/// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch (usually `master`).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_commitish")]
		public string Target_commitish { get; set; }
	}
	
	public enum ReactionsSlashlist_for_releaseContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 5,
	}
	
	public class ReactionsSlashcreate_for_releasePostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the release.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_releasePostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_releasePostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 5,
	}
	
	public class ReposSlashlist_cache_infoReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="git")]
		public ReposSlashlist_cache_infoReturnGit Git { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
	}
	
	public class ReposSlashlist_cache_infoReturnGit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_sync")]
		public System.DateTimeOffset Last_sync { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sync_status")]
		public ReposSlashlist_cache_infoReturnGitSync_status Sync_status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReposSlashlist_cache_infoReturnGitSync_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		offline = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inactive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		in_sync = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_in_sync = 3,
	}
	
	public class Secret_scanningSlashupdate_alertPatchBody
	{
		
		/// <summary>
		/// **Required when the `state` is `resolved`.** The reason for resolving the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public System.Nullable<Secret_scanningSlashupdate_alertPatchBodyResolution> Resolution { get; set; }
		
		/// <summary>
		/// Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public Organization_secret_scanning_alertState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Secret_scanningSlashupdate_alertPatchBodyResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		false_positive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wont_fix = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		revoked = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		used_in_tests = 4,
	}
	
	public class ReposSlashcreate_commit_statusPostBody
	{
		
		/// <summary>
		/// A string label to differentiate this status from the status of other systems. This field is case-insensitive.
		/// </summary>
		[System.ComponentModel.DefaultValue("default")]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; } = "default";
		
		/// <summary>
		/// A short description of the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The state of the status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ReposSlashcreate_commit_statusPostBodyState State { get; set; }
		
		/// <summary>
		/// The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  
		///For example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  
		///`http://ci.example.com/user/repo/build/sha`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_url")]
		public string Target_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReposSlashcreate_commit_statusPostBodyState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		error = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 3,
	}
	
	public class ActivitySlashset_repo_subscriptionPutBody
	{
		
		/// <summary>
		/// Determines if all notifications should be blocked from this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ignored")]
		public System.Nullable<System.Boolean> Ignored { get; set; }
		
		/// <summary>
		/// Determines if notifications should be received from this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscribed")]
		public System.Nullable<System.Boolean> Subscribed { get; set; }
	}
	
	public class ReposSlashcreate_tag_protectionPostBody
	{
		
		/// <summary>
		/// An optional glob pattern to match against when enforcing tag protection.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pattern")]
		public string Pattern { get; set; }
	}
	
	public class ReposSlashreplace_all_topicsPutBody
	{
		
		/// <summary>
		/// An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` cannot contain uppercase letters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="names")]
		public string[] Names { get; set; }
	}
	
	public class ReposSlashtransferPostBody
	{
		
		/// <summary>
		/// The username or organization name the repository will be transferred to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="new_owner")]
		public string New_owner { get; set; }
		
		/// <summary>
		/// ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="team_ids")]
		public int[] Team_ids { get; set; }
	}
	
	public class ReposSlashcreate_using_templatePostBody
	{
		
		/// <summary>
		/// A short description of the new repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_all_branches")]
		public System.Nullable<System.Boolean> Include_all_branches { get; set; }
		
		/// <summary>
		/// The name of the new repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public string Owner { get; set; }
		
		/// <summary>
		/// Either `true` to create a new private repository or `false` to create a new public one.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
	}
	
	public enum ReposSlashlist_publicVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 1,
	}
	
	public class ActionsSlashlist_environment_secretsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public Actions_secret[] Secrets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class ActionsSlashcreate_or_update_environment_secretPutBody
	{
		
		/// <summary>
		/// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/enterprise-server@3.6/rest/reference/actions#get-an-environment-public-key) endpoint.
		/// Required
		/// Pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encrypted_value")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$")]
		public string Encrypted_value { get; set; }
		
		/// <summary>
		/// ID of the key you used to encrypt the secret.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key_id")]
		public string Key_id { get; set; }
	}
	
	public enum SearchSlashcodeSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		indexed = 0,
	}
	
	public class SearchSlashcodeReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="incomplete_results")]
		public bool Incomplete_results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Code_search_result_item[] Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum SearchSlashcommitsSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="author-date")]
		authorMinusdate = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="committer-date")]
		committerMinusdate = 1,
	}
	
	public class SearchSlashcommitsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="incomplete_results")]
		public bool Incomplete_results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Commit_search_result_item[] Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum SearchSlashissues_and_pull_requestsSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		comments = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reactions = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="reactions-+1")]
		reactionsMinusPlus1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="reactions--1")]
		reactionsMinusMinus1 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="reactions-smile")]
		reactionsMinussmile = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="reactions-thinking_face")]
		reactionsMinusthinking_face = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="reactions-heart")]
		reactionsMinusheart = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="reactions-tada")]
		reactionsMinustada = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		interactions = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		created = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 10,
	}
	
	public class SearchSlashissues_and_pull_requestsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="incomplete_results")]
		public bool Incomplete_results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Issue_search_result_item[] Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class SearchSlashlabelsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="incomplete_results")]
		public bool Incomplete_results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Label_search_result_item[] Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum SearchSlashreposSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stars = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		forks = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="help-wanted-issues")]
		helpMinuswantedMinusissues = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 3,
	}
	
	public class SearchSlashreposReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="incomplete_results")]
		public bool Incomplete_results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Repo_search_result_item[] Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class SearchSlashtopicsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="incomplete_results")]
		public bool Incomplete_results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Topic_search_result_item[] Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public enum SearchSlashusersSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		followers = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		repositories = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		joined = 2,
	}
	
	public class SearchSlashusersReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="incomplete_results")]
		public bool Incomplete_results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public User_search_result_item[] Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class TeamsSlashupdate_legacyPatchBody
	{
		
		/// <summary>
		/// The description of the team.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the team.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of a team to set as the parent team.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent_team_id")]
		public System.Nullable<System.Int32> Parent_team_id { get; set; }
		
		/// <summary>
		/// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
		/// </summary>
		[System.ComponentModel.DefaultValue(TeamsSlashupdate_in_orgPatchBodyPermission.pull)]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public TeamsSlashupdate_in_orgPatchBodyPermission Permission { get; set; } = TeamsSlashupdate_in_orgPatchBodyPermission.pull;
		
		/// <summary>
		/// The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  
		///**For a non-nested team:**  
		/// * `secret` - only visible to organization owners and members of this team.  
		/// * `closed` - visible to all members of this organization.  
		///**For a parent or child team:**  
		/// * `closed` - visible to all members of this organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public TeamsSlashcreatePostBodyPrivacy Privacy { get; set; }
	}
	
	public class TeamsSlashcreate_discussion_legacyPostBody
	{
		
		/// <summary>
		/// The discussion post's body text.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		/// <summary>
		/// The discussion post's title.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class TeamsSlashupdate_discussion_legacyPatchBody
	{
		
		/// <summary>
		/// The discussion post's body text.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The discussion post's title.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class TeamsSlashcreate_discussion_comment_legacyPostBody
	{
		
		/// <summary>
		/// The discussion comment's body text.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public class TeamsSlashupdate_discussion_comment_legacyPatchBody
	{
		
		/// <summary>
		/// The discussion comment's body text.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	public enum ReactionsSlashlist_for_team_discussion_comment_legacyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReactionsSlashcreate_for_team_discussion_comment_legacyPostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the team discussion comment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_team_discussion_comment_legacyPostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_team_discussion_comment_legacyPostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public enum ReactionsSlashlist_for_team_discussion_legacyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class ReactionsSlashcreate_for_team_discussion_legacyPostBody
	{
		
		/// <summary>
		/// The [reaction type](https://docs.github.com/enterprise-server@3.6/rest/reference/reactions#reaction-types) to add to the team discussion.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ReactionsSlashcreate_for_team_discussion_legacyPostBodyContent Content { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReactionsSlashcreate_for_team_discussion_legacyPostBodyContent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="+1")]
		_Plus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="-1")]
		_Minus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		laugh = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		confused = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		heart = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hooray = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rocket = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eyes = 7,
	}
	
	public class TeamsSlashadd_or_update_membership_for_user_legacyPutBody
	{
		
		/// <summary>
		/// The role that this user should have in the team.
		/// </summary>
		[System.ComponentModel.DefaultValue(Team_membershipRole.member)]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public Team_membershipRole Role { get; set; } = Team_membershipRole.member;
	}
	
	public class TeamsSlashadd_or_update_project_permissions_legacyPutBody
	{
		
		/// <summary>
		/// The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.6/rest/overview/resources-in-the-rest-api#http-verbs)."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public App_permissionsOrganization_projects Permission { get; set; }
	}
	
	public class TeamsSlashadd_or_update_repo_permissions_legacyPutBody
	{
		
		/// <summary>
		/// The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public TeamsSlashupdate_in_orgPatchBodyPermission Permission { get; set; }
	}
	
	public class UsersSlashupdate_authenticatedPatchBody
	{
		
		/// <summary>
		/// The new short biography of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bio")]
		public string Bio { get; set; }
		
		/// <summary>
		/// The new blog URL of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blog")]
		public string Blog { get; set; }
		
		/// <summary>
		/// The new company of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="company")]
		public string Company { get; set; }
		
		/// <summary>
		/// The publicly visible email address of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The new hiring availability of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hireable")]
		public System.Nullable<System.Boolean> Hireable { get; set; }
		
		/// <summary>
		/// The new location of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// The new name of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The new Twitter username of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
	}
	
	public class UsersSlashadd_email_for_authenticated_userPostBody
	{
		
		/// <summary>
		/// Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
	}
	
	public class UsersSlashcreate_gpg_key_for_authenticated_userPostBody
	{
		
		/// <summary>
		/// A GPG key in ASCII-armored format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="armored_public_key")]
		public string Armored_public_key { get; set; }
		
		/// <summary>
		/// A descriptive name for the new key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class AppsSlashlist_installations_for_authenticated_userReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="installations")]
		public Installation[] Installations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class AppsSlashlist_installation_repos_for_authenticated_userReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Repository[] Repositories { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repository_selection")]
		public string Repository_selection { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_count")]
		public int Total_count { get; set; }
	}
	
	public class UsersSlashcreate_public_ssh_key_for_authenticated_userPostBody
	{
		
		/// <summary>
		/// The public SSH key to add to your GitHub account.
		/// Required
		/// Pattern: ^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) 
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) ")]
		public string Key { get; set; }
		
		/// <summary>
		/// A descriptive name for the new key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class OrgsSlashupdate_membership_for_authenticated_userPatchBody
	{
		
		/// <summary>
		/// The state that the membership should be in. Only `"active"` will be accepted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public OrgsSlashupdate_membership_for_authenticated_userPatchBodyState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum OrgsSlashupdate_membership_for_authenticated_userPatchBodyState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
	}
	
	public class MigrationsSlashstart_for_authenticated_userPostBody
	{
		
		/// <summary>
		/// Exclude attributes from the API response to improve performance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude")]
		public string[] Exclude { get; set; }
		
		/// <summary>
		/// Do not include attachments in the migration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_attachments")]
		public System.Nullable<System.Boolean> Exclude_attachments { get; set; }
		
		/// <summary>
		/// Indicates whether the repository git data should be excluded from the migration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_git_data")]
		public System.Nullable<System.Boolean> Exclude_git_data { get; set; }
		
		/// <summary>
		/// Indicates whether metadata should be excluded and only git source should be included for the migration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_metadata")]
		public System.Nullable<System.Boolean> Exclude_metadata { get; set; }
		
		/// <summary>
		/// Indicates whether projects owned by the organization or users should be excluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_owner_projects")]
		public System.Nullable<System.Boolean> Exclude_owner_projects { get; set; }
		
		/// <summary>
		/// Do not include releases in the migration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude_releases")]
		public System.Nullable<System.Boolean> Exclude_releases { get; set; }
		
		/// <summary>
		/// Lock the repositories being migrated at the start of the migration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lock_repositories")]
		public System.Nullable<System.Boolean> Lock_repositories { get; set; }
		
		/// <summary>
		/// Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="org_metadata_only")]
		public System.Nullable<System.Boolean> Org_metadata_only { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public string[] Repositories { get; set; }
	}
	
	public class ProjectsSlashcreate_for_authenticated_userPostBody
	{
		
		/// <summary>
		/// Body of the project
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Name of the project
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public enum ReposSlashlist_for_authenticated_userVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 2,
	}
	
	public enum ReposSlashlist_for_authenticated_userType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		owner = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		member = 4,
	}
	
	public class ReposSlashcreate_for_authenticated_userPostBody
	{
		
		/// <summary>
		/// Whether to allow Auto-merge to be used on pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_auto_merge")]
		public System.Nullable<System.Boolean> Allow_auto_merge { get; set; }
		
		/// <summary>
		/// Whether to allow merge commits for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_merge_commit")]
		public System.Nullable<System.Boolean> Allow_merge_commit { get; set; }
		
		/// <summary>
		/// Whether to allow rebase merges for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_rebase_merge")]
		public System.Nullable<System.Boolean> Allow_rebase_merge { get; set; }
		
		/// <summary>
		/// Whether to allow squash merges for pull requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_squash_merge")]
		public System.Nullable<System.Boolean> Allow_squash_merge { get; set; }
		
		/// <summary>
		/// Whether the repository is initialized with a minimal README.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auto_init")]
		public System.Nullable<System.Boolean> Auto_init { get; set; }
		
		/// <summary>
		/// Whether to delete head branches when pull requests are merged
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete_branch_on_merge")]
		public System.Nullable<System.Boolean> Delete_branch_on_merge { get; set; }
		
		/// <summary>
		/// A short description of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The desired language or platform to apply to the .gitignore.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gitignore_template")]
		public string Gitignore_template { get; set; }
		
		/// <summary>
		/// Whether discussions are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_discussions")]
		public System.Nullable<System.Boolean> Has_discussions { get; set; }
		
		/// <summary>
		/// Whether downloads are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_downloads")]
		public System.Nullable<System.Boolean> Has_downloads { get; set; }
		
		/// <summary>
		/// Whether issues are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_issues")]
		public System.Nullable<System.Boolean> Has_issues { get; set; }
		
		/// <summary>
		/// Whether projects are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_projects")]
		public System.Nullable<System.Boolean> Has_projects { get; set; }
		
		/// <summary>
		/// Whether the wiki is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_wiki")]
		public System.Nullable<System.Boolean> Has_wiki { get; set; }
		
		/// <summary>
		/// A URL with more information about the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="homepage")]
		public string Homepage { get; set; }
		
		/// <summary>
		/// Whether this repository acts as a template that can be used to generate new repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_template")]
		public System.Nullable<System.Boolean> Is_template { get; set; }
		
		/// <summary>
		/// The license keyword of the open source license for this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="license_template")]
		public string License_template { get; set; }
		
		/// <summary>
		/// The default value for a merge commit message.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `PR_BODY` - default to the pull request's body.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_message")]
		public RepositoryMerge_commit_message Merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a merge commit title.
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merge_commit_title")]
		public RepositoryMerge_commit_title Merge_commit_title { get; set; }
		
		/// <summary>
		/// The name of the repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Whether the repository is private.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private")]
		public System.Nullable<System.Boolean> Private { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit message:
		///
		///- `PR_BODY` - default to the pull request's body.
		///- `COMMIT_MESSAGES` - default to the branch's commit messages.
		///- `BLANK` - default to a blank commit message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_message")]
		public RepositorySquash_merge_commit_message Squash_merge_commit_message { get; set; }
		
		/// <summary>
		/// The default value for a squash merge commit title:
		///
		///- `PR_TITLE` - default to the pull request's title.
		///- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="squash_merge_commit_title")]
		public RepositorySquash_merge_commit_title Squash_merge_commit_title { get; set; }
		
		/// <summary>
		/// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="team_id")]
		public System.Nullable<System.Int32> Team_id { get; set; }
	}
	
	public enum UsersSlashget_context_for_userSubject_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		organization = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		repository = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		issue = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pull_request = 3,
	}
	
	public enum ReposSlashlist_for_userType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		owner = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		member = 2,
	}
	
	public class Enterprise_adminSlashsuspend_userPutBody
	{
		
		/// <summary>
		/// The reason the user is being suspended. This message will be logged in the [audit log](https://docs.github.com/enterprise-server@3.6/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/about-the-audit-log-for-your-enterprise). If you don't provide a `reason`, it will default to "Suspended via API by _SITE\_ADMINISTRATOR_", where _SITE\_ADMINISTRATOR_ is the person who performed the action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
