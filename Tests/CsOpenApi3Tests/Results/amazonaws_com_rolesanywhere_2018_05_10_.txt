//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProfileDetailResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public ProfileDetail Profile { get; set; }
	}
	
	/// <summary>
	/// The state of the profile after a read or write operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProfileDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="durationSeconds")]
		public System.Nullable<System.Int32> DurationSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="managedPolicyArns")]
		public string[] ManagedPolicyArns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profileArn")]
		public string ProfileArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profileId")]
		public string ProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requireInstanceProperties")]
		public System.Nullable<System.Boolean> RequireInstanceProperties { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="roleArns")]
		public string[] RoleArns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sessionPolicy")]
		public string SessionPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	/// <summary>
	/// A label that consists of a key and value you define. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessDeniedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrustAnchorDetailResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchor")]
		public TrustAnchorDetail TrustAnchor { get; set; }
	}
	
	/// <summary>
	/// The state of the trust anchor after a read or write operation. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrustAnchorDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notificationSettings")]
		public NotificationSettingDetail[] NotificationSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Source Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trustAnchorArn")]
		public string TrustAnchorArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trustAnchorId")]
		public string TrustAnchorId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	/// <summary>
	/// <p>The state of a notification setting.</p> <p>A notification setting includes information such as event name, threshold, status of the notification setting, and the channel to notify.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationSettingDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public NotificationChannel Channel { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="configuredBy")]
		public string ConfiguredBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public NotificationEvent Event { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public System.Nullable<System.Int32> Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NotificationChannel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NotificationEvent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CA_CERTIFICATE_EXPIRY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		END_ENTITY_CERTIFICATE_EXPIRY = 1,
	}
	
	/// <summary>
	/// The trust anchor type and its related certificate data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Source
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceData")]
		public SourceData SourceData { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceType")]
		public TrustAnchorType SourceType { get; set; }
	}
	
	/// <summary>
	/// The data field of the trust anchor depending on its type. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceData
	{
		
		[System.Runtime.Serialization.DataMember(Name="acmPcaArn")]
		public string AcmPcaArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="x509CertificateData")]
		public string X509CertificateData { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TrustAnchorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_ACM_PCA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERTIFICATE_BUNDLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SELF_SIGNED_REPOSITORY = 2,
	}
	
	/// <summary>
	///  Customizable notification settings that will be applied to notification events. IAM Roles Anywhere consumes these settings while notifying across multiple channels - CloudWatch metrics, EventBridge, and Health Dashboard. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationSetting
	{
		
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public NotificationChannel Channel { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public NotificationEvent Event { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public System.Nullable<System.Int32> Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CrlDetailResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crl")]
		public CrlDetail Crl { get; set; }
	}
	
	/// <summary>
	/// The state of the certificate revocation list (CRL) after a read or write operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CrlDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="crlArn")]
		public string CrlArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="crlData")]
		public string CrlData { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="crlId")]
		public string CrlId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trustAnchorArn")]
		public string TrustAnchorArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubjectDetailResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public SubjectDetail Subject { get; set; }
	}
	
	/// <summary>
	/// The state of the subject after a read or write operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubjectDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="credentials")]
		public CredentialSummary[] Credentials { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="instanceProperties")]
		public InstanceProperty[] InstanceProperties { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastSeenAt")]
		public System.DateTimeOffset LastSeenAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subjectArn")]
		public string SubjectArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subjectId")]
		public string SubjectId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="x509Subject")]
		public string X509Subject { get; set; }
	}
	
	/// <summary>
	/// A record of a presented X509 credential from a temporary credential request. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CredentialSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="failed")]
		public System.Nullable<System.Boolean> Failed { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seenAt")]
		public System.DateTimeOffset SeenAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serialNumber")]
		public string SerialNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="x509CertificateData")]
		public string X509CertificateData { get; set; }
	}
	
	/// <summary>
	/// A key-value pair you set that identifies a property of the authenticating instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceProperty
	{
		
		[System.Runtime.Serialization.DataMember(Name="failed")]
		public System.Nullable<System.Boolean> Failed { get; set; }
		
		/// <summary>
		/// A list of instanceProperty objects. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public object Properties { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seenAt")]
		public System.DateTimeOffset SeenAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCrlsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="crls")]
		public CrlDetail[] Crls { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListProfilesResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profiles")]
		public ProfileDetail[] Profiles { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListSubjectsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subjects")]
		public SubjectSummary[] Subjects { get; set; }
	}
	
	/// <summary>
	/// A summary representation of subjects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubjectSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastSeenAt")]
		public System.DateTimeOffset LastSeenAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subjectArn")]
		public string SubjectArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subjectId")]
		public string SubjectId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="x509Subject")]
		public string X509Subject { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrustAnchorsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trustAnchors")]
		public TrustAnchorDetail[] TrustAnchors { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutNotificationSettingsResponse
	{
		
		/// <summary>
		/// The state of the trust anchor after a read or write operation. 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchor")]
		public TrustAnchorDetail TrustAnchor { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResetNotificationSettingsResponse
	{
		
		/// <summary>
		/// The state of the trust anchor after a read or write operation. 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchor")]
		public TrustAnchorDetail TrustAnchor { get; set; }
	}
	
	/// <summary>
	/// A notification setting key to reset. A notification setting key includes the event and the channel. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationSettingKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public NotificationChannel Channel { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public NotificationEvent Event { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyTagsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateProfileRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="durationSeconds")]
		public System.Nullable<System.Int32> DurationSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="managedPolicyArns")]
		public string[] ManagedPolicyArns { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requireInstanceProperties")]
		public System.Nullable<System.Boolean> RequireInstanceProperties { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roleArns")]
		public string[] RoleArns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sessionPolicy")]
		public string SessionPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTrustAnchorRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notificationSettings")]
		public NotificationSetting[] NotificationSettings { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Source Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportCrlRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crlData")]
		public string CrlData { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchorArn")]
		public string TrustAnchorArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancePropertyMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutNotificationSettingsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationSettings")]
		public NotificationSetting[] NotificationSettings { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchorId")]
		public string TrustAnchorId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResetNotificationSettingsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationSettingKeys")]
		public NotificationSettingKey[] NotificationSettingKeys { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchorId")]
		public string TrustAnchorId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScalarCrlRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScalarProfileRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScalarSubjectRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScalarTrustAnchorRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagKeys")]
		public string[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateCrlRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="crlData")]
		public string CrlData { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateProfileRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="durationSeconds")]
		public System.Nullable<System.Int32> DurationSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="managedPolicyArns")]
		public string[] ManagedPolicyArns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="roleArns")]
		public string[] RoleArns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sessionPolicy")]
		public string SessionPolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTrustAnchorRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Source Source { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// <p>Creates a <i>profile</i>, a list of the roles that Roles Anywhere service is trusted to assume. You use profiles to intersect permissions with IAM managed policies.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:CreateProfile</code>. </p>
		/// CreateProfile profiles
		/// </summary>
		public async Task CreateProfileAsync(CreateProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all profiles in the authenticated account and Amazon Web Services Region.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:ListProfiles</code>. </p>
		/// ListProfiles profiles
		/// </summary>
		/// <param name="nextToken">A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.</param>
		/// <param name="pageSize">The number of resources in the paginated list. </param>
		/// <returns>Success</returns>
		public async Task<ListProfilesResponse> ListProfilesAsync(string nextToken, int pageSize, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profiles?nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&pageSize="+pageSize;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListProfilesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a trust anchor to establish trust between IAM Roles Anywhere and your certificate authority (CA). You can define a trust anchor as a reference to an Private Certificate Authority (Private CA) or by uploading a CA certificate. Your Amazon Web Services workloads can authenticate with the trust anchor using certificates issued by the CA in exchange for temporary Amazon Web Services credentials.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:CreateTrustAnchor</code>. </p>
		/// CreateTrustAnchor trustanchors
		/// </summary>
		public async Task CreateTrustAnchorAsync(CreateTrustAnchorPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "trustanchors";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the trust anchors in the authenticated account and Amazon Web Services Region.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:ListTrustAnchors</code>. </p>
		/// ListTrustAnchors trustanchors
		/// </summary>
		/// <param name="nextToken">A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.</param>
		/// <param name="pageSize">The number of resources in the paginated list. </param>
		/// <returns>Success</returns>
		public async Task<ListTrustAnchorsResponse> ListTrustAnchorsAsync(string nextToken, int pageSize, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "trustanchors?nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&pageSize="+pageSize;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTrustAnchorsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a certificate revocation list (CRL).</p> <p> <b>Required permissions: </b> <code>rolesanywhere:DeleteCrl</code>. </p>
		/// DeleteCrl crl/{crlId}
		/// </summary>
		/// <param name="crlId">The unique identifier of the certificate revocation list (CRL).</param>
		/// <returns>Success</returns>
		public async Task<CrlDetailResponse> DeleteCrlAsync(string crlId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "crl/"+ (crlId==null? "" : System.Uri.EscapeDataString(crlId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CrlDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets a certificate revocation list (CRL).</p> <p> <b>Required permissions: </b> <code>rolesanywhere:GetCrl</code>. </p>
		/// GetCrl crl/{crlId}
		/// </summary>
		/// <param name="crlId">The unique identifier of the certificate revocation list (CRL).</param>
		/// <returns>Success</returns>
		public async Task<CrlDetailResponse> GetCrlAsync(string crlId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "crl/"+ (crlId==null? "" : System.Uri.EscapeDataString(crlId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CrlDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Updates the certificate revocation list (CRL). A CRL is a list of certificates that have been revoked by the issuing certificate authority (CA). IAM Roles Anywhere validates against the CRL before issuing credentials.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:UpdateCrl</code>. </p>
		/// UpdateCrl crl/{crlId}
		/// </summary>
		/// <param name="crlId">The unique identifier of the certificate revocation list (CRL).</param>
		/// <returns>Success</returns>
		public async Task<CrlDetailResponse> UpdateCrlAsync(string crlId, UpdateCrlPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "crl/"+ (crlId==null? "" : System.Uri.EscapeDataString(crlId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CrlDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a profile.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:DeleteProfile</code>. </p>
		/// DeleteProfile profile/{profileId}
		/// </summary>
		/// <param name="profileId">The unique identifier of the profile.</param>
		/// <returns>Success</returns>
		public async Task<ProfileDetailResponse> DeleteProfileAsync(string profileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProfileDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets a profile.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:GetProfile</code>. </p>
		/// GetProfile profile/{profileId}
		/// </summary>
		/// <param name="profileId">The unique identifier of the profile.</param>
		/// <returns>Success</returns>
		public async Task<ProfileDetailResponse> GetProfileAsync(string profileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProfileDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Updates a <i>profile</i>, a list of the roles that IAM Roles Anywhere service is trusted to assume. You use profiles to intersect permissions with IAM managed policies.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:UpdateProfile</code>. </p>
		/// UpdateProfile profile/{profileId}
		/// </summary>
		/// <param name="profileId">The unique identifier of the profile.</param>
		/// <returns>Success</returns>
		public async Task<ProfileDetailResponse> UpdateProfileAsync(string profileId, UpdateProfilePatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProfileDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a trust anchor.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:DeleteTrustAnchor</code>. </p>
		/// DeleteTrustAnchor trustanchor/{trustAnchorId}
		/// </summary>
		/// <param name="trustAnchorId">The unique identifier of the trust anchor.</param>
		/// <returns>Success</returns>
		public async Task<TrustAnchorDetailResponse> DeleteTrustAnchorAsync(string trustAnchorId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "trustanchor/"+ (trustAnchorId==null? "" : System.Uri.EscapeDataString(trustAnchorId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrustAnchorDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets a trust anchor.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:GetTrustAnchor</code>. </p>
		/// GetTrustAnchor trustanchor/{trustAnchorId}
		/// </summary>
		/// <param name="trustAnchorId">The unique identifier of the trust anchor.</param>
		/// <returns>Success</returns>
		public async Task<TrustAnchorDetailResponse> GetTrustAnchorAsync(string trustAnchorId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "trustanchor/"+ (trustAnchorId==null? "" : System.Uri.EscapeDataString(trustAnchorId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrustAnchorDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Updates a trust anchor. You establish trust between IAM Roles Anywhere and your certificate authority (CA) by configuring a trust anchor. You can define a trust anchor as a reference to an Private Certificate Authority (Private CA) or by uploading a CA certificate. Your Amazon Web Services workloads can authenticate with the trust anchor using certificates issued by the CA in exchange for temporary Amazon Web Services credentials.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:UpdateTrustAnchor</code>. </p>
		/// UpdateTrustAnchor trustanchor/{trustAnchorId}
		/// </summary>
		/// <param name="trustAnchorId">The unique identifier of the trust anchor.</param>
		/// <returns>Success</returns>
		public async Task<TrustAnchorDetailResponse> UpdateTrustAnchorAsync(string trustAnchorId, UpdateTrustAnchorPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "trustanchor/"+ (trustAnchorId==null? "" : System.Uri.EscapeDataString(trustAnchorId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrustAnchorDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Disables a certificate revocation list (CRL).</p> <p> <b>Required permissions: </b> <code>rolesanywhere:DisableCrl</code>. </p>
		/// DisableCrl crl/{crlId}/disable
		/// </summary>
		/// <param name="crlId">The unique identifier of the certificate revocation list (CRL).</param>
		/// <returns>Success</returns>
		public async Task<CrlDetailResponse> DisableCrlAsync(string crlId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "crl/"+ (crlId==null? "" : System.Uri.EscapeDataString(crlId))+"/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CrlDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Disables a profile. When disabled, temporary credential requests with this profile fail.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:DisableProfile</code>. </p>
		/// DisableProfile profile/{profileId}/disable
		/// </summary>
		/// <param name="profileId">The unique identifier of the profile.</param>
		/// <returns>Success</returns>
		public async Task<ProfileDetailResponse> DisableProfileAsync(string profileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId))+"/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProfileDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Disables a trust anchor. When disabled, temporary credential requests specifying this trust anchor are unauthorized.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:DisableTrustAnchor</code>. </p>
		/// DisableTrustAnchor trustanchor/{trustAnchorId}/disable
		/// </summary>
		/// <param name="trustAnchorId">The unique identifier of the trust anchor.</param>
		/// <returns>Success</returns>
		public async Task<TrustAnchorDetailResponse> DisableTrustAnchorAsync(string trustAnchorId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "trustanchor/"+ (trustAnchorId==null? "" : System.Uri.EscapeDataString(trustAnchorId))+"/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrustAnchorDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Enables a certificate revocation list (CRL). When enabled, certificates stored in the CRL are unauthorized to receive session credentials.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:EnableCrl</code>. </p>
		/// EnableCrl crl/{crlId}/enable
		/// </summary>
		/// <param name="crlId">The unique identifier of the certificate revocation list (CRL).</param>
		/// <returns>Success</returns>
		public async Task<CrlDetailResponse> EnableCrlAsync(string crlId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "crl/"+ (crlId==null? "" : System.Uri.EscapeDataString(crlId))+"/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CrlDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Enables temporary credential requests for a profile. </p> <p> <b>Required permissions: </b> <code>rolesanywhere:EnableProfile</code>. </p>
		/// EnableProfile profile/{profileId}/enable
		/// </summary>
		/// <param name="profileId">The unique identifier of the profile.</param>
		/// <returns>Success</returns>
		public async Task<ProfileDetailResponse> EnableProfileAsync(string profileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId))+"/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProfileDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Enables a trust anchor. When enabled, certificates in the trust anchor chain are authorized for trust validation. </p> <p> <b>Required permissions: </b> <code>rolesanywhere:EnableTrustAnchor</code>. </p>
		/// EnableTrustAnchor trustanchor/{trustAnchorId}/enable
		/// </summary>
		/// <param name="trustAnchorId">The unique identifier of the trust anchor.</param>
		/// <returns>Success</returns>
		public async Task<TrustAnchorDetailResponse> EnableTrustAnchorAsync(string trustAnchorId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "trustanchor/"+ (trustAnchorId==null? "" : System.Uri.EscapeDataString(trustAnchorId))+"/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrustAnchorDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets a <i>subject</i>, which associates a certificate identity with authentication attempts. The subject stores auditing information such as the status of the last authentication attempt, the certificate data used in the attempt, and the last time the associated identity attempted authentication. </p> <p> <b>Required permissions: </b> <code>rolesanywhere:GetSubject</code>. </p>
		/// GetSubject subject/{subjectId}
		/// </summary>
		/// <param name="subjectId">The unique identifier of the subject. </param>
		/// <returns>Success</returns>
		public async Task<SubjectDetailResponse> GetSubjectAsync(string subjectId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subject/"+ (subjectId==null? "" : System.Uri.EscapeDataString(subjectId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SubjectDetailResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Imports the certificate revocation list (CRL). A CRL is a list of certificates that have been revoked by the issuing certificate Authority (CA). IAM Roles Anywhere validates against the CRL before issuing credentials. </p> <p> <b>Required permissions: </b> <code>rolesanywhere:ImportCrl</code>. </p>
		/// ImportCrl crls
		/// </summary>
		public async Task ImportCrlAsync(ImportCrlPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "crls";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all certificate revocation lists (CRL) in the authenticated account and Amazon Web Services Region.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:ListCrls</code>. </p>
		/// ListCrls crls
		/// </summary>
		/// <param name="nextToken">A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.</param>
		/// <param name="pageSize">The number of resources in the paginated list. </param>
		/// <returns>Success</returns>
		public async Task<ListCrlsResponse> ListCrlsAsync(string nextToken, int pageSize, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "crls?nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&pageSize="+pageSize;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListCrlsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the subjects in the authenticated account and Amazon Web Services Region.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:ListSubjects</code>. </p>
		/// ListSubjects subjects
		/// </summary>
		/// <param name="nextToken">A token that indicates where the output should continue from, if a previous request did not show all results. To get the next results, make the request again with this value.</param>
		/// <param name="pageSize">The number of resources in the paginated list. </param>
		/// <returns>Success</returns>
		public async Task<ListSubjectsResponse> ListSubjectsAsync(string nextToken, int pageSize, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subjects?nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&pageSize="+pageSize;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSubjectsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the tags attached to the resource.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:ListTagsForResource</code>. </p>
		/// ListTagsForResource ListTagsForResource#resourceArn
		/// </summary>
		/// <param name="resourceArn">The ARN of the resource.</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ListTagsForResource#resourceArn?resourceArn=" + (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Attaches a list of <i>notification settings</i> to a trust anchor.</p> <p>A notification setting includes information such as event name, threshold, status of the notification setting, and the channel to notify.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:PutNotificationSettings</code>. </p>
		/// PutNotificationSettings put-notifications-settings
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutNotificationSettingsResponse> PutNotificationSettingsAsync(PutNotificationSettingsPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "put-notifications-settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutNotificationSettingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Resets the <i>custom notification setting</i> to IAM Roles Anywhere default setting. </p> <p> <b>Required permissions: </b> <code>rolesanywhere:ResetNotificationSettings</code>. </p>
		/// ResetNotificationSettings reset-notifications-settings
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ResetNotificationSettingsResponse> ResetNotificationSettingsAsync(ResetNotificationSettingsPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "reset-notifications-settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResetNotificationSettingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Attaches tags to a resource.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:TagResource</code>. </p>
		/// TagResource TagResource
		/// </summary>
		public async Task TagResourceAsync(TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "TagResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Removes tags from the resource.</p> <p> <b>Required permissions: </b> <code>rolesanywhere:UntagResource</code>. </p>
		/// UntagResource UntagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UntagResourceResponse> UntagResourceAsync(UntagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "UntagResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UntagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public class CreateProfilePostBody
	{
		
		/// <summary>
		///  The number of seconds the vended session credentials are valid for. 
		/// Minimum: 900
		/// Maximum: 3600
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationSeconds")]
		[System.ComponentModel.DataAnnotations.Range(900, 3600)]
		public System.Nullable<System.Int32> DurationSeconds { get; set; }
		
		/// <summary>
		/// Specifies whether the profile is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// A list of managed policy ARNs that apply to the vended session credentials. 
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedPolicyArns")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] ManagedPolicyArns { get; set; }
		
		/// <summary>
		/// The name of the profile.
		/// Required
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[ a-zA-Z0-9-_]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[ a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies whether instance properties are required in temporary credential requests with this profile. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requireInstanceProperties")]
		public System.Nullable<System.Boolean> RequireInstanceProperties { get; set; }
		
		/// <summary>
		/// A list of IAM roles that this profile can assume in a temporary credential request.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roleArns")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] RoleArns { get; set; }
		
		/// <summary>
		/// A session policy that applies to the trust boundary of the vended session credentials. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionPolicy")]
		public string SessionPolicy { get; set; }
		
		/// <summary>
		/// The tags to attach to the profile.
		/// Minimum items: 0
		/// Maximum items: 200
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(200)]
		public Tag[] Tags { get; set; }
	}
	
	public class CreateTrustAnchorPostBody
	{
		
		/// <summary>
		/// Specifies whether the trust anchor is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The name of the trust anchor.
		/// Required
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[ a-zA-Z0-9-_]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[ a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of notification settings to be associated to the trust anchor.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notificationSettings")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public NotificationSetting[] NotificationSettings { get; set; }
		
		/// <summary>
		/// The trust anchor type and its related certificate data.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public CreateTrustAnchorPostBodySource Source { get; set; }
		
		/// <summary>
		/// The tags to attach to the trust anchor.
		/// Minimum items: 0
		/// Maximum items: 200
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(200)]
		public Tag[] Tags { get; set; }
	}
	
	public class CreateTrustAnchorPostBodySource
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceData")]
		public SourceData SourceData { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceType")]
		public TrustAnchorType SourceType { get; set; }
	}
	
	public class UpdateCrlPatchBody
	{
		
		/// <summary>
		/// The x509 v3 specified certificate revocation list (CRL).
		/// Max length: 300000
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="crlData")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(300000)]
		public string CrlData { get; set; }
		
		/// <summary>
		/// The name of the Crl.
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[ a-zA-Z0-9-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[ a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
	}
	
	public class UpdateProfilePatchBody
	{
		
		/// <summary>
		///  The number of seconds the vended session credentials are valid for. 
		/// Minimum: 900
		/// Maximum: 3600
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationSeconds")]
		[System.ComponentModel.DataAnnotations.Range(900, 3600)]
		public System.Nullable<System.Int32> DurationSeconds { get; set; }
		
		/// <summary>
		/// A list of managed policy ARNs that apply to the vended session credentials. 
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedPolicyArns")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] ManagedPolicyArns { get; set; }
		
		/// <summary>
		/// The name of the profile.
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[ a-zA-Z0-9-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[ a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of IAM roles that this profile can assume in a temporary credential request.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roleArns")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] RoleArns { get; set; }
		
		/// <summary>
		/// A session policy that applies to the trust boundary of the vended session credentials. 
		/// Max length: 100000
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionPolicy")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100000)]
		public string SessionPolicy { get; set; }
	}
	
	public class UpdateTrustAnchorPatchBody
	{
		
		/// <summary>
		/// The name of the trust anchor.
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[ a-zA-Z0-9-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[ a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// The trust anchor type and its related certificate data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public UpdateTrustAnchorPatchBodySource Source { get; set; }
	}
	
	public class UpdateTrustAnchorPatchBodySource
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceData")]
		public SourceData SourceData { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceType")]
		public TrustAnchorType SourceType { get; set; }
	}
	
	public class ImportCrlPostBody
	{
		
		/// <summary>
		/// The x509 v3 specified certificate revocation list (CRL).
		/// Required
		/// Max length: 300000
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crlData")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(300000)]
		public string CrlData { get; set; }
		
		/// <summary>
		/// Specifies whether the certificate revocation list (CRL) is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The name of the certificate revocation list (CRL).
		/// Required
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[ a-zA-Z0-9-_]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[ a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of tags to attach to the certificate revocation list (CRL).
		/// Minimum items: 0
		/// Maximum items: 200
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(200)]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.
		/// Required
		/// Max length: 1011
		/// Min length: 1
		/// Pattern: ^arn:aws(-[^:]+)?:rolesanywhere(:.*){2}(:trust-anchor.*)$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchorArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1011)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws(-[^:]+)?:rolesanywhere(:.*){2}(:trust-anchor.*)$")]
		public string TrustAnchorArn { get; set; }
	}
	
	public class PutNotificationSettingsPatchBody
	{
		
		/// <summary>
		/// A list of notification settings to be associated to the trust anchor.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationSettings")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public NotificationSetting[] NotificationSettings { get; set; }
		
		/// <summary>
		/// The unique identifier of the trust anchor.
		/// Required
		/// Max length: 36
		/// Min length: 36
		/// Pattern: [a-f0-9]{8}-([a-z0-9]{4}-){3}[a-z0-9]{12}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchorId")]
		[System.ComponentModel.DataAnnotations.MinLength(36)]
		[System.ComponentModel.DataAnnotations.MaxLength(36)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-f0-9]{8}-([a-z0-9]{4}-){3}[a-z0-9]{12}")]
		public string TrustAnchorId { get; set; }
	}
	
	public class ResetNotificationSettingsPatchBody
	{
		
		/// <summary>
		/// A list of notification setting keys to reset. A notification setting key includes the event and the channel. 
		/// Required
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationSettingKeys")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public NotificationSettingKey[] NotificationSettingKeys { get; set; }
		
		/// <summary>
		/// The unique identifier of the trust anchor.
		/// Required
		/// Max length: 36
		/// Min length: 36
		/// Pattern: [a-f0-9]{8}-([a-z0-9]{4}-){3}[a-z0-9]{12}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trustAnchorId")]
		[System.ComponentModel.DataAnnotations.MinLength(36)]
		[System.ComponentModel.DataAnnotations.MaxLength(36)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-f0-9]{8}-([a-z0-9]{4}-){3}[a-z0-9]{12}")]
		public string TrustAnchorId { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// The ARN of the resource.
		/// Required
		/// Max length: 1011
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1011)]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// The tags to attach to the resource.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 200
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(200)]
		public Tag[] Tags { get; set; }
	}
	
	public class UntagResourcePostBody
	{
		
		/// <summary>
		/// The ARN of the resource.
		/// Required
		/// Max length: 1011
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1011)]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// A list of keys. Tag keys are the unique identifiers of tags. 
		/// Required
		/// Minimum items: 0
		/// Maximum items: 200
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagKeys")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(200)]
		public string[] TagKeys { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
