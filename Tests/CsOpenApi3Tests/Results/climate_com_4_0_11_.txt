//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A batch of application activities
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApplicationActivities
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public ApplicationActivitySummary[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApplicationActivitySummary
	{
		
		/// <summary>
		/// The time the application activity was created. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// The start time of the application activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Array of field ids associated the application activity.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fieldIds")]
		public string[] FieldIds { get; set; }
		
		/// <summary>
		/// The id of an application activity.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The size in bytes of the raw application activity file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="length")]
		public long Length { get; set; }
		
		/// <summary>
		/// The start time of the application activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// The time the application activity was last updated. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApplicationActivityContents
	{
		
		/// <summary>
		/// Binary contents
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	/// <summary>
	/// Area with units. Units are always "hectare".
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Area
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="q")]
		public float Q { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="u")]
		public string U { get; set; }
	}
	
	/// <summary>
	/// A batch of boundary results
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Boundaries
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="features")]
		public Boundary[] Features { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public BoundariesType Type { get; set; }
	}
	
	/// <summary>
	/// Arbitrary boundary.  GeoJSON Feature.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Boundary
	{
		
		/// <summary>
		/// GeoJSON
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="geometry")]
		public Geometry Geometry { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Properties map.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public BoundaryProperties Properties { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public BoundaryType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BoundaryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Feature = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BoundariesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FeatureCollection = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BoundariesQuery
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	/// <summary>
	/// Properties map.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BoundaryProperties
	{
		
		/// <summary>
		/// Area with units. Units are always "hectare".
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="area")]
		public Area Area { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="centroid")]
		public Point Centroid { get; set; }
	}
	
	/// <summary>
	/// Arbitrary boundary in a geometry map
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BoundaryUpload
	{
		
		/// <summary>
		/// GeoJSON
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="geometry")]
		public Geometry Geometry { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreatedExport
	{
		
		/// <summary>
		/// Unique identifier for the export.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Empty
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ErrorError1 Error1 { get; set; }
	}
	
	public class ErrorError1
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Description of the error encountered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Client request to export data from a user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Export
	{
		
		/// <summary>
		/// Content type representing data being exported (e.g. application/vnd.climate.acrsi.geojson).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public ExportContentType ContentType { get; set; }
		
		/// <summary>
		/// Additional specifications for a client's data export request, dependent on the content type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ExportContentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.acrsi.geojson")]
		application_vnd_climate_acrsi_geojson = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.harvest.geojson")]
		application_vnd_climate_harvest_geojson = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportContents
	{
		
		/// <summary>
		/// Binary contents
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportStatus
	{
		
		/// <summary>
		/// Base64 encoded MD5 hash of the export's contents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checksum")]
		public string Checksum { get; set; }
		
		/// <summary>
		/// Message indicating reason for validation failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		/// <summary>
		/// Size of the export's contents in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// Current status of the export request:
		///  * `PROCESSING` - Export request has been received by Climate and is being processed.
		///  * `INVALID` - Export request has failed validity check.
		///  * `EXPIRED` - Export contents have expired, and are no longer available for retrieval.
		///  * `COMPLETED` - The export request has been successfully processed, and its contents are available for retrieval.
		///  * `NO_DATA` - The export request completed successfully but generated no data.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ExportStatusStatus Status { get; set; }
		
		/// <summary>
		/// Token which may be used when executing an identical export in
		///the future, but which only wants export data which was not
		///previously exported.
		///Assume a given field export request matches 12 fields today. And
		///tomorrow it matches 15 fields. By passing the xNextToken in the
		///definition section of tomorrow's field export request, only the
		///3 additional fields would be exported. Note, all other parameters
		///passed in the definition section must be identical to the original
		///request.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xNextToken")]
		public string XNextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ExportStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROCESSING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_DATA = 4,
	}
	
	/// <summary>
	/// Logical representation of a farm organization with a name and type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FarmOrganization
	{
		
		/// <summary>
		/// Unique identifier for a farm organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the farm organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Type of the farm organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FarmOrganizationType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FarmOrganizationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		farm = 0,
	}
	
	/// <summary>
	/// Logical representation of a Field with a name.  Spatial attributes of the Field are provided in the Boundary.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Field
	{
		
		/// <summary>
		/// Unique identifier for the current Field's Boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="boundaryId")]
		public string BoundaryId { get; set; }
		
		/// <summary>
		/// Unique identifier for a Field.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Field.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A minimal set of attributes regarding the parent of a farm organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public Parent Parent { get; set; }
		
		/// <summary>
		/// Unique identifier of the resource owner that owns the Field.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerId")]
		public string ResourceOwnerId { get; set; }
	}
	
	/// <summary>
	/// A batch of field results
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Fields
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public Field[] Results { get; set; }
	}
	
	/// <summary>
	/// GeoJSON
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Geometry
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="coordinates")]
		public string[] Coordinates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GeometryType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GeometryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Point = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Polygon = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MultiPolygon = 2,
	}
	
	/// <summary>
	/// A batch of harvest activities
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HarvestActivities
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public HarvestActivitySummary[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HarvestActivitySummary
	{
		
		/// <summary>
		/// The time the harvest activity was created. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// The start time of the harvest activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Array of field ids associated the harvest activity.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fieldIds")]
		public string[] FieldIds { get; set; }
		
		/// <summary>
		/// The id of a harvest activity.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The size in bytes of the raw harvest activity file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="length")]
		public long Length { get; set; }
		
		/// <summary>
		/// The start time of the harvest activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// The time the harvest activity was last updated. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HarvestActivityContents
	{
		
		/// <summary>
		/// Binary contents
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Metadata
	{
	}
	
	/// <summary>
	/// Logical representation of an operation with a name and resource owner.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Operation
	{
		
		/// <summary>
		/// Unique identifier for the operation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the operation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Unique identifier of the resource owner that owns the Operation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerId")]
		public string ResourceOwnerId { get; set; }
	}
	
	/// <summary>
	/// A batch of operation results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Operations
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public Operation[] Results { get; set; }
	}
	
	/// <summary>
	/// A minimal set of attributes regarding the parent of a farm organization.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Parent
	{
		
		/// <summary>
		/// Unique identifier for the parent of a farm organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Type of the parent of a farm organization.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FarmOrganizationType Type { get; set; }
	}
	
	/// <summary>
	/// A batch of planting activities
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlantingActivities
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PlantingActivitySummary[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlantingActivitySummary
	{
		
		/// <summary>
		/// The time the planting activity was created. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// The start time of the planting activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Array of field ids associated the planting activity.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fieldIds")]
		public string[] FieldIds { get; set; }
		
		/// <summary>
		/// The id of a planting activity.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The size in bytes of the raw planting activity file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="length")]
		public long Length { get; set; }
		
		/// <summary>
		/// The start time of the planting activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// The time the planting activity was last updated. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlantingActivityContents
	{
		
		/// <summary>
		/// Binary contents
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Point
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="coordinates")]
		public double[] Coordinates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceOwner
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScoutingObservation
	{
		
		/// <summary>
		/// The start time of the scouting observation. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Array of field ids associated with this observation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fieldIds")]
		public string[] FieldIds { get; set; }
		
		/// <summary>
		/// The id of a scouting observation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// GeoJSON
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Geometry Location { get; set; }
		
		/// <summary>
		/// Color of scouting pin assigned in the Climate FieldView app.
		///Limited in the Ux to a set of RGB values.
		///* #307af7
		///* #38d753
		///* #b037e4
		///* #ef3e3e
		///* #f7ec41
		///* #ff8439
		///* #808080
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locationDisplayColor")]
		public ScoutingObservationLocationDisplayColor LocationDisplayColor { get; set; }
		
		/// <summary>
		/// The text of the scouting observation. Maximum of 4000 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// The start time of the scouting observation. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// The status of the scouting observation For example : ACTIVE, DELETED
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ScoutingObservationStatus Status { get; set; }
		
		/// <summary>
		/// For example, ROCK_STONE, PONDING_WET, HAIL Maximum 20 tags allowed, 40 characters per tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public ScoutingTag[] Tags { get; set; }
		
		/// <summary>
		/// Permanent or seasonal
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timespan")]
		public ScoutingObservationTimespan Timespan { get; set; }
		
		/// <summary>
		/// The title or summary of the scouting observation. 40 Characters long, no emojis, and leading and trailing whitespace will be trimmed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// The time the scouting observation or any of its attachments was last updated.Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ScoutingObservationLocationDisplayColor
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#307af7")]
		_307af7 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#38d753")]
		_38d753 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#b037e4")]
		_b037e4 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#ef3e3e")]
		_ef3e3e = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#f7ec41")]
		_f7ec41 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#ff8439")]
		_ff8439 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#808080")]
		_808080 = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ScoutingObservationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScoutingTag
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ScoutingObservationTimespan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PERMANENT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEASONAL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScoutingObservationAttachment
	{
		
		/// <summary>
		/// The content type of the attachment, e.g. image/png.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
		
		/// <summary>
		/// id of the attachment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The number of bytes in the attachment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="length")]
		public long Length { get; set; }
		
		/// <summary>
		/// The status of the attachment. For example : ACTIVE, DELETED
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ScoutingObservationStatus Status { get; set; }
		
		/// <summary>
		/// The time the attachment was last updated.
		///Time in ISO 8601 format with UTC timezone, 3 fractional seconds.
		///(https://tools.ietf.org/html/rfc3339)
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScoutingObservationAttachmentContents
	{
		
		/// <summary>
		/// Binary contents
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
	}
	
	/// <summary>
	/// A batch of scouting attachments
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScoutingObservationAttachments
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public ScoutingObservationAttachment[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScoutingObservationSummary
	{
		
		/// <summary>
		/// The start time of the scouting observation. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// The id of a scouting observation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The start time of the scouting observation. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// The time the scouting observation or any of its attachments was last updated.Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	/// <summary>
	/// A batch of scouting observations
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScoutingObservations
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public ScoutingObservationSummary[] Results { get; set; }
	}
	
	/// <summary>
	/// Client request to upload data for a user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Upload
	{
		
		/// <summary>
		/// Content type representing data being uploaded (e.g. image/vnd.climate.rgb.geotiff)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public UploadContentType ContentType { get; set; }
		
		/// <summary>
		/// Content size in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="length")]
		public long Length { get; set; }
		
		/// <summary>
		/// Base64 encoded md5 hash of the content
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Metadata Metadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UploadContentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image/vnd.climate.thermal.geotiff")]
		image_vnd_climate_thermal_geotiff = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image/vnd.climate.ndvi.geotiff")]
		image_vnd_climate_ndvi_geotiff = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image/vnd.climate.rgb.geotiff")]
		image_vnd_climate_rgb_geotiff = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image/vnd.climate.rgb-nir.geotiff")]
		image_vnd_climate_rgbMinusnir_geotiff = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image/vnd.climate.rgb-cir.geotiff")]
		image_vnd_climate_rgbMinuscir_geotiff = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image/vnd.climate.waterstress.geotiff")]
		image_vnd_climate_waterstress_geotiff = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image/vnd.climate.elevation.geotiff")]
		image_vnd_climate_elevation_geotiff = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image/vnd.climate.raw.geotiff")]
		image_vnd_climate_raw_geotiff = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.field.geojson")]
		application_vnd_climate_field_geojson = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.rx.planting.shp")]
		application_vnd_climate_rx_planting_shp = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.prescription.zones.shp")]
		application_vnd_climate_prescription_zones_shp = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.modus.xml")]
		application_vnd_climate_modus_xml = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.stand-count.geojson")]
		application_vnd_climate_standMinuscount_geojson = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.weed-count.geojson")]
		application_vnd_climate_weedMinuscount_geojson = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.as-applied.zip")]
		application_vnd_climate_asMinusapplied_zip = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.as-planted.zip")]
		application_vnd_climate_asMinusplanted_zip = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.climate.as-harvested.zip")]
		application_vnd_climate_asMinusharvested_zip = 16,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UploadStatus
	{
		
		/// <summary>
		/// Unique identifier for the upload.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Current status of the upload:
		///  * `UPLOADING` - Uploading has started, parts are still coming in.
		///  * `INVALID` - Upload has failed validity check.
		///  * `PENDING` - Upload has been received by Climate and is being processed.
		///  * `INBOX` - The upload is awaiting user acceptance in their Data Inbox.
		///  * `DECLINED` - The user has declined the upload in their Data Inbox.
		///  * `IMPORTING` - The user has accepted the upload and it is being imported into their account.
		///  * `SUCCESS` - The upload has been successfully imported.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public UploadStatusStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UploadStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPLOADING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INBOX = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DECLINED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IMPORTING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UploadStatusQuery
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UploadStatuses
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public UploadStatus[] Results { get; set; }
	}
	
	/// <summary>
	/// Unique identifier of a successfully uploaded boundary
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UploadedBoundaryId
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Upload a boundary
		/// Upload a **Boundary** entry by passing the geometry of the boundary. This will store the boundary but will not create field in Climate FieldView and will not link to an existing field in Climate FieldView.
		/// This is restricted to callers with **boundaries:write** scope.
		/// To upload a field boundary for field creation in Climate FieldView, please use **POST /v4/uploads**.
		/// V4BoundariesPost v4/boundaries
		/// </summary>
		/// <returns>OK</returns>
		public async Task<UploadedBoundaryId> V4BoundariesPostAsync(BoundaryUpload requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/boundaries";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UploadedBoundaryId>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve Boundaries in batch
		/// Retrieve multiple **Boundaries** (up to 10 per request).
		/// V4BoundariesQueryPost v4/boundaries/query
		/// </summary>
		/// <returns>OK</returns>
		public async Task<Boundaries> V4BoundariesQueryPostAsync(BoundariesQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/boundaries/query";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Boundaries>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve a Boundary by ID
		/// Retrieve a **Boundary** by ID.
		/// V4Boundaries_boundaryIdGet v4/boundaries/{boundaryId}
		/// </summary>
		/// <param name="boundaryId">Unique identifier of the Boundary</param>
		/// <returns>OK</returns>
		public async Task<Boundary> V4Boundaries_boundaryIdGetAsync(string boundaryId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/boundaries/"+ (boundaryId==null? "" : System.Uri.EscapeDataString(boundaryId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Boundary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiate a new export request.
		/// Step one in requesting a data product. The method will return an **Export** ID which the caller will use in subsequent `GET` requests.
		/// The following `contentTypes` may be requested:
		/// * __application/vnd.climate.acrsi.geojson__ (Beta)
		/// Exports the planting activities accessible by the authenticated user and optionally filtered by resource owner
		/// as a [GeoJSON Feature Collection](https://tools.ietf.org/html/rfc7946#page-12).
		/// 
		/// The export request definition must contain the following properties:
		/// * plantingStartDate
		/// * plantingEndDate
		/// * resourceOwnerId
		/// 
		/// Requires `exports:read` and `plantingActivitySummary:read` scope.
		/// 
		/// * __application/vnd.climate.harvest.geojson__
		/// Exports the harvesting activities accessible by the authenticated user and optionally filtered by resource owner
		/// as a [GeoJSON Feature Collection](https://tools.ietf.org/html/rfc7946#page-12).
		/// 
		/// The export request definition must contain the following properties:
		/// * harvestStartDate
		/// * harvestEndDate
		/// * resourceOwnerId
		/// 
		/// Requires `exports:read` and `plantingActivitySummary:read` scope.
		/// V4ExportsPost v4/exports
		/// </summary>
		public async Task V4ExportsPostAsync(Export requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/exports";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the binary contents of a processed export request.
		/// Downloads larger than `5MiB` (`5242880 bytes`) in size must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB` (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`).
		/// V4Exports_exportIdContentsGet v4/exports/{exportId}/contents
		/// </summary>
		/// <param name="exportId">Unique identifier of an Export.</param>
		public async Task V4Exports_exportIdContentsGetAsync(string exportId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/exports/"+ (exportId==null? "" : System.Uri.EscapeDataString(exportId))+"/contents";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the status of an Export.
		/// Check the status of an **Export** by ID.
		/// V4Exports_exportIdStatusGet v4/exports/{exportId}/status
		/// </summary>
		/// <param name="exportId">Unique identifier of an Export.</param>
		/// <returns>OK</returns>
		public async Task<ExportStatus> V4Exports_exportIdStatusGetAsync(string exportId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/exports/"+ (exportId==null? "" : System.Uri.EscapeDataString(exportId))+"/status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExportStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a specific farm organization by organization type and ID
		/// Retrieve a given **farm organization** by organization type and ID.
		/// V4FarmOrganizations_farmOrganizationType_farmOrganizationIdGet v4/farmOrganizations/{farmOrganizationType}/{farmOrganizationId}
		/// </summary>
		/// <param name="farmOrganizationType">Type of the farm organization.</param>
		/// <param name="farmOrganizationId">Unique identifier of the farm organization.</param>
		/// <returns>Returns the requested farm organization.</returns>
		public async Task<FarmOrganization> V4FarmOrganizations_farmOrganizationType_farmOrganizationIdGetAsync(FarmOrganizationType farmOrganizationType, string farmOrganizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/farmOrganizations/"+farmOrganizationType+"/"+ (farmOrganizationId==null? "" : System.Uri.EscapeDataString(farmOrganizationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FarmOrganization>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve list of Fields
		/// Retrieve list of **Fields**. Filter the results by field name if the `fieldName` query parameter is specified.
		/// V4FieldsGetByFieldName v4/fields
		/// </summary>
		/// <param name="fieldName">Optional prefix filter for field name. Must be at least 3 characters.</param>
		/// <returns>OK</returns>
		public async Task<Fields> V4FieldsGetByFieldNameAsync(string fieldName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/fields?fieldName=" + (fieldName==null? "" : System.Uri.EscapeDataString(fieldName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Fields>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve list of all Fields the user has access to.
		/// Retrieve all fields the authenticated user has access to, including fields shared with the authenticated user from other resource owners. Filter the results by field name if the `fieldName` query parameter is specified.
		/// A 409 will be returned if the X-Next-Token has expired. When receiving a 409, the client should discard the X-Next-Token, discard all currently persisted fields for the user, and re-fetch fields from /fields/all.
		/// V4FieldsAllGetByFieldName v4/fields/all
		/// </summary>
		/// <param name="fieldName">Optional prefix filter for field name. Must be at least 3 characters.</param>
		/// <returns>OK</returns>
		public async Task<Fields> V4FieldsAllGetByFieldNameAsync(string fieldName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/fields/all?fieldName=" + (fieldName==null? "" : System.Uri.EscapeDataString(fieldName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Fields>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a specific Field by ID
		/// Retrieve a given **Field** by ID.
		/// V4Fields_fieldIdGet v4/fields/{fieldId}
		/// </summary>
		/// <param name="fieldId">Unique identifier of the Field.</param>
		/// <returns>Returns the requested Field.</returns>
		public async Task<Field> V4Fields_fieldIdGetAsync(string fieldId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/fields/"+ (fieldId==null? "" : System.Uri.EscapeDataString(fieldId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Field>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of application activities
		/// Retrieve a list of application activities. The id in the response is used for  GET /v4/layers/asApplied/{activityId}/contents.
		/// V4LayersAsAppliedGetByResourceOwnerIdAndOccurredAfterAndOccurredBeforeAndUpdatedAfter v4/layers/asApplied
		/// </summary>
		/// <param name="resourceOwnerId">Optional unique identifier of the resource owner.  If resourceOwnerId is not specified, it defaults to the x-authenticated-user-uuid.</param>
		/// <param name="occurredAfter">Optional start time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with an end time at or after (inclusive) the specified time will match this filter. If both occurredAfter and occurredBefore are populated, occurredAfter must be <= occurredBefore.</param>
		/// <param name="occurredBefore">Optional end time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with a start time at or before (inclusive) the specified time. If both occurredAfter and occurredBefore are populated, occurredAfter must be <= occurredBefore.</param>
		/// <param name="updatedAfter">Optional updated time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with a modification time at or after (inclusive) the specified time.</param>
		/// <returns>OK</returns>
		public async Task<ApplicationActivities> V4LayersAsAppliedGetByResourceOwnerIdAndOccurredAfterAndOccurredBeforeAndUpdatedAfterAsync(string resourceOwnerId, System.DateTimeOffset occurredAfter, System.DateTimeOffset occurredBefore, System.DateTimeOffset updatedAfter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/asApplied?resourceOwnerId=" + (resourceOwnerId==null? "" : System.Uri.EscapeDataString(resourceOwnerId))+"&occurredAfter=" + occurredAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&occurredBefore=" + occurredBefore.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAfter=" + updatedAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ApplicationActivities>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the raw application activity
		/// Retrieve an individual application activity by id.  Ids are retrieved via the  /layers/asApplied route. Downloads larger than `5MiB` (`5242880 bytes`) in size, must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB`  (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`). The data is compressed using .zip format.
		/// V4LayersAsApplied_activityIdContentsGet v4/layers/asApplied/{activityId}/contents
		/// </summary>
		/// <param name="activityId">Unique identifier of the Application Activity.</param>
		/// <returns>OK</returns>
		public async Task V4LayersAsApplied_activityIdContentsGetAsync(string activityId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/asApplied/"+ (activityId==null? "" : System.Uri.EscapeDataString(activityId))+"/contents";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of harvest activities
		/// Retrieve a list of harvest activities. The id in the response is used for  GET /v4/layers/asHarvested/{activityId}/contents.
		/// V4LayersAsHarvestedGetByResourceOwnerIdAndOccurredAfterAndOccurredBeforeAndUpdatedAfter v4/layers/asHarvested
		/// </summary>
		/// <param name="resourceOwnerId">Optional unique identifier of the resource owner.  If resourceOwnerId is not specified, it defaults to the x-authenticated-user-uuid.</param>
		/// <param name="occurredAfter">Optional start time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with an end time at or after (inclusive) the specified time will match this filter. If both occurredAfter and occurredBefore are populated, occurredAfter must be <= occurredBefore.</param>
		/// <param name="occurredBefore">Optional end time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with a start time at or before (inclusive) the specified time. If both occurredAfter and occurredBefore are populated, occurredAfter must be <= occurredBefore.</param>
		/// <param name="updatedAfter">Optional updated time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with a modification time at or after (inclusive) the specified time.</param>
		/// <returns>OK</returns>
		public async Task<HarvestActivities> V4LayersAsHarvestedGetByResourceOwnerIdAndOccurredAfterAndOccurredBeforeAndUpdatedAfterAsync(string resourceOwnerId, System.DateTimeOffset occurredAfter, System.DateTimeOffset occurredBefore, System.DateTimeOffset updatedAfter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/asHarvested?resourceOwnerId=" + (resourceOwnerId==null? "" : System.Uri.EscapeDataString(resourceOwnerId))+"&occurredAfter=" + occurredAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&occurredBefore=" + occurredBefore.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAfter=" + updatedAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HarvestActivities>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the raw harvest activity
		/// Retrieve an individual harvest activity by id.  Ids are retrieved via the  /layers/asHarvested route. Downloads larger than `5MiB` (`5242880 bytes`) in size, must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB`  (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`). The data is compressed using .zip format.
		/// V4LayersAsHarvested_activityIdContentsGet v4/layers/asHarvested/{activityId}/contents
		/// </summary>
		/// <param name="activityId">Unique identifier of the Harvest Activity.</param>
		/// <returns>OK</returns>
		public async Task V4LayersAsHarvested_activityIdContentsGetAsync(string activityId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/asHarvested/"+ (activityId==null? "" : System.Uri.EscapeDataString(activityId))+"/contents";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of planting activities
		/// Retrieve a list of planting activities. The id in the response is used for  GET /v4/layers/asPlanted/{activityId}/contents.
		/// V4LayersAsPlantedGetByResourceOwnerIdAndOccurredAfterAndOccurredBeforeAndUpdatedAfter v4/layers/asPlanted
		/// </summary>
		/// <param name="resourceOwnerId">Optional unique identifier of the resource owner.  If resourceOwnerId is not specified, it defaults to the x-authenticated-user-uuid.</param>
		/// <param name="occurredAfter">Optional start time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with an end time at or after (inclusive) the specified time will match this filter. If both occurredAfter and occurredBefore are populated, occurredAfter must be <= occurredBefore.</param>
		/// <param name="occurredBefore">Optional end time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with a start time at or before (inclusive) the specified time. If both occurredAfter and occurredBefore are populated, occurredAfter must be <= occurredBefore.</param>
		/// <param name="updatedAfter">Optional updated time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with a modification time at or after (inclusive) the specified time.</param>
		/// <returns>OK</returns>
		public async Task<PlantingActivities> V4LayersAsPlantedGetByResourceOwnerIdAndOccurredAfterAndOccurredBeforeAndUpdatedAfterAsync(string resourceOwnerId, System.DateTimeOffset occurredAfter, System.DateTimeOffset occurredBefore, System.DateTimeOffset updatedAfter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/asPlanted?resourceOwnerId=" + (resourceOwnerId==null? "" : System.Uri.EscapeDataString(resourceOwnerId))+"&occurredAfter=" + occurredAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&occurredBefore=" + occurredBefore.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAfter=" + updatedAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlantingActivities>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the raw planting activity
		/// Retrieve an individual planting activity by id.  Ids are retrieved via the  /layers/asPlanted route. Downloads larger than `5MiB` (`5242880 bytes`) in size, must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB`  (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`).  The data is compressed using .zip format.
		/// V4LayersAsPlanted_activityIdContentsGet v4/layers/asPlanted/{activityId}/contents
		/// </summary>
		/// <param name="activityId">Unique identifier of the Planting Activity.</param>
		/// <returns>OK</returns>
		public async Task V4LayersAsPlanted_activityIdContentsGetAsync(string activityId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/asPlanted/"+ (activityId==null? "" : System.Uri.EscapeDataString(activityId))+"/contents";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of scouting observations
		/// Retrieve a list of scouting observations created or updated by the user identified by the Authorization header.
		/// V4LayersScoutingObservationsGetByOccurredAfterAndOccurredBefore v4/layers/scoutingObservations
		/// </summary>
		/// <param name="occurredAfter">Optional start time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with an end time at or after (inclusive) the specified time will match this filter. If both occurredAfter and occurredBefore are populated, occurredAfter must be <= occurredBefore.</param>
		/// <param name="occurredBefore">Optional end time by which to filter layer results. Time must be in ISO 8601 format with time zone, e.g. 2016-05-13T00:00:00Z (https://tools.ietf.org/html/rfc3339). Layers with a start time at or before (inclusive) the specified time. If both occurredAfter and occurredBefore are populated, occurredAfter must be <= occurredBefore.</param>
		/// <returns>OK</returns>
		public async Task<ScoutingObservations> V4LayersScoutingObservationsGetByOccurredAfterAndOccurredBeforeAsync(System.DateTimeOffset occurredAfter, System.DateTimeOffset occurredBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/scoutingObservations?occurredAfter=" + occurredAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&occurredBefore=" + occurredBefore.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScoutingObservations>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve individual scouting observation
		/// Retrieve an individual scouting observation by id.  Ids are retrieved via the /layers/scoutingObservations route.
		/// V4LayersScoutingObservations_scoutingObservationIdGet v4/layers/scoutingObservations/{scoutingObservationId}
		/// </summary>
		/// <param name="scoutingObservationId">Unique identifier of the Scouting Observation.</param>
		/// <returns>Returns the requested scouting observation.</returns>
		public async Task<ScoutingObservation> V4LayersScoutingObservations_scoutingObservationIdGetAsync(string scoutingObservationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/scoutingObservations/"+ (scoutingObservationId==null? "" : System.Uri.EscapeDataString(scoutingObservationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScoutingObservation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve attachments associated with a given scouting observation.
		/// Retrieve attachments associated with a given scouting observation. Photos added to scouting notes in the FieldView app are capped to 20MB, and we won’t store photos larger than that in a scouting note.
		/// V4LayersScoutingObservations_scoutingObservationIdAttachmentsGet v4/layers/scoutingObservations/{scoutingObservationId}/attachments
		/// </summary>
		/// <param name="scoutingObservationId">Unique identifier of the Scouting Observation.</param>
		/// <returns>OK</returns>
		public async Task<ScoutingObservationAttachments> V4LayersScoutingObservations_scoutingObservationIdAttachmentsGetAsync(string scoutingObservationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/scoutingObservations/"+ (scoutingObservationId==null? "" : System.Uri.EscapeDataString(scoutingObservationId))+"/attachments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScoutingObservationAttachments>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the binary contents of a scouting observation’s attachment.
		/// Photos added to scouting notes in the FieldView app are capped to `20MiB` (`20971520 bytes`), and we won’t store photos larger than that in a scouting note. Downloads larger than `5MiB` (`5242880 bytes`) in size, must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB` (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`).
		/// V4LayersScoutingObservations_scoutingObservationIdAttachments_attachmentIdContentsGet v4/layers/scoutingObservations/{scoutingObservationId}/attachments/{attachmentId}/contents
		/// </summary>
		/// <param name="scoutingObservationId">Unique identifier of the Scouting Observation.</param>
		/// <param name="attachmentId">Unique identifier of the attachment.</param>
		/// <returns>OK</returns>
		public async Task V4LayersScoutingObservations_scoutingObservationIdAttachments_attachmentIdContentsGetAsync(string scoutingObservationId, string attachmentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/layers/scoutingObservations/"+ (scoutingObservationId==null? "" : System.Uri.EscapeDataString(scoutingObservationId))+"/attachments/"+ (attachmentId==null? "" : System.Uri.EscapeDataString(attachmentId))+"/contents";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the operations accessible to a a given user.
		/// Retrieve the **operations** accessible to the authenticated user. Filter the results by resource owner if the `resourceOwnerId` query parameter is specified.
		/// V4OperationsAllGetByResourceOwnerId v4/operations/all
		/// </summary>
		/// <param name="resourceOwnerId">Optional comma-separated list of resource owner unique identifiers by which to filter results.</param>
		/// <returns>Returns the requested operations.</returns>
		public async Task<Operations> V4OperationsAllGetByResourceOwnerIdAsync(string resourceOwnerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/operations/all?resourceOwnerId=" + (resourceOwnerId==null? "" : System.Uri.EscapeDataString(resourceOwnerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operations>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a resource owner by ID
		/// Retrieve a resource owner for the given `resourceOwnerId`.
		/// V4ResourceOwners_resourceOwnerIdGet v4/resourceOwners/{resourceOwnerId}
		/// </summary>
		/// <param name="resourceOwnerId">Unique identifier of the resource owner.</param>
		/// <returns>OK</returns>
		public async Task<ResourceOwner> V4ResourceOwners_resourceOwnerIdGetAsync(string resourceOwnerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/resourceOwners/"+ (resourceOwnerId==null? "" : System.Uri.EscapeDataString(resourceOwnerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceOwner>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiate a new upload
		/// Step one in uploading a data product. The method will return an **Upload** ID which the caller will use in subsequent `PUT` requests.
		/// The following `contentTypes` may be uploaded:
		/// <details><summary>__image/vnd.climate.thermal.geotiff__</summary>
		/// 
		/// Allows for the upload of a thermal image. The image is a single band geotiff with 64 bit signed floating point values in degrees Celsius. The Coordinate Reference System (CRS) must be UTM with WGS84 datum.
		/// 
		/// The following metadata entries are required to be embedded in the geotiff:
		/// * acquisitionStartDate - ISO8601 date
		/// * acquisitionEndDate - ISO8601 date
		/// * isCalibrated - boolean
		/// 
		/// The following metadata entries are optional:
		/// * sourceId - uuid referencing the asset in the partner's system
		/// * fieldId - uuid referencing a field in the Climate system
		/// * boundaryId - uuid referencing a boundary in the Climate system
		/// * brandId - uuid referencing a partner's branding in the Climate system
		/// * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
		/// 
		/// Requires either imagery:write or platform scope.
		/// </details>
		/// <details><summary>__image/vnd.climate.ndvi.geotiff__</summary>
		/// 
		/// Allows for the upload of a NDVI image. The image is a single band geotiff with 64 bit signed floating point values in the range of -1 to 1 inclusive. The Coordinate Reference System (CRS) must be UTM with WGS84 datum.
		/// 
		/// The following metadata entries are required to be embedded in the geotiff:
		/// * acquisitionStartDate - ISO8601 date
		/// * acquisitionEndDate - ISO8601 date
		/// 
		/// The following metadata entries are optional:
		/// * sourceId - uuid referencing the asset in the partner's system
		/// * fieldId - uuid referencing a field in the Climate system
		/// * boundaryId - uuid referencing a boundary in the Climate system
		/// * brandId - uuid referencing a partner's branding in the Climate system
		/// * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
		/// 
		/// Requires either imagery:write or platform scope.
		/// </details>
		/// <details><summary> __image/vnd.climate.rgb.geotiff__</summary>
		/// 
		/// Allows for the upload of a true color image. The image is a multi band geotiff with 24-bit composite values. Each band is 8 bits with values in the range of 0 to 255. The Coordinate Reference System (CRS) must be UTM with WGS84 datum. The geotiff must contain 3 bands in the order Red, Green, Blue.
		/// 
		/// The following metadata entries are required to be embedded in the geotiff:
		/// * acquisitionStartDate - ISO8601 date
		/// * acquisitionEndDate - ISO8601 date
		/// * isCalibrated - boolean
		/// 
		/// The following metadata entries are optional:
		/// * sourceId - uuid referencing the asset in the partner's system
		/// * fieldId - uuid referencing a field in the Climate system
		/// * boundaryId - uuid referencing a boundary in the Climate system
		/// * brandId - uuid referencing a partner's branding in the Climate system
		/// * reflectanceComputeMethod - either TOA or GROUND
		/// * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
		/// 
		/// Requires either imagery:write or platform scope.
		/// </details>
		/// <details><summary> __image/vnd.climate.rgb-nir.geotiff__</summary>
		/// 
		/// Allows for the upload of a Near Infrared (NIR) image. The Coordinate Reference System (CRS) must be UTM with WGS84 datum.
		/// 
		/// The following metadata entries are required to be embedded in the geotiff:
		/// * acquisitionStartDate - ISO8601 date
		/// * acquisitionEndDate - ISO8601 date
		/// * isCalibrated - boolean
		/// 
		/// The following metadata entries are optional:
		/// * sourceId - uuid referencing the asset in the partner's system
		/// * fieldId - uuid referencing a field in the Climate system
		/// * boundaryId - uuid referencing a boundary in the Climate system
		/// * brandId - uuid referencing a partner's branding in the Climate system
		/// * reflectanceComputeMethod - either TOA or GROUND
		/// * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
		/// 
		/// Requires either imagery:write or platform scope.
		/// </details>
		/// <details><summary>__image/vnd.climate.rgb-cir.geotiff__</summary>
		/// 
		/// Allows for the upload of a Color Infrared (CIR) image. The Coordinate Reference System (CRS) must be UTM with WGS84 datum.
		/// 
		/// The following metadata entries are required to be embedded in the geotiff:
		/// * acquisitionStartDate - ISO8601 date
		/// * acquisitionEndDate - ISO8601 date
		/// * isCalibrated - boolean
		/// 
		/// The following metadata entries are optional:
		/// * sourceId - uuid referencing the asset in the partner's system
		/// * fieldId - uuid referencing a field in the Climate system
		/// * boundaryId - uuid referencing a boundary in the Climate system
		/// * brandId - uuid referencing a partner's branding in the Climate system
		/// * reflectanceComputeMethod - either TOA or GROUND
		/// * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
		/// 
		/// Requires either imagery:write or platform scope.
		/// </details>
		/// <details><summary> __application/vnd.climate.rx.planting.shp__</summary>
		/// 
		/// Allows for the upload of a planting prescription in shapefile format.  The upload must be an archive in the zip format.  It should contain one and only one of each of the following file types:
		/// * .shp
		/// * .shx
		/// * .dbf
		/// 
		/// All files with the above suffixes must have the same prefix, ie Back40.shp, Back40.shx and Back40.dbf.
		/// 
		/// Requires either rx:write or platform scope.
		/// </details>
		/// <details><summary> __application/vnd.climate.prescription.zones.shp__</summary>
		/// 
		/// Allows for the upload of a zones prescription in shapefile format.  The upload must be an archive in the zip format.  It should contain one and only one of each of the following file types:
		/// * .shp
		/// * .shx
		/// * .dbf
		/// 
		/// All files with the above suffixes must have the same prefix, ie Back40.shp, Back40.shx and Back40.dbf.
		/// 
		/// The following metadata entries are required:
		/// * fieldId - field identifier for prescription zones.
		/// 
		/// Requires either rxZones:write or platform scope.
		/// </details>
		/// <details><summary> __application/vnd.climate.modus.xml__</summary>
		/// 
		/// Allows for the upload of a soil sampling file in the modus 1.0 format with some restrictions.  The upload must be a single xml file.
		/// 
		/// The following elements are required to be present in the modus file.
		/// * EventCode - Max length of 64 bytes
		/// * EventDate - Must be in ISO8601
		/// * SoilSample - Has a maxOccurs of 20k
		/// * Depth - Has a maxOccurs of 50
		/// * LabName - Must be non-empty.
		/// * StartingDepth - 0 to 36 inclusive, default 0
		/// * EndingDepth - 1 - 36 inclusive, default 1
		/// * ColumnDepth
		/// * DepthUnit - must be inches
		/// * Geometry - point in wgs84
		/// 
		/// Requires the soil:write scope.
		/// </details>
		/// <details><summary> __application/vnd.climate.stand-count.geojson__</summary>
		/// 
		/// Allows for the upload of a valid [geojson feature collection](https://tools.ietf.org/html/rfc7946#section-3.3).
		/// 
		/// Each feature in the collection must contain the following entry in its properties section:
		/// * StandPPA - A count of the number of plants per acre:
		/// 
		/// Additionally, the type field of each feature's geometry field must be:
		/// * Point
		/// 
		/// Requires `imagery:write` scope.
		/// </details>
		/// <details><summary> __application/vnd.climate.weed-count.geojson__</summary>
		/// 
		/// Allows for the upload of a valid [geojson feature collection](https://tools.ietf.org/html/rfc7946#section-3.3).
		/// 
		/// Each feature in the collection must contain the following entry in its properties section:
		/// * StandPPA - A count of the number of plants per acre:
		/// 
		/// Additionally, the type field of each feature's geometry field must be:
		/// * Point
		/// 
		/// Requires `imagery:write` scope.
		/// </details>
		/// <details><summary> __application/vnd.climate.as-applied.zip__</summary>
		/// 
		/// Allows for the upload of a valid application data [supported formats](https://support.climate.com/kt#/kA02A000000DjvOSAS/en_US).
		/// 
		/// The following metadata entries are required:
		/// * fileName - name of the file being uploaded.
		/// 
		/// The following metadata entries are optional:
		/// * resourceOwner - the grower's account email, where dealer/partner wants to upload data. As a prerequisite the grower must share their operation with the dealer/partner.
		/// 
		/// Requires `asApplied:write` scope.
		/// </details>
		/// <details><summary> __application/vnd.climate.as-planted.zip__</summary>
		/// 
		/// Allows for the upload of a valid planting data [supported formats](https://support.climate.com/kt#/kA02A000000DjvOSAS/en_US).
		/// 
		/// The following metadata entries are required:
		/// * fileName - name of the file being uploaded.
		/// 
		/// The following metadata entries are optional:
		/// * resourceOwner - the grower's account email, where dealer/partner wants to upload data. As a prerequisite the grower must share their operation with the dealer/partner.
		/// 
		/// Requires `asPlanted:write` scope.
		/// </details>
		/// <details><summary> __application/vnd.climate.as-harvested.zip__</summary>
		/// 
		/// Allows for the upload of a valid harvest data [supported formats](https://support.climate.com/kt#/kA02A000000DjvOSAS/en_US).
		/// 
		/// The following metadata entries are required:
		/// * fileName - name of the file being uploaded.
		/// 
		/// The following metadata entries are optional:
		/// * resourceOwner - the grower's account email, where dealer/partner wants to upload data. As a prerequisite the grower must share their operation with the dealer/partner.
		/// 
		/// Requires `asHarvested:write` scope.
		/// </details>
		/// V4UploadsPost v4/uploads
		/// </summary>
		public async Task V4UploadsPostAsync(Upload requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/uploads";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve Upload statuses in batch
		/// Check the status of multiple **Uploads** (up to 100 per request).
		/// V4UploadsStatusQueryPost v4/uploads/status/query
		/// </summary>
		/// <returns>OK</returns>
		public async Task<UploadStatuses> V4UploadsStatusQueryPostAsync(UploadStatusQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/uploads/status/query";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UploadStatuses>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Chunked upload of data
		/// Send chunked data for an **Upload**.
		/// V4Uploads_uploadIdPut v4/uploads/{uploadId}
		/// </summary>
		/// <param name="uploadId">Unique identifier of an Upload.</param>
		public async Task V4Uploads_uploadIdPutAsync(string uploadId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/uploads/"+ (uploadId==null? "" : System.Uri.EscapeDataString(uploadId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve Upload status
		/// Check the status of an **Upload** by ID.
		/// V4Uploads_uploadIdStatusGet v4/uploads/{uploadId}/status
		/// </summary>
		/// <param name="uploadId">Unique identifier of an Upload.</param>
		/// <returns>OK</returns>
		public async Task<UploadStatus> V4Uploads_uploadIdStatusGetAsync(string uploadId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/uploads/"+ (uploadId==null? "" : System.Uri.EscapeDataString(uploadId))+"/status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UploadStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
