//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Eventsv1event_type
	{
		
		/// <summary>
		/// The date that this Event Type was created, given in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The date that this Event Type was updated, given in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_updated")]
		public System.Nullable<System.DateTimeOffset> Date_updated { get; set; }
		
		/// <summary>
		/// A human readable description for this Event Type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string Links { get; set; }
		
		/// <summary>
		/// A string that uniquely identifies the Schema this Event Type adheres to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema_id")]
		public string Schema_id { get; set; }
		
		/// <summary>
		/// A string that uniquely identifies this Event Type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The URL of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Eventsv1schema
	{
		
		/// <summary>
		/// The unique identifier of the schema. Each schema can have multiple versions, that share the same id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The latest version published of this schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latest_version")]
		public System.Nullable<System.Int32> Latest_version { get; set; }
		
		/// <summary>
		/// The date that the latest schema version was created, given in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latest_version_date_created")]
		public System.Nullable<System.DateTimeOffset> Latest_version_date_created { get; set; }
		
		/// <summary>
		/// Contains a dictionary of URL links to nested resources of this schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string Links { get; set; }
		
		/// <summary>
		/// The URL of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Eventsv1schemaschema_version
	{
		
		/// <summary>
		/// The date the schema version was created, given in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The unique identifier of the schema. Each schema can have multiple versions, that share the same id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="raw")]
		public string Raw { get; set; }
		
		/// <summary>
		/// The version of this schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema_version")]
		public System.Nullable<System.Int32> Schema_version { get; set; }
		
		/// <summary>
		/// The URL of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Eventsv1sink
	{
		
		/// <summary>
		/// The date that this Sink was created, given in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The date that this Sink was updated, given in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_updated")]
		public System.Nullable<System.DateTimeOffset> Date_updated { get; set; }
		
		/// <summary>
		/// A human readable description for the Sink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Contains a dictionary of URL links to nested resources of this Sink.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string Links { get; set; }
		
		/// <summary>
		/// A 34 character string that uniquely identifies this Sink.
		/// Min length: 34
		/// Max length: 34
		/// Pattern: ^DG[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^DG[0-9a-fA-F]{32}$")]
		public string Sid { get; set; }
		
		/// <summary>
		/// The information required for Twilio to connect to the provided Sink encoded as JSON.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sink_configuration")]
		public object Sink_configuration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sink_type")]
		public System.Nullable<Eventsv1sinkSink_type> Sink_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<Eventsv1sinkStatus> Status { get; set; }
		
		/// <summary>
		/// The URL of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Eventsv1sinkSink_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		kinesis = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		webhook = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		segment = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Eventsv1sinkStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		initialized = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		validating = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Eventsv1sinksink_test
	{
		
		/// <summary>
		/// Feedback indicating whether the test event was generated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public string Result { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Eventsv1sinksink_validate
	{
		
		/// <summary>
		/// Feedback indicating whether the given Sink was validated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public string Result { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Eventsv1subscription
	{
		
		/// <summary>
		/// The unique SID identifier of the Account.
		/// Min length: 34
		/// Max length: 34
		/// Pattern: ^AC[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AC[0-9a-fA-F]{32}$")]
		public string Account_sid { get; set; }
		
		/// <summary>
		/// The date that this Subscription was created, given in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The date that this Subscription was updated, given in ISO 8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_updated")]
		public System.Nullable<System.DateTimeOffset> Date_updated { get; set; }
		
		/// <summary>
		/// A human readable description for the Subscription
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Contains a dictionary of URL links to nested resources of this Subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string Links { get; set; }
		
		/// <summary>
		/// A 34 character string that uniquely identifies this Subscription.
		/// Min length: 34
		/// Max length: 34
		/// Pattern: ^DF[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^DF[0-9a-fA-F]{32}$")]
		public string Sid { get; set; }
		
		/// <summary>
		/// The SID of the sink that events selected by this subscription should be sent to. Sink must be active for the subscription to be created.
		/// Min length: 34
		/// Max length: 34
		/// Pattern: ^DG[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sink_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^DG[0-9a-fA-F]{32}$")]
		public string Sink_sid { get; set; }
		
		/// <summary>
		/// The URL of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Eventsv1subscriptionsubscribed_event
	{
		
		/// <summary>
		/// The unique SID identifier of the Account.
		/// Min length: 34
		/// Max length: 34
		/// Pattern: ^AC[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AC[0-9a-fA-F]{32}$")]
		public string Account_sid { get; set; }
		
		/// <summary>
		/// The schema version that the Subscription should use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema_version")]
		public System.Nullable<System.Int32> Schema_version { get; set; }
		
		/// <summary>
		/// The unique SID identifier of the Subscription.
		/// Min length: 34
		/// Max length: 34
		/// Pattern: ^DF[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^DF[0-9a-fA-F]{32}$")]
		public string Subscription_sid { get; set; }
		
		/// <summary>
		/// Type of event being subscribed to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The URL of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Sink_enum_sink_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		kinesis = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		webhook = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		segment = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Sink_enum_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		initialized = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		validating = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Fetch a specific schema with its nested versions.
		/// FetchSchema v1/Schemas/{Id}
		/// </summary>
		/// <param name="Id">The unique identifier of the schema. Each schema can have multiple versions, that share the same id.</param>
		/// <returns>OK</returns>
		public async Task<Eventsv1schema> FetchSchemaAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Schemas/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Eventsv1schema>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a paginated list of versions of the schema.
		/// ListSchemaVersion v1/Schemas/{Id}/Versions
		/// </summary>
		/// <param name="Id">The unique identifier of the schema. Each schema can have multiple versions, that share the same id.</param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="Page">The page index. This value is simply for client state.
		/// Minimum: 0
		// </param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListSchemaVersionReturn> ListSchemaVersionAsync(string Id, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Schemas/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/Versions&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSchemaVersionReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a specific schema and version.
		/// FetchSchemaVersion v1/Schemas/{Id}/Versions/{SchemaVersion}
		/// </summary>
		/// <param name="Id">The unique identifier of the schema. Each schema can have multiple versions, that share the same id.</param>
		/// <param name="SchemaVersion">The version of the schema</param>
		/// <returns>OK</returns>
		public async Task<Eventsv1schemaschema_version> FetchSchemaVersionAsync(string Id, int SchemaVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Schemas/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/Versions/"+SchemaVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Eventsv1schemaschema_version>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a paginated list of Sinks belonging to the account used to make the request.
		/// ListSink v1/Sinks
		/// </summary>
		/// <param name="InUse">A boolean query parameter filtering the results to return sinks used/not used by a subscription.</param>
		/// <param name="Status">A String query parameter filtering the results by status `initialized`, `validating`, `active` or `failed`.</param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="Page">The page index. This value is simply for client state.
		/// Minimum: 0
		// </param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListSinkReturn> ListSinkAsync(bool InUse, string Status, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Sinks?InUse="+InUse+"&Status=" + (Status==null? "" : System.Uri.EscapeDataString(Status))+"&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSinkReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a specific Sink.
		/// DeleteSink v1/Sinks/{Sid}
		/// </summary>
		/// <param name="Sid">A 34 character string that uniquely identifies this Sink.
		/// Min length: 34
		/// Max length: 34
		// </param>
		public async Task DeleteSinkAsync(string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Sinks/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a specific Sink.
		/// FetchSink v1/Sinks/{Sid}
		/// </summary>
		/// <param name="Sid">A 34 character string that uniquely identifies this Sink.
		/// Min length: 34
		/// Max length: 34
		// </param>
		/// <returns>OK</returns>
		public async Task<Eventsv1sink> FetchSinkAsync(string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Sinks/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Eventsv1sink>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new Sink Test Event for the given Sink.
		/// CreateSinkTest v1/Sinks/{Sid}/Test
		/// </summary>
		/// <param name="Sid">A 34 character string that uniquely identifies the Sink to be Tested.
		/// Min length: 34
		/// Max length: 34
		// </param>
		public async Task CreateSinkTestAsync(string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Sinks/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid))+"/Test";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a paginated list of Subscriptions belonging to the account used to make the request.
		/// ListSubscription v1/Subscriptions
		/// </summary>
		/// <param name="SinkSid">The SID of the sink that the list of Subscriptions should be filtered by.
		/// Min length: 34
		/// Max length: 34
		// </param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="Page">The page index. This value is simply for client state.
		/// Minimum: 0
		// </param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListSubscriptionReturn> ListSubscriptionAsync(string SinkSid, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Subscriptions?SinkSid=" + (SinkSid==null? "" : System.Uri.EscapeDataString(SinkSid))+"&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSubscriptionReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a specific Subscription.
		/// DeleteSubscription v1/Subscriptions/{Sid}
		/// </summary>
		/// <param name="Sid">A 34 character string that uniquely identifies this Subscription.
		/// Min length: 34
		/// Max length: 34
		// </param>
		public async Task DeleteSubscriptionAsync(string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Subscriptions/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a specific Subscription.
		/// FetchSubscription v1/Subscriptions/{Sid}
		/// </summary>
		/// <param name="Sid">A 34 character string that uniquely identifies this Subscription.
		/// Min length: 34
		/// Max length: 34
		// </param>
		/// <returns>OK</returns>
		public async Task<Eventsv1subscription> FetchSubscriptionAsync(string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Subscriptions/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Eventsv1subscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of all Subscribed Event types for a Subscription.
		/// ListSubscribedEvent v1/Subscriptions/{SubscriptionSid}/SubscribedEvents
		/// </summary>
		/// <param name="SubscriptionSid">The unique SID identifier of the Subscription.
		/// Min length: 34
		/// Max length: 34
		// </param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="Page">The page index. This value is simply for client state.
		/// Minimum: 0
		// </param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListSubscribedEventReturn> ListSubscribedEventAsync(string SubscriptionSid, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Subscriptions/"+ (SubscriptionSid==null? "" : System.Uri.EscapeDataString(SubscriptionSid))+"/SubscribedEvents&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSubscribedEventReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove an event type from a Subscription.
		/// DeleteSubscribedEvent v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}
		/// </summary>
		/// <param name="SubscriptionSid">The unique SID identifier of the Subscription.
		/// Min length: 34
		/// Max length: 34
		// </param>
		/// <param name="Type">Type of event being subscribed to.</param>
		public async Task DeleteSubscribedEventAsync(string SubscriptionSid, string Type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Subscriptions/"+ (SubscriptionSid==null? "" : System.Uri.EscapeDataString(SubscriptionSid))+"/SubscribedEvents/"+ (Type==null? "" : System.Uri.EscapeDataString(Type));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Read an Event for a Subscription.
		/// FetchSubscribedEvent v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}
		/// </summary>
		/// <param name="SubscriptionSid">The unique SID identifier of the Subscription.
		/// Min length: 34
		/// Max length: 34
		// </param>
		/// <param name="Type">Type of event being subscribed to.</param>
		/// <returns>OK</returns>
		public async Task<Eventsv1subscriptionsubscribed_event> FetchSubscribedEventAsync(string SubscriptionSid, string Type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Subscriptions/"+ (SubscriptionSid==null? "" : System.Uri.EscapeDataString(SubscriptionSid))+"/SubscribedEvents/"+ (Type==null? "" : System.Uri.EscapeDataString(Type));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Eventsv1subscriptionsubscribed_event>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a paginated list of all the available Event Types.
		/// ListEventType v1/Types
		/// </summary>
		/// <param name="SchemaId">A string parameter filtering the results to return only the Event Types using a given schema.</param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="Page">The page index. This value is simply for client state.
		/// Minimum: 0
		// </param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListEventTypeReturn> ListEventTypeAsync(string SchemaId, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Types?SchemaId=" + (SchemaId==null? "" : System.Uri.EscapeDataString(SchemaId))+"&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListEventTypeReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a specific Event Type.
		/// FetchEventType v1/Types/{Type}
		/// </summary>
		/// <param name="Type">A string that uniquely identifies this Event Type.</param>
		/// <returns>OK</returns>
		public async Task<Eventsv1event_type> FetchEventTypeAsync(string Type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Types/"+ (Type==null? "" : System.Uri.EscapeDataString(Type));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Eventsv1event_type>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class ListSchemaVersionReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListSchemaVersionReturnMeta Meta { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="schema_versions")]
		public Eventsv1schemaschema_version[] Schema_versions { get; set; }
	}
	
	public class ListSchemaVersionReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ListSinkReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListSinkReturnMeta Meta { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sinks")]
		public Eventsv1sink[] Sinks { get; set; }
	}
	
	public class ListSinkReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ListSubscriptionReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListSubscriptionReturnMeta Meta { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscriptions")]
		public Eventsv1subscription[] Subscriptions { get; set; }
	}
	
	public class ListSubscriptionReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ListSubscribedEventReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListSubscribedEventReturnMeta Meta { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="types")]
		public Eventsv1subscriptionsubscribed_event[] Types { get; set; }
	}
	
	public class ListSubscribedEventReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ListEventTypeReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListEventTypeReturnMeta Meta { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="types")]
		public Eventsv1event_type[] Types { get; set; }
	}
	
	public class ListEventTypeReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
