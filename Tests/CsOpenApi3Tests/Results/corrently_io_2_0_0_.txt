//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Balance
	{
		
		/// <summary>
		/// Sum owned - sum due by account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="balance")]
		public System.Nullable<System.Int32> Balance1 { get; set; }
		
		/// <summary>
		/// Sum owned by account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="haben")]
		public System.Nullable<System.Int32> Haben { get; set; }
		
		/// <summary>
		/// Sum due by account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="soll")]
		public System.Nullable<System.Int32> Soll { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txs")]
		public Transactions[] Txs { get; set; }
		
		/// <summary>
		/// Type of subbalance (sub account)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variation")]
		public System.Nullable<BalanceVariation> Variation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Transactions
	{
		
		/// <summary>
		/// Pretty print of counter signing party
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cashier")]
		public string Cashier { get; set; }
		
		/// <summary>
		/// Cross signed timestamp of transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeStamp")]
		public System.Nullable<System.Int32> TimeStamp { get; set; }
		
		/// <summary>
		/// Unique hash of this transaction as provided by counter signing party
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// Type of transaction per cashier implementation and schema
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txtype")]
		public string Txtype { get; set; }
		
		/// <summary>
		/// Amount covered by transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BalanceVariation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		gsb = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		erzeugung = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eigenstrom = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		co2 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		baeume = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DispatchLocation
	{
		
		/// <summary>
		/// Percentage of energy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="energy")]
		public System.Nullable<System.Double> Energy { get; set; }
		
		/// <summary>
		/// GeoJSON encoded location of target or source of green energy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForecastItem
	{
		
		/// <summary>
		/// CO2 footprint in Gramm per kwh (only Green Power)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="co2_g_oekostrom")]
		public System.Nullable<System.Int32> Co2_g_oekostrom { get; set; }
		
		/// <summary>
		/// Local/regional energyprice modification (cent per kWh or euro per MWh).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="energyprice")]
		public System.Nullable<System.Double> Energyprice { get; set; }
		
		/// <summary>
		/// Timestamps in Seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="epochtime")]
		public System.Nullable<System.Int32> Epochtime { get; set; }
		
		/// <summary>
		/// Actual GreenPowerIndex for given Timestamp (between 0-100)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gsi")]
		public System.Nullable<System.Int32> Gsi { get; set; }
		
		/// <summary>
		/// Indicates if scaling is in operation to predict values
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scaled")]
		public System.Nullable<System.Boolean> Scaled { get; set; }
		
		/// <summary>
		/// Subindex just for Solar Energy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sci")]
		public System.Nullable<System.Int32> Sci { get; set; }
		
		/// <summary>
		/// Timestamp in Standard Milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeStamp")]
		public System.Nullable<System.Int32> TimeStamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MarketData
	{
		
		/// <summary>
		/// Timestamp in Standard Milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_timestamp")]
		public System.Nullable<System.Int32> End_timestamp { get; set; }
		
		/// <summary>
		/// Actual Marketprice for regional green power in EUR per MWh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="marketprice")]
		public System.Nullable<System.Double> Marketprice { get; set; }
		
		/// <summary>
		/// Timestamp in Standard Milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_timestamp")]
		public System.Nullable<System.Int32> Start_timestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tariffh0
	{
		
		/// <summary>
		/// Energy price in cent per kwh. (Arbeitspreis) including all taxes and fees.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ap")]
		public System.Nullable<System.Int32> Ap { get; set; }
		
		/// <summary>
		/// Base price in euro per montah (Grundpreis) including all taxes and fees.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gp")]
		public System.Nullable<System.Int32> Gp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Componentsh0
	{
		
		/// <summary>
		/// Sub components of this price
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="components")]
		public Componentsh0[] Components { get; set; }
		
		/// <summary>
		/// What is this price component about
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="describtion")]
		public string Describtion { get; set; }
		
		/// <summary>
		/// Frequency/dependency of component
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mutlityplier")]
		public string Mutlityplier { get; set; }
		
		/// <summary>
		/// Single unit price multiyplier is based on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="per")]
		public System.Nullable<System.Double> Per { get; set; }
		
		/// <summary>
		/// Total sum in Euro for this price component.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sum")]
		public System.Nullable<System.Double> Sum { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Easee_charger
	{
		
		/// <summary>
		/// Given ID by easee api
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// lastSession Info as given by easee API
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSession")]
		public string LastSession { get; set; }
		
		/// <summary>
		/// Name set for charger
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Ommeters
	{
		
		/// <summary>
		/// Factor imposed on metered current by a transducer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentScalingFactor")]
		public System.Nullable<System.Int32> CurrentScalingFactor { get; set; }
		
		/// <summary>
		/// Metering load profile type associated with the meter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadProfileType")]
		public string LoadProfileType { get; set; }
		
		/// <summary>
		/// Basic address information for geo coding
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// DLMS manufacturerId
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="manufacturerId")]
		public string ManufacturerId { get; set; }
		
		/// <summary>
		/// Physical quantity being measured by the meter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="measurementType")]
		public string MeasurementType { get; set; }
		
		/// <summary>
		/// Statistical metadata for this household
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public string Meta { get; set; }
		
		/// <summary>
		/// identifier to be used in other methods like readings or activities.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meterId")]
		public string MeterId { get; set; }
		
		/// <summary>
		/// Factor imposed on metered current AND voltage by a transducer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scalingFactor")]
		public System.Nullable<System.Int32> ScalingFactor { get; set; }
		
		/// <summary>
		/// Device type of the meter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Factor imposed on metered voltage by a transducer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voltageScalingFactor")]
		public System.Nullable<System.Int32> VoltageScalingFactor { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Returns lastSession info for all easee wallboxes (chargers) given user has access to.
		/// Refer to easee.cloud API for details.
		/// 
		/// EaseeSessions alternative/easee/lastSessions
		/// </summary>
		/// <param name="username">Username as used on easy.cloud</param>
		/// <param name="password">Password as used on easy.cloud</param>
		/// <returns>Success</returns>
		public async Task<Easee_charger[]> EaseeSessionsAsync(string username, string password, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "alternative/easee/lastSessions?username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&password=" + (password==null? "" : System.Uri.EscapeDataString(password));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Easee_charger[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Last Session Info
		/// Returns lastSession info of OCCP Cloud service for clearing in corrently ecosystem. Might be tested via [OCPP cloud simulator](https://ocpp.corrently.cloud).
		/// Last session Info of managed EV charging stations connected to the correnty ecosystem.
		/// 
		/// OcppSessions alternative/ocpp/lastSessions
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Easee_charger[]> OcppSessionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "alternative/ocpp/lastSessions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Easee_charger[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Public shared smart meters installed in Germany and available for subservices and exploration.
		/// Provides a list of available meterrs in the OpenMETER project ( https://www.openmeter.de/ ) which grants access for analytics as data discovery.
		/// 
		/// OmActivities alternative/openmeter/activities
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Ommeters[]> OmActivitiesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "alternative/openmeter/activities";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ommeters[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Public shared smart meters installed in Germany and available for subservices and exploration.
		/// Provides a list of available meterrs in the OpenMETER project ( https://www.openmeter.de/ ) which grants access for analytics as data discovery.
		/// 
		/// OmMeters alternative/openmeter/meters
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Ommeters[]> OmMetersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "alternative/openmeter/meters";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ommeters[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Public shared smart meters installed in Germany and available for subservices and exploration.
		/// Provides a list of available meterrs in the OpenMETER project ( https://www.openmeter.de/ ) which grants access for analytics as data discovery.
		/// 
		/// OmReadings alternative/openmeter/readings
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Ommeters[]> OmReadingsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "alternative/openmeter/readings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ommeters[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get best hour (with most regional green energy) in a given timeframe.
		/// Simple Wrapper around the GreenPowerIndex for easy integration into almost any SmartHome system that allows access to a JSON/REST Service This endpoint is designed to indicate if a device should be turned on or off. (Switch state).
		/// 
		/// GsiBesthour gsi/bestHour
		/// </summary>
		/// <param name="zip">Zipcode (Postleitzahl) of a city in Germany.</param>
		/// <param name="key">Any valid Stromkonto account (address).</param>
		/// <param name="timeframe">Number of hours to check (default 24 hours from now).</param>
		/// <param name="hours">How many hours in row do you need the device turned on?</param>
		/// <returns>Success</returns>
		public async Task<bool> GsiBesthourAsync(string zip, string key, int timeframe, int hours, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gsi/bestHour?zip=" + (zip==null? "" : System.Uri.EscapeDataString(zip))+"&key=" + (key==null? "" : System.Uri.EscapeDataString(key))+"&timeframe="+timeframe+"&hours="+hours;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<bool>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Dispatch (Green Energy Distribution Schedule)
		/// Dispatch of green energy has two aspects to consider:
		/// - Availability of gerneration facility (depends on weather and installed capacity)
		/// - Demand of energy
		/// Using the green power index (GrünstromIndex) we have received a tool to automate distribution of energy in order to prevent redispatch situations. Doing this alows to opimize resource usage (tactical) and leverage data for investment planning (strategic).
		/// 
		/// GsiDispatch gsi/dispatch
		/// </summary>
		/// <param name="zip">Zipcode (Postleitzahl) of a city in Germany.</param>
		/// <param name="key">Any valid Stromkonto account (address).</param>
		/// <returns>Success</returns>
		public async Task<GsiDispatchReturn> GsiDispatchAsync(string zip, string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gsi/dispatch?zip=" + (zip==null? "" : System.Uri.EscapeDataString(zip))+"&key=" + (key==null? "" : System.Uri.EscapeDataString(key));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GsiDispatchReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Marketdata
		/// Compatible to awattar (https://api.awattar.de/v1/marketdata) API interface but data comes from GreenPowerIndex instead of EPEXSpot.
		/// 
		/// GsiMarketdata gsi/marketdata
		/// </summary>
		/// <param name="zip">Zipcode (Postleitzahl) of a city in Germany.</param>
		/// <returns>Success</returns>
		public async Task<GsiMarketdataReturn> GsiMarketdataAsync(string zip, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gsi/marketdata?zip=" + (zip==null? "" : System.Uri.EscapeDataString(zip));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GsiMarketdataReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Prediction
		/// Retrieval the GreenPowerIndex (GrünstromIndex) for a given city (by zipcode) in Germany.
		/// 
		/// GsiPrediction gsi/prediction
		/// </summary>
		/// <param name="zip">Zipcode (Postleitzahl) of a city in Germany.</param>
		/// <param name="key">Any valid Stromkonto account (address).</param>
		/// <returns>Success</returns>
		public async Task<GsiPredictionReturn> GsiPredictionAsync(string zip, string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "gsi/prediction?zip=" + (zip==null? "" : System.Uri.EscapeDataString(zip))+"&key=" + (key==null? "" : System.Uri.EscapeDataString(key));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GsiPredictionReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Meter Reading
		/// Retrieves a metered reading using account (Stromkonto).
		/// 
		/// MeteringGet metering/reading
		/// </summary>
		/// <param name="account">Account/Address (Stromkonto) to retrieve reading for.</param>
		/// <returns>Success</returns>
		public async Task<MeteringGetReturn> MeteringGetAsync(string account, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metering/reading?account=" + (account==null? "" : System.Uri.EscapeDataString(account));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MeteringGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Meter Reading
		/// Post meter reading and get it decorated. Best practice is to first create a new Stromkonto with the register method and choose a nice secret to protect updates. Now regularly send updates to get readings (consumption) split into green power (1.8.1) and grey power (1.8.2).
		/// 
		/// MeteringPost metering/reading
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MeteringPostReturn> MeteringPostAsync(MeteringPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metering/reading";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MeteringPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Finishs a collection of data and finalizes receipt. Use this method after collecting all data via quittung/prepare
		/// Uses collected fields or provided fields to create a final receipt (Strom-Quittung).
		/// 
		/// QuittungComit quittung/commit
		/// </summary>
		/// <returns>Success</returns>
		public async Task<string> QuittungComitAsync(QuittungComitPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "quittung/commit";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a receipt for an energy delivery (only valid in Germany).
		/// Creates a full featured receipt (Quittung) for an energy delivery as it appears on a charging session or similar events. Allows to embed receipt generation directly into external services.
		/// 
		/// QuittungCreate quittung/create
		/// </summary>
		/// <returns>Success</returns>
		public async Task<string> QuittungCreateAsync(QuittungCreatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "quittung/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Allows to collect data with several requests (or a single) for a receipt.
		/// During the first call an account parameter will be returned within the result object. Any other parameter will be set inside the preperation. If account is put into body/request in following requests, the existing collection will be extended/updated with the provided body parameters/values.
		/// 
		/// QuittungPrepare quittung/prepare
		/// </summary>
		/// <returns>Success</returns>
		public async Task<string> QuittungPrepareAsync(QuittungPreparePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "quittung/prepare";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve TSE (Technische Sicherheitseinrichtung) Data for a given receipt (Strom-Quittung).
		/// Allows to retrieve all relevant data assiciated to a TSE service call. E.q. Input parameters, public key and signature.
		/// 
		/// QuittungTSE quittung/tse
		/// </summary>
		/// <param name="account">Quittung Identifier  (serialnumber generated during receipt generation process)</param>
		/// <returns>Success</returns>
		public async Task<QuittungTSEReturn> QuittungTSEAsync(string account, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "quittung/tse?account=" + (account==null? "" : System.Uri.EscapeDataString(account));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<QuittungTSEReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve TSE (Technische Sicherheitseinrichtung) raw data  only for a given receipt (Strom-Quittung).
		/// Allows to retrieve input string for a signing process.
		/// 
		/// QuittungTSEData quittung/tsedata
		/// </summary>
		/// <param name="account">Quittung Identifier  (serialnumber generated during receipt generation process)</param>
		/// <returns>Success</returns>
		public async Task QuittungTSEDataAsync(string account, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "quittung/tsedata?account=" + (account==null? "" : System.Uri.EscapeDataString(account));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve TSE (Technische Sicherheitseinrichtung) Signature only for a given receipt (Strom-Quittung).
		/// Allows to retrieve digital signature for a given receipt.
		/// 
		/// QuittungTSEsignature quittung/tsesignature
		/// </summary>
		/// <param name="account">Quittung Identifier  (serialnumber generated during receipt generation process)</param>
		/// <returns>Success</returns>
		public async Task QuittungTSEsignatureAsync(string account, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "quittung/tsesignature?account=" + (account==null? "" : System.Uri.EscapeDataString(account));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve Zugferd XML for a given receipt (Strom-Quittung).
		/// Allows to retrieve XML of the zugferd invoice.
		/// 
		/// QuittungZugferd quittung/zugferd
		/// </summary>
		/// <param name="account">Quittung Identifier  (serialnumber generated during receipt generation process)</param>
		/// <returns>Success</returns>
		public async Task QuittungZugferdAsync(string account, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "quittung/zugferd?account=" + (account==null? "" : System.Uri.EscapeDataString(account));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Balances
		/// Stromkonto represents a core component of the Corrently Ecosystem. It is a ledger for green energy related transactions and gets heavily used by the public Web-UI on www.stromkonto.net . Beside of some decoration and reformating operations all data is backed by the [Energychain blockchain](https://github.com/energychain/) to provide consensus of balances and transactions. Use this API Endppoint if you prefere not to work with low level Distributed Ledger Technology (Blockchain).
		/// 
		/// StromkontoBalances stromkonto/balances
		/// </summary>
		/// <param name="account">Ethereum style address referencing a valid account (AKA Stromkonto).</param>
		/// <returns>Success</returns>
		public async Task<Balance[]> StromkontoBalancesAsync(string account, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stromkonto/balances?account=" + (account==null? "" : System.Uri.EscapeDataString(account));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Balance[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Selectable Choices for customer
		/// Signable choices (contract changes) for customer.
		/// 
		/// StromkontoChoices stromkonto/choices
		/// </summary>
		/// <param name="account">Ethereum style address referencing a valid account alias (never use Stromkonto directly!).</param>
		/// <returns>Success</returns>
		public async Task<Balance[]> StromkontoChoicesAsync(string account, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stromkonto/choices?account=" + (account==null? "" : System.Uri.EscapeDataString(account));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Balance[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Login (via Mail)
		/// Sends a mail to a given email address to login this user. This function makes life a bit easier in order to not having to deal with private key protection on the user side as a shared key is used to sign transactions onbehalf of a particular account.  However viewing consensus information (balances) are public and *might move* from account to account without prior notification. Best practice for third party uses is to always start a session with the login RESP call and only create a user in case the response indicates an `unregistered` status.
		/// 
		/// StromkontoLogin stromkonto/login
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StromkontoLoginReturn> StromkontoLoginAsync(StromkontoLoginPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stromkonto/login";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StromkontoLoginReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Prepare Transaction
		/// Prepares and inques a transaction (transfer) between two accounts (Stromkonten). This might be used to send any balanced entity. Using this endpoint will only prepare the transaction and enques it for signing and countersigning. This is done from within the user UI using validation process. Note: This API method does not validate any transations. In other words authentication, authorization, validation and actual transfer of value is done using a smart contract during processing in the energy blockchain.
		/// 
		/// PrepareTransaction stromkonto/prepareTransaction
		/// </summary>
		/// <returns>Success</returns>
		public async Task PrepareTransactionAsync(PrepareTransactionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stromkonto/prepareTransaction";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Register (new Stromkonto)
		/// Calling this method with an unregistered (new) email will create a new account (Stromkonto) with all balances having a value of `0` and no transaction history. In addition some basic properties like region and zipcode are set to allow further operation of account.
		/// 
		/// StromkontoRegister stromkonto/register
		/// </summary>
		/// <returns>Success</returns>
		public async Task StromkontoRegisterAsync(StromkontoRegisterPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stromkonto/register";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Energy Tariff price components
		/// Provides insides into the different cost components of energy for a private household.
		/// Sample Request: https://api.corrently.io/v2.0/tariff/components?email=demo%40corrently.io&zip=69168&kwha=3300
		/// 
		/// Tariffcomponents tariff/components
		/// </summary>
		/// <param name="zipcode">Zipcode (Postzleitzahl) of a city in Germany.</param>
		/// <param name="email">Valid email address to assign request to (pre offer generation). Ensure GDPR (DSGVO) at any time</param>
		/// <param name="kwha">Total amount of energy in kilo-watt-hours per year. (sample 2100)</param>
		/// <param name="milliseconds">If provided all results will be scaled to this timeframe</param>
		/// <param name="wh">If provided together with milliseconds, a cost component stament for a particular event (like charging a car) will be created.</param>
		/// <returns>Success</returns>
		public async Task<Componentsh0> TariffcomponentsAsync(string zipcode, string email, int kwha, int milliseconds, int wh, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tariff/components?zipcode=" + (zipcode==null? "" : System.Uri.EscapeDataString(zipcode))+"&email=" + (email==null? "" : System.Uri.EscapeDataString(email))+"&kwha="+kwha+"&milliseconds="+milliseconds+"&wh="+wh;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Componentsh0>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Energy Tariff information
		/// Provides pricing data for private households with standard load profiles (Standardlastprofil H0).
		/// 
		/// TariffSLPH0 tariff/slph0
		/// </summary>
		/// <param name="zipcode">Zipcode (Postzleitzahl) of a city in Germany.</param>
		/// <returns>Success</returns>
		public async Task<Tariffh0[]> TariffSLPH0Async(string zipcode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tariff/slph0?zipcode=" + (zipcode==null? "" : System.Uri.EscapeDataString(zipcode));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Tariffh0[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// WiM Proess Informtion
		/// Access to status information of an existing metering change and allocation process.
		/// 
		/// Wimstatus wim/status
		/// </summary>
		/// <param name="vid">VID key of the process.</param>
		/// <returns>Success</returns>
		public async Task<WimstatusReturn> WimstatusAsync(string vid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "wim/status?vid=" + (vid==null? "" : System.Uri.EscapeDataString(vid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WimstatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class GsiDispatchReturn
	{
		
		/// <summary>
		/// Averaged geospatial distance in kilometers between energy generation and usage at requested location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avg_distance_km")]
		public System.Nullable<System.Double> Avg_distance_km { get; set; }
		
		/// <summary>
		/// List of current sources of green energy (into requested location)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dispatch_from")]
		public DispatchLocation[] Dispatch_from { get; set; }
		
		/// <summary>
		/// List of current targets of green energy (out of requested location)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dispatch_target")]
		public DispatchLocation[] Dispatch_target { get; set; }
		
		/// <summary>
		/// Green Energy Mix after dispatch of given city
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postmix")]
		public string Postmix { get; set; }
		
		/// <summary>
		/// Green Energy Mix prior to dispatch of given city
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="premix")]
		public string Premix { get; set; }
		
		/// <summary>
		/// Evaluated timeframe for this request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeframe")]
		public GsiDispatchReturnTimeframe Timeframe { get; set; }
	}
	
	public class GsiDispatchReturnTimeframe
	{
		
		/// <summary>
		/// Ending time of window evaluated for this request/dispatches.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public System.Nullable<System.Int32> End { get; set; }
		
		/// <summary>
		/// Starting time of window evaluated in order to get dispatches
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public System.Nullable<System.Int32> Start { get; set; }
	}
	
	public class GsiMarketdataReturn
	{
		
		/// <summary>
		/// Energyprice for the upcomming hours
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MarketData[] Data { get; set; }
	}
	
	public class GsiPredictionReturn
	{
		
		/// <summary>
		/// Prediction for the upcomming hours
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forecast")]
		public ForecastItem[] Forecast { get; set; }
		
		/// <summary>
		/// Standarized location info sourced for prediction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public GsiPredictionReturnLocation Location { get; set; }
		
		/// <summary>
		/// Device switching recommendation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matrix")]
		public GsiPredictionReturnMatrix Matrix { get; set; }
	}
	
	public class GsiPredictionReturnLocation
	{
		
		/// <summary>
		/// Pretty Print city name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// Zipcode (Postleitzahl)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zip")]
		public string Zip { get; set; }
	}
	
	public class GsiPredictionReturnMatrix
	{
		
		/// <summary>
		/// Indicates number of hours a device should run
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="h0")]
		public GsiPredictionReturnMatrixH0 H0 { get; set; }
	}
	
	public class GsiPredictionReturnMatrixH0
	{
		
		/// <summary>
		/// device should run in 1 hour
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avg_1")]
		public string Avg_1 { get; set; }
		
		/// <summary>
		/// device should run in 2 hours
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avg_2")]
		public string Avg_2 { get; set; }
		
		/// <summary>
		/// device should run in 3 hour
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avg_3")]
		public string Avg_3 { get; set; }
	}
	
	public class MeteringGetReturn
	{
		
		/// <summary>
		/// Reading as provided as input in Wh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1.8.0")]
		public System.Nullable<System.Int32> _1_8_0 { get; set; }
		
		/// <summary>
		/// Green energy calculated using Green Power Index (GrünstromIndex) in Wh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1.8.1")]
		public System.Nullable<System.Int32> _1_8_1 { get; set; }
		
		/// <summary>
		/// Grey energy calculated using Green Power Index (GrünstromIndex) in Wh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1.8.2")]
		public System.Nullable<System.Int32> _1_8_2 { get; set; }
		
		/// <summary>
		/// Time this reading got imported into consensus (e.q. signed timestamp).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> _processingTime { get; set; }
		
		/// <summary>
		/// Stromkonto/Metering address allocated (this is not the MELOID!)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public string Account { get; set; }
		
		/// <summary>
		/// CO2 Emission of metered energy in a green energy mix (e.q. Ökostromtarif)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="co2_g_oekostrom")]
		public System.Nullable<System.Int32> Co2_g_oekostrom { get; set; }
		
		/// <summary>
		/// CO2 Emission of metered energy in a standard mix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="co2_g_standard")]
		public System.Nullable<System.Int32> Co2_g_standard { get; set; }
		
		/// <summary>
		/// Update credits this meter has. Gets refilled automtically to prevent too frequent updates
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credits")]
		public object Credits { get; set; }
		
		/// <summary>
		/// API Consensus time this reading was fully received
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeStamp")]
		public System.Nullable<System.Int32> TimeStamp { get; set; }
		
		/// <summary>
		/// Time to Live for this reader. If no update is provided it gets decommissioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
	}
	
	public class MeteringPostPostBody
	{
		
		/// <summary>
		/// Meter Reading (prefered in Wh)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1.8.0")]
		public System.Nullable<System.Int32> _1_8_0 { get; set; }
		
		/// <summary>
		/// Stromkonto account (address) associated with this metering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public string Account { get; set; }
		
		/// <summary>
		/// Alias for 1.8.0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="energy")]
		public System.Nullable<System.Int32> Energy { get; set; }
		
		/// <summary>
		/// Some private password you might choose on first update. However you need to use the same secret on every further posts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// Alias for 1.8.0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
		
		/// <summary>
		/// Zipcode (Postleitzahl) of metered location
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zip")]
		public string Zip { get; set; }
	}
	
	public class MeteringPostReturn
	{
		
		/// <summary>
		/// Reading as provided as input in Wh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1.8.0")]
		public System.Nullable<System.Int32> _1_8_0 { get; set; }
		
		/// <summary>
		/// Green energy calculated using Green Power Index (GrünstromIndex) in Wh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1.8.1")]
		public System.Nullable<System.Int32> _1_8_1 { get; set; }
		
		/// <summary>
		/// Grey energy calculated using Green Power Index (GrünstromIndex) in Wh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1.8.2")]
		public System.Nullable<System.Int32> _1_8_2 { get; set; }
		
		/// <summary>
		/// Time this reading got imported into consensus (e.q. signed timestamp).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> _processingTime { get; set; }
		
		/// <summary>
		/// Stromkonto/Metering address allocated (this is not the MELOID!)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public string Account { get; set; }
		
		/// <summary>
		/// CO2 Emission of metered energy in a green energy mix (e.q. Ökostromtarif)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="co2_g_oekostrom")]
		public System.Nullable<System.Int32> Co2_g_oekostrom { get; set; }
		
		/// <summary>
		/// CO2 Emission of metered energy in a standard mix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="co2_g_standard")]
		public System.Nullable<System.Int32> Co2_g_standard { get; set; }
		
		/// <summary>
		/// API Consensus time this reading was fully received
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeStamp")]
		public System.Nullable<System.Int32> TimeStamp { get; set; }
	}
	
	public class QuittungComitPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="account")]
		public string Account { get; set; }
	}
	
	public class QuittungCreatePostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
	}
	
	public class QuittungPreparePostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="account")]
		public string Account { get; set; }
	}
	
	public class QuittungTSEReturn
	{
		
		/// <summary>
		/// JSON object that got signed by TSE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public object Data { get; set; }
		
		/// <summary>
		/// Public Key of TSE
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publickey")]
		public string Publickey { get; set; }
		
		/// <summary>
		/// Datastring of JSON Object as it got used to create signature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="raw")]
		public string Raw { get; set; }
		
		/// <summary>
		/// Resulting signature by signing raw datastring using private key of TSE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
	}
	
	public class StromkontoLoginPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
	}
	
	public class StromkontoLoginReturn
	{
		
		/// <summary>
		/// Registration status of a user. In case unregistered gets returned use the `register` endpoint to (re-)register.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<StromkontoLoginReturnStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum StromkontoLoginReturnStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		registered = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unregistered = 1,
	}
	
	public class PrepareTransactionPostBody
	{
		
		/// <summary>
		/// Stromkonto account address of sender
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public string Account { get; set; }
		
		/// <summary>
		/// Signature per Stromkonto setting (might be simple email confirmation link)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
		
		/// <summary>
		/// Stromkonto account address of reciever
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
		
		/// <summary>
		/// Amount to transfer (in Watthours for electricity, or pcs for trees)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="variation")]
		public BalanceVariation Variation { get; set; }
	}
	
	public class StromkontoRegisterPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="first_name")]
		public string First_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_name")]
		public string Last_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="zipcode")]
		public string Zipcode { get; set; }
	}
	
	public class WimstatusReturn
	{
		
		/// <summary>
		/// Starting time of process
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wim_started")]
		public System.Nullable<System.Int32> Wim_started { get; set; }
		
		/// <summary>
		/// Latest Status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wim_status")]
		public string Wim_status { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
