//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalServerException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThrottlingException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessDeniedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CancelPolicyGenerationResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateAccessPreviewResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Access control configuration structures for your resource. You specify the configuration as a type-value pair. You can specify only one type of access control configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Configuration
	{
		
		[System.Runtime.Serialization.DataMember(Name="ebsSnapshot")]
		public EbsSnapshotConfiguration EbsSnapshot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ecrRepository")]
		public EcrRepositoryConfiguration EcrRepository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="iamRole")]
		public IamRoleConfiguration IamRole { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="efsFileSystem")]
		public EfsFileSystemConfiguration EfsFileSystem { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kmsKey")]
		public KmsKeyConfiguration KmsKey { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rdsDbClusterSnapshot")]
		public RdsDbClusterSnapshotConfiguration RdsDbClusterSnapshot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rdsDbSnapshot")]
		public RdsDbSnapshotConfiguration RdsDbSnapshot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secretsManagerSecret")]
		public SecretsManagerSecretConfiguration SecretsManagerSecret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="s3Bucket")]
		public S3BucketConfiguration S3Bucket { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snsTopic")]
		public SnsTopicConfiguration SnsTopic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sqsQueue")]
		public SqsQueueConfiguration SqsQueue { get; set; }
	}
	
	/// <summary>
	/// The proposed access control configuration for an Amazon EBS volume snapshot. You can propose a configuration for a new Amazon EBS volume snapshot or an Amazon EBS volume snapshot that you own by specifying the user IDs, groups, and optional KMS encryption key. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySnapshotAttribute.html">ModifySnapshotAttribute</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EbsSnapshotConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="userIds")]
		public string[] UserIds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public string[] Groups { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kmsKeyId")]
		public string KmsKeyId { get; set; }
	}
	
	/// <summary>
	/// <p>The proposed access control configuration for an Amazon ECR repository. You can propose a configuration for a new Amazon ECR repository or an existing Amazon ECR repository that you own by specifying the Amazon ECR policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_Repository.html">Repository</a>.</p> <ul> <li> <p>If the configuration is for an existing Amazon ECR repository and you do not specify the Amazon ECR policy, then the access preview uses the existing Amazon ECR policy for the repository.</p> </li> <li> <p>If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon ECR repository without a policy.</p> </li> <li> <p>To propose deletion of an existing Amazon ECR repository policy, you can specify an empty string for the Amazon ECR policy.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EcrRepositoryConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="repositoryPolicy")]
		public string RepositoryPolicy { get; set; }
	}
	
	/// <summary>
	/// The proposed access control configuration for an IAM role. You can propose a configuration for a new IAM role or an existing IAM role that you own by specifying the trust policy. If the configuration is for a new IAM role, you must specify the trust policy. If the configuration is for an existing IAM role that you own and you do not propose the trust policy, the access preview uses the existing trust policy for the role. The proposed trust policy cannot be an empty string. For more information about role trust policy limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html">IAM and STS quotas</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IamRoleConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="trustPolicy")]
		public string TrustPolicy { get; set; }
	}
	
	/// <summary>
	/// <p>The proposed access control configuration for an Amazon EFS file system. You can propose a configuration for a new Amazon EFS file system or an existing Amazon EFS file system that you own by specifying the Amazon EFS policy. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/using-fs.html">Using file systems in Amazon EFS</a>.</p> <ul> <li> <p>If the configuration is for an existing Amazon EFS file system and you do not specify the Amazon EFS policy, then the access preview uses the existing Amazon EFS policy for the file system.</p> </li> <li> <p>If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon EFS file system without a policy.</p> </li> <li> <p>To propose deletion of an existing Amazon EFS file system policy, you can specify an empty string for the Amazon EFS policy.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EfsFileSystemConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="fileSystemPolicy")]
		public string FileSystemPolicy { get; set; }
	}
	
	/// <summary>
	/// <p>Proposed access control configuration for a KMS key. You can propose a configuration for a new KMS key or an existing KMS key that you own by specifying the key policy and KMS grant configuration. If the configuration is for an existing key and you do not specify the key policy, the access preview uses the existing policy for the key. If the access preview is for a new resource and you do not specify the key policy, then the access preview uses the default key policy. The proposed key policy cannot be an empty string. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default">Default key policy</a>. For more information about key policy limits, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/resource-limits.html">Resource quotas</a>.</p> <p/>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmsKeyConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="keyPolicies")]
		public KmsKeyPoliciesMap KeyPolicies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="grants")]
		public KmsGrantConfiguration[] Grants { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmsKeyPoliciesMap
	{
	}
	
	/// <summary>
	/// A proposed grant configuration for a KMS key. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateGrant.html">CreateGrant</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmsGrantConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public KmsGrantOperation[] Operations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="granteePrincipal")]
		public string GranteePrincipal { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="retiringPrincipal")]
		public string RetiringPrincipal { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public KmsGrantConstraints Constraints { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issuingAccount")]
		public string IssuingAccount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum KmsGrantOperation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CreateGrant")]
		CreateGrant = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Decrypt")]
		Decrypt = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DescribeKey")]
		DescribeKey = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Encrypt")]
		Encrypt = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GenerateDataKey")]
		GenerateDataKey = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GenerateDataKeyPair")]
		GenerateDataKeyPair = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GenerateDataKeyPairWithoutPlaintext")]
		GenerateDataKeyPairWithoutPlaintext = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GenerateDataKeyWithoutPlaintext")]
		GenerateDataKeyWithoutPlaintext = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GetPublicKey")]
		GetPublicKey = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ReEncryptFrom")]
		ReEncryptFrom = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ReEncryptTo")]
		ReEncryptTo = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RetireGrant")]
		RetireGrant = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sign")]
		Sign = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Verify")]
		Verify = 13,
	}
	
	/// <summary>
	/// Use this structure to propose allowing <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic operations</a> in the grant only when the operation request includes the specified <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">encryption context</a>. You can specify only one type of encryption context. An empty map is treated as not specified. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_GrantConstraints.html">GrantConstraints</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmsGrantConstraints
	{
		
		[System.Runtime.Serialization.DataMember(Name="encryptionContextEquals")]
		public KmsConstraintsMap EncryptionContextEquals { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="encryptionContextSubset")]
		public KmsConstraintsMap EncryptionContextSubset { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmsConstraintsMap
	{
	}
	
	/// <summary>
	/// The proposed access control configuration for an Amazon RDS DB cluster snapshot. You can propose a configuration for a new Amazon RDS DB cluster snapshot or an Amazon RDS DB cluster snapshot that you own by specifying the <code>RdsDbClusterSnapshotAttributeValue</code> and optional KMS encryption key. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBClusterSnapshotAttribute.html">ModifyDBClusterSnapshotAttribute</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RdsDbClusterSnapshotConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public RdsDbClusterSnapshotAttributesMap Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kmsKeyId")]
		public string KmsKeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RdsDbClusterSnapshotAttributesMap
	{
	}
	
	/// <summary>
	/// The proposed access control configuration for an Amazon RDS DB snapshot. You can propose a configuration for a new Amazon RDS DB snapshot or an Amazon RDS DB snapshot that you own by specifying the <code>RdsDbSnapshotAttributeValue</code> and optional KMS encryption key. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBSnapshotAttribute.html">ModifyDBSnapshotAttribute</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RdsDbSnapshotConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public RdsDbSnapshotAttributesMap Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kmsKeyId")]
		public string KmsKeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RdsDbSnapshotAttributesMap
	{
	}
	
	/// <summary>
	/// <p>The configuration for a Secrets Manager secret. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html">CreateSecret</a>.</p> <p>You can propose a configuration for a new secret or an existing secret that you own by specifying the secret policy and optional KMS encryption key. If the configuration is for an existing secret and you do not specify the secret policy, the access preview uses the existing policy for the secret. If the access preview is for a new resource and you do not specify the policy, the access preview assumes a secret without a policy. To propose deletion of an existing policy, you can specify an empty string. If the proposed configuration is for a new secret and you do not specify the KMS key ID, the access preview uses the Amazon Web Services managed key <code>aws/secretsmanager</code>. If you specify an empty string for the KMS key ID, the access preview uses the Amazon Web Services managed key of the Amazon Web Services account. For more information about secret policy limits, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_limits.html">Quotas for Secrets Manager.</a>.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecretsManagerSecretConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="kmsKeyId")]
		public string KmsKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secretPolicy")]
		public string SecretPolicy { get; set; }
	}
	
	/// <summary>
	/// Proposed access control configuration for an Amazon S3 bucket. You can propose a configuration for a new Amazon S3 bucket or an existing Amazon S3 bucket that you own by specifying the Amazon S3 bucket policy, bucket ACLs, bucket BPA settings, Amazon S3 access points, and multi-region access points attached to the bucket. If the configuration is for an existing Amazon S3 bucket and you do not specify the Amazon S3 bucket policy, the access preview uses the existing policy attached to the bucket. If the access preview is for a new resource and you do not specify the Amazon S3 bucket policy, the access preview assumes a bucket without a policy. To propose deletion of an existing bucket policy, you can specify an empty string. For more information about bucket policy limits, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html">Bucket Policy Examples</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class S3BucketConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="bucketPolicy")]
		public string BucketPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bucketAclGrants")]
		public S3BucketAclGrantConfiguration[] BucketAclGrants { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bucketPublicAccessBlock")]
		public S3PublicAccessBlockConfiguration BucketPublicAccessBlock { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="accessPoints")]
		public S3AccessPointConfigurationsMap AccessPoints { get; set; }
	}
	
	/// <summary>
	/// A proposed access control list grant configuration for an Amazon S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#setting-acls">How to Specify an ACL</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class S3BucketAclGrantConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public AclPermission Permission { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="grantee")]
		public AclGrantee Grantee { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AclPermission
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="READ")]
		READ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WRITE")]
		WRITE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="READ_ACP")]
		READ_ACP = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WRITE_ACP")]
		WRITE_ACP = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FULL_CONTROL")]
		FULL_CONTROL = 4,
	}
	
	/// <summary>
	/// You specify each grantee as a type-value pair using one of these types. You can specify only one type of grantee. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketAcl.html">PutBucketAcl</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AclGrantee
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// The <code>PublicAccessBlock</code> configuration to apply to this Amazon S3 bucket. If the proposed configuration is for an existing Amazon S3 bucket and the configuration is not specified, the access preview uses the existing setting. If the proposed configuration is for a new bucket and the configuration is not specified, the access preview uses <code>false</code>. If the proposed configuration is for a new access point or multi-region access point and the access point BPA configuration is not specified, the access preview uses <code>true</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html">PublicAccessBlockConfiguration</a>. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class S3PublicAccessBlockConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ignorePublicAcls")]
		public bool IgnorePublicAcls { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restrictPublicBuckets")]
		public bool RestrictPublicBuckets { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class S3AccessPointConfigurationsMap
	{
	}
	
	/// <summary>
	/// The proposed access control configuration for an Amazon SNS topic. You can propose a configuration for a new Amazon SNS topic or an existing Amazon SNS topic that you own by specifying the policy. If the configuration is for an existing Amazon SNS topic and you do not specify the Amazon SNS policy, then the access preview uses the existing Amazon SNS policy for the topic. If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon SNS topic without a policy. To propose deletion of an existing Amazon SNS topic policy, you can specify an empty string for the Amazon SNS policy. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_Topic.html">Topic</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnsTopicConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="topicPolicy")]
		public string TopicPolicy { get; set; }
	}
	
	/// <summary>
	/// The proposed access control configuration for an Amazon SQS queue. You can propose a configuration for a new Amazon SQS queue or an existing Amazon SQS queue that you own by specifying the Amazon SQS policy. If the configuration is for an existing Amazon SQS queue and you do not specify the Amazon SQS policy, the access preview uses the existing Amazon SQS policy for the queue. If the access preview is for a new resource and you do not specify the policy, the access preview assumes an Amazon SQS queue without a policy. To propose deletion of an existing Amazon SQS queue policy, you can specify an empty string for the Amazon SQS policy. For more information about Amazon SQS policy limits, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-policies.html">Quotas related to policies</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SqsQueueConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="queuePolicy")]
		public string QueuePolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceQuotaExceededException
	{
	}
	
	/// <summary>
	/// The response to the request to create an analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateAnalyzerResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	/// <summary>
	/// An criterion statement in an archive rule. Each archive rule may have multiple criteria.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InlineArchiveRule
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleName")]
		public string RuleName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public FilterCriteriaMap Filter { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilterCriteriaMap
	{
	}
	
	/// <summary>
	/// The criteria to use in the filter that defines the archive rule. For more information on available filter keys, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html">IAM Access Analyzer filter keys</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Criterion
	{
		
		[System.Runtime.Serialization.DataMember(Name="eq")]
		public string[] Eq { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="neq")]
		public string[] Neq { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="contains")]
		public string[] Contains { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exists")]
		public System.Nullable<System.Boolean> Exists { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAccessPreviewResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accessPreview")]
		public AccessPreview AccessPreview { get; set; }
	}
	
	/// <summary>
	/// Contains information about an access preview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessPreview
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configurations")]
		public ConfigurationsMap Configurations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public AccessPreviewStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statusReason")]
		public AccessPreviewStatusReason StatusReason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationsMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AccessPreviewStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPLETED")]
		COMPLETED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 2,
	}
	
	/// <summary>
	/// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a <code>Failed</code> status is returned. This failure can be due to an internal issue with the analysis or due to an invalid proposed resource configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessPreviewStatusReason
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AccessPreviewStatusReasonCode Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AccessPreviewStatusReasonCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INTERNAL_ERROR")]
		INTERNAL_ERROR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_CONFIGURATION")]
		INVALID_CONFIGURATION = 1,
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAnalyzedResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public AnalyzedResource Resource { get; set; }
	}
	
	/// <summary>
	/// Contains details about the analyzed resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalyzedResource
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public ResourceType ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzedAt")]
		public System.DateTimeOffset AnalyzedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isPublic")]
		public bool IsPublic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public string[] Actions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sharedVia")]
		public string[] SharedVia { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public FindingStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerAccount")]
		public string ResourceOwnerAccount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3::Bucket")]
		AWSS3Bucket = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::IAM::Role")]
		AWSIAMRole = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::SQS::Queue")]
		AWSSQSQueue = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::Lambda::Function")]
		AWSLambdaFunction = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::Lambda::LayerVersion")]
		AWSLambdaLayerVersion = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::KMS::Key")]
		AWSKMSKey = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::SecretsManager::Secret")]
		AWSSecretsManagerSecret = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::EFS::FileSystem")]
		AWSEFSFileSystem = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::EC2::Snapshot")]
		AWSEC2Snapshot = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::ECR::Repository")]
		AWSECRRepository = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::RDS::DBSnapshot")]
		AWSRDSDBSnapshot = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::RDS::DBClusterSnapshot")]
		AWSRDSDBClusterSnapshot = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::SNS::Topic")]
		AWSSNSTopic = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FindingStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ARCHIVED")]
		ARCHIVED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RESOLVED")]
		RESOLVED = 2,
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAnalyzerResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzer")]
		public AnalyzerSummary Analyzer { get; set; }
	}
	
	/// <summary>
	/// Contains information about the analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalyzerSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Type Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastResourceAnalyzed")]
		public string LastResourceAnalyzed { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastResourceAnalyzedAt")]
		public System.DateTimeOffset LastResourceAnalyzedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagsMap Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public AnalyzerStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statusReason")]
		public StatusReason StatusReason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACCOUNT")]
		ACCOUNT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ORGANIZATION")]
		ORGANIZATION = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagsMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AnalyzerStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 3,
	}
	
	/// <summary>
	/// Provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a <code>Failed</code> status is returned. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the Amazon Web Services organization.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatusReason
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public ReasonCode Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReasonCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS_SERVICE_ACCESS_DISABLED")]
		AWS_SERVICE_ACCESS_DISABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELEGATED_ADMINISTRATOR_DEREGISTERED")]
		DELEGATED_ADMINISTRATOR_DEREGISTERED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ORGANIZATION_DELETED")]
		ORGANIZATION_DELETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SERVICE_LINKED_ROLE_CREATION_FAILED")]
		SERVICE_LINKED_ROLE_CREATION_FAILED = 3,
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetArchiveRuleResponse
	{
		
		/// <summary>
		/// Contains information about an archive rule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archiveRule")]
		public ArchiveRuleSummary ArchiveRule { get; set; }
	}
	
	/// <summary>
	/// Contains information about an archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArchiveRuleSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleName")]
		public string RuleName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public FilterCriteriaMap Filter { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetFindingResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="finding")]
		public Finding Finding { get; set; }
	}
	
	/// <summary>
	/// Contains information about a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Finding
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="principal")]
		public PrincipalMap Principal { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string[] Action { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isPublic")]
		public System.Nullable<System.Boolean> IsPublic { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public ResourceType ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="condition")]
		public ConditionKeyMap Condition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzedAt")]
		public System.DateTimeOffset AnalyzedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public FindingStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerAccount")]
		public string ResourceOwnerAccount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public FindingSource[] Sources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrincipalMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConditionKeyMap
	{
	}
	
	/// <summary>
	/// The source of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FindingSource
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FindingSourceType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public FindingSourceDetail Detail { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FindingSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="POLICY")]
		POLICY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BUCKET_ACL")]
		BUCKET_ACL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="S3_ACCESS_POINT")]
		S3_ACCESS_POINT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="S3_ACCESS_POINT_ACCOUNT")]
		S3_ACCESS_POINT_ACCOUNT = 3,
	}
	
	/// <summary>
	/// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FindingSourceDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="accessPointArn")]
		public string AccessPointArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="accessPointAccount")]
		public string AccessPointAccount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetGeneratedPolicyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobDetails")]
		public JobDetails JobDetails { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="generatedPolicyResult")]
		public GeneratedPolicyResult GeneratedPolicyResult { get; set; }
	}
	
	/// <summary>
	/// Contains details about the policy generation request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobId")]
		public string JobId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public JobStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startedOn")]
		public System.DateTimeOffset StartedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="completedOn")]
		public System.DateTimeOffset CompletedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="jobError")]
		public JobError JobError { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum JobStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IN_PROGRESS")]
		IN_PROGRESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SUCCEEDED")]
		SUCCEEDED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CANCELED")]
		CANCELED = 3,
	}
	
	/// <summary>
	/// Contains the details about the policy generation error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobError
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public JobErrorCode Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum JobErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AUTHORIZATION_ERROR")]
		AUTHORIZATION_ERROR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RESOURCE_NOT_FOUND_ERROR")]
		RESOURCE_NOT_FOUND_ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SERVICE_QUOTA_EXCEEDED_ERROR")]
		SERVICE_QUOTA_EXCEEDED_ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SERVICE_ERROR")]
		SERVICE_ERROR = 3,
	}
	
	/// <summary>
	/// Contains the text for the generated policy and its details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GeneratedPolicyResult
	{
		
		/// <summary>
		/// A <code>GeneratedPolicyProperties</code> object that contains properties of the generated policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public object Properties { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="generatedPolicies")]
		public GeneratedPolicy[] GeneratedPolicies { get; set; }
	}
	
	/// <summary>
	/// Contains the text for the generated policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GeneratedPolicy
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAccessPreviewFindingsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findings")]
		public AccessPreviewFinding[] Findings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// An access preview finding generated by the access preview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessPreviewFinding
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="existingFindingId")]
		public string ExistingFindingId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="existingFindingStatus")]
		public FindingStatus ExistingFindingStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="principal")]
		public PrincipalMap Principal { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string[] Action { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="condition")]
		public ConditionKeyMap Condition { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isPublic")]
		public System.Nullable<System.Boolean> IsPublic { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public ResourceType ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="changeType")]
		public FindingChangeType ChangeType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public FindingStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerAccount")]
		public string ResourceOwnerAccount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public FindingSource[] Sources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FindingChangeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CHANGED")]
		CHANGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NEW")]
		NEW = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNCHANGED")]
		UNCHANGED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAccessPreviewsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accessPreviews")]
		public AccessPreviewSummary[] AccessPreviews { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains a summary of information about an access preview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessPreviewSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public AccessPreviewStatus Status { get; set; }
		
		/// <summary>
		/// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a <code>Failed</code> status is returned. This failure can be due to an internal issue with the analysis or due to an invalid proposed resource configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusReason")]
		public AccessPreviewStatusReason StatusReason { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAnalyzedResourcesResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzedResources")]
		public AnalyzedResourceSummary[] AnalyzedResources { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains the ARN of the analyzed resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalyzedResourceSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerAccount")]
		public string ResourceOwnerAccount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public ResourceType ResourceType { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAnalyzersResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzers")]
		public AnalyzerSummary[] Analyzers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListArchiveRulesResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archiveRules")]
		public ArchiveRuleSummary[] ArchiveRules { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListFindingsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findings")]
		public FindingSummary[] Findings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains information about a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FindingSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="principal")]
		public PrincipalMap Principal { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string[] Action { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isPublic")]
		public System.Nullable<System.Boolean> IsPublic { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public ResourceType ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="condition")]
		public ConditionKeyMap Condition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzedAt")]
		public System.DateTimeOffset AnalyzedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public FindingStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerAccount")]
		public string ResourceOwnerAccount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public FindingSource[] Sources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum OrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ASC")]
		ASC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DESC")]
		DESC = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListPolicyGenerationsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyGenerations")]
		public PolicyGeneration[] PolicyGenerations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains details about the policy generation status and properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyGeneration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobId")]
		public string JobId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principalArn")]
		public string PrincipalArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public JobStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startedOn")]
		public System.DateTimeOffset StartedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="completedOn")]
		public System.DateTimeOffset CompletedOn { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagsMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartPolicyGenerationResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobId")]
		public string JobId { get; set; }
	}
	
	/// <summary>
	/// Contains details about the CloudTrail trail being analyzed to generate a policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trail
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cloudTrailArn")]
		public string CloudTrailArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allRegions")]
		public System.Nullable<System.Boolean> AllRegions { get; set; }
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceResponse
	{
	}
	
	/// <summary>
	/// The response to the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidatePolicyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findings")]
		public ValidatePolicyFinding[] Findings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// A finding in a policy. Each finding is an actionable recommendation that can be used to improve the policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidatePolicyFinding
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findingDetails")]
		public string FindingDetails { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findingType")]
		public ValidatePolicyFindingType FindingType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issueCode")]
		public string IssueCode { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="learnMoreLink")]
		public string LearnMoreLink { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public Location[] Locations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ValidatePolicyFindingType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR")]
		ERROR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SECURITY_WARNING")]
		SECURITY_WARNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SUGGESTION")]
		SUGGESTION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WARNING")]
		WARNING = 3,
	}
	
	/// <summary>
	/// A location in a policy that is represented as a path through the JSON representation and a corresponding span.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Location
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public PathElement[] Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="span")]
		public Span Span { get; set; }
	}
	
	/// <summary>
	/// A single element in a path through the JSON representation of a policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PathElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Int32> Index { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="substring")]
		public Substring Substring { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A reference to a substring of a literal string in a JSON document.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Substring
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public int Start { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="length")]
		public int Length { get; set; }
	}
	
	/// <summary>
	/// A span in a policy. The span consists of a start position (inclusive) and end position (exclusive).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Span
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public Position Start { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public Position End { get; set; }
	}
	
	/// <summary>
	/// A position in a policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Position
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="line")]
		public int Line { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column")]
		public int Column { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="offset")]
		public int Offset { get; set; }
	}
	
	/// <summary>
	/// Retroactively applies an archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApplyArchiveRuleRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleName")]
		public string RuleName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CancelPolicyGenerationRequest
	{
	}
	
	/// <summary>
	/// Contains information about CloudTrail access.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudTrailDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trails")]
		public Trail[] Trails { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accessRole")]
		public string AccessRole { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
	}
	
	/// <summary>
	/// Contains details about the CloudTrail trail being analyzed to generate a policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrailProperties
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cloudTrailArn")]
		public string CloudTrailArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="allRegions")]
		public System.Nullable<System.Boolean> AllRegions { get; set; }
	}
	
	/// <summary>
	/// Contains information about CloudTrail access.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudTrailProperties
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trailProperties")]
		public TrailProperties[] TrailProperties { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateAccessPreviewRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configurations")]
		public ConfigurationsMap Configurations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	/// <summary>
	/// Creates an analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateAnalyzerRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerName")]
		public string AnalyzerName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Type Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archiveRules")]
		public InlineArchiveRule[] ArchiveRules { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagsMap Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	/// <summary>
	/// Creates an archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateArchiveRuleRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleName")]
		public string RuleName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public FilterCriteriaMap Filter { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	/// <summary>
	/// Deletes an analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteAnalyzerRequest
	{
	}
	
	/// <summary>
	/// Deletes an archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteArchiveRuleRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FindingStatusUpdate
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ARCHIVED")]
		ARCHIVED = 1,
	}
	
	/// <summary>
	/// Contains the generated policy details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GeneratedPolicyProperties
	{
		
		[System.Runtime.Serialization.DataMember(Name="isComplete")]
		public System.Nullable<System.Boolean> IsComplete { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principalArn")]
		public string PrincipalArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cloudTrailProperties")]
		public CloudTrailProperties CloudTrailProperties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAccessPreviewRequest
	{
	}
	
	/// <summary>
	/// Retrieves an analyzed resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAnalyzedResourceRequest
	{
	}
	
	/// <summary>
	/// Retrieves an analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAnalyzerRequest
	{
	}
	
	/// <summary>
	/// Retrieves an archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetArchiveRuleRequest
	{
	}
	
	/// <summary>
	/// Retrieves a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetFindingRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetGeneratedPolicyRequest
	{
	}
	
	/// <summary>
	/// This configuration sets the network origin for the Amazon S3 access point or multi-region access point to <code>Internet</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternetConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAccessPreviewFindingsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public FilterCriteriaMap Filter { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAccessPreviewsRequest
	{
	}
	
	/// <summary>
	/// Retrieves a list of resources that have been analyzed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAnalyzedResourcesRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public ResourceType ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	/// <summary>
	/// Retrieves a list of analyzers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAnalyzersRequest
	{
	}
	
	/// <summary>
	/// Retrieves a list of archive rules created for the specified analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListArchiveRulesRequest
	{
	}
	
	/// <summary>
	/// The criteria used to sort.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SortCriteria
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributeName")]
		public string AttributeName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="orderBy")]
		public OrderBy OrderBy { get; set; }
	}
	
	/// <summary>
	/// Retrieves a list of findings generated by the specified analyzer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListFindingsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public FilterCriteriaMap Filter { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sort")]
		public SortCriteria Sort { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListPolicyGenerationsRequest
	{
	}
	
	/// <summary>
	/// Retrieves a list of tags applied to the specified resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Locale
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DE")]
		DE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EN")]
		EN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ES")]
		ES = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FR")]
		FR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IT")]
		IT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="JA")]
		JA = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="KO")]
		KO = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PT_BR")]
		PT_BR = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ZH_CN")]
		ZH_CN = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ZH_TW")]
		ZH_TW = 9,
	}
	
	/// <summary>
	/// The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. VPC configuration does not apply to multi-region access points. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html">VpcConfiguration</a>. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vpcId")]
		public string VpcId { get; set; }
	}
	
	/// <summary>
	/// The proposed <code>InternetConfiguration</code> or <code>VpcConfiguration</code> to apply to the Amazon S3 access point. <code>VpcConfiguration</code> does not apply to multi-region access points. You can make the access point accessible from the internet, or you can specify that all requests made through that access point must originate from a specific virtual private cloud (VPC). You can specify only one type of network configuration. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html">Creating access points</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkOriginConfiguration
	{
		
		/// <summary>
		/// The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. VPC configuration does not apply to multi-region access points. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html">VpcConfiguration</a>. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpcConfiguration")]
		public VpcConfiguration VpcConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="internetConfiguration")]
		public InternetConfiguration InternetConfiguration { get; set; }
	}
	
	/// <summary>
	/// Contains the ARN details about the IAM entity for which the policy is generated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyGenerationDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principalArn")]
		public string PrincipalArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IDENTITY_POLICY")]
		IDENTITY_POLICY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RESOURCE_POLICY")]
		RESOURCE_POLICY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SERVICE_CONTROL_POLICY")]
		SERVICE_CONTROL_POLICY = 2,
	}
	
	/// <summary>
	/// The values for a manual Amazon RDS DB cluster snapshot attribute.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RdsDbClusterSnapshotAttributeValue
	{
		
		[System.Runtime.Serialization.DataMember(Name="accountIds")]
		public string[] AccountIds { get; set; }
	}
	
	/// <summary>
	/// The name and values of a manual Amazon RDS DB snapshot attribute. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB snapshot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RdsDbSnapshotAttributeValue
	{
		
		[System.Runtime.Serialization.DataMember(Name="accountIds")]
		public string[] AccountIds { get; set; }
	}
	
	/// <summary>
	/// The configuration for an Amazon S3 access point or multi-region access point for the bucket. You can propose up to 10 access points or multi-region access points per bucket. If the proposed Amazon S3 access point configuration is for an existing bucket, the access preview uses the proposed access point configuration in place of the existing access points. To propose an access point without a policy, you can provide an empty string as the access point policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html">Creating access points</a>. For more information about access point policy limits, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-points-restrictions-limitations.html">Access points restrictions and limitations</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class S3AccessPointConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="accessPointPolicy")]
		public string AccessPointPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="publicAccessBlock")]
		public S3PublicAccessBlockConfiguration PublicAccessBlock { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="networkOrigin")]
		public NetworkOriginConfiguration NetworkOrigin { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartPolicyGenerationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyGenerationDetails")]
		public PolicyGenerationDetails PolicyGenerationDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cloudTrailDetails")]
		public CloudTrailDetails CloudTrailDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	/// <summary>
	/// Starts a scan of the policies applied to the specified resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartResourceScanRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerAccount")]
		public string ResourceOwnerAccount { get; set; }
	}
	
	/// <summary>
	/// Adds a tag to the specified resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagsMap Tags { get; set; }
	}
	
	/// <summary>
	/// Removes a tag from the specified resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceRequest
	{
	}
	
	/// <summary>
	/// Updates the specified archive rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateArchiveRuleRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public FilterCriteriaMap Filter { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	/// <summary>
	/// Updates findings with the new values provided in the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateFindingsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public FindingStatusUpdate Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ValidatePolicyResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3::Bucket")]
		AWSS3Bucket = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3::AccessPoint")]
		AWSS3AccessPoint = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3::MultiRegionAccessPoint")]
		AWSS3MultiRegionAccessPoint = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3ObjectLambda::AccessPoint")]
		AWSS3ObjectLambdaAccessPoint = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::IAM::AssumeRolePolicyDocument")]
		AWSIAMAssumeRolePolicyDocument = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidatePolicyRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="locale")]
		public Locale Locale { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyDocument")]
		public string PolicyDocument { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyType")]
		public PolicyType PolicyType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="validatePolicyResourceType")]
		public ValidatePolicyResourceType ValidatePolicyResourceType { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Retroactively applies the archive rule to existing findings that meet the archive rule criteria.
		/// ApplyArchiveRule archive-rule
		/// </summary>
		/// <returns>Success</returns>
		public async Task ApplyArchiveRuleAsync(ApplyArchiveRulePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archive-rule";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Cancels the requested policy generation.
		/// CancelPolicyGeneration policy/generation/{jobId}
		/// </summary>
		/// <param name="jobId">The <code>JobId</code> that is returned by the <code>StartPolicyGeneration</code> operation. The <code>JobId</code> can be used with <code>GetGeneratedPolicy</code> to retrieve the generated policies or used with <code>CancelPolicyGeneration</code> to cancel the policy generation request.</param>
		/// <returns>Success</returns>
		public async Task<CancelPolicyGenerationResponse> CancelPolicyGenerationAsync(string jobId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policy/generation/"+ (jobId==null? "" : System.Uri.EscapeDataString(jobId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CancelPolicyGenerationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the policy that was generated using <code>StartPolicyGeneration</code>.
		/// GetGeneratedPolicy policy/generation/{jobId}
		/// </summary>
		/// <param name="jobId">The <code>JobId</code> that is returned by the <code>StartPolicyGeneration</code> operation. The <code>JobId</code> can be used with <code>GetGeneratedPolicy</code> to retrieve the generated policies or used with <code>CancelPolicyGeneration</code> to cancel the policy generation request.</param>
		/// <param name="includeResourcePlaceholders"><p>The level of detail that you want to generate. You can specify whether to generate policies with placeholders for resource ARNs for actions that support resource level granularity in policies.</p> <p>For example, in the resource section of a policy, you can receive a placeholder such as <code>"Resource":"arn:aws:s3:::${BucketName}"</code> instead of <code>"*"</code>.</p></param>
		/// <param name="includeServiceLevelTemplate"><p>The level of detail that you want to generate. You can specify whether to generate service-level policies. </p> <p>IAM Access Analyzer uses <code>iam:servicelastaccessed</code> to identify services that have been used recently to create this service-level template.</p></param>
		/// <returns>Success</returns>
		public async Task<GetGeneratedPolicyResponse> GetGeneratedPolicyAsync(string jobId, bool includeResourcePlaceholders, bool includeServiceLevelTemplate, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policy/generation/"+ (jobId==null? "" : System.Uri.EscapeDataString(jobId))+"&includeResourcePlaceholders="+includeResourcePlaceholders+"&includeServiceLevelTemplate="+includeServiceLevelTemplate;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetGeneratedPolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an access preview that allows you to preview IAM Access Analyzer findings for your resource before deploying resource permissions.
		/// CreateAccessPreview access-preview
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateAccessPreviewResponse> CreateAccessPreviewAsync(CreateAccessPreviewPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "access-preview";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateAccessPreviewResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates an analyzer for your account.
		/// CreateAnalyzer analyzer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateAnalyzerResponse> CreateAnalyzerAsync(CreateAnalyzerPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateAnalyzerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of analyzers.
		/// ListAnalyzers analyzer
		/// </summary>
		/// <param name="nextToken">A token used for pagination of results returned.</param>
		/// <param name="maxResults">The maximum number of results to return in the response.</param>
		/// <param name="type">The type of analyzer.</param>
		/// <returns>Success</returns>
		public async Task<ListAnalyzersResponse> ListAnalyzersAsync(string nextToken, int maxResults, Type type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer?nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&type=" + type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListAnalyzersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates an archive rule for the specified analyzer. Archive rules automatically archive new findings that meet the criteria you define when you create the rule.</p> <p>To learn about filter keys that you can use to create an archive rule, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html">IAM Access Analyzer filter keys</a> in the <b>IAM User Guide</b>.</p>
		/// CreateArchiveRule analyzer/{analyzerName}/archive-rule
		/// </summary>
		/// <param name="analyzerName">The name of the created analyzer.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task CreateArchiveRuleAsync(string analyzerName, CreateArchiveRulePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : System.Uri.EscapeDataString(analyzerName))+"/archive-rule";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of archive rules created for the specified analyzer.
		/// ListArchiveRules analyzer/{analyzerName}/archive-rule
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer to retrieve rules from.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="nextToken">A token used for pagination of results returned.</param>
		/// <param name="maxResults">The maximum number of results to return in the request.</param>
		/// <returns>Success</returns>
		public async Task<ListArchiveRulesResponse> ListArchiveRulesAsync(string analyzerName, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : System.Uri.EscapeDataString(analyzerName))+"/archive-rule&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListArchiveRulesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified analyzer. When you delete an analyzer, IAM Access Analyzer is disabled for the account or organization in the current or specific Region. All findings that were generated by the analyzer are deleted. You cannot undo this action.
		/// DeleteAnalyzer analyzer/{analyzerName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="clientToken">A client token.</param>
		/// <returns>Success</returns>
		public async Task DeleteAnalyzerAsync(string analyzerName, string clientToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : System.Uri.EscapeDataString(analyzerName))+"&clientToken=" + (clientToken==null? "" : System.Uri.EscapeDataString(clientToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about the specified analyzer.
		/// GetAnalyzer analyzer/{analyzerName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer retrieved.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<GetAnalyzerResponse> GetAnalyzerAsync(string analyzerName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : System.Uri.EscapeDataString(analyzerName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetAnalyzerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified archive rule.
		/// DeleteArchiveRule analyzer/{analyzerName}/archive-rule/{ruleName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer that associated with the archive rule to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="ruleName">The name of the rule to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="clientToken">A client token.</param>
		/// <returns>Success</returns>
		public async Task DeleteArchiveRuleAsync(string analyzerName, string ruleName, string clientToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : System.Uri.EscapeDataString(analyzerName))+"/archive-rule/"+ (ruleName==null? "" : System.Uri.EscapeDataString(ruleName))+"&clientToken=" + (clientToken==null? "" : System.Uri.EscapeDataString(clientToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves information about an archive rule.</p> <p>To learn about filter keys that you can use to create an archive rule, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html">IAM Access Analyzer filter keys</a> in the <b>IAM User Guide</b>.</p>
		/// GetArchiveRule analyzer/{analyzerName}/archive-rule/{ruleName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer to retrieve rules from.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="ruleName">The name of the rule to retrieve.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<GetArchiveRuleResponse> GetArchiveRuleAsync(string analyzerName, string ruleName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : System.Uri.EscapeDataString(analyzerName))+"/archive-rule/"+ (ruleName==null? "" : System.Uri.EscapeDataString(ruleName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetArchiveRuleResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the criteria and values for the specified archive rule.
		/// UpdateArchiveRule analyzer/{analyzerName}/archive-rule/{ruleName}
		/// </summary>
		/// <param name="analyzerName">The name of the analyzer to update the archive rules for.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="ruleName">The name of the rule to update.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task UpdateArchiveRuleAsync(string analyzerName, string ruleName, UpdateArchiveRulePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzer/"+ (analyzerName==null? "" : System.Uri.EscapeDataString(analyzerName))+"/archive-rule/"+ (ruleName==null? "" : System.Uri.EscapeDataString(ruleName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about an access preview for the specified analyzer.
		/// GetAccessPreview access-preview/{accessPreviewId}#analyzerArn
		/// </summary>
		/// <param name="accessPreviewId">The unique ID for the access preview.</param>
		/// <param name="analyzerArn">The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> used to generate the access preview.</param>
		/// <returns>Success</returns>
		public async Task<GetAccessPreviewResponse> GetAccessPreviewAsync(string accessPreviewId, string analyzerArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "access-preview/"+ (accessPreviewId==null? "" : System.Uri.EscapeDataString(accessPreviewId))+"#analyzerArn&analyzerArn=" + (analyzerArn==null? "" : System.Uri.EscapeDataString(analyzerArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetAccessPreviewResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about a resource that was analyzed.
		/// GetAnalyzedResource analyzed-resource#analyzerArn&resourceArn
		/// </summary>
		/// <param name="analyzerArn">The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> to retrieve information from.</param>
		/// <param name="resourceArn">The ARN of the resource to retrieve information about.</param>
		/// <returns>Success</returns>
		public async Task<GetAnalyzedResourceResponse> GetAnalyzedResourceAsync(string analyzerArn, string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzed-resource#analyzerArn&resourceArn?analyzerArn=" + (analyzerArn==null? "" : System.Uri.EscapeDataString(analyzerArn))+"&resourceArn=" + (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetAnalyzedResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about the specified finding.
		/// GetFinding finding/{id}#analyzerArn
		/// </summary>
		/// <param name="analyzerArn">The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> that generated the finding.</param>
		/// <param name="id">The ID of the finding to retrieve.</param>
		/// <returns>Success</returns>
		public async Task<GetFindingResponse> GetFindingAsync(string analyzerArn, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "finding/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"#analyzerArn?analyzerArn=" + (analyzerArn==null? "" : System.Uri.EscapeDataString(analyzerArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetFindingResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of access preview findings generated by the specified access preview.
		/// ListAccessPreviewFindings access-preview/{accessPreviewId}
		/// </summary>
		/// <param name="accessPreviewId">The unique ID for the access preview.</param>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListAccessPreviewFindingsResponse> ListAccessPreviewFindingsAsync(string accessPreviewId, string maxResults, string nextToken, ListAccessPreviewFindingsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "access-preview/"+ (accessPreviewId==null? "" : System.Uri.EscapeDataString(accessPreviewId))+"&maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListAccessPreviewFindingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of access previews for the specified analyzer.
		/// ListAccessPreviews access-preview#analyzerArn
		/// </summary>
		/// <param name="analyzerArn">The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> used to generate the access preview.</param>
		/// <param name="nextToken">A token used for pagination of results returned.</param>
		/// <param name="maxResults">The maximum number of results to return in the response.</param>
		/// <returns>Success</returns>
		public async Task<ListAccessPreviewsResponse> ListAccessPreviewsAsync(string analyzerArn, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "access-preview#analyzerArn?analyzerArn=" + (analyzerArn==null? "" : System.Uri.EscapeDataString(analyzerArn))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListAccessPreviewsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of resources of the specified type that have been analyzed by the specified analyzer..
		/// ListAnalyzedResources analyzed-resource
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListAnalyzedResourcesResponse> ListAnalyzedResourcesAsync(string maxResults, string nextToken, ListAnalyzedResourcesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyzed-resource?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListAnalyzedResourcesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves a list of findings generated by the specified analyzer.</p> <p>To learn about filter keys that you can use to retrieve a list of findings, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html">IAM Access Analyzer filter keys</a> in the <b>IAM User Guide</b>.</p>
		/// ListFindings finding
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListFindingsResponse> ListFindingsAsync(string maxResults, string nextToken, ListFindingsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "finding?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListFindingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the status for the specified findings.
		/// UpdateFindings finding
		/// </summary>
		/// <returns>Success</returns>
		public async Task UpdateFindingsAsync(UpdateFindingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "finding";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all of the policy generations requested in the last seven days.
		/// ListPolicyGenerations policy/generation
		/// </summary>
		/// <param name="principalArn">The ARN of the IAM entity (user or role) for which you are generating a policy. Use this with <code>ListGeneratedPolicies</code> to filter the results to only include results for a specific principal.</param>
		/// <param name="maxResults">The maximum number of results to return in the response.
		/// Minimum: 1
		// </param>
		/// <param name="nextToken">A token used for pagination of results returned.</param>
		/// <returns>Success</returns>
		public async Task<ListPolicyGenerationsResponse> ListPolicyGenerationsAsync(string principalArn, int maxResults, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policy/generation?principalArn=" + (principalArn==null? "" : System.Uri.EscapeDataString(principalArn))+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListPolicyGenerationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts the policy generation request.
		/// StartPolicyGeneration policy/generation
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartPolicyGenerationResponse> StartPolicyGenerationAsync(StartPolicyGenerationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policy/generation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartPolicyGenerationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of tags applied to the specified resource.
		/// ListTagsForResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The ARN of the resource to retrieve tags from.</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a tag to the specified resource.
		/// TagResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The ARN of the resource to add the tag to.</param>
		/// <returns>Success</returns>
		public async Task<TagResourceResponse> TagResourceAsync(string resourceArn, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Immediately starts a scan of the policies applied to the specified resource.
		/// StartResourceScan resource/scan
		/// </summary>
		/// <returns>Success</returns>
		public async Task StartResourceScanAsync(StartResourceScanPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "resource/scan";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from the specified resource.
		/// UntagResource tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">The ARN of the resource to remove the tag from.</param>
		/// <param name="tagKeys">The key for the tag to add.</param>
		/// <returns>Success</returns>
		public async Task<UntagResourceResponse> UntagResourceAsync(string resourceArn, string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn))+"#tagKeys&"+string.Join("&", tagKeys.Select(z => $"tagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UntagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Requests the validation of a policy and returns a list of findings. The findings help you identify issues and provide actionable recommendations to resolve the issue and enable you to author functional policies that meet security best practices.
		/// ValidatePolicy policy/validation
		/// </summary>
		/// <param name="maxResults">The maximum number of results to return in the response.</param>
		/// <param name="nextToken">A token used for pagination of results returned.</param>
		/// <returns>Success</returns>
		public async Task<ValidatePolicyResponse> ValidatePolicyAsync(int maxResults, string nextToken, ValidatePolicyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policy/validation?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ValidatePolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public class ApplyArchiveRulePutBody
	{
		
		/// <summary>
		/// The Amazon resource name (ARN) of the analyzer.
		/// Required
		/// Pattern: [^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// The name of the rule to apply.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// Pattern: [A-Za-z][A-Za-z0-9_.-]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[A-Za-z][A-Za-z0-9_.-]*")]
		public string RuleName { get; set; }
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	public class CreateAccessPreviewPutBody
	{
		
		/// <summary>
		/// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the account analyzer</a> used to generate the access preview. You can only create an access preview for analyzers with an <code>Account</code> type and <code>Active</code> status.
		/// Required
		/// Pattern: [^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Access control configuration for your resource that is used to generate the access preview. The access preview includes findings for external access allowed to the resource with the proposed access control configuration. The configuration must contain exactly one element.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configurations")]
		public System.Collections.Generic.Dictionary<string, Configuration> Configurations { get; set; }
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	public class CreateAnalyzerPutBody
	{
		
		/// <summary>
		/// The name of the analyzer to create.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// Pattern: [A-Za-z][A-Za-z0-9_.-]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[A-Za-z][A-Za-z0-9_.-]*")]
		public string AnalyzerName { get; set; }
		
		/// <summary>
		/// The type of analyzer to create. Only ACCOUNT and ORGANIZATION analyzers are supported. You can create only one analyzer per account per Region. You can create up to 5 analyzers per organization per Region.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Type Type { get; set; }
		
		/// <summary>
		/// Specifies the archive rules to add for the analyzer. Archive rules automatically archive findings that meet the criteria you define for the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archiveRules")]
		public InlineArchiveRule[] ArchiveRules { get; set; }
		
		/// <summary>
		/// The tags to apply to the analyzer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	public class CreateArchiveRulePutBody
	{
		
		/// <summary>
		/// The name of the rule to create.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// Pattern: [A-Za-z][A-Za-z0-9_.-]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[A-Za-z][A-Za-z0-9_.-]*")]
		public string RuleName { get; set; }
		
		/// <summary>
		/// The criteria for the rule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public System.Collections.Generic.Dictionary<string, Criterion> Filter { get; set; }
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	public class UpdateArchiveRulePutBody
	{
		
		/// <summary>
		/// A filter to match for the rules to update. Only rules that match the filter are updated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public System.Collections.Generic.Dictionary<string, Criterion> Filter { get; set; }
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	public class ListAccessPreviewFindingsPostBody
	{
		
		/// <summary>
		/// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> used to generate the access.
		/// Required
		/// Pattern: [^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// Criteria to filter the returned findings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public System.Collections.Generic.Dictionary<string, Criterion> Filter { get; set; }
		
		/// <summary>
		/// A token used for pagination of results returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// The maximum number of results to return in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	public class ListAnalyzedResourcesPostBody
	{
		
		/// <summary>
		/// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> to retrieve a list of analyzed resources from.
		/// Required
		/// Pattern: [^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// The type of resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public System.Nullable<ListAnalyzedResourcesPostBodyResourceType> ResourceType { get; set; }
		
		/// <summary>
		/// A token used for pagination of results returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// The maximum number of results to return in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ListAnalyzedResourcesPostBodyResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3::Bucket")]
		AWSS3Bucket = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::IAM::Role")]
		AWSIAMRole = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::SQS::Queue")]
		AWSSQSQueue = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::Lambda::Function")]
		AWSLambdaFunction = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::Lambda::LayerVersion")]
		AWSLambdaLayerVersion = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::KMS::Key")]
		AWSKMSKey = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::SecretsManager::Secret")]
		AWSSecretsManagerSecret = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::EFS::FileSystem")]
		AWSEFSFileSystem = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::EC2::Snapshot")]
		AWSEC2Snapshot = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::ECR::Repository")]
		AWSECRRepository = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::RDS::DBSnapshot")]
		AWSRDSDBSnapshot = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::RDS::DBClusterSnapshot")]
		AWSRDSDBClusterSnapshot = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::SNS::Topic")]
		AWSSNSTopic = 12,
	}
	
	public class ListFindingsPostBody
	{
		
		/// <summary>
		/// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> to retrieve findings from.
		/// Required
		/// Pattern: [^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// A filter to match for the findings to return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public System.Collections.Generic.Dictionary<string, Criterion> Filter { get; set; }
		
		/// <summary>
		/// The criteria used to sort.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sort")]
		public ListFindingsPostBodySort Sort { get; set; }
		
		/// <summary>
		/// A token used for pagination of results returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// The maximum number of results to return in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	public class ListFindingsPostBodySort
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributeName")]
		public string AttributeName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="orderBy")]
		public OrderBy OrderBy { get; set; }
	}
	
	public class UpdateFindingsPutBody
	{
		
		/// <summary>
		/// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> that generated the findings to update.
		/// Required
		/// Pattern: [^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// The state represents the action to take to update the finding Status. Use <code>ARCHIVE</code> to change an Active finding to an Archived finding. Use <code>ACTIVE</code> to change an Archived finding to an Active finding.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public FindingStatusUpdate Status { get; set; }
		
		/// <summary>
		/// The IDs of the findings to update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// The ARN of the resource identified in the finding.
		/// Pattern: arn:[^:]*:[^:]*:[^:]*:[^:]*:.*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// A client token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	public class StartPolicyGenerationPutBody
	{
		
		/// <summary>
		/// Contains the ARN details about the IAM entity for which the policy is generated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyGenerationDetails")]
		public StartPolicyGenerationPutBodyPolicyGenerationDetails PolicyGenerationDetails { get; set; }
		
		/// <summary>
		/// Contains information about CloudTrail access.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudTrailDetails")]
		public StartPolicyGenerationPutBodyCloudTrailDetails CloudTrailDetails { get; set; }
		
		/// <summary>
		/// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect.</p> <p>If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
	}
	
	public class StartPolicyGenerationPutBodyPolicyGenerationDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="principalArn")]
		public string PrincipalArn { get; set; }
	}
	
	public class StartPolicyGenerationPutBodyCloudTrailDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="trails")]
		public Trail[] Trails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="accessRole")]
		public string AccessRole { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// The tags to add to the resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class StartResourceScanPostBody
	{
		
		/// <summary>
		/// The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of the analyzer</a> to use to scan the policies applied to the specified resource.
		/// Required
		/// Pattern: [^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyzerArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:analyzer/.{1,255}")]
		public string AnalyzerArn { get; set; }
		
		/// <summary>
		/// The ARN of the resource to scan.
		/// Required
		/// Pattern: arn:[^:]*:[^:]*:[^:]*:[^:]*:.*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceOwnerAccount")]
		public string ResourceOwnerAccount { get; set; }
	}
	
	public class ValidatePolicyPostBody
	{
		
		/// <summary>
		/// The locale to use for localizing the findings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locale")]
		public Locale Locale { get; set; }
		
		/// <summary>
		/// The JSON policy document to use as the content for the policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyDocument")]
		public string PolicyDocument { get; set; }
		
		/// <summary>
		/// <p>The type of policy to validate. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. They also include service-control policies (SCPs) that are attached to an Amazon Web Services organization, organizational unit (OU), or an account.</p> <p>Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy. </p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyType")]
		public PolicyType PolicyType { get; set; }
		
		/// <summary>
		/// <p>The type of resource to attach to your resource policy. Specify a value for the policy validation resource type only if the policy type is <code>RESOURCE_POLICY</code>. For example, to validate a resource policy to attach to an Amazon S3 bucket, you can choose <code>AWS::S3::Bucket</code> for the policy validation resource type.</p> <p>For resource types not supported as valid values, IAM Access Analyzer runs policy checks that apply to all resource policies. For example, to validate a resource policy to attach to a KMS key, do not specify a value for the policy validation resource type and IAM Access Analyzer will run policy checks that apply to all resource policies.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validatePolicyResourceType")]
		public System.Nullable<ValidatePolicyPostBodyValidatePolicyResourceType> ValidatePolicyResourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ValidatePolicyPostBodyValidatePolicyResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3::Bucket")]
		AWSS3Bucket = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3::AccessPoint")]
		AWSS3AccessPoint = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3::MultiRegionAccessPoint")]
		AWSS3MultiRegionAccessPoint = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::S3ObjectLambda::AccessPoint")]
		AWSS3ObjectLambdaAccessPoint = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS::IAM::AssumeRolePolicyDocument")]
		AWSIAMAssumeRolePolicyDocument = 4,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
