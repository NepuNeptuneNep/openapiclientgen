//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AclGroupOriginCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lists")]
		public AclGroupOriginOutput[] Lists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AclGroupOriginOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public int Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public AclGroupOriginOutputStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public int Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AclGroupOriginOutputStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AclListCollectionOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="asns")]
		public string[] Asns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cidrs")]
		public string[] Cidrs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="continents")]
		public string[] Continents { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="countries")]
		public string[] Countries { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="datacenters")]
		public string[] Datacenters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reported")]
		public string[] Reported { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ActivityCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activities")]
		public ActivityOutput[] Activities { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public int Page { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public int Page_size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ActivityOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public int Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public V1__models__token__SourceOutput Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class V1__models__token__SourceOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status_code")]
		public int Status_code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ua_string")]
		public string Ua_string { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AutonomousSystemOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country_code")]
		public AutonomousSystemOutputCountry_code Country_code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefixes")]
		public string Prefixes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="registry")]
		public string Registry { get; set; }
		
		/// <summary>
		/// Pattern: ^(\d{4})(\d{2})(\d{2})$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_date")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(\d{4})(\d{2})(\d{2})$")]
		public string Registry_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="risk")]
		public System.Nullable<AutonomousSystemOutputRisk> Risk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AutonomousSystemOutputCountry_code
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AF = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AX = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AL = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DZ = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AS = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AD = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AO = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AI = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AQ = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AG = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AR = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AM = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AW = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AU = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AT = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AZ = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BS = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BH = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BD = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BB = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BY = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BE = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BZ = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BJ = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BM = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BT = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BO = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BQ = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BA = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BW = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BV = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BR = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IO = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BN = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BG = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BF = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BI = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CV = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KH = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CM = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CA = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KY = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CF = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TD = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CL = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CN = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CX = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CC = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CO = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KM = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CG = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CD = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CK = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CR = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CI = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HR = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CU = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CW = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CY = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CZ = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DK = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DJ = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DM = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DO = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EC = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EG = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SV = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GQ = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ER = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EE = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ET = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FK = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FO = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FJ = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FI = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FR = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GF = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PF = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TF = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GA = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GM = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GE = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DE = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GH = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GI = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GR = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GL = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GD = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GP = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GU = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GT = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GG = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GN = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GW = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GY = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HT = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HM = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VA = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HN = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HK = 100,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HU = 101,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IS = 102,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN = 103,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ID = 104,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IR = 105,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IQ = 106,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IE = 107,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IM = 108,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IL = 109,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IT = 110,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JM = 111,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JP = 112,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JE = 113,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JO = 114,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KZ = 115,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KE = 116,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KI = 117,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KP = 118,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KR = 119,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KW = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KG = 121,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LA = 122,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LV = 123,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LB = 124,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LS = 125,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LR = 126,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LY = 127,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LI = 128,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LT = 129,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LU = 130,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MO = 131,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MK = 132,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MG = 133,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MW = 134,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MY = 135,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MV = 136,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ML = 137,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MT = 138,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MH = 139,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MQ = 140,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MR = 141,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MU = 142,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YT = 143,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MX = 144,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FM = 145,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MD = 146,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MC = 147,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MN = 148,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ME = 149,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MS = 150,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MA = 151,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MZ = 152,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MM = 153,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NA = 154,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NR = 155,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NP = 156,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NL = 157,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NC = 158,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NZ = 159,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NI = 160,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NE = 161,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NG = 162,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NU = 163,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NF = 164,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MP = 165,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO = 166,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OM = 167,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PK = 168,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PW = 169,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PS = 170,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PA = 171,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PG = 172,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PY = 173,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PE = 174,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PH = 175,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PN = 176,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL = 177,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PT = 178,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PR = 179,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QA = 180,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RE = 181,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RO = 182,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RU = 183,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RW = 184,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BL = 185,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SH = 186,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KN = 187,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LC = 188,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MF = 189,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PM = 190,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VC = 191,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WS = 192,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SM = 193,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ST = 194,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SA = 195,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SN = 196,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RS = 197,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SC = 198,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SL = 199,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SG = 200,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SX = 201,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SK = 202,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SI = 203,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SB = 204,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SO = 205,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZA = 206,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GS = 207,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SS = 208,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ES = 209,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LK = 210,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SD = 211,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SR = 212,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SJ = 213,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SZ = 214,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SE = 215,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CH = 216,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SY = 217,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TW = 218,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TJ = 219,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TZ = 220,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TH = 221,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TL = 222,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TG = 223,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TK = 224,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TO = 225,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TT = 226,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TN = 227,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TR = 228,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TM = 229,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TC = 230,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TV = 231,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UG = 232,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UA = 233,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AE = 234,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GB = 235,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		US = 236,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UM = 237,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UY = 238,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UZ = 239,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VU = 240,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VE = 241,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VN = 242,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VG = 243,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VI = 244,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WF = 245,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EH = 246,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YE = 247,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZM = 248,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZW = 249,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZZ = 250,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EU = 251,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RESERVED BY RFC6793")]
		RESERVED_BY_RFC6793 = 252,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AutonomousSystemOutputRisk
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MEDIUM = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIGH = 3,
	}
	
	/// <summary>
	/// AutonomousSystemPrefixResponse class to return the information to the user
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AutonomousSystemPrefixOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="asn")]
		public string Asn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mantainer")]
		public string Mantainer { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="object_type")]
		public string Object_type { get; set; }
		
		/// <summary>
		/// Pattern: ^(\d{4})(\d{2})(\d{2})$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_date")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(\d{4})(\d{2})(\d{2})$")]
		public string Registry_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registry_status")]
		public string Registry_status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="risk")]
		public AutonomousSystemOutputRisk Risk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AutonomousSystemPrefixesOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="asn")]
		public string Asn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefixes_v4")]
		public AutonomousSystemPrefixOutput[] Prefixes_v4 { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefixes_v6")]
		public AutonomousSystemPrefixOutput[] Prefixes_v6 { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	/// <summary>
	/// The Registry information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AutonomousSystemRegistryOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	/// <summary>
	/// The Status information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AutonomousSystemStatusOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_assess_ip_set_csv_v1_assess_ip_csv_post
	{
		
		/// <summary>
		/// The CSV file with the IP addresses
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="csv_file")]
		public string Csv_file { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_assess_ip_set_csv_v1_geo_csv_post
	{
		
		/// <summary>
		/// The CSV file with the IP addresses
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="csv_file")]
		public string Csv_file { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__put
	{
		
		/// <summary>
		/// The status of the list. ACTIVE or INACTIVE
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Body_change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__putStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Body_change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__putStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_change_status_of_the_denylist_v1_denylist_public__denylist_id__put
	{
		
		/// <summary>
		/// The status of the list. ACTIVE or INACTIVE
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Body_change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__putStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_put
	{
		
		/// <summary>
		/// The protocol and domain of the origin to change the status
		/// Required
		/// Min length: 1
		/// Max length: 2083
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2083)]
		public string Origin { get; set; }
		
		/// <summary>
		/// The status of the list. ACTIVE, INACTIVE, DELETED
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_putStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_putStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_change_status_of_the_origin_allowlist_v1_allowlist_public__allowlist_id__origin_put
	{
		
		/// <summary>
		/// The protocol and domain of the origin to change the status
		/// Required
		/// Min length: 1
		/// Max length: 2083
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2083)]
		public string Origin { get; set; }
		
		/// <summary>
		/// The status of the list. ACTIVE, INACTIVE, DELETED
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_putStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_change_status_of_the_origin_denylist_v1_denylist_private__denylist_id__origin_put
	{
		
		/// <summary>
		/// The protocol and domain of the origin to change the status
		/// Required
		/// Min length: 1
		/// Max length: 2083
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2083)]
		public string Origin { get; set; }
		
		/// <summary>
		/// The status of the list. ACTIVE, INACTIVE, DELETED
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_putStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_change_status_of_the_origin_denylist_v1_denylist_public__denylist_id__origin_put
	{
		
		/// <summary>
		/// The protocol and domain of the origin to change the status
		/// Required
		/// Min length: 1
		/// Max length: 2083
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2083)]
		public string Origin { get; set; }
		
		/// <summary>
		/// The status of the list. ACTIVE, INACTIVE, DELETED
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_putStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_create_private_allowlist_of_the_user_v1_allowlist_private_post
	{
		
		/// <summary>
		/// The information needed to create a new allowlist
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public PrivateAclGroupListInput Payload { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PrivateAclGroupListInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource_type")]
		public PrivateAclGroupListInputResource_type Resource_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PrivateAclGroupListInputResource_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CIDR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COUNTRY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTINENT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATACENTER = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USERAGENT = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_create_private_denylist_of_the_user_v1_denylist_private_post
	{
		
		/// <summary>
		/// The information needed to create a new denylist
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public PrivateAclGroupListInput Payload { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_delete_token_v1_origin_token_delete
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin_token_id")]
		public string Origin_token_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_disable_origin_token_v1_origin_token_disable_put
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin_token_id")]
		public string Origin_token_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_enable_origin_token_v1_origin_token_enable_put
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin_token_id")]
		public string Origin_token_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_parse_user_agents_csv_v1_ua_csv_post
	{
		
		/// <summary>
		/// The CSV file with the User Agents to parse
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="csv_file")]
		public string Csv_file { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_query_asn_prefix_information_v1_asn_prefix_post
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_query_datacenter_prefix_information_v1_datacenter_prefix_post
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_query_origin_status_v1_origin_status_post
	{
		
		/// <summary>
		/// The IP address to query the status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The cookie id to query the status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_id")]
		public string Cookie_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_query_origin_token_info_v1_origin_token_post
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin_token_id")]
		public string Origin_token_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_update_configuration_origin_v1_origin_put
	{
		
		/// <summary>
		/// The configuration information to store in the origin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config")]
		public string Config { get; set; }
		
		/// <summary>
		/// The origin site to modify the configruation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_update_origin_status_v1_origin_status_put
	{
		
		/// <summary>
		/// The log id to change the status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="log_id")]
		public string Log_id { get; set; }
		
		/// <summary>
		/// The scope to change the status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public System.Nullable<Body_update_origin_status_v1_origin_status_putScope> Scope { get; set; }
		
		/// <summary>
		/// The status id to change the details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<Body_update_origin_status_v1_origin_status_putStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Body_update_origin_status_v1_origin_status_putScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		address_and_cookie = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		address = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cookie = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Body_update_origin_status_v1_origin_status_putStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pass = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		block = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		challenge = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		bypass = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_update_private_allowlist_of_the_user_v1_allowlist_private__allowlist_id__put
	{
		
		/// <summary>
		/// The human readable full description of the list
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the list
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of tags to associate with the list
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Optional. The Time To Live (TTL) of a resource in the list in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_update_private_content_of_the_allowlist_of_the_user_v1_allowlist_private__allowlist_id__content_put
	{
		
		/// <summary>
		/// The name of the resources to append to the allowlist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="append")]
		public string[] Append { get; set; }
		
		/// <summary>
		/// The name of the resources to remove from the allowlist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove")]
		public string[] Remove { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_update_private_content_of_the_denylist_of_the_user_v1_denylist_private__denylist_id__content_put
	{
		
		/// <summary>
		/// The name of the resources to append to the denylist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="append")]
		public string[] Append { get; set; }
		
		/// <summary>
		/// The name of the resources to remove from the denylist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove")]
		public string[] Remove { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Body_update_private_denylist_of_the_user_v1_denylist_private__denylist_id__put
	{
		
		/// <summary>
		/// The human readable full description of the list
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the list
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of tags to associate with the list
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Optional. The Time To Live (TTL) of a resource in the list in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatacenterOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asn")]
		public string Asn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefixes")]
		public string Prefixes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="risk")]
		public AutonomousSystemOutputRisk Risk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<DatacenterOutputStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatacenterOutputStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatacenterPrefixOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public string Datacenter { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ip_abuse_total")]
		public System.Nullable<System.Int32> Ip_abuse_total { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="max_score")]
		public System.Nullable<System.Int32> Max_score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="min_score")]
		public System.Nullable<System.Int32> Min_score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="risk")]
		public AutonomousSystemOutputRisk Risk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatacenterPrefixesOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefixes_v4")]
		public DatacenterPrefixOutput[] Prefixes_v4 { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefixes_v6")]
		public DatacenterPrefixOutput[] Prefixes_v6 { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatasetTypeCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="types")]
		public DatasetTypeOutput[] Types { get; set; }
	}
	
	/// <summary>
	/// The Status information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatasetTypeOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public int Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public DatasetTypeOutputStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DatasetTypeOutputType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatasetTypeOutputStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatasetTypeOutputType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ip = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		domain = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeviceOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FamilyOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GeoIPCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public GeoIPOutput[] Results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GeoIPOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accuracy_radius")]
		public double Accuracy_radius { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asn_country_iso_code")]
		public string Asn_country_iso_code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city_geoname_code")]
		public int City_geoname_code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city_name")]
		public string City_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="continent_code")]
		public string Continent_code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country_iso_code")]
		public string Country_iso_code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostnames")]
		public string[] Hostnames { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="postal_code")]
		public string Postal_code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region_geoname_code")]
		public int Region_geoname_code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region_name")]
		public string Region_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="time_zone")]
		public string Time_zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HTTPValidationError
	{
		
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public ValidationError[] Detail { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ValidationError
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="loc")]
		public string[] Loc { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="msg")]
		public string Msg { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPAssessmentCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public IPAssessmentOutput[] Results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPAssessmentOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowlisted")]
		public string Allowlisted { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asn")]
		public string Asn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asn_prefix")]
		public string Asn_prefix { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public string Datacenter { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter_prefix")]
		public string Datacenter_prefix { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datasets")]
		public string[] Datasets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="denylisted")]
		public string Denylisted { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="first_appearance")]
		public string[] First_appearance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_appearance")]
		public string[] Last_appearance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="risk")]
		public AutonomousSystemOutputRisk Risk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public string[] Sources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPListCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public IPListOutput[] Addresses { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPListOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataset")]
		public string Dataset { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public int Expiry { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_report")]
		public int Last_report { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public IPListOutputProtocol Protocol { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_reports")]
		public int Total_reports { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum IPListOutputProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPV4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPV6 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPLogCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logs")]
		public IPLogOutput[] Logs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPLogOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public IPLogOutputAction Action { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataset")]
		public string Dataset { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lapse")]
		public IPLogOutputLapse Lapse { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="risk")]
		public AutonomousSystemOutputRisk Risk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public int Timestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum IPLogOutputAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum IPLogOutputLapse
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1H")]
		_1H = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6H")]
		_6H = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12H")]
		_12H = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1D")]
		_1D = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7D")]
		_7D = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30D")]
		_30D = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="90D")]
		_90D = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="180D")]
		_180D = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="365D")]
		_365D = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OSOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="family")]
		public string Family { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vendor")]
		public string Vendor { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginAddressStatusCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public OriginAddressStatusOutput[] Addresses { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public int Page { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public int Page_size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginAddressStatusOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.Int32> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public System.Nullable<System.Int32> Expiry { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="log_id")]
		public string Log_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.Int32> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginClientAnalysisCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="data")]
		public OriginClientAnalysisOutput[] Data { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from_timestamp")]
		public int From_timestamp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public string Interval { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to_timestamp")]
		public int To_timestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginClientAnalysisOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_browser")]
		public int Client_browser { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_crawler")]
		public int Client_crawler { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_email")]
		public int Client_email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_library")]
		public int Client_library { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_mobile_browser")]
		public int Client_mobile_browser { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_multimedia_player")]
		public int Client_multimedia_player { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_offline_browser")]
		public int Client_offline_browser { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_total")]
		public int Client_total { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_ua_anonymizer")]
		public int Client_ua_anonymizer { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_unrecognized")]
		public int Client_unrecognized { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_validator")]
		public int Client_validator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="client_wap_browser")]
		public int Client_wap_browser { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_feed_fetcher")]
		public int Crawler_feed_fetcher { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_link_checker")]
		public int Crawler_link_checker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_marketing")]
		public int Crawler_marketing { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_screenshot_creator")]
		public int Crawler_screenshot_creator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_search_engine_bot")]
		public int Crawler_search_engine_bot { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_site_monitor")]
		public int Crawler_site_monitor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_speed_tester")]
		public int Crawler_speed_tester { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_tool")]
		public int Crawler_tool { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_total")]
		public int Crawler_total { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_uncategorised")]
		public int Crawler_uncategorised { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_unrecognized")]
		public int Crawler_unrecognized { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_virus_scanner")]
		public int Crawler_virus_scanner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_vulnerability_scanner")]
		public int Crawler_vulnerability_scanner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crawler_web_scraper")]
		public int Crawler_web_scraper { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public int Timestamp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origins")]
		public OriginOutput[] Origins { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public string Actions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string Addresses { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public string Config { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cookies")]
		public string Cookies { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public int Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logs")]
		public string Logs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scripts")]
		public string Scripts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public DatasetTypeOutputStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public int Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginCookieIdStatusCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cookie_ids")]
		public OriginCookieIdStatusOutput[] Cookie_ids { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public int Page { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public int Page_size { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginCookieIdStatusOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cookie_id")]
		public string Cookie_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.Int32> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public System.Nullable<System.Int32> Expiry { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="log_id")]
		public string Log_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.Int32> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginScriptsOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="detection")]
		public string Detection { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginStatusDetailsCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="list")]
		public OriginStatusDetailsOutput[] List { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginStatusDetailsOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cardinality")]
		public int Cardinality { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginStatusOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public OriginAddressStatusOutput Address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cookie_id")]
		public OriginCookieIdStatusOutput Cookie_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginTokenCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tokens")]
		public OriginTokenOutput[] Tokens { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginTokenOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public int Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region_id")]
		public string Region_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public DatasetTypeOutputStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public int Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginTokenInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginTrafficAnalysisCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="data")]
		public OriginTrafficAnalysisOutput[] Data { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from_timestamp")]
		public int From_timestamp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public string Interval { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to_timestamp")]
		public int To_timestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OriginTrafficAnalysisOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asn_risky")]
		public int Asn_risky { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bots")]
		public int Bots { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenters")]
		public int Datacenters { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="denylists")]
		public int Denylists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_country_mismatches")]
		public int Network_country_mismatches { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score_high")]
		public int Score_high { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public int Timestamp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="webdrivers")]
		public int Webdrivers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PrivateAclGroupListCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lists")]
		public PrivateAclGroupListOutput[] Lists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PrivateAclGroupListOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public int Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="list_type")]
		public PrivateAclGroupListOutputList_type List_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="origins")]
		public AclGroupOriginCollectionOutput Origins { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource_type")]
		public PrivateAclGroupListInputResource_type Resource_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public int Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PrivateAclGroupListOutputList_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALLOW = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DENY = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PrivateAclListCollectionOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="asns")]
		public int[] Asns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cidrs")]
		public string[] Cidrs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="continents")]
		public string[] Continents { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="countries")]
		public string[] Countries { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="datacenters")]
		public string[] Datacenters { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_agents")]
		public string[] User_agents { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PublicAclGroupListCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lists")]
		public PublicAclGroupListOutput[] Lists { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PublicAclGroupListOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public int Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="list_type")]
		public PrivateAclGroupListOutputList_type List_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="origins")]
		public AclGroupOriginCollectionOutput Origins { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource_type")]
		public PrivateAclGroupListInputResource_type Resource_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public AclGroupOriginOutputStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public int Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceCollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public V1__models__source__SourceOutput[] Sources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class V1__models__source__SourceOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataset")]
		public string Dataset { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maximum_risk")]
		public AutonomousSystemOutputRisk Maximum_risk { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maximum_score")]
		public int Maximum_score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minimum_risk")]
		public AutonomousSystemOutputRisk Minimum_risk { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minimum_score")]
		public int Minimum_score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="refresh")]
		public V1__models__source__SourceOutputRefresh Refresh { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptions")]
		public string[] Subscriptions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="time_ranges")]
		public string[] Time_ranges { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public int Updated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum V1__models__source__SourceOutputRefresh
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1H")]
		_1H = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6H")]
		_6H = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12H")]
		_12H = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1D")]
		_1D = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7D")]
		_7D = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30D")]
		_30D = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="90D")]
		_90D = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="180D")]
		_180D = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="365D")]
		_365D = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceTimeRangeOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public int Items { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lapse")]
		public SourceTimeRangeOutputLapse Lapse { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="risk")]
		public AutonomousSystemOutputRisk Risk { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="score")]
		public int Score { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public int Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SourceTimeRangeOutputLapse
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1H")]
		_1H = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6H")]
		_6H = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12H")]
		_12H = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1D")]
		_1D = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7D")]
		_7D = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30D")]
		_30D = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="90D")]
		_90D = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="180D")]
		_180D = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="365D")]
		_365D = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TokenOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public int Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_minute_bucket_init_value")]
		public int Last_minute_bucket_init_value { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_minute_bucket_refill_ratio")]
		public int Last_minute_bucket_refill_ratio { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_minute_bucket_refresh")]
		public int Last_minute_bucket_refresh { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_minute_bucket_value")]
		public int Last_minute_bucket_value { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_month_bucket_init_value")]
		public int Last_month_bucket_init_value { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_month_bucket_refresh")]
		public int Last_month_bucket_refresh { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_month_bucket_value")]
		public int Last_month_bucket_value { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region_id")]
		public string Region_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public DatasetTypeOutputStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public int Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TypeOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public TypeOutputType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TypeOutputType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CRAWLER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UACollectionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public UAOutput[] Results { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UAOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agent")]
		public string Agent { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="classification")]
		public UAOutputClassification Classification { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="device")]
		public string Device { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="engine")]
		public string Engine { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="family")]
		public string Family { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequent")]
		public UAOutputFrequent Frequent { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latest")]
		public string Latest { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os")]
		public string Os { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="string")]
		public string String { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vendor")]
		public string Vendor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UAOutputClassification
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CRAWLER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UAOutputFrequent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMON = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RARE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VERY_RARE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VendorOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Creates a new private allowlist binded to the user.
		/// ### What
		/// Creates a new allowlist with the information given and binded to the current user. The parameters are:
		/// - name
		/// - description
		/// - tags
		/// - expiry
		/// - Time to Live (TTL)
		/// - Resource Type (`CIDR`, `AS`, `COUNTRY`, `CONTINENT`, `DATACENTER_ID` and `USER AGENT`)
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will immediately return a 202 Accepted response. The operation will also return the UUID of the list.
		/// 
		/// ### Parameters
		/// In the query string the ID of the private allow list to delete.
		/// 
		/// In the body the following parameters:
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``tags``: A list of tags that describe the list.
		/// - ``ttl``: (Optional) The Time To Live of the list, in seconds. If it does not exist, it will never expire.
		/// - ``resource_type``: The type of resource that the list contains. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT``,    ``DATACENTER_ID`` or ``USER AGENT``.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with the UUID of the new list in the body.
		/// 
		/// ### Errors
		/// 
		/// - If the information is not valid, it will return a `422` (Unprocessable Entity) error.
		/// - If the ttl is negative, it will return a `400` (Bad Request) error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Create_private_allowlist_of_the_user_v1_allowlist_private_post v1/allowlist/private
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<string> Create_private_allowlist_of_the_user_v1_allowlist_private_postAsync(Body_create_private_allowlist_of_the_user_v1_allowlist_private_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of private allowlists of the user.
		/// ### What
		/// Obtain the set of private allow lists of the user available in the service.
		/// 
		/// ### Parameters
		/// No parameters
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as a allowlist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED`` it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_all_private_allowlists_v1_allowlist_private_all_get v1/allowlist/private/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PrivateAclGroupListCollectionOutput> Get_all_private_allowlists_v1_allowlist_private_all_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of private allowlists of the user by resource type.
		/// ### What
		/// Obtain the set of private allow lists of the user available in the service filtering by resource type. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``
		/// 
		/// ### Parameters
		/// The ``resource type`` to filter. The values can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as a allowlist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED`` it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// - If the resource type is not valid, it will return a ``400`` error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Get_all_private_allowlists_by_resource_type_v1_allowlist_private_all__resource_type__get v1/allowlist/private/all/{resource_type}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PrivateAclGroupListCollectionOutput> Get_all_private_allowlists_by_resource_type_v1_allowlist_private_all__resource_type__getAsync(Get_all_private_allowlists_by_resource_type_v1_allowlist_private_all__resource_type__getResource_type resource_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/all/"+resource_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the different private allowlists where the IP address was found.
		/// ### What
		/// Obtain the list of all the different private allowlists where the IP address entered by the user. The allowlisted forbidden datasets are the ones submitted manually by the user from files or indidual items.
		/// 
		/// ### Parameters
		/// The endpoint accepts the `address` parameter as query string.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual status.
		/// - ``cidrs``: the URI of the lists of CIDRs where the IP was found.
		/// - ``country``: the URIs where the lists of countries where the IP address was found
		/// - ``continent``: the URI where the continent where the IP address was found.
		/// - ``asn``: the URIs where the list of continents of the ASN where the IP address was found.
		/// - ``datacenter``: the URIs of the lists of datacenters where the IP address was found. If not found, the result is an empty string.
		/// - ``reported``: the URI of the information of the IP address reported by the user. For allowlist should be empty.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the IP address was malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_resource_denylists_v1_allowlist_private_ip__address__get v1/allowlist/private/ip/{address}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AclListCollectionOutput> Query_resource_denylists_v1_allowlist_private_ip__address__getAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/ip/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AclListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all the bindings between a user and a private allowlist.
		/// ### What
		/// Delete all the bindings between a user and a private allowlist. This will remove the content of the allowlist, the allowlist from the user and also all the origins that are using the allowlist.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request willimmediately return a 202 Accepted response.
		/// 
		/// ### Parameters
		/// In the query string the ID of the private allow list to delete.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// - If the list does not exist, it will return a 404 error.
		/// - If the allow list is not a valid UUID, it will return a 422 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Delete_the_allowlist_v1_allowlist_private__allowlist_id__delete v1/allowlist/private/{allowlist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_the_allowlist_v1_allowlist_private__allowlist_id__deleteAsync(string allowlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the details of a specific private allowlist of the user.
		/// ### What
		/// Obtain the details of the private allow list of the user available in the service.
		/// 
		/// ### Parameters
		/// Pass the private allowlist ID as query parameter.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as a allowlist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED`` it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// - If the allow list is not a valid UUID, it will return a 422 error.
		/// - If the private allowlist ID does not exist, it will return a ``404`` error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Get_single_allowlist_v1_allowlist_private__allowlist_id__get v1/allowlist/private/{allowlist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PrivateAclGroupListOutput> Get_single_allowlist_v1_allowlist_private__allowlist_id__getAsync(string allowlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateAclGroupListOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the information of an existing private allowlist of the user.
		/// ### What
		/// Updates the information that describes the allowlist of the user in the system. The parameters that can be modified are:
		/// - name
		/// - description
		/// - tags
		/// - expiry
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will immediately return a 202 Accepted response.
		/// 
		/// ### Parameters
		/// In the query string the ID of the private allow list to delete.
		/// 
		/// In the body the following parameters:
		/// - ``name``: (Optional) A human readable name of the list.
		/// - ``description``: (Optional) A long detailed information about what the list contains and how it is used.
		/// - ``tags``: (Optional) A list of tags that describe the list.
		/// - ``expiry``: (Optional) Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// - If the list does not exist, it will return a `404` (Not found) error.
		/// - If the list is a default list, it will return a `403` (Forbidden) error.
		/// - If the allow list is not a valid UUID, it will return a `422` (Unprocessable Entity) error.
		/// - If the expiry is not a valid timestamp, it will return a `422` (Unprocessable Entity) error.
		/// - If the expiry is in the past, it will return a `400` (Bad Request) error.
		/// - If the name is not a string, it will return a `422` (Unprocessable Entity) error.
		/// - If the description is not a string, it will return a `422` (Unprocessable Entity) error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Update_private_allowlist_of_the_user_v1_allowlist_private__allowlist_id__put v1/allowlist/private/{allowlist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Update_private_allowlist_of_the_user_v1_allowlist_private__allowlist_id__putAsync(string allowlist_id, Body_update_private_allowlist_of_the_user_v1_allowlist_private__allowlist_id__put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all the content of a private allowlist of the user.
		/// ### What
		/// Delete all the content of a private allowlist of the user. This will remove all the elements, and there is no way to recover them.
		/// 
		/// ### Parameters
		/// Pass the private allowlist ID as query parameter.
		/// 
		/// ### Result
		/// If successful, it will return a ``202`` (Accepted) response with an empty body. The operation is asynchronous,and can take several seconds to complete.
		/// 
		/// ### Errors
		/// 
		/// - If the allow list is not a valid UUID, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the private allowlist ID does not exist, it will return a ``404`` (Not found) error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Delete_the_allowlist_content_v1_allowlist_private__allowlist_id__content_delete v1/allowlist/private/{allowlist_id}/content
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_the_allowlist_content_v1_allowlist_private__allowlist_id__content_deleteAsync(string allowlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id))+"/content";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of a private allowlist of the user.
		/// ### What
		/// Returns the content of the private allowlist of the user. The content can be CIDRs, ASNs, countries, continents or    datacenter IDs.
		/// 
		/// ### Parameters
		/// Pass the private allowlist ID as query parameter.
		/// 
		/// The following pagination parameters are required as query string parameters:
		/// - ``page``: (Optional) the page number to retrieve. The first page is 1. Default is 1.
		/// - ``page_size``: (Optional) the number of items per page. Default is 20.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to the content of the list.
		/// - ``cidrs``: (Optional) list of CIDRs in the list.
		/// - ``asns``: (Optional) list of ASNs in the list.
		/// - ``countries``: (Optional) list of countries in the list.
		/// - ``continents``: (Optional) list of continents in the list.
		/// - ``datacenters``: (Optional) list of datacenters in the list.
		/// 
		/// ### Errors
		/// 
		/// - If the allow list is not a valid UUID, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the private allowlist ID does not exist, it will return a ``404`` (Not found) error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Get_allowlist_content_v1_allowlist_private__allowlist_id__content_get v1/allowlist/private/{allowlist_id}/content
		/// </summary>
		/// <param name="page">The page to be returned</param>
		/// <param name="page_size">The number of items per page</param>
		/// <returns>Successful Response</returns>
		public async Task<PrivateAclListCollectionOutput> Get_allowlist_content_v1_allowlist_private__allowlist_id__content_getAsync(string allowlist_id, int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id))+"/content&page="+page+"&page_size="+page_size;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateAclListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add or remove content of a private allowlist of the user.
		/// ### What
		/// Add or remove content of a private allowlist of the user. The content can be CIDRs, ASNs, countries, continents or datacenter IDs.
		/// 
		/// The number of elements allowed in all the lists are limited depending on the plan of the user:
		/// - Free: 100 elements
		/// - Basic: 1000 elements
		/// - Pro: 10000 elements
		/// 
		/// ### Parameters
		/// Pass the private allowlist ID as query parameter.
		/// 
		/// In the body the following parameters:
		/// - ``append``: (Optional) Add CIDRs, ASNs, countries, continents or datacenter IDs to add to the list. It's not possible to mix different resource types in the same list.
		/// - ``remove``: (Optional) Extract CIDRs, ASNs, countries, continents or datacenter IDs to add to the list. It's not possible to mix different resource types in the same list.
		/// 
		/// 
		/// ### Result
		/// If successful, it will return a ``202`` (Accepted) response with an empty body. The operation is asynchronous,and can take several seconds to complete.
		/// 
		/// ### Errors
		/// 
		/// - If the allow list is not a valid UUID, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the private allowlist ID does not exist, it will return a ``404`` (Not found) error.
		/// - If the ``append`` or ``remove`` parameters are not processable, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the number of elements in the lists is over the limit, it will return a ``413`` (Payload Too Large) error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Update_private_content_of_the_allowlist_of_the_user_v1_allowlist_private__allowlist_id__content_put v1/allowlist/private/{allowlist_id}/content
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Update_private_content_of_the_allowlist_of_the_user_v1_allowlist_private__allowlist_id__content_putAsync(string allowlist_id, Body_update_private_content_of_the_allowlist_of_the_user_v1_allowlist_private__allowlist_id__content_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id))+"/content";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Toogle the status of the origin in an allow list.
		/// ### What
		/// Change the status of the origin of an allow list to ``ACTIVE``, ``INACTIVE`` or ``DELETED``.
		/// 
		/// An ``ACTIVE`` origin will apply the allow list to the protocol and domain of the origin. An origin can be created and activated simply toogling the ``ACTIVE`` status. As an optional parameter it can be provided an ``ttl`` or Time To Live parameter of the origin in the list in seconds. After the TTL expires, the origin will be removed from the list.  If the TTL is not provided, the origin will never expire.
		/// 
		/// An ``INACTIVE`` origin will not apply the allow list to the protocol and domain of the origin.
		/// 
		/// A ``DELETED`` origin will be removed from the list. It will not be used by the service anymore. The user can activate it again with the ``ACTIVE`` status.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will  immediately return a 202 Accepted response.
		/// 
		/// *This operation is not available in the Freemium plan.*
		/// 
		/// ### Parameters
		/// In the query string the ID of the allow list to change the status.
		/// In the body the JSON object with the following fields:
		/// - ``origin``: The protocol and domain of the origin. It can be ``http://example.com`` or ``https://example.com``.
		/// - ``status``: The status of the list. It can be ``ACTIVE``, ``INACTIVE`` or ``DELETED``.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// If the status is not ``ACTIVE`` or ``INACTIVE``, it will return a 422 error.
		/// If the TTL is negative in the past, it will return a 422 error.
		/// If the allow list is not a valid UUID, it will return a 422 error.
		/// If the origin is not a valid URL, it will return a 400 error.
		/// If the allowlist is not active, it will returna 409 error.
		/// If the origin is not found in the set owned by the user, it will return a 404 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_put v1/allowlist/private/{allowlist_id}/origin
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_putAsync(string allowlist_id, Body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/private/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id))+"/origin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of public allowlists.
		/// ### What
		/// Obtain the set of public allow lists available in the service and also which ones are already selected by the user and wich ones are not.
		/// 
		/// ### Parameters
		/// No parameters
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``    it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// If the list is already selected by the user, the JSON object will also contain the following fields:
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an allowlist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``        it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_all_public_allowlists_v1_allowlist_public_all_get v1/allowlist/public/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListCollectionOutput> Get_all_public_allowlists_v1_allowlist_public_all_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of public allowlists by resource type.
		/// ### What
		/// Obtain the set of public allow lists available in the service and also which ones are already selected by the user and wich ones are not filtering by the resource type.
		/// 
		/// ### Parameters
		/// The ``resource type`` to filter. The values can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``    it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// If the list is already selected by the user, the JSON object will also contain the following fields:
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an allowlist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``        it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_all_public_allowlists_by_resource_type_v1_allowlist_public_all__resource_type__get v1/allowlist/public/all/{resource_type}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListCollectionOutput> Get_all_public_allowlists_by_resource_type_v1_allowlist_public_all__resource_type__getAsync(Get_all_public_allowlists_by_resource_type_v1_allowlist_public_all__resource_type__getResource_type resource_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/all/"+resource_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the different public allowlists where the IP address was found.
		/// ### What
		/// Obtain the list of all the different public allowlists where the IP address entered by the user is. The public allowlists are the ones activated by the user, but managed by Threatjammer administrators.
		/// 
		/// ### Parameters
		/// The endpoint accepts the `address` parameter as query string.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual status.
		/// - ``cidrs``: the URI of the lists of CIDRs where the IP was found.
		/// - ``country``: the URIs where the lists of countries where the IP address was found
		/// - ``continent``: the URI where the continent where the IP address was found.
		/// - ``asn``: the URIs where the list of continents of the ASN where the IP address was found.
		/// - ``datacenter``: the URIs of the lists of datacenters where the IP address was found. If not found, the result is an empty string.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the IP address was malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_resource_allowlists_v1_allowlist_public_ip__address__get v1/allowlist/public/ip/{address}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AclListCollectionOutput> Query_resource_allowlists_v1_allowlist_public_ip__address__getAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/ip/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AclListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of owned allowlists.
		/// ### What
		/// Obtain the set of public allow lists available in the service selected by the user.
		/// 
		/// ### Parameters
		/// No parameters
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``    it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an allowlist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``            it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_public_allowlists_owned_by_the_user_v1_allowlist_public_owned_get v1/allowlist/public/owned
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListCollectionOutput> Get_public_allowlists_owned_by_the_user_v1_allowlist_public_owned_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/owned";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of public allowlists of a user by resource type.
		/// ### What
		/// Obtain the set of public allow lists selected by the user and wich ones are not filtering by the resource type.
		/// 
		/// ### Parameters
		/// The ``resource type`` to filter. The values can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``    it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an allowlist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``            it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_all_owned_allowlists_by_resource_type_v1_allowlist_public_owned__resource_type__get v1/allowlist/public/owned/{resource_type}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListCollectionOutput> Get_all_owned_allowlists_by_resource_type_v1_allowlist_public_owned__resource_type__getAsync(Get_all_owned_allowlists_by_resource_type_v1_allowlist_public_owned__resource_type__getResource_type resource_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/owned/"+resource_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all the bindings between a user and an allowlist.
		/// ### What
		/// Delete all the bindings between a user and an allowlist. This will remove the allowlist from the user and also all the origins that are using the allowlist.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will  immediately return a 202 Accepted response.
		/// 
		/// ### Parameters
		/// In the query string the ID of the allow list to change the status.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// If the allow list is not a valid UUID, it will return a 422 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Delete_the_allowlist_v1_allowlist_public__allowlist_id__delete v1/allowlist/public/{allowlist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_the_allowlist_v1_allowlist_public__allowlist_id__deleteAsync(string allowlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the details of the allowlist.
		/// ### What
		/// Obtain the details of an allow list available in the service.
		/// 
		/// ### Parameters
		/// No parameters
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// If the list is already selected by the user, the JSON object will also contain the following fields:
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an allowlist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``            it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_single_allowlist_v1_allowlist_public__allowlist_id__get v1/allowlist/public/{allowlist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListOutput> Get_single_allowlist_v1_allowlist_public__allowlist_id__getAsync(string allowlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Toogle the status of an allow list.
		/// ### What
		/// Change the status of an allow list to ``ACTIVE`` or ``INACTIVE``. An ``INACTIVE`` list will not be used by the service. An ``ACTIVE`` list will be used by the service. As an optional parameter it can be provided an ``expiry`` date in seconds since epoch. If not provided, the list will never expire.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will  immediately return a 202 Accepted response.
		/// 
		/// ### Parameters
		/// In the query string the ID of the allow list to change the status.
		/// In the body the JSON object with the following fields:
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE``.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// If the status is not ``ACTIVE`` or ``INACTIVE``, it will return a 422 error.
		/// If the expiry is not a valid timestamp, it will return a 422 error.
		/// If the allow list is not a valid UUID, it will return a 422 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__put v1/allowlist/public/{allowlist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__putAsync(string allowlist_id, Body_change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Toogle the status of the origin in an allow list.
		/// ### What
		/// Change the status of the origin of an allow list to ``ACTIVE``, ``INACTIVE`` or ``DELETED``.
		/// 
		/// An ``ACTIVE`` origin will apply the allow list to the protocol and domain of the origin. An origin can be created and activated simply toogling the ``ACTIVE`` status. As an optional parameter it can be provided an ``ttl`` or Time To Live parameter of the origin in the list in seconds. After the TTL expires, the origin will be removed from the list.  If the TTL is not provided, the origin will never expire.
		/// 
		/// An ``INACTIVE`` origin will not apply the allow list to the protocol and domain of the origin.
		/// 
		/// A ``DELETED`` origin will be removed from the list. It will not be used by the service anymore. The user can activate it again with the ``ACTIVE`` status.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will  immediately return a 202 Accepted response.
		/// 
		/// *This operation is not available in the Freemium plan.*
		/// 
		/// ### Parameters
		/// In the query string the ID of the allow list to change the status.
		/// In the body the JSON object with the following fields:
		/// - ``origin``: The protocol and domain of the origin. It can be ``http://example.com`` or ``https://example.com``.
		/// - ``status``: The status of the list. It can be ``ACTIVE``, ``INACTIVE`` or ``DELETED``.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// If the status is not ``ACTIVE`` or ``INACTIVE``, it will return a 422 error.
		/// If the TTL is negative in the past, it will return a 422 error.
		/// If the allow list is not a valid UUID, it will return a 422 error.
		/// If the origin is not a valid URL, it will return a 400 error.
		/// If the allowlist is not active, it will returna 409 error.
		/// If the origin is not found in the set owned by the user, it will return a 404 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Change_status_of_the_origin_allowlist_v1_allowlist_public__allowlist_id__origin_put v1/allowlist/public/{allowlist_id}/origin
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Change_status_of_the_origin_allowlist_v1_allowlist_public__allowlist_id__origin_putAsync(string allowlist_id, Body_change_status_of_the_origin_allowlist_v1_allowlist_public__allowlist_id__origin_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/allowlist/public/"+ (allowlist_id==null? "" : System.Uri.EscapeDataString(allowlist_id))+"/origin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the IPv4 or IPv6 prefix of the IP address given.
		/// ### What
		/// Obtain the IPv4 or IPv6 prefix and the Autonomous System information of the IP address passed as a parameter.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``ip_address``: (Mandatory) The IPv4 or IPv6 address to be queried.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to individual IPv4 prefix.
		/// - ``asn``: the URI to query the full details of the ASN.
		/// - ``object_type``: the type of the prefix. The allowed values are: IPv4 or IPv6.
		/// - ``maintainer``: the information about the maintainer of this prefix in the registry.
		/// - ``description``: the description of the prefix as registered in the registry.
		/// - ``registry_date``: the date of registration of the prefix in the registry. The format is YYYY-MM-DD.
		/// - ``registry_status``: the URI of the status of the prefix as stored in the registry.
		/// - ``score``: The risk score of the prefix. It ranges from 0 to 99.
		/// - ``risk``: The risk of the prefix. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if the prefix information was not found.
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_IP_address_network_information_v1_asn_ip__ip_address__get v1/asn/ip/{ip_address}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AutonomousSystemPrefixOutput> Query_IP_address_network_information_v1_asn_ip__ip_address__getAsync(string ip_address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/asn/ip/"+ (ip_address==null? "" : System.Uri.EscapeDataString(ip_address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AutonomousSystemPrefixOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the IPv4 or IPv6 prefix of the CIDR given.
		/// ### What
		/// Obtain the IPv4 or IPv6 prefix and the Autonomous System information of the CIDR passed in the body as a POST method. This endpoint works around the problem of passing '/' addresses in the URI.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the body as a JSON object:
		/// - ``prefix``: (Mandatory) The CIDR v4 or v6 to be queried.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to individual IPv4 prefix.
		/// - ``asn``: the URI to query the full details of the ASN.
		/// - ``object_type``: the type of the prefix. The allowed values are: IPv4 or IPv6.
		/// - ``maintainer``: the information about the maintainer of this prefix in the registry.
		/// - ``description``: the description of the prefix as registered in the registry.
		/// - ``registry_date``: the date of registration of the prefix in the registry. The format is YYYY-MM-DD.
		/// - ``registry_status``: the URI of the status of the prefix as stored in the registry.
		/// - ``score``: The risk score of the prefix. It ranges from 0 to 99.
		/// - ``risk``: The risk of the prefix. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if the prefix information was not found.
		/// - a `422 Unprocessable Entity` error if the CIDR is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_asn_prefix_information_v1_asn_prefix_post v1/asn/prefix
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AutonomousSystemPrefixOutput> Query_asn_prefix_information_v1_asn_prefix_postAsync(Body_query_asn_prefix_information_v1_asn_prefix_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/asn/prefix";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AutonomousSystemPrefixOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of the Regional Internet Registries (RIRs) entities worldwide.
		/// ### What
		/// Obtain the list of Regional Internet Registries (RIRs) entities worldwide.
		/// 
		/// ### Parameters
		/// No parameters are required.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual RIR.
		/// - ``name``: the RIR name.
		/// - ``code``: the internal code of the RIR in the system. Possible values are: iana, arin, ripencc, afrinic, apnic, lacnic.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_registry_names_v1_asn_registry_all_get v1/asn/registry/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AutonomousSystemRegistryOutput[]> Query_registry_names_v1_asn_registry_all_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/asn/registry/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AutonomousSystemRegistryOutput[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of a Regional Internet Registries (RIRs) given.
		/// ### What
		/// Obtain the information about the Regional Internet Registries (RIRs) given as a parameter.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``code``: (Mandatory) The code that identifies uniquely the RIR. Possible values are: iana, arin, ripencc, afrinic, apnic, lacnic.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to individual RIR.
		/// - ``name``: the RIR name.
		/// - ``code``: the internal code of the RIR in the system.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the code is not one of the available.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_registry_by_the_name_v1_asn_registry__code__get v1/asn/registry/{code}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AutonomousSystemRegistryOutput> Query_registry_by_the_name_v1_asn_registry__code__getAsync(Query_registry_by_the_name_v1_asn_registry__code__getCode code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/asn/registry/"+code;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AutonomousSystemRegistryOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of status of an object in a registry.
		/// ### What
		/// Obtain the list of status of an object can be in a registry.
		/// 
		/// ### Parameters
		/// No parameters are required.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual status.
		/// - ``name``: the code name.
		/// - ``code``: the internal code of the status in the system. Possible values are: assigned, reserved, allocated, available.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_status_names_v1_asn_status_all_get v1/asn/status/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AutonomousSystemStatusOutput[]> Query_status_names_v1_asn_status_all_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/asn/status/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AutonomousSystemStatusOutput[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of a status given.
		/// ### What
		/// Obtain the information about the status of an object in the registry as a parameter.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``code``: (Mandatory) The code that identifies uniquely the status in the registry. Possible values are: assigned, reserved, allocated, available.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to individual status.
		/// - ``name``: the human readable name of the status.
		/// - ``code``: the internal code of the status in the system.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the code is not one of the available.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_status_by_the_name_v1_asn_status__code__get v1/asn/status/{code}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AutonomousSystemStatusOutput> Query_status_by_the_name_v1_asn_status__code__getAsync(Query_status_by_the_name_v1_asn_status__code__getCode code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/asn/status/"+code;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AutonomousSystemStatusOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the Autonomous System details of the AS number given.
		/// ### What
		/// Obtain the full details of the Autonomous System Number (ASN) passed as a parameter.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``number``: (Mandatory) The ASN number to be queried.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``name``: the name of the Autonomous System as registered in the registries databases.
		/// - ``description``: the description of the Autonomous System as registered in the registries databases.
		/// - ``country_code``: the ISO 3166-1 alpha-2 country code of the Autonomous System.
		/// - ``registry_date``: the date of registration of the Autonomous System in the registry. The format is YYYY-MM-DD.
		/// - ``registry``: the URI of the registry where the Autonomous System is registered.
		/// - ``status``: the status of the Autonomous System as stored in the registry.
		/// - ``prefixes``: the URI to the list of prefixes that belong to the Autonomous System.
		/// - ``score``: The risk score of the Autonomous System. It ranges from 0 to 99.
		/// - ``risk``: The risk of the Autonomous System. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if the AS was not found.
		/// - a `422 Unprocessable Entity` error if the AS number is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_asn_v1_asn__number__get v1/asn/{number}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AutonomousSystemOutput> Query_asn_v1_asn__number__getAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/asn/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AutonomousSystemOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of IPv4 and IPv6 prefixes of the AS number given.
		/// ### What
		/// Obtain the full list of IPv4 and IPv6 prefixes of the Autonomous System Number (ASN) passed as a parameter.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``number``: (Mandatory) The ASN number to be queried.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``asn``: the URI to query the full details of the ASN.
		/// - ``prefixes_v4``: the list of IPv4 prefixes that belong to the ASN. Each element of the list is a JSON object with the following structure:
		/// - ``self``: the URI to individual IPv4 prefix.
		/// - ``asn``: the URI to query the full details of the ASN.
		/// - ``object_type``: the type of the prefix. The allowed values are: IPv4.
		/// - ``maintainer``: the information about the maintainer of this prefix in the registry.
		/// - ``description``: the description of the prefix as registered in the registry.
		/// - ``registry_date``: the date of registration of the prefix in the registry. The format is YYYY-MM-DD.
		/// - ``registry_status``: the URI of the status of the prefix as stored in the registry.
		/// - ``score``: The risk score of the prefix. It ranges from 0 to 99.
		/// - ``risk``: The risk of the prefix. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// - ``prefixes_v6``: the list of IPv6 prefixes that belong to the ASN. Each element of the list is a JSON object with the following structure:
		/// - ``self``: the URI to individual IPv6 prefix.
		/// - ``asn``: the URI to query the full details of the ASN.
		/// - ``object_type``: the type of the prefix. The allowed values are: IPv6.
		/// - ``maintainer``: the information about the maintainer of this prefix in the registry.
		/// - ``description``: the description of the prefix as registered in the registry.
		/// - ``registry_date``: the date of registration of the prefix in the registry. The format is YYYY-MM-DD.
		/// - ``registry_status``: the URI of the status of the prefix as stored in the registry.
		/// - ``score``: The risk score of the prefix. It ranges from 0 to 99.
		/// - ``risk``: The risk of the prefix. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if the AS was not found.
		/// - a `422 Unprocessable Entity` error if the AS number is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_asn_prefixes_list_v1_asn__number__prefixes_get v1/asn/{number}/prefixes
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AutonomousSystemPrefixesOutput> Query_asn_prefixes_list_v1_asn__number__prefixes_getAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/asn/"+number+"/prefixes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AutonomousSystemPrefixesOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the risk score of all IP address passed in the body and other data signals.
		/// ### What
		/// Obtain a numerical score and a risk assessment of all the IP addresses passed as argument.
		/// 
		/// ### Parameters
		/// A list of public IPv4 or IPv6 addresses is required in the body of the request.
		/// 
		/// ### Result
		/// The result contains a list of the result for each IP address, with two main sets of data:
		/// - The score is a number **between 0 and 99** describing the probability of the IP address being a malicious one, being **0** means that the IP address is not malicious and is not a threat. Being **99** means that the service behind the IP address is probably malicious an certainly a threat.
		/// 
		/// - The list of information gathered from the IP address to obtain the score.
		/// 
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``score``: The score of the IP address. It ranges from 0 to 99.
		/// - ``risk``: The risk of the IP address. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// - ``reason``: It's a human readable representation of the reason of the risk.
		/// - ``datasets``: The IP address was found in the these lists of datasets used to obtain the risk score. Datasets are described as a list of URIs.
		/// - ``sources``: The IP address was found in the these source lists at an specific time with a specific risk score. Sources are described as a list of URIs.
		/// - ``log``: The activity of the IP address in the different datasets used to obtain the risk score. The log is a URI reference.
		/// - ``asn``: The information about the Autonomous System (AS) of the IP address. The AS is described as an URI.
		/// - ``asn_prefix``: The information about the Autonomous System (AS) network prefix of the IP address. The prefix is described as an URI.
		/// - ``datacenter``: If the IP address is part of a datacenter pool, the information about the datacenter is described as an URI.
		/// - ``datacenter_prefix``: The information about the Datacenter network prefix of the IP address. The `asn_prefix` and `datacenter_prefix` can be the same, but it is not mandatory. The prefix is described as an URI.
		/// - ``denylisted``: If the IP address was denylisted by the user, the information about the denylisted IP address is described as an URI.
		/// - ``first_appearence``: URI to the first appearance of the IP address in the different datasets used to obtain the risk score.
		/// - ``last_appearence``: URI to the last appearance of the IP address in the different datasets used to obtain the risk score.
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// The private IP addresses will be ignored, if any.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Assess_ip_set_v1_assess_ip_post v1/assess/ip
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<IPAssessmentCollectionOutput> Assess_ip_set_v1_assess_ip_postAsync(string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/assess/ip";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IPAssessmentCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a risk score of the IP address and different data signals.
		/// ### What
		/// Obtain a numerical score and a risk assessment of the IP address passed as argument.
		/// 
		/// ### Parameters
		/// The only argument accepted in the query string is a public IPv4 or IPv6 addresses.
		/// 
		/// ### Result
		/// The result contains two main sets of data:
		/// - The score is a number **between 0 and 99** describing the probability of the IP address being a malicious one, being **0** means that the IP address is not malicious and is not a threat. Being **99** means that the service behind the IP address is probably malicious an certainly a threat.
		/// 
		/// - The list of information gathered from the IP address to obtain the score.
		/// 
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``score``: The score of the IP address. It ranges from 0 to 99.
		/// - ``risk``: The risk of the IP address. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// - ``reason``: It's a human readable representation of the reason of the risk.
		/// - ``datasets``: The IP address was found in the these lists of datasets used to obtain the risk score. Datasets are described as a list of URIs.
		/// - ``sources``: The IP address was found in the these source lists at an specific time with a specific risk score. Sources are described as a list of URIs.
		/// - ``log``: The activity of the IP address in the different datasets used to obtain the risk score. The log is a URI reference.
		/// - ``asn``: The information about the Autonomous System (AS) of the IP address. The AS is described as an URI.
		/// - ``asn_prefix``: The information about the Autonomous System (AS) network prefix of the IP address. The prefix is described as an URI.
		/// - ``datacenter``: If the IP address is part of a datacenter pool, the information about the datacenter is described as an URI.
		/// - ``datacenter_prefix``: The information about the Datacenter network prefix of the IP address. The `asn_prefix` and `datacenter_prefix` can be the same, but it is not mandatory. The prefix is described as an URI.
		/// - ``denylisted``: If the IP address was denylisted by the user, the information about the denylisted IP address is described as an URI.
		/// - ``first_appearence``: URI to the first appearance of the IP address in the different datasets used to obtain the risk score.
		/// - ``last_appearence``: URI to the last appearance of the IP address in the different datasets used to obtain the risk score.
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `400 Bad Request` error if the IP address is not public.
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Assess_ip_v1_assess_ip__ip_address__get v1/assess/ip/{ip_address}
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<IPAssessmentOutput> Assess_ip_v1_assess_ip__ip_address__getAsync(string ip_address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/assess/ip/"+ (ip_address==null? "" : System.Uri.EscapeDataString(ip_address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IPAssessmentOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the IPv4 or IPv6 prefix of the IP address given.
		/// ### What
		/// Obtain the IPv4 or IPv6 prefix and the Datacenter information of the IP address passed as a parameter.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``ip_address``: (Mandatory) The IPv4 or IPv6 address to be queried.
		/// 
		/// ### Result
		/// - The result is a JSON object with the following structure:
		/// - ``self``: the URI to individual IPv4 prefix.
		/// - ``datacenter_id``: the URI to query the full details of the Datacenter.
		/// - ``score``: The risk score of the prefix. It ranges from 0 to 99.
		/// - ``risk``: The risk of the prefix. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// - ``min_score``: The minimum risk score of the prefix. It ranges from 0 to 99.
		/// - ``max_score``: The maximum risk score of the prefix. It ranges from 0 to 99.
		/// - ``ip_abuse_total``: The total number of IPs that have been reported as abuse in the range.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if the prefix information was not found.
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_IP_address_network_information_v1_datacenter_ip__ip_address__get v1/datacenter/ip/{ip_address}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<DatacenterPrefixOutput> Query_IP_address_network_information_v1_datacenter_ip__ip_address__getAsync(string ip_address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/datacenter/ip/"+ (ip_address==null? "" : System.Uri.EscapeDataString(ip_address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DatacenterPrefixOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the IPv4 or IPv6 prefix of the CIDR given.
		/// ### What
		/// Obtain the IPv4 or IPv6 prefix and the Datacenter information of the CIDR passed in the body as a POST method. This endpoint works around the problem of passing '/' addresses in the URI.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the body as a JSON object:
		/// - ``prefix``: (Mandatory) The CIDR v4 or v6 to be queried.
		/// 
		/// ### Result
		/// - The result is a JSON object with the following structure:
		/// - ``self``: the URI to individual IPv4 prefix.
		/// - ``datacenter_id``: the URI to query the full details of the Datacenter.
		/// - ``score``: The risk score of the prefix. It ranges from 0 to 99.
		/// - ``risk``: The risk of the prefix. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// - ``min_score``: The minimum risk score of the prefix. It ranges from 0 to 99.
		/// - ``max_score``: The maximum risk score of the prefix. It ranges from 0 to 99.
		/// - ``ip_abuse_total``: The total number of IPs that have been reported as abuse in the range.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if the prefix information was not found.
		/// - a `422 Unprocessable Entity` error if the CIDR is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_datacenter_prefix_information_v1_datacenter_prefix_post v1/datacenter/prefix
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<DatacenterPrefixOutput> Query_datacenter_prefix_information_v1_datacenter_prefix_postAsync(Body_query_datacenter_prefix_information_v1_datacenter_prefix_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/datacenter/prefix";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DatacenterPrefixOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the Datacenter details of datacente given.
		/// ### What
		/// Obtain the details of the Datacenter ID passed as a parameter.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``datacenter_id``: (Mandatory) The internal Datacenter ID to be queried.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``name``: the generic name of the Datacenter. The database takes the name from different sources, so it may be different from the real name.
		/// - ``description``: a full name of the Datacenter. It contains more details about the Datacenter.
		/// - ``source``: website of the company that owns the Datacenter.
		/// - ``asn``: the URI to the ASN of the Datacenter.
		/// - ``status``: the status of the Datacenter. It can be: `enabled` or `disabled`.
		/// - ``prefixes``: the URI to the list of prefixes that belong to the Datacenter.
		/// - ``score``: The risk score of the Datacenter. It ranges from 0 to 99.
		/// - ``risk``: The risk of the Datacenter. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if the Datacenter was not found.
		/// - a `422 Unprocessable Entity` error if the Datacenter is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_datacenter_v1_datacenter__datacenter_id__get v1/datacenter/{datacenter_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<DatacenterOutput> Query_datacenter_v1_datacenter__datacenter_id__getAsync(string datacenter_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/datacenter/"+ (datacenter_id==null? "" : System.Uri.EscapeDataString(datacenter_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DatacenterOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of IPv4 and IPv6 prefixes of the Datacenter given.
		/// ### What
		/// Obtain the full list of IPv4 and IPv6 prefixes of the Datacenter passed as a parameter.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``datacenter_id``: (Mandatory) The internal Datacenter ID to be queried.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``datacenter_id``: the URI to query the full details of the Datacenter.
		/// - ``prefixes_v4``: the list of IPv4 prefixes that belong to the Datacenter. Each element of the list is a JSON object with the following structure:
		/// 
		/// - ``self``: the URI to individual IPv4 prefix.
		/// - ``datacenter_id``: the URI to query the full details of the Datacenter.
		/// - ``score``: The risk score of the prefix. It ranges from 0 to 99.
		/// - ``risk``: The risk of the prefix. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// - ``min_score``: The minimum risk score of the prefix. It ranges from 0 to 99.
		/// - ``max_score``: The maximum risk score of the prefix. It ranges from 0 to 99.
		/// - ``ip_abuse_total``: The total number of IPs that have been reported as abuse in the range.
		/// 
		/// - ``prefixes_v6``: the list of IPv6 prefixes that belong to the Datacenter. Each element of the list is a JSON object with the following structure:
		/// 
		/// - ``self``: the URI to individual IPv4 prefix.
		/// - ``datacenter_id``: the URI to query the full details of the Datacenter.
		/// - ``score``: The risk score of the prefix. It ranges from 0 to 99.
		/// - ``risk``: The risk of the prefix. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// - ``min_score``: The minimum risk score of the prefix. It ranges from 0 to 99.
		/// - ``max_score``: The maximum risk score of the prefix. It ranges from 0 to 99.
		/// - ``ip_abuse_total``: The total number of IPs that have been reported as abuse in the range.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if the Datacenter was not found.
		/// - a `422 Unprocessable Entity` error if the Datacenter number is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_datacenter_prefixes_list_v1_datacenter__datacenter_id__prefixes_get v1/datacenter/{datacenter_id}/prefixes
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<DatacenterPrefixesOutput> Query_datacenter_prefixes_list_v1_datacenter__datacenter_id__prefixes_getAsync(string datacenter_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/datacenter/"+ (datacenter_id==null? "" : System.Uri.EscapeDataString(datacenter_id))+"/prefixes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DatacenterPrefixesOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of all the datasets available in the platform.
		/// ### What
		/// Obtain the list of all the datasets available in the platform. A dataset is a collection of different data sources that are related to a specific topic. The name of the dataset describes the specific topic.
		/// 
		/// ### Parameters
		/// No parameters are required.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual status.
		/// - ``types``: a list of JSON objects with the following fields:
		/// - ``self``: the URI to individual dataset information.
		/// - ``type``: what type of dataset is this. The only allowed value is ``ip``.
		/// - ``name``: the name of the dataset in human readable form.
		/// - ``description``: a human readable long description of the dataset.
		/// - ``status``: the status of the dataset. The only allowed value is ``ENABLED``.
		/// - ``items``: the number of 'live' items in the dataset when the request is performed.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_datataset_information_of_all_the_resource_types_v1_dataset_ip_get v1/dataset/ip
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<DatasetTypeCollectionOutput> Query_datataset_information_of_all_the_resource_types_v1_dataset_ip_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/dataset/ip";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DatasetTypeCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the detailed information of the dataset queried.
		/// ### What
		/// Get the detailed information of the dataset queried by the name. A dataset is a collection of different data sources that are related to a specific topic. The name of the dataset describes the specific topic.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``name``: (Mandatory) The code name that identifies uniquely the dataset in the platform. It must be composed of uppercase letters, numbers and underscores.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to individual dataset information.
		/// - ``type``: what type of dataset is this. The only allowed value is ``ip``.
		/// - ``name``: the name of the dataset in human readable form.
		/// - ``description``: a human readable long description of the dataset.
		/// - ``status``: the status of the dataset. The only allowed value is ``ENABLED``.
		/// - ``items``: the number of 'live' items in the dataset when the request is performed.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the dataset code name was not found.
		/// - a `422 Unprocessable Entity` error if dataset code name does not follow the naming convention.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_datataset_information_of_the_resource_type_v1_dataset_ip__name__get v1/dataset/ip/{name}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<DatasetTypeOutput> Query_datataset_information_of_the_resource_type_v1_dataset_ip__name__getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/dataset/ip/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DatasetTypeOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new private denylist binded to the user.
		/// ### What
		/// Creates a new denylist with the information given and binded to the current user. The parameters are:
		/// - name
		/// - description
		/// - tags
		/// - expiry
		/// - Time to Live (TTL)
		/// - Resource Type (`CIDR`, `AS`, `COUNTRY`, `CONTINENT`, `DATACENTER_ID` and `USER AGENT`)
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will immediately return a 202 Accepted response. The operation will also return the UUID of the list.
		/// 
		/// ### Parameters
		/// In the query string the ID of the private deny list to delete.
		/// 
		/// In the body the following parameters:
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``tags``: A list of tags that describe the list.
		/// - ``ttl``: (Optional) The Time To Live of the list, in seconds. If it does not exist, it will never expire.
		/// - ``resource_type``: The type of resource that the list contains. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT``,    ``DATACENTER_ID`` or ``USER AGENT``.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with the UUID of the new list in the body.
		/// 
		/// ### Errors
		/// 
		/// - If the information is not valid, it will return a `422` (Unprocessable Entity) error.
		/// - If the ttl is negative, it will return a `400` (Bad Request) error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Create_private_denylist_of_the_user_v1_denylist_private_post v1/denylist/private
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<string> Create_private_denylist_of_the_user_v1_denylist_private_postAsync(Body_create_private_denylist_of_the_user_v1_denylist_private_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of private denylists of the user.
		/// ### What
		/// Obtain the set of private deny lists of the user available in the service. These lists are different datasets:
		/// - Lists that are part of the automatically reported data from the Report IP, focused on honeypots and automaticreporting from external sources. The name is `External sources reported CIDRs`.
		/// - Lists that are part of the automatically denylisted by the Threat Jammer service. The name is `Default denylist`.
		/// - Lists that are created by the user.
		/// 
		/// ### Parameters
		/// No parameters
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as a denylist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED`` it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_all_private_denylists_v1_denylist_private_all_get v1/denylist/private/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PrivateAclGroupListCollectionOutput> Get_all_private_denylists_v1_denylist_private_all_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of private denylists of the user by resource type.
		/// ### What
		/// Obtain the set of private deny lists of the user available in the service filtering by resource type. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``
		/// 
		/// These lists are different datasets:
		/// - Lists that are part of the automatically reported data from the Report IP, focused on honeypots and automaticreporting from external sources. The name is `External sources reported CIDRs`. The resource type is ``CIDR``.
		/// - Lists that are part of the automatically denylisted by the Threat Jammer service. The name is `Default denylist`. The resource type is ``CIDR``.
		/// - Lists that are created by the user.
		/// 
		/// ### Parameters
		/// The ``resource type`` to filter. The values can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as a denylist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED`` it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// - If the resource type is not valid, it will return a ``422`` (Unprocessable Entity) error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Get_all_private_denylists_by_resource_type_v1_denylist_private_all__resource_type__get v1/denylist/private/all/{resource_type}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PrivateAclGroupListCollectionOutput> Get_all_private_denylists_by_resource_type_v1_denylist_private_all__resource_type__getAsync(Get_all_private_denylists_by_resource_type_v1_denylist_private_all__resource_type__getResource_type resource_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/all/"+resource_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the different denylists where the IP address was found.
		/// ### What
		/// Obtain the list of all the different denylists where the IP address entered by the user. The denylisted forbidden datasets are the ones submitted manually by the user from files or indidual items.
		/// 
		/// ### Parameters
		/// The endpoint accepts the `address` parameter as query string.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual status.
		/// - ``cidrs``: the URI of the lists of CIDRs where the IP was found.
		/// - ``country``: the URIs where the lists of countries where the IP address was found
		/// - ``continent``: the URI where the continent where the IP address was found.
		/// - ``asn``: the URIs where the list of continents of the ASN where the IP address was found.
		/// - ``datacenter``: the URIs of the lists of datacenters where the IP address was found. If not found, the result is an empty string.
		/// - ``reported``: the URI of the information of the IP address reported by the user.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the IP address was malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_resource_denylists_v1_denylist_private_ip__address__get v1/denylist/private/ip/{address}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AclListCollectionOutput> Query_resource_denylists_v1_denylist_private_ip__address__getAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/ip/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AclListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all the bindings between a user and a private denylist.
		/// ### What
		/// Delete all the bindings between a user and a private denylist. This will remove the content of the denylist, the denylist from the user and also all the origins that are using the denylist.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request willimmediately return a 202 Accepted response.
		/// 
		/// The default lists ``External sources reported CIDRs`` and ``Default denylist`` cannot be deleted, but can be emptied. Please refer to the documentation to delete the content.
		/// 
		/// ### Parameters
		/// In the query string the ID of the private deny list to delete.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// - If the list does not exist, it will return a `404` (Not found) error.
		/// - If the list is a default list, it will return a `403` (Forbidden) error.
		/// - If the deny list is not a valid UUID, it will return a `422` (Unprocessable Entity) error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Delete_the_denylist_v1_denylist_private__denylist_id__delete v1/denylist/private/{denylist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_the_denylist_v1_denylist_private__denylist_id__deleteAsync(string denylist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the details of a specific private denylist of the user.
		/// ### What
		/// Obtain the details of the private deny list of the user available in the service.
		/// 
		/// ### Parameters
		/// Pass the private denylist ID as query parameter.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as a denylist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED`` it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// - If the deny list is not a valid UUID, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the private denylist ID does not exist, it will return a ``404`` (Not found) error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Get_single_denylist_v1_denylist_private__denylist_id__get v1/denylist/private/{denylist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PrivateAclGroupListOutput> Get_single_denylist_v1_denylist_private__denylist_id__getAsync(string denylist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateAclGroupListOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the information of an existing private denylist of the user.
		/// ### What
		/// Updates the information that describes the denylist of the user in the system. The parameters that can be modified are:
		/// - name
		/// - description
		/// - tags
		/// - expiry
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will immediately return a 202 Accepted response.
		/// 
		/// The default lists ``External sources reported CIDRs`` and ``Default denylist`` cannot be updated.
		/// 
		/// ### Parameters
		/// In the query string the ID of the private deny list to delete.
		/// 
		/// In the body the following parameters:
		/// - ``name``: (Optional) A human readable name of the list.
		/// - ``description``: (Optional) A long detailed information about what the list contains and how it is used.
		/// - ``tags``: (Optional) A list of tags that describe the list.
		/// - ``expiry``: (Optional) Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// - If the list does not exist, it will return a `404` (Not found) error.
		/// - If the list is a default list, it will return a `403` (Forbidden) error.
		/// - If the deny list is not a valid UUID, it will return a `422` (Unprocessable Entity) error.
		/// - If the expiry is not a valid timestamp, it will return a `422` (Unprocessable Entity) error.
		/// - If the expiry is in the past, it will return a `400` (Bad Request) error.
		/// - If the name is not a string, it will return a `422` (Unprocessable Entity) error.
		/// - If the description is not a string, it will return a `422` (Unprocessable Entity) error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Update_private_denylist_of_the_user_v1_denylist_private__denylist_id__put v1/denylist/private/{denylist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Update_private_denylist_of_the_user_v1_denylist_private__denylist_id__putAsync(string denylist_id, Body_update_private_denylist_of_the_user_v1_denylist_private__denylist_id__put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all the content of a private denylist of the user.
		/// ### What
		/// Delete all the content of a private denylist of the user. This will remove all the elements, and there is no way to recover them.
		/// 
		/// ### Parameters
		/// Pass the private denylist ID as query parameter.
		/// 
		/// ### Result
		/// If successful, it will return a ``202`` (Accepted) response with an empty body. The operation is asynchronous,and can take several seconds to complete.
		/// 
		/// ### Errors
		/// 
		/// - If the deny list is not a valid UUID, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the private denylist ID does not exist, it will return a ``404`` (Not found) error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Delete_the_denylist_content_v1_denylist_private__denylist_id__content_delete v1/denylist/private/{denylist_id}/content
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_the_denylist_content_v1_denylist_private__denylist_id__content_deleteAsync(string denylist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id))+"/content";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of a private denylist of the user.
		/// ### What
		/// Returns the content of the private denylist of the user. The content can be CIDRs, ASNs, countries, continents or    datacenter IDs.
		/// 
		/// ### Parameters
		/// Pass the private denylist ID as query parameter.
		/// 
		/// The following pagination parameters are required as query string parameters:
		/// - ``page``: (Optional) the page number to retrieve. The first page is 1. Default is 1.
		/// - ``page_size``: (Optional) the number of items per page. Default is 20.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to the content of the list.
		/// - ``cidrs``: (Optional) list of CIDRs in the list.
		/// - ``asns``: (Optional) list of ASNs in the list.
		/// - ``countries``: (Optional) list of countries in the list.
		/// - ``continents``: (Optional) list of continents in the list.
		/// - ``datacenters``: (Optional) list of datacenters in the list.
		/// 
		/// ### Errors
		/// 
		/// - If the deny list is not a valid UUID, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the private denylist ID does not exist, it will return a ``404`` (Not found) error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Get_denylist_content_v1_denylist_private__denylist_id__content_get v1/denylist/private/{denylist_id}/content
		/// </summary>
		/// <param name="page">The page to be returned</param>
		/// <param name="page_size">The number of items per page</param>
		/// <returns>Successful Response</returns>
		public async Task<PrivateAclListCollectionOutput> Get_denylist_content_v1_denylist_private__denylist_id__content_getAsync(string denylist_id, int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id))+"/content&page="+page+"&page_size="+page_size;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateAclListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add or remove content of a private denylist of the user.
		/// ### What
		/// Add or remove content of a private denylist of the user. The content can be CIDRs, ASNs, countries, continents or datacenter IDs.
		/// 
		/// The number of elements allowed in all the lists are limited depending on the plan of the user:
		/// - Free: 100 elements
		/// - Basic: 1000 elements
		/// - Pro: 10000 elements
		/// 
		/// ### Parameters
		/// Pass the private denylist ID as query parameter.
		/// 
		/// In the body the following parameters:
		/// - ``append``: (Optional) Add CIDRs, ASNs, countries, continents or datacenter IDs to add to the list. It's not possible to mix different resource types in the same list.
		/// - ``remove``: (Optional) Extract CIDRs, ASNs, countries, continents or datacenter IDs to add to the list. It's not possible to mix different resource types in the same list.
		/// 
		/// 
		/// ### Result
		/// If successful, it will return a ``202`` (Accepted) response with an empty body. The operation is asynchronous,and can take several seconds to complete.
		/// 
		/// ### Errors
		/// 
		/// - If the deny list is not a valid UUID, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the private denylist ID does not exist, it will return a ``404`` (Not found) error.
		/// - If the ``append`` or ``remove`` parameters are not processable, it will return a ``422`` (Unprocessable Entity) error.
		/// - If the number of elements in the lists is over the limit, it will return a ``413`` (Payload Too Large) error.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Update_private_content_of_the_denylist_of_the_user_v1_denylist_private__denylist_id__content_put v1/denylist/private/{denylist_id}/content
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Update_private_content_of_the_denylist_of_the_user_v1_denylist_private__denylist_id__content_putAsync(string denylist_id, Body_update_private_content_of_the_denylist_of_the_user_v1_denylist_private__denylist_id__content_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id))+"/content";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Toogle the status of the origin in a deny list.
		/// ### What
		/// Change the status of the origin of a deny list to ``ACTIVE``, ``INACTIVE`` or ``DELETED``.
		/// 
		/// An ``ACTIVE`` origin will apply the deny list to the protocol and domain of the origin. An origin can be created and activated simply toogling the ``ACTIVE`` status. As an optional parameter it can be provided an ``ttl`` or Time To Live parameter of the origin in the list in seconds. After the TTL expires, the origin will be removed from the list.  If the TTL is not provided, the origin will never expire.
		/// 
		/// An ``INACTIVE`` origin will not apply the deny list to the protocol and domain of the origin.
		/// 
		/// A ``DELETED`` origin will be removed from the list. It will not be used by the service anymore. The user can activate it again with the ``ACTIVE`` status.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will  immediately return a 202 Accepted response.
		/// 
		/// *This operation is not available in the Freemium plan.*
		/// 
		/// ### Parameters
		/// In the query string the ID of the deny list to change the status.
		/// In the body the JSON object with the following fields:
		/// - ``origin``: The protocol and domain of the origin. It can be ``http://example.com`` or ``https://example.com``.
		/// - ``status``: The status of the list. It can be ``ACTIVE``, ``INACTIVE`` or ``DELETED``.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// If the status is not ``ACTIVE`` or ``INACTIVE``, it will return a 422 error.
		/// If the TTL is negative in the past, it will return a 422 error.
		/// If the deny list is not a valid UUID, it will return a 422 error.
		/// If the origin is not a valid URL, it will return a 400 error.
		/// If the denylist is not active, it will returna 409 error.
		/// If the origin is not found in the set owned by the user, it will return a 404 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Change_status_of_the_origin_denylist_v1_denylist_private__denylist_id__origin_put v1/denylist/private/{denylist_id}/origin
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Change_status_of_the_origin_denylist_v1_denylist_private__denylist_id__origin_putAsync(string denylist_id, Body_change_status_of_the_origin_denylist_v1_denylist_private__denylist_id__origin_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/private/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id))+"/origin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of public denylists.
		/// ### What
		/// Obtain the set of public deny lists available in the service and also which ones are already selected by the user and wich ones are not.
		/// 
		/// ### Parameters
		/// No parameters
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``    it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// If the list is already selected by the user, the JSON object will also contain the following fields:
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an denylist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``        it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_all_public_denylists_v1_denylist_public_all_get v1/denylist/public/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListCollectionOutput> Get_all_public_denylists_v1_denylist_public_all_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of public denylists by resource type.
		/// ### What
		/// Obtain the set of public deny lists available in the service and also which ones are already selected by the user and wich ones are not filtering by the resource type.
		/// 
		/// ### Parameters
		/// The ``resource type`` to filter. The values can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``    it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// If the list is already selected by the user, the JSON object will also contain the following fields:
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an denylist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``        it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_all_public_denylists_by_resource_type_v1_denylist_public_all__resource_type__get v1/denylist/public/all/{resource_type}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListCollectionOutput> Get_all_public_denylists_by_resource_type_v1_denylist_public_all__resource_type__getAsync(Get_all_public_denylists_by_resource_type_v1_denylist_public_all__resource_type__getResource_type resource_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/all/"+resource_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the different public denylists where the IP address was found.
		/// ### What
		/// Obtain the list of all the different public denylists where the IP address entered by the user is. The public denylists are the ones activated by the user, but managed by Threatjammer administrators.
		/// 
		/// ### Parameters
		/// The endpoint accepts the `address` parameter as query string.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual status.
		/// - ``cidrs``: the URI of the lists of CIDRs where the IP was found.
		/// - ``country``: the URIs where the lists of countries where the IP address was found
		/// - ``continent``: the URI where the continent where the IP address was found.
		/// - ``asn``: the URIs where the list of continents of the ASN where the IP address was found.
		/// - ``datacenter``: the URIs of the lists of datacenters where the IP address was found. If not found, the result is an empty string.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the IP address was malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_resource_denylists_v1_denylist_public_ip__address__get v1/denylist/public/ip/{address}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<AclListCollectionOutput> Query_resource_denylists_v1_denylist_public_ip__address__getAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/ip/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AclListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of owned denylists.
		/// ### What
		/// Obtain the set of public deny lists available in the service selected by the user.
		/// 
		/// ### Parameters
		/// No parameters
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``    it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an denylist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``            it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_public_denylists_owned_by_the_user_v1_denylist_public_owned_get v1/denylist/public/owned
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListCollectionOutput> Get_public_denylists_owned_by_the_user_v1_denylist_public_owned_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/owned";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the set of public denylists of a user by resource type.
		/// ### What
		/// Obtain the set of public deny lists selected by the user and wich ones are not filtering by the resource type.
		/// 
		/// ### Parameters
		/// The ``resource type`` to filter. The values can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to the status of all the lists.
		/// - ``lists``: a list of JSON objects with the available lists:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``    it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an denylist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``            it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_all_owned_denylists_by_resource_type_v1_denylist_public_owned__resource_type__get v1/denylist/public/owned/{resource_type}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListCollectionOutput> Get_all_owned_denylists_by_resource_type_v1_denylist_public_owned__resource_type__getAsync(Get_all_owned_denylists_by_resource_type_v1_denylist_public_owned__resource_type__getResource_type resource_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/owned/"+resource_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all the bindings between a user and an denylist.
		/// ### What
		/// Delete all the bindings between a user and an denylist. This will remove the denylist from the user and also all the origins that are using the denylist.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will  immediately return a 202 Accepted response.
		/// 
		/// ### Parameters
		/// In the query string the ID of the deny list to change the status.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// If the deny list is not a valid UUID, it will return a 422 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Delete_the_denylist_v1_denylist_public__denylist_id__delete v1/denylist/public/{denylist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_the_denylist_v1_denylist_public__denylist_id__deleteAsync(string denylist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the details of the denylist.
		/// ### What
		/// Obtain the details of an deny list available in the service.
		/// 
		/// ### Parameters
		/// No parameters
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual information of the list.
		/// - ``name``: A human readable name of the list.
		/// - ``description``: A long detailed information about what the list contains and how it is used.
		/// - ``resource_type``: The type of the list. It can be ``CIDR``, ``AS``, ``COUNTRY``, ``CONTINENT`` or ``DATACENTER_ID``.
		/// - ``list_type``: The type of the list. It can be ``ALLOW`` or ``DENY``.
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``it means that the list is not available anymore if not renewed.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// If the list is already selected by the user, the JSON object will also contain the following fields:
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``origins``: list of websites that are using the list as an denylist.
		/// - ``self``: the URI to all the list of origins.
		/// - ``lists``: list of lists that the origin is using.
		/// - ``self``: the URI to the individual information of the list.
		/// - ``origin``: the protocol and domain of the website that is using the list.
		/// - ``status``: the status of the list. It can be ``ACTIVE`` or ``INACTIVE`` or ``EXPIRED``. If the list is ``EXPIRED``            it means that the list is not available anymore if not renewed.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// - ``created_at``: Unix timestamp in seconds when the list was created.
		/// - ``updated_at``: Unix timestamp in seconds when the list was updated.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_single_denylist_v1_denylist_public__denylist_id__get v1/denylist/public/{denylist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<PublicAclGroupListOutput> Get_single_denylist_v1_denylist_public__denylist_id__getAsync(string denylist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublicAclGroupListOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Toogle the status of an deny list.
		/// ### What
		/// Change the status of an deny list to ``ACTIVE`` or ``INACTIVE``. An ``INACTIVE`` list will not be used by the service. An ``ACTIVE`` list will be used by the service. As an optional parameter it can be provided an ``expiry`` date in seconds since epoch. If not provided, the list will never expire.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will  immediately return a 202 Accepted response.
		/// 
		/// ### Parameters
		/// In the query string the ID of the deny list to change the status.
		/// In the body the JSON object with the following fields:
		/// - ``status``: The status of the list. It can be ``ACTIVE`` or ``INACTIVE``.
		/// - ``expiry``: Unix timestamp in seconds when the list will expire. If it does not exist, it will never expire.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// If the status is not ``ACTIVE`` or ``INACTIVE``, it will return a 422 error.
		/// If the expiry is not a valid timestamp, it will return a 422 error.
		/// If the deny list is not a valid UUID, it will return a 422 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Change_status_of_the_denylist_v1_denylist_public__denylist_id__put v1/denylist/public/{denylist_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Change_status_of_the_denylist_v1_denylist_public__denylist_id__putAsync(string denylist_id, Body_change_status_of_the_denylist_v1_denylist_public__denylist_id__put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Toogle the status of the origin in a deny list.
		/// ### What
		/// Change the status of the origin of a deny list to ``ACTIVE``, ``INACTIVE`` or ``DELETED``.
		/// 
		/// An ``ACTIVE`` origin will apply the deny list to the protocol and domain of the origin. An origin can be created and activated simply toogling the ``ACTIVE`` status. As an optional parameter it can be provided an ``ttl`` or Time To Live parameter of the origin in the list in seconds. After the TTL expires, the origin will be removed from the list.  If the TTL is not provided, the origin will never expire.
		/// 
		/// An ``INACTIVE`` origin will not apply the deny list to the protocol and domain of the origin.
		/// 
		/// A ``DELETED`` origin will be removed from the list. It will not be used by the service anymore. The user can activate it again with the ``ACTIVE`` status.
		/// 
		/// This is an asynchronous operation. It can take several seconds until the operation completes, but the request will  immediately return a 202 Accepted response.
		/// 
		/// *This operation is not available in the Freemium plan.*
		/// 
		/// ### Parameters
		/// In the query string the ID of the deny list to change the status.
		/// In the body the JSON object with the following fields:
		/// - ``origin``: The protocol and domain of the origin. It can be ``http://example.com`` or ``https://example.com``.
		/// - ``status``: The status of the list. It can be ``ACTIVE``, ``INACTIVE`` or ``DELETED``.
		/// 
		/// ### Result
		/// It should always return a 202 Accepted response with an empty body.
		/// 
		/// ### Errors
		/// 
		/// If the list does not exist, it will return a 404 error.
		/// If the status is not ``ACTIVE`` or ``INACTIVE``, it will return a 422 error.
		/// If the TTL is negative in the past, it will return a 422 error.
		/// If the deny list is not a valid UUID, it will return a 422 error.
		/// If the origin is not a valid URL, it will return a 400 error.
		/// If the denylist is not active, it will returna 409 error.
		/// If the origin is not found in the set owned by the user, it will return a 404 error.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Change_status_of_the_origin_denylist_v1_denylist_public__denylist_id__origin_put v1/denylist/public/{denylist_id}/origin
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Change_status_of_the_origin_denylist_v1_denylist_public__denylist_id__origin_putAsync(string denylist_id, Body_change_status_of_the_origin_denylist_v1_denylist_public__denylist_id__origin_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/public/"+ (denylist_id==null? "" : System.Uri.EscapeDataString(denylist_id))+"/origin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of automatically reported IP addresses by the user.
		/// ### What
		/// Obtain the list of all the IPv4 or IPv6 addresses that have been automatically reported by the user. A user can report automatically an IP address with the asynchronous API. The reported IP addresses differ from the ones managed with the endpoint ``/v1/denylist/private/ip/%s``. As a rule of thumb,
		/// the reported IP addresses are the ones submitted by devices like honeypots, firewalls, log engines, etc. The denylisted IP addresses are the ones submitted manually by the user from files or indidual items.
		/// 
		/// ### Parameters
		/// The endpoint accepts the following parameters in the query string:
		/// - ``dataset``: (Optional) Name of the dataset to filter the query. If not given, then all datasets are queried. If given, then only the changes logged in the given dataset are returned. The list of datasets is obtained from the ``/v1/dataset/ip`` endpoint.
		/// - ``reported_before``: (Optional) The UNIX timestamp in milliseconds of the earliest reported date to be included in the query. If not given, then the earliest date is current time.
		/// - ``reported_after``: (Optional) The UNIX timestamp in milliseconds of the oldest reported date to be included in the query. If not given, then the oldest date is the first event logged.
		/// - ``expires_before``: (Optional) The UNIX timestamp in milliseconds of the earliest expiry date to be included in the query. If not given, then the earliest date is current time.
		/// - ``expires_after``: (Optional) The UNIX timestamp in milliseconds of the oldest expiry date to be included in the query. If not given, then the oldest date is the first event logged.
		/// - ``greater_than``: (Optional) Restricts the result displaying only the IP addresses reported more times than the given value. It must be an integer greater than 0.
		/// - ``less_than``: (Optional) Restricts the result displaying only the IP addresses reported less times than the given value. It must be an integer greater than 0.
		/// - ``ip_protocol_version``: (Optional) Restricts the result displaying only the IP addresses with the given IP protocol version. Values are: ALL, IPV4, IPV6. If not given, then all IP addresses are returned.
		/// - ``output_format``: (Optional) The format of the output. Values are: JSON, CSV, AWS-WAF. If not given, then the default format is JSON. AWS-WAF is the format used by AWS WAF to import ipsets in the service. You can find more information about AWS WAF import [here](https://docs.aws.amazon.com/waf/latest/APIReference/API_CreateIPSet.html).
		/// 
		/// ### Result
		/// The result is a JSON object with a list of the following JSON objects:
		/// - ``self``: the URI to individual status.
		/// - ``addresses``: a list of JSON objects with the following fields:
		/// - ``self``: the URI to individual reported IP information.
		/// - ``last_report``: Unix timestamp in milliseconds when the IP address was last reported.
		/// - ``expiry``: Unix timestamp in milliseconds when the IP address will expire and be removed.
		/// - ``total_reports``: Total number of reports for the IP address.
		/// - ``protocol``: IP protocol version of the IP address. Same value as the ``ip_protocol_version`` parameter if given.
		/// - ``dataset``: Name of the dataset where the IP address was reported. Must be a value from the ``/v1/dataset/ip`` endpoint.
		/// - ``tags``: A list of strings with the tags associated to the IP address at the origin device. It helps to classify the origin of the report.
		/// 
		/// ### Errors
		/// - a `400 Bad Request` error if any timestamp is in the future.
		/// - a `400 Bad Request` error if the dataset is not a string that can have numbers, upper and lower case letters, and underscores.
		/// - a `404 Not Found` error if the dataset was not found.
		/// - a `422 Unprocessable Entity` error if some of the parameters are malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_all_the_ip_addresses_reported_by_the_user_v1_denylist_reported_ip_get v1/denylist/reported/ip
		/// </summary>
		/// <param name="dataset">The dataset list type to filter for. Must be uppercase, numbers and underscore</param>
		/// <param name="reported_before">Restricts the result displaying only the IP addresses reported before `reported_before`. It must be a UNIX timestamp in seconds.</param>
		/// <param name="reported_after">Restricts the result displaying only the IP addresses reported after `reported_after`. It must be a UNIX timestamp in seconds.</param>
		/// <param name="expires_before">Restricts the result displaying only the IP addresses that will expire before `expires_before`. It must be a UNIX timestamp in seconds greater than the current UNIX timestamp.</param>
		/// <param name="expires_after">Restricts the result displaying only the IP addresses that will expire after `expires_after`. It must be a UNIX timestamp in seconds greater than the current UNIX timestamp.</param>
		/// <param name="greater_than">Restricts the result displaying only the IP addresses reported more times than `greater_than`. It must be an integer greater than 0.</param>
		/// <param name="less_than">Restricts the result displaying only the IP addresses reported less times than `less_than`. It must be an integer greater than 1.</param>
		/// <param name="ip_protocol_version">Restrict the result displaying the IP protocol version requested (IPV4 or IPV6) or both (ALL). Some output formats MUST filter by IP protocol version first.</param>
		/// <param name="output_format">The output format of the datasets.</param>
		/// <returns>Successful Response</returns>
		public async Task<IPListCollectionOutput> Query_all_the_ip_addresses_reported_by_the_user_v1_denylist_reported_ip_getAsync(string dataset, int reported_before, int reported_after, int expires_before, int expires_after, int greater_than, int less_than, IPListOutputProtocol ip_protocol_version, Query_all_the_ip_addresses_reported_by_the_user_v1_denylist_reported_ip_getOutput_format output_format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/reported/ip?dataset=" + (dataset==null? "" : System.Uri.EscapeDataString(dataset))+"&reported_before="+reported_before+"&reported_after="+reported_after+"&expires_before="+expires_before+"&expires_after="+expires_after+"&greater_than="+greater_than+"&less_than="+less_than+"&ip_protocol_version=" + ip_protocol_version+"&output_format=" + output_format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IPListCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all the automatically reported IP addresses by the user.
		/// ### What
		/// Delete all the IP addresses that have been automatically reported by the user. This option cannot be reverted.
		/// 
		/// ### Parameters
		/// No parameters are required.
		/// 
		/// ### Result
		/// A successful result is an empty response with the the HTTP status code ``204 No Content``.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Delete_all_ip_addresses_reported_by_the_user_v1_denylist_reported_ip_all_delete v1/denylist/reported/ip/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_all_ip_addresses_reported_by_the_user_v1_denylist_reported_ip_all_deleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/reported/ip/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the automatically reported IP address by the user.
		/// ### What
		/// Delete an IP address that was automatically reported by the user. This option cannot be reverted.
		/// 
		/// ### Parameters
		/// The endpoint accepts the following parameters in the path:
		/// - ``ip_address``: (Mandatory) The public IPv4 or IPv6 addresses to be deleted.
		/// 
		/// ### Result
		/// A successful result is an empty response with the the HTTP status code ``204 No Content``.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Delete_an_ip_address_reported_by_the_user_v1_denylist_reported_ip__ip_address__delete v1/denylist/reported/ip/{ip_address}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_an_ip_address_reported_by_the_user_v1_denylist_reported_ip__ip_address__deleteAsync(string ip_address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/reported/ip/"+ (ip_address==null? "" : System.Uri.EscapeDataString(ip_address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the details of an automatically reported IP addresses by the user.
		/// ### What
		/// Obtain the details of an IPv4 or IPv6 addresses that have been automatically reported by the user. A user can report automatically an IP address with the asynchronous API. The reported IP address differs from the ones managed with the endpoint ``/v1/denylist/private/ip/%s``. As a rule of thumb,
		/// the reported IP addresses are the ones submitted by devices like honeypots, firewalls, log engines, etc. The denylisted IP addresses are the ones submitted manually by the user from files or indidual items.
		/// 
		/// ### Parameters
		/// The endpoint accepts the following parameters in the path:
		/// - ``ip_address``: (Mandatory) The public IPv4 or IPv6 addresses to be queried.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to individual reported IP information.
		/// - ``last_report``: Unix timestamp in milliseconds when the IP address was last reported.
		/// - ``expiry``: Unix timestamp in milliseconds when the IP address will expire and be removed.
		/// - ``total_reports``: Total number of reports for the IP address.
		/// - ``protocol``: IP protocol version of the IP address. Values can be IPV4 or IPV6.
		/// - ``dataset``: Name of the dataset where the IP address was reported. Must be a value from the ``/v1/dataset/ip`` endpoint.
		/// - ``tags``: A list of strings with the tags associated to the IP address at the origin device. It helps to classify the origin of the report.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_an_ip_addresses_reported_by_the_user_v1_denylist_reported_ip__ip_address__get v1/denylist/reported/ip/{ip_address}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<IPListOutput> Query_an_ip_addresses_reported_by_the_user_v1_denylist_reported_ip__ip_address__getAsync(string ip_address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/denylist/reported/ip/"+ (ip_address==null? "" : System.Uri.EscapeDataString(ip_address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IPListOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the geolocation data of the IP addresses set.
		/// ### What
		/// Get the geo location data of all the IP addresses passed as argument. This information includes:
		/// - Latitude and longitude
		/// - Time zone
		/// - Accuracy radius
		/// - Postal code
		/// - City name
		/// - Region
		/// - Country
		/// - Country of the service provider
		/// - Continent
		/// - Reverse PTR hostnames
		/// 
		/// ### Parameters
		/// A list of public IPv4 or IPv6 addresses is required in the body of the request.
		/// 
		/// ### Result
		/// The result contains a list of the result for each IP address, with the following data set:
		/// 
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``accuracy_radius``:  The radius in kilometers around the specified location where the IP address is likely to be.
		/// - ``asn_country_iso_code``: The ISO code of the country of the Autonomous System (AS) owner of the IP address.
		/// - ``city_geoname_code``:``: City geoname code. The geoname code by [GeoNames](https://en.wikipedia.org/wiki/GeoNames) is a unique identifier assigned to each geographical point on the globe.
		/// - ``city_name``:``: City name, in english. The developer can use the geoname code to localize the name of the city.
		/// - ``continent_code``: The continent code. It can be any of the following: AF, AN, AS, EU, NA, OC, SA.
		/// - ``country_iso_code``: The country ISO 3166-1 alpha-2 code.
		/// - ``hostnames``: The list of hostnames associated with the IP address obtained from the reverse DNS lookup.
		/// - ``latitude``: The latitude of the geolocation.
		/// - ``longitude``: The longitude of the geolocation.
		/// - ``postal_code``:``: The postal code of the city.
		/// - ``region_geoname_code``:``: The geoname code of the region.
		/// - ``region_name``:``: The region name, in english. The developer can use the geoname code to localize the name of the region.
		/// - ``time_zone``: The name of the time zone.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// The private IP addresses will be ignored, if any.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Geolocate_ip_set_v1_geo_post v1/geo
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<GeoIPCollectionOutput> Geolocate_ip_set_v1_geo_postAsync(string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/geo";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GeoIPCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the geo location data of the IP address.
		/// ### What
		/// Get the geo location data of the IP address passed as argument. This information includes:
		/// - Latitude and longitude
		/// - Time zone
		/// - Accuracy radius
		/// - Postal code
		/// - City name
		/// - Region
		/// - Country
		/// - Country of the service provider
		/// - Continent
		/// - Reverse PTR hostnames
		/// 
		/// 
		/// ### Parameters
		/// The only argument accepted in the query string is a public IPv4 or IPv6 addresses.
		/// 
		/// ### Result
		/// The result contains the following set of data:
		/// 
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``accuracy_radius``:  The radius in kilometers around the specified location where the IP address is likely to be.
		/// - ``asn_country_iso_code``: The ISO code of the country of the Autonomous System (AS) owner of the IP address.
		/// - ``city_geoname_code``:``: City geoname code. The geoname code by [GeoNames](https://en.wikipedia.org/wiki/GeoNames) is a unique identifier assigned to each geographical point on the globe.
		/// - ``city_name``:``: City name, in english. The developer can use the geoname code to localize the name of the city.
		/// - ``continent_code``: The continent code. It can be any of the following: AF, AN, AS, EU, NA, OC, SA.
		/// - ``country_iso_code``: The country ISO 3166-1 alpha-2 code.
		/// - ``hostnames``: The list of hostnames associated with the IP address obtained from the reverse DNS lookup.
		/// - ``latitude``: The latitude of the geolocation.
		/// - ``longitude``: The longitude of the geolocation.
		/// - ``postal_code``:``: The postal code of the city.
		/// - ``region_geoname_code``:``: The geoname code of the region.
		/// - ``region_name``:``: The region name, in english. The developer can use the geoname code to localize the name of the region.
		/// - ``time_zone``: The name of the time zone.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `400 Bad Request` error if the IP address is not public.
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Geolocate_ip_v1_geo__ip_address__get v1/geo/{ip_address}
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<GeoIPOutput> Geolocate_ip_v1_geo__ip_address__getAsync(string ip_address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/geo/"+ (ip_address==null? "" : System.Uri.EscapeDataString(ip_address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GeoIPOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a log event.
		/// ### What
		/// Obtain the full detail of a specific log change.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameters in the path:
		/// - ``logchange_id``: (Mandatory) A unique integer of the change event log.
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``cidr``: The CIDR affected by the change.
		/// - ``score``: The score of the IP address when the event happened. It ranges from 0 to 99.
		/// - ``risk``: The risk of the IP address when the event happened. The allowed values are: LOW, MEDIUM, HIGH. It's a human readable representation of the score.
		/// - ``dataset``: The URI of the dataset where the change was logged.
		/// - ``source``: The URI of the data source where the change was found.
		/// - ``lapse``: The time elapsed between the event found and the moment the source was queried. The possible values are: 1H, 6H, 12H, 1D, 7D, 30D, 90D, 180D, 365D.
		/// - ``action``: The action that was performed on the IP address. The allowed values are: ADD, DELETE.
		/// - ``timestamp``: The UNIX timestamp in milliseconds when the change was logged.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `404 Not Found` error if there is no event in the log with the ``logchange_ID`` given.
		/// - a `422 Unprocessable Entity` error if the ``logchange_ID`` is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Log_change_id_v1_log_ip_id__logchange_id__get v1/log/ip/id/{logchange_id}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<IPLogOutput> Log_change_id_v1_log_ip_id__logchange_id__getAsync(int logchange_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/log/ip/id/"+logchange_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IPLogOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the changes logged in the different datasets of an IP address.
		/// ### What
		/// Obtain a list of changes logged in the different datasets of the IP address given.
		/// 
		/// ### Parameters
		/// The endpoint accepts the following parameters in the path:
		/// - ``ip_address``: (Mandatory) The public IPv4 or IPv6 addresses to be queried.
		/// 
		/// The endpoint accepts the following parameters in the query string:
		/// - ``dataset``: (Optional) Name of the dataset to filter the query. If not given, then all datasets are queried. If given, then only the changes logged in the given dataset are returned. The list of datasets is obtained from the ``/v1/dataset/ip`` endpoint.
		/// - ``logged_after``: (Optional) The UNIX timestamp in milliseconds of the earliest date to be included in the query. If not given, then the earliest date is the date of the first change logged in the dataset.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``logs``: The list of log changes. Each element of the list is a JSON object of a specific log change with the structure described in the endpoint ``/v1/log/ip/id/logchange_id``.
		/// ### Errors
		/// The endpoint will return the following errors:
		/// - a `400 Bad Request` error if the IP address is not public.
		/// - a `400 Bad Request` error if the timestamp is in the future.
		/// - a `400 Bad Request` error if the dataset is not a string that can have numbers, upper and lower case letters, and underscores.
		/// - a `404 Not Found` error if the dataset was not found.
		/// - a `422 Unprocessable Entity` error if the IP address is malformed.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Logchanges_ip_v1_log_ip__ip_address__get v1/log/ip/{ip_address}
		/// </summary>
		/// <param name="ip_address">The IPv4 or IPv6 address to asses the risk</param>
		/// <param name="dataset">The name of the dataset to restrict the query</param>
		/// <param name="logged_after">A UNIX timestamp in milliseconds to restrict the results of the query to entries logged after this value.</param>
		/// <returns>Successful Response</returns>
		public async Task<IPLogCollectionOutput> Logchanges_ip_v1_log_ip__ip_address__getAsync(string ip_address, string dataset, int logged_after, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/log/ip/"+ (ip_address==null? "" : System.Uri.EscapeDataString(ip_address))+"&dataset=" + (dataset==null? "" : System.Uri.EscapeDataString(dataset))+"&logged_after="+logged_after;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IPLogCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of an origin of the user in the region.
		/// ### What
		/// Obtain the attributes of the origin of the user passed as argument in the selected region. The purpose of this function is to display the information of configuration of the origin and also access to the live data of the origin.
		/// 
		/// The origin is a combination of protocol and domain (Ex: https://example.com) and the origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// In the querystring of the request, add the origin of the user to the `query` parameter with the following format:1. Protocol: Can be ``http`` or ``https``.
		/// 2. Domain: The domain of the origin.
		/// 
		/// Then, the origin must be urlencoded. Example:
		/// ```
		/// https://example.com
		/// ```
		/// 
		/// ```
		/// https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// The querystring must be like this:
		/// ```
		/// ?query=https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to the request to obtain the full details of an origin.
		/// - ``origin``: the protocol and the domain where the origin token is valid.
		/// - ``status``: the status of the origin token. The only allowed values are ``ENABLED`` and ``DISABLED``.
		/// - ``token``: the URI to the request to obtain the token of the origin.
		/// - ``data``: a JSON object containing all the parameters of the origin as key-value pairs.
		/// - ``logs``: the URI to the request to obtain the log activity in the origin.
		/// - ``addresses``: the URI to the request to obtain the list of IP addresses active in the origin.
		/// - ``cookies``: the URI to the request to obtain the list of cookies active in the origin.
		/// - ``created_at``: the date and time when the origin token was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: the date and time when the origin token was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the origin token is not found.
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Query_origin_information_v1_origin_get v1/origin
		/// </summary>
		/// <param name="query">The origin site to query</param>
		/// <returns>Successful Response</returns>
		public async Task<OriginOutput> Query_origin_information_v1_origin_getAsync(string query, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin?query=" + (query==null? "" : System.Uri.EscapeDataString(query));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the configuration of an origin of the user in the region.
		/// ### What
		/// Modify the configuration metadata of the origin of the user in the selected region.
		/// 
		/// The origin is a combination of protocol and domain (Ex: https://example.com) and the origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// In the body of the request, add the `origin` of the user and the `config` parameter with the following format for the `origin`:1. Protocol: Can be ``http`` or ``https``.
		/// 2. Domain: The domain of the origin.
		/// 
		/// The `config` parameter is a JSON object containing the configuration of the origin. It only accepts the existing parameters obtained from the `GET` request of the origin. If the parameter is not present in the `config` object, it will fail to store it. It's not necessary to send all the parameters, only the ones that need to be updated.
		/// 
		/// ### Result
		/// The result is the JSON object with all the new values of the origin configuration.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the origin token is not found.
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// - a `400 Bad Request` error if the `config` parameter is not a JSON object or unknown parameters are sent.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Update_configuration_origin_v1_origin_put v1/origin
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<string> Update_configuration_origin_v1_origin_putAsync(Body_update_configuration_origin_v1_origin_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the address status of the origin of the user in the region.
		/// ### What
		/// 
		/// Obtain the status that trigger the change in the status of the origin of a specific IP address. The status will also describe the current state of the status and the information that triggered the change.
		/// 
		/// The origin is a combination of protocol and domain (Ex: https://example.com) and the origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// In the querystring of the request, add the origin of the user to the `query` parameter with the following format:1. Protocol: Can be ``http`` or ``https``.
		/// 2. Domain: The domain of the origin.
		/// 
		/// Then, the origin must be urlencoded. Example:
		/// ```
		/// https://example.com
		/// ```
		/// 
		/// ```
		/// https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// The querystring must be like this:
		/// ```
		/// ?query=https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to the request to obtain the full details of the status of an origin.
		/// - ``addresses``: a list of JSON objects with the following fields:
		/// - ``address``: the IP address of the origin.
		/// - ``status``: the status of IP address for the given origin.
		/// - ``log_id``: the ID of the log that triggered the change in the status of the origin.
		/// - ``expiry``: the date and time when the origin status will expire in UNIX timestamp in milliseconds.
		/// - ``created_at``: the date and time when the origin status was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: the date and time when the origin status was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the origin is not found.
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Query_origin_address_status_information_v1_origin_addresses_get v1/origin/addresses
		/// </summary>
		/// <param name="query">The origin site to query</param>
		/// <param name="page">The page to be returned</param>
		/// <param name="page_size">The number of items per page</param>
		/// <returns>Successful Response</returns>
		public async Task<OriginAddressStatusCollectionOutput> Query_origin_address_status_information_v1_origin_addresses_getAsync(string query, int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/addresses?query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&page="+page+"&page_size="+page_size;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginAddressStatusCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the origins of the user in the region.
		/// ### What
		/// Obtain the attributes of all the origins of the user in the selected region. The purpose of this function is to display the information of configuration of the origins and also access to the live data of the origins.
		/// 
		/// The origin is a combination of protocol and domain (Ex: https://example.com) and the origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// No parameters are required.
		/// 
		/// ### Result
		/// The result is a list of JSON objects with the following fields:
		/// - ``self``: the URI to the request to obtain all the origins of the user.
		/// - ``origins``: A list of JSON objects with the following fields:
		/// - ``self``: the URI to the request to obtain the full details of an origin.
		/// - ``origin``: the protocol and the domain where the origin token is valid.
		/// - ``status``: the status of the origin token. The only allowed values are ``ENABLED`` and ``DISABLED``.
		/// - ``token``: the URI to the request to obtain the token of the origin.
		/// - ``data``: a JSON object containing all the parameters of the origin as key-value pairs.
		/// - ``logs``: the URI to the request to obtain the log activity in the origin.
		/// - ``addresses``: the URI to the request to obtain the list of IP addresses active in the origin.
		/// - ``cookies``: the URI to the request to obtain the list of cookies active in the origin.
		/// - ``created_at``: the date and time when the origin token was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: the date and time when the origin token was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_all_origin_information_v1_origin_all_get v1/origin/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<OriginCollectionOutput> Query_all_origin_information_v1_origin_all_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the type of clients of the trafffic of the origin.
		/// ### What
		/// Obtain the type of clients of trhe traffic in the specified time range and interval. Thequery will return the number of requests and the different type of CLIENTs and CRAWLERs.
		/// 
		/// The origin is a combination of protocol and domain (Ex: https://example.com) and the origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// In the querystring of the request, add the origin of the user to the `query` parameter with the following format:1. Protocol: Can be ``http`` or ``https``.
		/// 2. Domain: The domain of the origin.
		/// 
		/// Then, the origin must be urlencoded. Example:
		/// ```
		/// https://example.com
		/// ```
		/// 
		/// ```
		/// https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// The querystring must be like this:
		/// ```
		/// ?query=https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// To restrict the query to a specific time range, add the following parameters to the querystring:
		/// - ``from_timestamp``: the start date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``to_timestamp``: (Optional) the end date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``interval``: (Optional) the interval of the analysis in minutes. The default value is 60 minutes (HOURLY). Possible values are: ``HOURLY``.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to the request to obtain the traffic client analysis for the origin.
		/// - ``from_timestamp``: the start date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``to_timestamp``: the end date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``interval``: the interval of the analysis. Possible values are: ``HOURLY``.
		/// - ``data``: a JSON list with the following elements each one with the following fields:
		/// - ``timestamp``: the date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``total``: the total number of requests.
		/// - ``client_*``: the number of requests from a specific client. The possible clients are: ``browser``, ``crawler``, ``email``, ``library``, ``mobile_browser``, ``multimedia_player``, ``offline_browser``, ``unrecognized``, ``ua_anonymizer``, ``validator``, ``wap_browser``.
		/// - ``crawler_*``: the number of requests from a specific crawler. The possible crawlers are:``feed_fetcher``, ``link_checker``, ``marketing``, ``screenshot_creator``, ``search_engine_bot``,``site_monitor``, ``speed_tester``, ``tool``, ``uncategorized``, ``unrecognized``, ``virus_scanner``,``vulnerability_scanner``, ``web_scraper``.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the origin token is not found.
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Query_origin_traffic_client_v1_origin_client_analysis_get v1/origin/client/analysis
		/// </summary>
		/// <param name="query">The origin site to query</param>
		/// <param name="interval">The data inteval to aggregate the result dataset</param>
		/// <param name="from_timestamp">A UNIX timestamp in milliseconds to restrict the results of the query to entries logged after or equal to this value.</param>
		/// <param name="to_timestamp">A UNIX timestamp in milliseconds to restrict the results of the query to entries logged before this value.</param>
		/// <returns>Successful Response</returns>
		public async Task<OriginClientAnalysisCollectionOutput> Query_origin_traffic_client_v1_origin_client_analysis_getAsync(string query, Query_origin_traffic_client_v1_origin_client_analysis_getInterval interval, int from_timestamp, int to_timestamp, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/client/analysis?query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&interval=" + interval+"&from_timestamp="+from_timestamp+"&to_timestamp="+to_timestamp;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginClientAnalysisCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the tracking cookie ID status of the origin of the user in the region.
		/// ### What
		/// 
		/// Obtain the status that trigger the change in the status of the origin of the cookie ID used to track the users. The status will also describe the current state of the status and the information that triggered the change.
		/// 
		/// The origin is a combination of protocol and domain (Ex: https://example.com) and the origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// In the querystring of the request, add the origin of the user to the `query` parameter with the following format:1. Protocol: Can be ``http`` or ``https``.
		/// 2. Domain: The domain of the origin.
		/// 
		/// Then, the origin must be urlencoded. Example:
		/// ```
		/// https://example.com
		/// ```
		/// 
		/// ```
		/// https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// The querystring must be like this:
		/// ```
		/// ?query=https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to the request to obtain the full details of the status of an origin.
		/// - ``addresses``: a list of JSON objects with the following fields:
		/// - ``cookie_id``: the ID of the tracking cookie for the origin.
		/// - ``status``: the status of tracking cookie ID for the given origin.
		/// - ``log_id``: the ID of the log that triggered the change in the status of the origin.
		/// - ``expiry``: the date and time when the origin status will expire in UNIX timestamp in milliseconds.
		/// - ``created_at``: the date and time when the origin status was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: the date and time when the origin status was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the origin is not found.
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Query_origin_cookie_id_status_information_v1_origin_cookies_get v1/origin/cookies
		/// </summary>
		/// <param name="query">The origin site to query</param>
		/// <param name="page">The page to be returned</param>
		/// <param name="page_size">The number of items per page</param>
		/// <returns>Successful Response</returns>
		public async Task<OriginCookieIdStatusCollectionOutput> Query_origin_cookie_id_status_information_v1_origin_cookies_getAsync(string query, int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/cookies?query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&page="+page+"&page_size="+page_size;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginCookieIdStatusCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the code snippets of an origin of the user in the region.
		/// ### What
		/// Obtain the code snippets of the origin of the user passed as argument in the selected region. The purpose of this function is to help the user to integrate the javascript library in their website with a preconfigured script that contains the origin token.
		/// 
		/// ### Parameters
		/// In the querystring of the request, add the origin of the user to the `query` parameter with the following format:1. Protocol: Can be ``http`` or ``https``.
		/// 2. Domain: The domain of the origin.
		/// 
		/// Then, the origin must be urlencoded. Example:
		/// ```
		/// https://example.com
		/// ```
		/// 
		/// ```
		/// https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// The querystring must be like this:
		/// ```
		/// ?query=https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to the request to obtain the full details of an origin.
		/// - ``detection``: code snippet to integrate into the website described in the origin to detect malicious activity.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the origin token is not found.
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Query_origin_scripts_v1_origin_scripts_get v1/origin/scripts
		/// </summary>
		/// <param name="query">The origin site to query</param>
		/// <returns>Successful Response</returns>
		public async Task<OriginScriptsOutput> Query_origin_scripts_v1_origin_scripts_getAsync(string query, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/scripts?query=" + (query==null? "" : System.Uri.EscapeDataString(query));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginScriptsOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the current cookie ID and IP address status of the origin of user in the region.
		/// ### What
		/// 
		/// Obtain the current status of the origin for a given IP address and/or cookie ID. The values can be correlated, but they are not required to be. The status will also describe the following information:
		/// - `PASS`: The traffic should not be intercepted, but should be analyzed and a positive detection should trigger a change in the status.
		/// - `BLOCK`: The traffic must be intercepted and redirected to a blocking page. Only a timeout of the IP address or Cookie ID, a solved challenge or a manual status change can change the status.
		/// - `CHALLENGE`: The traffic must be intercepted and redirected to a page where the user must solve a challenge. If the challenge is succesfully solved the status will change to `PASS`. If the user fails to change the challenge a specific amount of times, the status can change to `BLOCK`.
		/// - `BYPASS`: The traffic should not be tapped even if it is suspected to be malicious, as long as the timeout has not expired. When the timeout is reached, it should revert to a previous state instead of going to `PASS`.
		/// - `IGNORE`: Whatever happens to the traffic of the user, it should not be tapped. Once the time expires, it should return to the state PASS.
		/// 
		/// The origin is a combination of protocol and domain (Ex: https://example.com) and the origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// In the querystring of the request, add the origin of the user to the `query` parameter with the following format:1. Protocol: Can be ``http`` or ``https``.
		/// 2. Domain: The domain of the origin.
		/// 
		/// Then, the origin must be urlencoded. Example:
		/// ```
		/// https://example.com
		/// ```
		/// 
		/// ```
		/// https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// The querystring must be like this:
		/// ```
		/// ?query=https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// The body should have at least one of the following fields:
		/// - `address`: The IP address of the user to query.
		/// - `cookie_id`: The ID of the tracking cookie of the user to query.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to the request to obtain the full details of the `cookie_id` and `address` status of an origin.
		/// - ``cookie_id``: a JSON object with the following fields:
		/// - ``cookie_id``: the ID of the tracking cookie for the origin.
		/// - ``status``: the URI to the status detail of the cookie ID.
		/// - ``log_id``: (Optional) the ID of the log that triggered the change in the status of the origin.
		/// - ``expiry``: (Optional) the date and time when the origin status will expire in UNIX timestamp in milliseconds.
		/// - ``created_at``: (Optional) the date and time when the origin status was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: (Optional) the date and time when the origin status was last updated in UNIX timestamp in milliseconds.
		/// - ``address``: a JSON object with the following fields:
		/// - ``address``: the address for the origin.
		/// - ``status``: the URI to the status detail of the cookie ID.
		/// - ``log_id``: (Optional) the ID of the log that triggered the change in the status of the origin.
		/// - ``expiry``: (Optional) the date and time when the origin status will expire in UNIX timestamp in milliseconds.
		/// - ``created_at``: (Optional) the date and time when the origin status was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: (Optional) the date and time when the origin status was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the origin is not found.
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Query_origin_status_v1_origin_status_post v1/origin/status
		/// </summary>
		/// <param name="query">The origin site to query</param>
		/// <returns>Successful Response</returns>
		public async Task<OriginStatusOutput> Query_origin_status_v1_origin_status_postAsync(string query, Body_query_origin_status_v1_origin_status_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/status?query=" + (query==null? "" : System.Uri.EscapeDataString(query));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginStatusOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the status of a given origin event in the platform.
		/// ### What
		/// Update the status of a given origin event in the platform. The status can be one of the    following values:
		/// - `PASS`: The event is not considered as a threat.
		/// - `BLOCK`: The event is considered as a threat and the origin must be blocked.
		/// - `CHALLENGE`: The event is considered as a threat and the origin must be challenged.
		/// - `BYPASS`: The event is considered as a threat but the origin must be bypassed.
		/// - `IGNORE`: The event is considered as a threat but the origin must be ignored.
		/// 
		/// To apply the change, it's necessary to send a request to the API with the `log_id` of the    origin status event and the scope of the change. The scope can be one of the following values:
		/// - `address_and_cookie`: The change will be applied to the origin IP address and the cookie.
		/// - `address`: The change will be applied to the origin IP address.
		/// - `cookie`: The change will be applied to the cookie.
		/// 
		/// ### Parameters
		/// The request must send the following parameters in the body of the request:
		/// - ``log_id``: the log id of the origin status event.
		/// - ``scope``: the scope of the change. Possible values are: ``address_and_cookie``, ``address``, ``cookie``.
		/// - ``status``: the new status of the origin. Possible values are: ``pass``, ``block``, ``challenge``, ``bypass``, ``ignore``.
		/// 
		/// And in the `query` query string parameter, add the origin website in the format `https://example.com`.
		/// 
		/// ### Result
		/// A 200 OK response without any content.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// If the parameters are invalid, it will return a `400 Bad Request` error.
		/// Update_origin_status_v1_origin_status_put v1/origin/status
		/// </summary>
		/// <param name="query">The origin site to query</param>
		/// <returns>Successful Response</returns>
		public async Task<object> Update_origin_status_v1_origin_status_putAsync(string query, Body_update_origin_status_v1_origin_status_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/status?query=" + (query==null? "" : System.Uri.EscapeDataString(query));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detail of a status available in the platform.
		/// ### What
		/// Obtain the description of a status available in the platform.
		/// 
		/// ### Parameters
		/// A `status_id` parameter in the path of the request:
		/// - `PASS`
		/// - `BLOCK`
		/// - `CHALLENGE`
		/// - `BYPASS`
		/// - `IGNORE`
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to the status detail.
		/// - ``description``: a human readable description of the status.
		/// - ``cardinality``: The number describing the cardinality of the status.
		/// 
		/// ### Errors
		/// - a `400 Bad Request` error if the origin status is not any of the available ones.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Query_origin_status_detail_v1_origin_status_detail__status_id__get v1/origin/status/detail/{status_id}
		/// </summary>
		/// <param name="status_id">The status id to query the details</param>
		/// <returns>Successful Response</returns>
		public async Task<OriginStatusDetailsOutput> Query_origin_status_detail_v1_origin_status_detail__status_id__getAsync(Body_update_origin_status_v1_origin_status_putStatus status_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/status/detail/"+status_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginStatusDetailsOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of different status available in the platform.
		/// ### What
		/// Obtain the full list and description of the different status available in the platform.
		/// 
		/// ### Parameters
		/// No parameters needed.
		/// 
		/// ### Result
		/// The result is a JSON list with the following fields:
		/// - ``self``: the URI to the request to obtain the list.
		/// - ``list``: a JSON list with the following elements each one with the following fields:
		/// - ``self``: the URI to the status detail.
		/// - ``description``: a human readable description of the status.
		/// - ``cardinality``: The number describing the cardinality of the status.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_origin_status_details_v1_origin_status_details_get v1/origin/status/details
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<OriginStatusDetailsCollectionOutput> Query_origin_status_details_v1_origin_status_details_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/status/details";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginStatusDetailsCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the traffic analysis of the origin.
		/// ### What
		/// Obtain the traffic analysis of the origin in the specified time range and interval. Theanalysis will return the number of requests and the anomalies detected like:
		/// 
		/// - number of requests
		/// - overall score
		/// - malicious synthetic traffic (bad bot traffic)
		/// - IP in a denylist
		/// - IP in a datacenter
		/// - user uses a headless webdriver
		/// - Autonomous System (ASN) of the IP is risky
		/// - The location of the IP address and the ASN is different
		/// 
		/// The origin is a combination of protocol and domain (Ex: https://example.com) and the origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// In the querystring of the request, add the origin of the user to the `query` parameter with the following format:1. Protocol: Can be ``http`` or ``https``.
		/// 2. Domain: The domain of the origin.
		/// 
		/// Then, the origin must be urlencoded. Example:
		/// ```
		/// https://example.com
		/// ```
		/// 
		/// ```
		/// https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// The querystring must be like this:
		/// ```
		/// ?query=https%3A%2F%2Fexample.com
		/// ```
		/// 
		/// To restrict the analysis to a specific time range, add the following parameters to the querystring:
		/// - ``from_timestamp``: the start date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``to_timestamp``: (Optional) the end date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``interval``: (Optional) the interval of the analysis in minutes. The default value is 60 minutes (HOURLY). Possible values are: ``HOURLY``.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to the request to obtain the traffic analysis for the origin.
		/// - ``from_timestamp``: the start date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``to_timestamp``: the end date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``interval``: the interval of the analysis. Possible values are: ``HOURLY``.
		/// - ``data``: a JSON list with the following elements each one with the following fields:
		/// - ``timestamp``: the date and time of the analysis in UNIX timestamp in milliseconds.
		/// - ``total``: the total number of requests.
		/// - ``score_high``: the number of requests with a high score (bad traffic).
		/// - ``bots``: the number of requests from bad bots.
		/// - ``denylists``: the number of requests from IPs in a denylist.
		/// - ``datacenters``: the number of requests from IPs in a datacenter.
		/// - ``webdrivers``: the number of requests from IPs using a headless webdriver.
		/// - ``asn_risky``: the number of requests from IPs with a risky ASN.
		/// - ``network_country_mismatches``: the number of requests from IPs with a different location than the ASN.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the origin token is not found.
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Query_origin_traffic_analysis_v1_origin_traffic_analysis_get v1/origin/traffic/analysis
		/// </summary>
		/// <param name="query">The origin site to query</param>
		/// <param name="interval">The data inteval to aggregate the result dataset</param>
		/// <param name="from_timestamp">A UNIX timestamp in milliseconds to restrict the results of the query to entries logged after or equal to this value.</param>
		/// <param name="to_timestamp">A UNIX timestamp in milliseconds to restrict the results of the query to entries logged before this value.</param>
		/// <returns>Successful Response</returns>
		public async Task<OriginTrafficAnalysisCollectionOutput> Query_origin_traffic_analysis_v1_origin_traffic_analysis_getAsync(string query, Query_origin_traffic_client_v1_origin_client_analysis_getInterval interval, int from_timestamp, int to_timestamp, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin/traffic/analysis?query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&interval=" + interval+"&from_timestamp="+from_timestamp+"&to_timestamp="+to_timestamp;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginTrafficAnalysisCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an origin token of the user in the region.
		/// ### What
		/// Deletes the origin token passed as argument of the user in the selected region. Once the token is deleted, it will no longer be valid and the protocol and domain of the origin will no longer be under protection.
		/// 
		/// To delete an origin token, the user must be the owner and the token must be ``DISABLED`` first.
		/// 
		/// ### Parameters
		/// The Origin Token is required in the body of the request in the parameter `origin_token_id`.
		/// 
		/// ### Result
		/// If successful, the result will be an empty response with a status code of `204 No Content`.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// 
		/// It will also return the following errors:
		/// - a `404 Not Found` error if the origin token is not found.
		/// - a `409 Conflict` error if the origin token is not disabled.
		/// Delete_token_v1_origin_token_delete v1/origin_token
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Delete_token_v1_origin_token_deleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin_token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of an origin token of the user in the region.
		/// ### What
		/// Obtain the attributes of the given origin token of the user in the selected region. The purpose of this function is to show what protocol and domain is linked to the token.
		/// 
		/// The origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// The Origin Token is required in the body of the request in the parameter `origin_token_id`.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to individual origin token information.
		/// - ``region_id``: the name of the region where the origin token is valid.
		/// - ``origin``: the protocol and the domain where the origin token is valid.
		/// - ``status``: the status of the origin token. The only allowed values are ``ENABLED`` and ``DISABLED``.
		/// - ``created_at``: the date and time when the origin token was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: the date and time when the origin token was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_origin_token_info_v1_origin_token_post v1/origin_token
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<OriginTokenOutput> Query_origin_token_info_v1_origin_token_postAsync(Body_query_origin_token_info_v1_origin_token_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin_token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginTokenOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the origin tokens of the user in the region.
		/// ### What
		/// Obtain the attributes of all the origin tokens of the user in the selected region. The purpose of this function is to show what protocol and domain is linked to all the tokens.
		/// 
		/// The origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// No parameters are required.
		/// 
		/// ### Result
		/// The result is a list of JSON objects with the following fields:
		/// - ``self``: the URI to individual origin token information.
		/// - ``region_id``: the name of the region where the origin token is valid.
		/// - ``origin``: the protocol and the domain where the origin token is valid.
		/// - ``status``: the status of the origin token. The only allowed values are ``ENABLED`` and ``DISABLED``.
		/// - ``created_at``: the date and time when the origin token was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: the date and time when the origin token was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_all_origin_tokens_in_the_region_v1_origin_token_all_get v1/origin_token/all
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<OriginTokenCollectionOutput> Query_all_origin_tokens_in_the_region_v1_origin_token_all_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin_token/all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginTokenCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable a enabled origin token of the user in the region.
		/// ### What
		/// Disable an enabled origin token passed as argument of the user in the selected region. When a token is enabled, it will participate in the protection of the origin protocol and domain. If the token is disabled, it will not participate in the protection of the origin protocol and domain.
		/// 
		/// To disable an origin token, the user must be the owner. If the token is already disabled, the function will not perform any action. If the token is enabled, it will be disabled.
		/// 
		/// ### Parameters
		/// The Origin Token is required in the body of the request in the parameter `origin_token_id`.
		/// 
		/// ### Result
		/// If successful, the result will be an empty response with a status code of `204 No Content`.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// 
		/// It will also return the following errors:
		/// - a `404 Not Found` error if the origin token is not found.
		/// Disable_origin_token_v1_origin_token_disable_put v1/origin_token/disable
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Disable_origin_token_v1_origin_token_disable_putAsync(Body_disable_origin_token_v1_origin_token_disable_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin_token/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable a disabled origin token of the user in the region.
		/// ### What
		/// Enable a disabled origin token passed as argument of the user in the selected region. When a token is enabled, it will participate in the protection of the origin protocol and domain. If the token is disabled, it will not participate in the protection of the origin protocol and domain.
		/// 
		/// To enable an origin token, the user must be the owner. If the token is already enabled, the function will not perform any action. If the token is disabled, it will be enabled.
		/// 
		/// ### Parameters
		/// The Origin Token is required in the body of the request in the parameter `origin_token_id`.
		/// 
		/// ### Result
		/// If successful, the result will be an empty response with a status code of `204 No Content`.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// 
		/// It will also return the following errors:
		/// - a `404 Not Found` error if the origin token is not found.
		/// Enable_origin_token_v1_origin_token_enable_put v1/origin_token/enable
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<object> Enable_origin_token_v1_origin_token_enable_putAsync(Body_enable_origin_token_v1_origin_token_enable_put requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin_token/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an origin token of the user in the region.
		/// ### What
		/// Creates a new origin token for the user passing as argument the origin. The origin parameter is the protocol and the domain where the origin token is valid.
		/// 
		/// The origin token is a special key used in conjunction with javascript library used for abuse detection. This key is owned by the user and is used to identify the origin of the request.
		/// Hence, the protocol and domain of the origin must be the one where the javascript is loaded.
		/// 
		/// ### Parameters
		/// The origin with the protocol and domain is required in the body of the request in the parameter ``origin``. The allowed protocols are ``https://``, and ``http://``.
		/// 
		/// ### Result
		/// The result is a JSON object with the new origin token and the following fields:
		/// - ``self``: the URI to individual origin token information.
		/// - ``region_id``: the name of the region where the origin token is valid.
		/// - ``origin``: the protocol and the domain where the origin token is valid.
		/// - ``status``: the status of the origin token. The only allowed values are ``ENABLED`` and ``DISABLED``.
		/// - ``created_at``: the date and time when the origin token was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: the date and time when the origin token was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// 
		/// It will also return the following errors:
		/// - a `400 Bad Request` error if the origin does not have the correct format.
		/// - a `409 Conflict` error if the origin token already exists.
		/// Create_a_new_origin_token_v1_origin_token_new_post v1/origin_token/new
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<OriginTokenOutput> Create_a_new_origin_token_v1_origin_token_new_postAsync(OriginTokenInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/origin_token/new";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OriginTokenOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the full information of all the source lists for the subscription level given.
		/// ### What
		/// Obtain the full meta information of all the source lists available for the subscription level of the user. A source list is a collection of resources combined together with other sources to create a dataset.
		/// 
		/// A source list has some unique properties. The most relevant ones are the score and risk. The score is a number **between 0 and 99** describing the probability of the IP address being a malicious one, being **0** means that the IP address is not malicious and is not a threat. Being **99** means that the service behind the IP address is probably malicious an certainly a threat.
		/// 
		/// Each source list groups several collections of resource by the lapse of time or time range that they are related to according to their age. Each group by time range has a score and a risk.
		/// 
		/// ### Parameters
		/// The endpoint does not accept any parameter. The subscription level is obtained from the token provided in the header.
		/// 
		/// ### Result
		/// The result is a JSON object with a self reference and a list of JSON objects with the following fields:
		/// - ``self``: the URI to individual source list information.
		/// - ``dataset``: the URI to the dataset that aggregates the resources of this list.
		/// - ``name``: the unique name of the source list. Must be uppercase letters, numbers and underscores.
		/// - ``description``: a human readable long description of the source list.
		/// - ``source``: Origin of the list.
		/// - ``url``: The URL where the source list was found.
		/// - ``refresh``: The refresh period of the source list.
		/// - ``minimum_score``: The minimum score found in the different source list time ranges. Is in the range 0-99.
		/// - ``maximum_score``: The maximum score found in the different source list time ranges. Is in the range 0-99.
		/// - ``minimum_risk``: The minimum human readable risk score found in the different source list time ranges. Can be UNKNOWN, LOW, MEDIUM or HIGH.
		/// - ``maximum_risk``: The maximum human readable risk score found in the different source list time ranges. Can be UNKNOWN, LOW, MEDIUM or HIGH.
		/// - ``time_range``: the list of URIs pointing to the different source list time ranges information.
		/// - ``updated_at``: The UNIX timestamp in milliseconds of last update of the source list.
		/// - ``subscriptions``: The list of subscription levels that can access this source list.
		/// 
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Get_all_sources_v1_source_ip_get v1/source/ip
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<SourceCollectionOutput> Get_all_sources_v1_source_ip_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source/ip";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the full information of the source list given as argument.
		/// ### What
		/// Obtain the full meta information of the source list given as argument. A source list is a collection of resources combined together with other sources to create a dataset. A source list has some unique properties. The most relevant ones are the score and risk. The score is a number **between 0 and 99** describing the probability of the IP address being a malicious one, being **0** means that the IP address is not malicious and is not a threat. Being **99** means that the service behind the IP address is probably malicious an certainly a threat.
		/// 
		/// Each source list groups several collections of resource by the lapse of time or time range that they are related to according to their age. Each group by time range has a score and a risk.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``source``: (Mandatory) The code name that identifies uniquely the source list in the platform. It must be composed of uppercase letters, numbers and underscores.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to individual source list information.
		/// - ``dataset``: the URI to the dataset that aggregates the resources of this list.
		/// - ``name``: the unique name of the source list. Must be uppercase letters, numbers and underscores.
		/// - ``description``: a human readable long description of the source list.
		/// - ``source``: Origin of the list.
		/// - ``url``: The URL where the source list was found.
		/// - ``refresh``: The refresh period of the source list.
		/// - ``minimum_score``: The minimum score found in the different source list time ranges. Is in the range 0-99.
		/// - ``maximum_score``: The maximum score found in the different source list time ranges. Is in the range 0-99.
		/// - ``minimum_risk``: The minimum human readable risk score found in the different source list time ranges. Can be UNKNOWN, LOW, MEDIUM or HIGH.
		/// - ``maximum_risk``: The maximum human readable risk score found in the different source list time ranges. Can be UNKNOWN, LOW, MEDIUM or HIGH.
		/// - ``time_range``: the list of URIs pointing to the different source list time ranges information.
		/// - ``updated_at``: The UNIX timestamp in milliseconds of last update of the source list.
		/// - ``subscriptions``: The list of subscription levels that can access this source list.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the source list code name was not found.
		/// - a `422 Unprocessable Entity` error if source list code name does not follow the naming convention.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_source_info_v1_source_ip__source__get v1/source/ip/{source}
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<V1__models__source__SourceOutput> Get_source_info_v1_source_ip__source__getAsync(string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source/ip/"+ (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<V1__models__source__SourceOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the source list given for a specific time range.
		/// ### What
		/// Obtain the meta information of the source list and the time range given as arguments. A source list is a collection of resources combined together with other sources to create a dataset. A source list has some unique properties. The most relevant ones are the score and risk. The score is a number **between 0 and 99** describing the probability of the IP address being a malicious one, being **0** means that the IP address is not malicious and is not a threat. Being **99** means that the service behind the IP address is probably malicious an certainly a threat.
		/// 
		/// The time ranges or lapse of time of each source are how the resources are stored according to their age. Each group by time range has a score and a risk.
		/// 
		/// ### Parameters
		/// The endpoint accepts the following two parameters in the path:
		/// - ``source``: (Mandatory) The code name that identifies uniquely the source list in the platform. It must be composed of uppercase letters, numbers and underscores.
		/// - ``time_range``: (Mandatory) The code name that identifies uniquely the time ranges. Must be: 1H, 6H, 12H, 1D, 7D, 30D, 90D, 180D y 365D.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to individual source list and time range information.
		/// - ``source``: the URI to individual source list information.
		/// - ``items``: Number of elements in the source list in the time range given.
		/// - ``lapse``: The lapse of time or time range of the specific source list. Can be 1H, 6H, 12H, 1D, 7D, 30D, 90D, 180D or 365D.
		/// - ``score``: The score found in the source list time range. Is in the range 0-99.
		/// - ``risk``: The human readable risk score found in the source list time range. Can be UNKNOWN, LOW, MEDIUM or HIGH.
		/// - ``updated_at``: The UNIX timestamp in milliseconds of last update of the source list.
		/// 
		/// ### Errors
		/// - a `404 Not Found` error if the source list code name was not found.
		/// - a `404 Not Found` error if the time range was not found.
		/// - a `422 Unprocessable Entity` error if source list code name or time ranges does not follow the naming convention.
		/// 
		/// It will return the API Global errors described in the API description.
		/// Get_source_and_timerange_info_v1_source_ip__source__range__time_range__get v1/source/ip/{source}/range/{time_range}
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<SourceTimeRangeOutput> Get_source_and_timerange_info_v1_source_ip__source__range__time_range__getAsync(string source, Get_source_and_timerange_info_v1_source_ip__source__range__time_range__getTime_range time_range, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source/ip/"+ (source==null? "" : System.Uri.EscapeDataString(source))+"/range/"+time_range;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceTimeRangeOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the user's token in the region.
		/// ### What
		/// Obtain the list of all the token attributes of the current user in the selected region. The purpose of this function is to show the current values of the user's quota.
		/// 
		/// ### Parameters
		/// No parameters are required. The token is obtained automatically from the `Bearer` in the header.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to individual token information.
		/// - ``region_id``: the name of the region where the token is valid.
		/// - ``last_month_bucket_init_value``: the initial value of the monthly bucket.
		/// - ``last_month_bucket_value``: the current value of consumed quota in the monthly bucket.
		/// - ``last_month_bucket_refresh``: Unix timestamp in milliseconds of the next monthly bucket reset.
		/// - ``last_minute_bucket_init_value``: the initial value of the per minute bucket.
		/// - ``last_minute_bucket_value``: the current value of consumed quota in the per minute bucket.
		/// - ``last_minute_bucket_refresh``: Unix timestamp in milliseconds of the next per minute bucket reset.
		/// - ``last_minute_bucket_refill_ratio``: the number of tokens to add every second to the per minute bucket.
		/// - ``status``: the status of the token. The only allowed value is ``ENABLED``.
		/// - ``created_at``: the date and time when the token was created in UNIX timestamp in milliseconds.
		/// - ``updated_at``: the date and time when the token was last updated in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_token_info_v1_token_get v1/token
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<TokenOutput> Query_token_info_v1_token_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TokenOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the activity information of the token in the region.
		/// ### What
		/// Obtain the list of all the activity events of the current user in the selected region. The purpose of this function is to show what actions performed a user with the specific token.
		/// 
		/// ### Parameters
		/// The following pagination parameters are required as query string parameters:
		/// - ``page``: (Optional) the page number to retrieve. The first page is 1. Default is 1.
		/// - ``page_size``: (Optional) the number of items per page. Default is 20.
		/// 
		/// The token is obtained automatically from the `Bearer` in the header.
		/// 
		/// ### Result
		/// The result is a JSON object with the following fields:
		/// - ``self``: the URI to all activities of the token.
		/// - ``activities``: a list of activities performed by the user with the token.
		/// - ``self``: the URI to individual activity information.
		/// - ``event``: ID of the reference of the event type.
		/// - ``description``: Human readable description of the event.
		/// - ``data``: the payload of the event. It can be empty.
		/// - ``source``: A JSON object with the following fields:
		/// - ``address``: the IP address of the client.
		/// - ``ua_string``: the user agent string of the client.
		/// - ``status_code``: the HTTP status code of the response.
		/// - ``uri``: the URI of the request.
		/// - ``body``: the body of the request.
		/// - ``method``: the HTTP method of the request.
		/// - ``created_at``: the date and time when the token was created in UNIX timestamp in milliseconds.
		/// 
		/// ### Errors
		/// It will return the API Global errors described in the API description.
		/// Query_token_activity_v1_token_activity_get v1/token/activity
		/// </summary>
		/// <param name="page">The page to be returned</param>
		/// <param name="page_size">The number of items per page</param>
		/// <returns>Successful Response</returns>
		public async Task<ActivityCollectionOutput> Query_token_activity_v1_token_activity_getAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/token/activity?page="+page+"&page_size="+page_size;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ActivityCollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information found in a set of User Agents.
		/// ### What
		/// Get the information found in the list of User Agents passed as argument. This information includes:
		/// - Type
		/// - Render Engine
		/// - Version
		/// - Vendor
		/// - Operating System
		/// - Device
		/// - How common is the agent worldwide
		/// 
		/// ### Parameters
		/// A list of User Agents are required in the body of the request.
		/// 
		/// ### Result
		/// The result contains a list of the result for each User Agent, with the following data set:
		/// 
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``string``:  The full user agent string passed as argument.
		/// - ``classification``: The classification of the user agent. It can be one of the following: ``CRAWLER``, ``CLIENT``, ``UNKNOWN``.
		/// - ``type``: An URI to the type of user agent used to identify the client (browser, bot, crawler, etc.).
		/// - ``agent``: Name of the agent and the version, if any.
		/// - ``engine``: Agent render engine.
		/// - ``version``: Version of the agent.
		/// - ``latest``: Latests known version of the agent.
		/// - ``family``: URI to the family of the agent.
		/// - ``vendor``: URI to the vendor or company that produces the agent.
		/// - ``os``: URI to the operating system used by the agent.
		/// - ``device``: URI to the device used by the agent.
		/// - ``frequent``: If the agent is frequently used worlwide or not. The values are ``COMMON``, ``RARE``, and ``UNKNOWN``.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the API Global errors described in the API description.
		/// Parse_user_agents_v1_ua_post v1/ua
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<UACollectionOutput> Parse_user_agents_v1_ua_postAsync(string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/ua";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UACollectionOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the device of a user agent.
		/// ### What
		/// Obtain the details of a device of a User Agent.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``code``: (Mandatory) The code that identifies uniquely the device origin of a User Agent. The value must be an alphanumeric upper case string.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to the device.
		/// - ``description``: the human readable description of the device.
		/// - ``code``: the internal code of the device in the system.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the code is not one of the available.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_device_by_code_v1_ua_device__code__get v1/ua/device/{code}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<DeviceOutput> Query_device_by_code_v1_ua_device__code__getAsync(string code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/ua/device/"+ (code==null? "" : System.Uri.EscapeDataString(code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DeviceOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the family of a user agent.
		/// ### What
		/// Obtain the details of a family of a User Agent.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``code``: (Mandatory) The code that identifies uniquely the family of a User Agent. The value must be an alphanumeric upper case string.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to the family.
		/// - ``description``: the human readable description of the famly.
		/// - ``code``: the internal code of the family in the system.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the code is not one of the available.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_family_by_code_v1_ua_family__code__get v1/ua/family/{code}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<FamilyOutput> Query_family_by_code_v1_ua_family__code__getAsync(string code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/ua/family/"+ (code==null? "" : System.Uri.EscapeDataString(code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<FamilyOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the Operating System of a user agent.
		/// ### What
		/// Obtain the details of the Operating System of a User Agent.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``code``: (Mandatory) The code that identifies uniquely the Operating System at the origin of a User Agent. The value must be an alphanumeric upper case string.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to the OS.
		/// - ``description``: the human readable description of the OS.
		/// - ``code``: the internal code of the OS in the system.
		/// - ``family``: the family of the OS.
		/// - ``vendor``: the vendor or manufacturer of the OS.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the code is not one of the available.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_os_by_code_v1_ua_os__code__get v1/ua/os/{code}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<OSOutput> Query_os_by_code_v1_ua_os__code__getAsync(string code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/ua/os/"+ (code==null? "" : System.Uri.EscapeDataString(code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OSOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the type of a user agent.
		/// ### What
		/// Obtain the details of a type of a User Agent.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``code``: (Mandatory) The code that identifies uniquely the type of a User Agent. The value must be an alphanumeric upper case string.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to the type.
		/// - ``description``: the human readable description of the type.
		/// - ``code``: the internal code of the type in the system.
		/// - ``type``: the type of the User Agent. Can be ``INTERACTIVE``, ``CRAWLER`` or ``UNKNOWN`` if the type is not known.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the code is not one of the available.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_type_by_code_v1_ua_type__code__get v1/ua/type/{code}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<TypeOutput> Query_type_by_code_v1_ua_type__code__getAsync(string code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/ua/type/"+ (code==null? "" : System.Uri.EscapeDataString(code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TypeOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information of the vendor of a user agent.
		/// ### What
		/// Obtain the details of a vendor of a User Agent.
		/// 
		/// ### Parameters
		/// The endpoint accepts only the following parameter in the path:
		/// - ``code``: (Mandatory) The code that identifies uniquely the vendor or manufacurer of a User Agent. The value must be an alphanumeric upper case string.
		/// 
		/// 
		/// ### Result
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI to the vendor.
		/// - ``description``: the human readable description of the vendor.
		/// - ``code``: the internal code of the vendor in the system.
		/// 
		/// ### Errors
		/// - a `422 Unprocessable Entity` error if the code is not one of the available.
		/// 
		/// It will also return the API Global errors described in the API description.
		/// Query_vendor_by_code_v1_ua_vendor__code__get v1/ua/vendor/{code}
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task<VendorOutput> Query_vendor_by_code_v1_ua_vendor__code__getAsync(string code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/ua/vendor/"+ (code==null? "" : System.Uri.EscapeDataString(code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<VendorOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the information found in an User Agent.
		/// ### What
		/// Get the information found in the User Agent passed as argument. This information includes:
		/// - Type
		/// - Render Engine
		/// - Version
		/// - Vendor
		/// - Operating System
		/// - Device
		/// - How common is the agent worldwide
		/// 
		/// 
		/// ### Parameters
		/// The only argument accepted in the query string is an URL encoded User Agent string.
		/// 
		/// ### Result
		/// The result contains the following set of data:
		/// 
		/// The result is a JSON object with the following structure:
		/// - ``self``: the URI of the API call
		/// - ``string``:  The full user agent string passed as argument.
		/// - ``classification``: The classification of the user agent. It can be one of the following: ``CRAWLER``, ``CLIENT``, ``UNKNOWN``.
		/// - ``type``: An URI to the type of user agent used to identify the client (browser, bot, crawler, etc.).
		/// - ``agent``: Name of the agent and the version, if any.
		/// - ``engine``: Agent render engine.
		/// - ``version``: Version of the agent.
		/// - ``latest``: Latests known version of the agent.
		/// - ``family``: URI to the family of the agent.
		/// - ``vendor``: URI to the vendor or company that produces the agent.
		/// - ``os``: URI to the operating system used by the agent.
		/// - ``device``: URI to the device used by the agent.
		/// - ``frequent``: If the agent is frequently used worlwide or not. The values are ``COMMON``, ``RARE``, and ``UNKNOWN``.
		/// 
		/// 
		/// ### Errors
		/// The endpoint will return the API Global errors described in the API description.
		/// Parse_user_agent_v1_ua__user_agent_urlencoded__get v1/ua/{user_agent_urlencoded}
		/// </summary>
		/// <returns>The server will return a valid answer in the following cases:</returns>
		public async Task<UAOutput> Parse_user_agent_v1_ua__user_agent_urlencoded__getAsync(string user_agent_urlencoded, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/ua/"+ (user_agent_urlencoded==null? "" : System.Uri.EscapeDataString(user_agent_urlencoded));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UAOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Get_all_private_allowlists_by_resource_type_v1_allowlist_private_all__resource_type__getResource_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cidr = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		country = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		continent = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="as")]
		_as = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		datacenter = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		useragent = 5,
	}
	
	public enum Get_all_public_allowlists_by_resource_type_v1_allowlist_public_all__resource_type__getResource_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cidr = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		country = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		continent = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="as")]
		_as = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		datacenter = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		useragent = 5,
	}
	
	public enum Get_all_owned_allowlists_by_resource_type_v1_allowlist_public_owned__resource_type__getResource_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cidr = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		country = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		continent = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="as")]
		_as = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		datacenter = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		useragent = 5,
	}
	
	public enum Query_registry_by_the_name_v1_asn_registry__code__getCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		iana = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		arin = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ripencc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		afrinic = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		apnic = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lacnic = 5,
	}
	
	public enum Query_status_by_the_name_v1_asn_status__code__getCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		assigned = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reserved = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		available = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		allocated = 3,
	}
	
	public enum Get_all_private_denylists_by_resource_type_v1_denylist_private_all__resource_type__getResource_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cidr = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		country = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		continent = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="as")]
		_as = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		datacenter = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		useragent = 5,
	}
	
	public enum Get_all_public_denylists_by_resource_type_v1_denylist_public_all__resource_type__getResource_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cidr = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		country = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		continent = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="as")]
		_as = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		datacenter = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		useragent = 5,
	}
	
	public enum Get_all_owned_denylists_by_resource_type_v1_denylist_public_owned__resource_type__getResource_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cidr = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		country = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		continent = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="as")]
		_as = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		datacenter = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		useragent = 5,
	}
	
	public enum Query_all_the_ip_addresses_reported_by_the_user_v1_denylist_reported_ip_getOutput_format
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CSV = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS-WAF")]
		AWSMinusWAF = 2,
	}
	
	public enum Query_origin_traffic_client_v1_origin_client_analysis_getInterval
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HOURLY = 0,
	}
	
	public enum Get_source_and_timerange_info_v1_source_ip__source__range__time_range__getTime_range
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1H")]
		_1H = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6H")]
		_6H = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12H")]
		_12H = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1D")]
		_1D = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7D")]
		_7D = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30D")]
		_30D = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="90D")]
		_90D = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="180D")]
		_180D = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="365D")]
		_365D = 8,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
