//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A broadcast service that can subscribe to content for multiple destinations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BroadcastService
	{
		
		/// <summary>
		/// The date the broadcast service was created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.DateTimeOffset CreatedDate { get; set; }
		
		/// <summary>
		/// The description of the broadcast service.
		/// Min length: 0
		/// Max length: 1200
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1200)]
		public string Description { get; set; }
		
		/// <summary>
		/// The ID of the broadcast service.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long Id { get; set; }
		
		/// <summary>
		/// The date the broadcast service was last modified.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastModifiedDate")]
		public System.DateTimeOffset LastModifiedDate { get; set; }
		
		/// <summary>
		/// The name of the broadcast service.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A file in the CD Drive that contains content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CDDriveFile
	{
		
		/// <summary>
		/// The date and time the file was created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public string CreatedDate { get; set; }
		
		/// <summary>
		/// The ID of the file.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long Id { get; set; }
		
		/// <summary>
		/// The date and time the file was last modified.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastModifiedDate")]
		public string LastModifiedDate { get; set; }
		
		/// <summary>
		/// The name of the file including the extension.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// Pattern: ^[a-zA-Z0-9][a-zA-Z0-9 \._]*[a-zA-Z0-9]$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9][a-zA-Z0-9 \._]*[a-zA-Z0-9]$")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the parent folder or 0 for the root folder.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parentId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long ParentId { get; set; }
		
		/// <summary>
		/// The size of the file in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
	}
	
	/// <summary>
	/// A folder in the CD Drive that can contain other items such as files or folders.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CDDriveFolder
	{
		
		/// <summary>
		/// The date and time the folder was created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public string CreatedDate { get; set; }
		
		/// <summary>
		/// The ID of the folder.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long Id { get; set; }
		
		/// <summary>
		/// The date and time the folder was last modified. This may only represent a modification to to the folder metadata itself, not to the contents of the folder.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastModifiedDate")]
		public string LastModifiedDate { get; set; }
		
		/// <summary>
		/// The name of the folder.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// Pattern: ^[a-zA-Z0-9][a-zA-Z0-9 \._]*[a-zA-Z0-9]$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9][a-zA-Z0-9 \._]*[a-zA-Z0-9]$")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the parent folder or 0 for the root folder.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parentId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long ParentId { get; set; }
	}
	
	/// <summary>
	/// A generic reference to an item in the CD Drive such as a file or folder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CDDriveItem
	{
		
		/// <summary>
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CDDriveItemType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CDDriveItemType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="file")]
		file = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="folder")]
		folder = 1,
	}
	
	/// <summary>
	/// An episode that defines a specific air date for an instance of a program.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Episode
	{
		
		/// <summary>
		/// The date the air window opens for the episode.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="beginAirDate")]
		public System.DateTimeOffset BeginAirDate { get; set; }
		
		/// <summary>
		/// The date the live stream begins for the episode. Only set for live and LWSF episodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="beginTransmissionDate")]
		public System.Nullable<System.DateTimeOffset> BeginTransmissionDate { get; set; }
		
		/// <summary>
		/// The date the segment was created. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The ID of the customer that owns this programs.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> CustomerId { get; set; }
		
		/// <summary>
		/// The date the air window closes for the episode.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endAirDate")]
		public System.DateTimeOffset EndAirDate { get; set; }
		
		/// <summary>
		/// The date the live stream ends for the episode. Only set for live and LWSF episodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTransmissionDate")]
		public System.Nullable<System.DateTimeOffset> EndTransmissionDate { get; set; }
		
		/// <summary>
		/// The unique ID of the episode. Generated at creation.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// The date the segment was last modified/updated. Automatically updated on any write operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModifiedDate")]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		/// <summary>
		/// The ID of the program that owns this episode.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="programId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long ProgramId { get; set; }
		
		/// <summary>
		/// The title of the program.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// Standard error response. See the [Problem Details for HTTP APIs](https://datatracker.ietf.org/doc/html/rfc7807) for more details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		/// <summary>
		/// The occurrence-specific problem description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// The status code of the error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		/// <summary>
		/// The general problem description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// The metadata about a "piece" which may be a story, song, report, etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Piece
	{
		
		/// <summary>
		/// The artist or contributor name.
		/// Max length: 26
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contributor")]
		[System.ComponentModel.DataAnnotations.MaxLength(26)]
		public string Contributor { get; set; }
		
		/// <summary>
		/// The date the piece was created. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The short description of the piece.
		/// Max length: 180
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(180)]
		public string Description { get; set; }
		
		/// <summary>
		/// The ID of the episode that owns the piece.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="episodeId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long EpisodeId { get; set; }
		
		/// <summary>
		/// The long description of the piece.
		/// Max length: 1200
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullDescription")]
		[System.ComponentModel.DataAnnotations.MaxLength(1200)]
		public string FullDescription { get; set; }
		
		/// <summary>
		/// The unique ID of the piece. Generated at creation.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// The URI to the piece image content in CD Drive. Format should be 'cddrive:id:{value}' or 'cddrive://{path}'. This property is only used on modification and is not returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageCdDriveUri")]
		public string ImageCdDriveUri { get; set; }
		
		/// <summary>
		/// The name of the piece image file. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageFileName")]
		public string ImageFileName { get; set; }
		
		/// <summary>
		/// The size of the piece image file in bytes. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageFileSize")]
		public System.Nullable<System.Int64> ImageFileSize { get; set; }
		
		/// <summary>
		/// The user's original name of the piece image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageOriginalFileName")]
		public string ImageOriginalFileName { get; set; }
		
		/// <summary>
		/// The date the piece was last modified/updated. Automatically updated on any write operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModifiedDate")]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		/// <summary>
		/// Seconds relative to the start of the episode.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="relativeEndTime")]
		public int RelativeEndTime { get; set; }
		
		/// <summary>
		/// Seconds relative to the start of the episode.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="relativeStartTime")]
		public int RelativeStartTime { get; set; }
		
		/// <summary>
		/// The number of the segment that this piece is in, starting with 1. This is an optional field but it can be used to provide more detail by linking the piece to a specific audio segment.
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="segmentNumber")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SegmentNumber { get; set; }
		
		/// <summary>
		/// The human readable title of the piece that is normally displayed on an end user's device.
		/// Required
		/// Max length: 37
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		[System.ComponentModel.DataAnnotations.MaxLength(37)]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// A program that stations can subscribe to to get live or file content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Program
	{
		
		/// <summary>
		/// The date the segment was created. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The ID of the customer that owns this program.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> CustomerId { get; set; }
		
		/// <summary>
		/// The unique ID of the program. Generated at creation.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// The date the program was last modified/updated. Automatically updated on any write operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModifiedDate")]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		/// <summary>
		/// The title of the program.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// An electronic program guide (EPG) batch operation to create or update metadata on one or more guide programs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProgramInformationBatch
	{
		
		/// <summary>
		/// The date and time the batch was created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public string CreatedDate { get; set; }
		
		/// <summary>
		/// The date and time the batch finished (either successful or failed).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="finishedDate")]
		public string FinishedDate { get; set; }
		
		/// <summary>
		/// The format of the metadata file defining the create or update actions to be performed on one or more EPG programs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public ProgramInformationBatchFormat Format { get; set; }
		
		/// <summary>
		/// The ID of the batch.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long Id { get; set; }
		
		/// <summary>
		/// The human readable success or failure message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The optional name of the batch for human reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The program information to associate the ingested metadata with. This is only required if the metadata format doesn't provide the program title and air date information directly. If this is specified, it will overrite the value specfified in the metadata file. If this is specified, the metadata file should only contain one program.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="program")]
		public ProgramInformationBatchProgram Program { get; set; }
		
		/// <summary>
		/// The current processing status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ProgramInformationBatchStatus Status { get; set; }
		
		/// <summary>
		/// The URI to the metadata file defining the batch creates/updates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ProgramInformationBatchFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="radiodns")]
		radiodns = 0,
	}
	
	public class ProgramInformationBatchProgram
	{
		
		/// <summary>
		/// The airDate for the program in ISO 8601 format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="airDate")]
		public string AirDate { get; set; }
		
		/// <summary>
		/// The title of the program.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ProgramInformationBatchStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="queued")]
		queued = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="processing")]
		processing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="failed")]
		failed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="successful")]
		successful = 3,
	}
	
	/// <summary>
	/// An audio segment in an episode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Segment
	{
		
		/// <summary>
		/// The number of audio channels in the segment. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channels")]
		public System.Nullable<System.Int32> Channels { get; set; }
		
		/// <summary>
		/// The date the segment was created. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The ID of the episode that owns the segment.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="episodeId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long EpisodeId { get; set; }
		
		/// <summary>
		/// The name of the audio content file. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileName")]
		public string FileName { get; set; }
		
		/// <summary>
		/// The size of the audio content file in bytes. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileSize")]
		public System.Nullable<System.Int64> FileSize { get; set; }
		
		/// <summary>
		/// The unique ID of the segment. Generated at creation.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// The in-cue copy that signals the start of the segment to a board operator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inCue")]
		public string InCue { get; set; }
		
		/// <summary>
		/// The date the segment was last modified/updated. Automatically updated on any write operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModifiedDate")]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		/// <summary>
		/// The length (duration) of the segment in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="length")]
		public System.Nullable<System.Int32> Length { get; set; }
		
		/// <summary>
		/// The original name of the audio content file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originalFileName")]
		public string OriginalFileName { get; set; }
		
		/// <summary>
		/// The out-cue copy that signals the end of the segment to a board operator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outCue")]
		public string OutCue { get; set; }
		
		/// <summary>
		/// The number of the segment in the episode, starting with 1.
		/// Required
		/// Minimum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="segmentNumber")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public int SegmentNumber { get; set; }
	}
	
	/// <summary>
	/// An audio spot for insertion.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Spot
	{
		
		/// <summary>
		/// The date the spot was created. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The length (duration) of the spot in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// The name of the audio content file. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileName")]
		public string FileName { get; set; }
		
		/// <summary>
		/// The size of the audio content file in bytes. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileSize")]
		public System.Nullable<System.Int64> FileSize { get; set; }
		
		/// <summary>
		/// The unique ID of the spot. Generated at creation.
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// The date the spot was last modified/updated. Automatically updated on any write operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModifiedDate")]
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		/// <summary>
		/// The date the spot audio file was uploaded. Automatically updated on upload.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUploadedDate")]
		public System.Nullable<System.DateTimeOffset> LastUploadedDate { get; set; }
		
		/// <summary>
		/// The unique name of the spot
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Miscellaneous notes about the spot
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The original name of the audio content file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originalFileName")]
		public string OriginalFileName { get; set; }
	}
	
	/// <summary>
	/// A spot insertion for playing a series of spots when a cue is received during a program.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SpotInsertion
	{
		
		/// <summary>
		/// The ID of the broadcast service for the spot insertion.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="broadcastServiceId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long BroadcastServiceId { get; set; }
		
		/// <summary>
		/// The date and time the spot insertion was created. Generated at creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The cue that triggers the spot insertion.
		/// Required
		/// Pattern: ^S:[A-F0-9]{3,4}_[A-Za-z0-9_-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cue")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^S:[A-F0-9]{3,4}_[A-Za-z0-9_-]*$")]
		public string Cue { get; set; }
		
		/// <summary>
		/// The ID of the customer who owns the spot insertion. Set to the logged-in customer at creation.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> CustomerId { get; set; }
		
		/// <summary>
		/// The duration of the spot insertion.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public int Duration { get; set; }
		
		/// <summary>
		/// The date the spot insertion ends. The time will be set to midnight Eastern Time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endDate")]
		public System.DateOnly EndDate { get; set; }
		
		/// <summary>
		/// The unique ID of the spot insertion. Generated at creation.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// The ID of the program for the spot insertion.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="programId")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public long ProgramId { get; set; }
		
		/// <summary>
		/// The ordered list of spot IDs to play.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spots")]
		public int[] Spots { get; set; }
		
		/// <summary>
		/// The date the spot insertion can start. The time will be set to midnight Eastern Time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public System.DateOnly StartDate { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Gets broadcast services matching the given criteria.
		/// ApiV2BroadcastservicesGetByPageStartAndPageSizeAndOrderById api/v2/broadcastservices
		/// </summary>
		/// <param name="pageStart">The start page of the results to return. The first item is indexed at 0.
		/// Minimum: 0
		// </param>
		/// <param name="pageSize">The number of items to return. Must be between 0 and 500, inclusive.
		/// Minimum: 0
		/// Maximum: 500
		// </param>
		/// <param name="orderById">The sort order of the list of broadcast services, based on broadcast service ID. If unspecified, the broadcast services are returned in random order. If using paging to iterate through the results, sort order should be specified.</param>
		/// <returns>The matching broadcast services.</returns>
		public async Task<Episode[]> ApiV2BroadcastservicesGetByPageStartAndPageSizeAndOrderByIdAsync(int pageStart, int pageSize, ApiV2BroadcastservicesGetByPageStartAndPageSizeAndOrderByIdOrderById orderById, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/broadcastservices?pageStart="+pageStart+"&pageSize="+pageSize+"&orderById=" + orderById;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Episode[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the broadcast service matching the given ID.
		/// ApiV2Broadcastservices_idGet api/v2/broadcastservices/{id}
		/// </summary>
		/// <returns>The matching broadcast service.</returns>
		public async Task<BroadcastService> ApiV2Broadcastservices_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/broadcastservices/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BroadcastService>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a file.
		/// Delete a file from the customer's private CD Drive.
		/// ApiV2CddriveFiles_file_idDelete api/v2/cddrive/files/{file_id}
		/// </summary>
		public async Task ApiV2CddriveFiles_file_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/cddrive/files/{file_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get file information.
		/// Get the information about a file in the customer's private CD Drive.
		/// ApiV2CddriveFiles_file_idGet api/v2/cddrive/files/{file_id}
		/// </summary>
		/// <returns>The file information.</returns>
		public async Task<CDDriveFile> ApiV2CddriveFiles_file_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/cddrive/files/{file_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CDDriveFile>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// UNDER DEVELOPMENT - Download a file.
		/// Download a file from the customer's private CD Drive.
		/// ApiV2CddriveFiles_file_idContentGet api/v2/cddrive/files/{file_id}/content
		/// </summary>
		/// <returns>The file was found and will be returned in the body of the response.</returns>
		public async Task ApiV2CddriveFiles_file_idContentGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/cddrive/files/{file_id}/content";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// UNDER DEVELOPMENT - Delete a folder.
		/// Delete a file from the customer's private CD Drive.
		/// ApiV2CddriveFolders_folder_idDeleteByRecursive api/v2/cddrive/folders/{folder_id}
		/// </summary>
		/// <param name="recursive">Flag to indicate if the folder should be deleted if it has items inside of it.</param>
		public async Task ApiV2CddriveFolders_folder_idDeleteByRecursiveAsync(bool recursive, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/cddrive/folders/{folder_id}?recursive="+recursive;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// UNDER DEVELOPMENT - Get folder information.
		/// Get the information about a folder in the customer's private CD Drive.
		/// ApiV2CddriveFolders_folder_idGet api/v2/cddrive/folders/{folder_id}
		/// </summary>
		/// <returns>The folder information.</returns>
		public async Task<CDDriveFolder> ApiV2CddriveFolders_folder_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/cddrive/folders/{folder_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CDDriveFolder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the items in the folder.
		/// Get the information about a folder in the customer's private CD Drive.
		/// ApiV2CddriveFolders_folder_idItemsGetByOffsetAndLimit api/v2/cddrive/folders/{folder_id}/items
		/// </summary>
		/// <param name="offset">The offset into the items to begin the response.</param>
		/// <param name="limit">The maximum number of items to return in the response.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <returns>The folder information.</returns>
		public async Task<ApiV2CddriveFolders_folder_idItemsGetByOffsetAndLimitReturn> ApiV2CddriveFolders_folder_idItemsGetByOffsetAndLimitAsync(int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/cddrive/folders/{folder_id}/items?offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ApiV2CddriveFolders_folder_idItemsGetByOffsetAndLimitReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets episodes matching the given criteria.
		/// ApiV2EpisodesGetByIdAndBeginAirDateAfterAndEndAirDateBeforeAndProgramIdAndPageStartAndPageSizeAndOrderById api/v2/episodes
		/// </summary>
		/// <param name="id">Matches on the ID of the episode.</param>
		/// <param name="beginAirDateAfter">Matches on the begin air date of the episode (inclusive).</param>
		/// <param name="endAirDateBefore">Matches on the end air date of the episode (inclusive).</param>
		/// <param name="programId">Matches on the ID of the program that owns the episode.</param>
		/// <param name="pageStart">The start page of the results to return. The first item is indexed at 0.
		/// Minimum: 0
		// </param>
		/// <param name="pageSize">The number of items to return. Must be between 0 and 500, inclusive.
		/// Minimum: 0
		/// Maximum: 500
		// </param>
		/// <param name="orderById">The sort order of the list of episodes, based on episode ID. If unspecified, the episodes are returned in random order. If using paging to iterate through the results, sort order should be specified.</param>
		/// <returns>The matching episode.</returns>
		public async Task<Episode[]> ApiV2EpisodesGetByIdAndBeginAirDateAfterAndEndAirDateBeforeAndProgramIdAndPageStartAndPageSizeAndOrderByIdAsync(long id, System.DateTimeOffset beginAirDateAfter, System.DateTimeOffset endAirDateBefore, long programId, int pageStart, int pageSize, ApiV2BroadcastservicesGetByPageStartAndPageSizeAndOrderByIdOrderById orderById, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/episodes?id="+id+"&beginAirDateAfter=" + beginAirDateAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endAirDateBefore=" + endAirDateBefore.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&programId="+programId+"&pageStart="+pageStart+"&pageSize="+pageSize+"&orderById=" + orderById;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Episode[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the episode matching the given ID.
		/// ApiV2Episodes_idGet api/v2/episodes/{id}
		/// </summary>
		/// <returns>The matching episode.</returns>
		public async Task<Episode> ApiV2Episodes_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/episodes/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Episode>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a batch operation on EPG information.
		/// Create a batch to process the metadata of one or more electronic program guide (EPG) programs using metadata that has been uploaded to the customer's CD Drive. If multiple EPG programs are present in the metadata, they will all be updated, however updates across programs are not atomic. Note that an EPG program maps to the ContentDepot concept of an episode which is also known as a "program instance".
		/// 
		/// A batch operation must be explicitly created rather than the server attempting to detect new metadata in order to allow for all the content to be uploaded including any supporting content like images. A batch operation is accepted and queued for asynchronous processing at a later time. A client can poll the batch periodically to determine when it completes and the resulting state.
		/// 
		/// ApiV2MetapubProgram_informationBatchPost api/v2/metapub/program-information/batch
		/// </summary>
		public async Task ApiV2MetapubProgram_informationBatchPostAsync(ApiV2MetapubProgram_informationBatchPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/metapub/program-information/batch";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an EPG batch operation.
		/// Gets the batch information which can be used to check the status of the operation or retrieve more details if the batch fails.
		/// ApiV2MetapubProgram_informationBatch_batch_idGet api/v2/metapub/program-information/batch/{batch_id}
		/// </summary>
		/// <returns>The batch information.</returns>
		public async Task<ProgramInformationBatch> ApiV2MetapubProgram_informationBatch_batch_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/metapub/program-information/batch/{batch_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProgramInformationBatch>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the pieces matching the query parameters.
		/// ApiV2PiecesGetByEpisodeId api/v2/pieces
		/// </summary>
		/// <param name="episodeId">The ID of the episode that owns the piece.</param>
		/// <returns>The pieces matching the query parameters</returns>
		public async Task<Piece[]> ApiV2PiecesGetByEpisodeIdAsync(long episodeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/pieces?episodeId="+episodeId;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Piece[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new piece.
		/// ApiV2PiecesPost api/v2/pieces
		/// </summary>
		public async Task ApiV2PiecesPostAsync(Piece requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/pieces";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the piece with the given ID.
		/// ApiV2Pieces_idDelete api/v2/pieces/{id}
		/// </summary>
		/// <returns>The piece was deleted.</returns>
		public async Task ApiV2Pieces_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/pieces/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the piece matching the given ID.
		/// ApiV2Pieces_idGet api/v2/pieces/{id}
		/// </summary>
		/// <returns>The piece with the given ID.</returns>
		public async Task<Piece> ApiV2Pieces_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/pieces/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Piece>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Optimized free-text search for programs using various filters.
		/// ApiV2ProgramsSearchGetByKeywordsAndPageStartAndPageSize api/v2/programs/search
		/// </summary>
		/// <param name="keywords">Free text search that matches against the program title or description.</param>
		/// <param name="pageStart">The start page of the results to return. The first item is indexed at 0.
		/// Minimum: 0
		// </param>
		/// <param name="pageSize">The number of items to return. Must be between 0 and 500, inclusive.
		/// Minimum: 0
		/// Maximum: 500
		// </param>
		/// <returns>Programs matching the search request sorted by relevance.</returns>
		public async Task<Program[]> ApiV2ProgramsSearchGetByKeywordsAndPageStartAndPageSizeAsync(string keywords, int pageStart, int pageSize, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/programs/search?keywords=" + (keywords==null? "" : System.Uri.EscapeDataString(keywords))+"&pageStart="+pageStart+"&pageSize="+pageSize;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Program[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the program matching the given ID.
		/// ApiV2Programs_idGet api/v2/programs/{id}
		/// </summary>
		/// <returns>The matching program.</returns>
		public async Task<Program> ApiV2Programs_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/programs/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Program>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the segments matching the query parameters.
		/// ApiV2SegmentsGetByEpisodeIdAndSegmentNumberAndPageStartAndPageSizeAndOrderById api/v2/segments
		/// </summary>
		/// <param name="episodeId">The ID of the episode that owns the segment.</param>
		/// <param name="pageStart">The start page of the results to return. The first item is indexed at 0.
		/// Minimum: 0
		// </param>
		/// <param name="pageSize">The number of items to return. Must be between 0 and 500, inclusive.
		/// Minimum: 0
		/// Maximum: 500
		// </param>
		/// <param name="orderById">The sort order of the list of segments, based on segment ID. If unspecified, the segments are returned in random order. If using paging to iterate through the results, sort order should be specified.</param>
		/// <returns>The segments matching the query parameters</returns>
		public async Task<Segment[]> ApiV2SegmentsGetByEpisodeIdAndSegmentNumberAndPageStartAndPageSizeAndOrderByIdAsync(long episodeId, int segmentNumber, int pageStart, int pageSize, ApiV2BroadcastservicesGetByPageStartAndPageSizeAndOrderByIdOrderById orderById, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/segments?episodeId="+episodeId+"&segmentNumber="+segmentNumber+"&pageStart="+pageStart+"&pageSize="+pageSize+"&orderById=" + orderById;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Segment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the segment with the given ID.
		/// ApiV2Segments_idDelete api/v2/segments/{id}
		/// </summary>
		/// <returns>The segment was deleted.</returns>
		public async Task ApiV2Segments_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/segments/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the segment matching the given ID.
		/// ApiV2Segments_idGet api/v2/segments/{id}
		/// </summary>
		/// <returns>The segment with the given ID.</returns>
		public async Task<Segment> ApiV2Segments_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/segments/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Segment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// UNDER DEVELOPMENT - Returns the audio content segment matching the given ID.
		/// ApiV2Segments_idContentGet api/v2/segments/{id}/content
		/// </summary>
		/// <returns>The audio content of the requested segment.</returns>
		public async Task ApiV2Segments_idContentGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/segments/{id}/content";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the spot insertions matching the query parameters.
		/// ApiV2SpotinsertionsGetByPageStartAndPageSizeAndOrderById api/v2/spotinsertions
		/// </summary>
		/// <param name="pageStart">The start page of the results to return. The first item is indexed at 0.
		/// Minimum: 0
		// </param>
		/// <param name="pageSize">The number of items to return. Must be between 0 and 500, inclusive.
		/// Minimum: 0
		/// Maximum: 500
		// </param>
		/// <param name="orderById">The sort order of the list of spot insertions, based on ID. If unspecified, the spot insertions are returned in random order. If using paging to iterate through the results, sort order should be specified.</param>
		/// <returns>The spot insertions matching the query parameters</returns>
		public async Task<SpotInsertion[]> ApiV2SpotinsertionsGetByPageStartAndPageSizeAndOrderByIdAsync(int pageStart, int pageSize, ApiV2BroadcastservicesGetByPageStartAndPageSizeAndOrderByIdOrderById orderById, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/spotinsertions?pageStart="+pageStart+"&pageSize="+pageSize+"&orderById=" + orderById;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SpotInsertion[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new spot insertion.
		/// ApiV2SpotinsertionsPost api/v2/spotinsertions
		/// </summary>
		public async Task ApiV2SpotinsertionsPostAsync(SpotInsertion requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/spotinsertions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the spot insertion with the given ID.
		/// ApiV2Spotinsertions_idDelete api/v2/spotinsertions/{id}
		/// </summary>
		/// <returns>The spot insertion was deleted.</returns>
		public async Task ApiV2Spotinsertions_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/spotinsertions/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the spot insertion matching the given ID.
		/// ApiV2Spotinsertions_idGet api/v2/spotinsertions/{id}
		/// </summary>
		/// <returns>The spot insertion with the given ID.</returns>
		public async Task<SpotInsertion> ApiV2Spotinsertions_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/spotinsertions/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SpotInsertion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the spots matching the query parameters.
		/// ApiV2SpotsGetByPageStartAndPageSizeAndOrderById api/v2/spots
		/// </summary>
		/// <param name="pageStart">The start page of the spot to return. The first item is indexed at 0.
		/// Minimum: 0
		// </param>
		/// <param name="pageSize">The number of items to return. Must be between 0 and 500, inclusive.
		/// Minimum: 0
		/// Maximum: 500
		// </param>
		/// <param name="orderById">The sort order of the list of spots, based on spot ID. If unspecified, the spots are returned in random order. If using paging to iterate through the results, sort order should be specified.</param>
		/// <returns>The spots matching the query parameters</returns>
		public async Task<Spot[]> ApiV2SpotsGetByPageStartAndPageSizeAndOrderByIdAsync(int pageStart, int pageSize, ApiV2BroadcastservicesGetByPageStartAndPageSizeAndOrderByIdOrderById orderById, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/spots?pageStart="+pageStart+"&pageSize="+pageSize+"&orderById=" + orderById;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Spot[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the spot with the given ID.
		/// ApiV2Spots_idDelete api/v2/spots/{id}
		/// </summary>
		/// <returns>The spot was deleted.</returns>
		public async Task ApiV2Spots_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/spots/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the spot matching the given ID.
		/// ApiV2Spots_idGet api/v2/spots/{id}
		/// </summary>
		/// <returns>The spot with the given ID.</returns>
		public async Task<Spot> ApiV2Spots_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/spots/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Spot>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the group information document.
		/// The group information (GI) document allows programs to be put into groups such as serials, series, shows, or general themes and provide additional metadata for that group such as a description, links, and a logo. A program in the guide can be linked to its group using the "memberOf" field to allow clients to easily link programs together for a given Content Depot Program/Show in the EPG. GI will be published for all Content Depot programs that have the "publish metadata" option enabled. By using the group information, clients have the ability to access a single list of all metadata supported program titles, links, images, and descriptions. This information can be used to assist a station when setting up a schedule or it can be used in the end user metadata to provide additional information about the content such as displaying "other episodes from this program" or displaying the group, program, and program event images.
		/// 
		/// Currently all programs with "publish metadata" enabled will be included in the group information even if they are not active in the program guide. This may change in the future if the number of programs grows.
		/// 
		/// Note that while the location of the GI document isn't expected to change in the near future, as per the RadioDNS specification the authoritative link to the document is defined in the SI document with the mime value ```application/xml+gi```.
		/// 
		/// The response will use standard HTTP cache-control headers to indicate when the document should be refreshed as well as an ETag to allow for lightweight change detection.
		/// 
		/// RadiodnsSpi3_1GI_xmlGet radiodns/spi/3.1/GI.xml
		/// </summary>
		/// <returns>The group information document is returned in the body of the response.</returns>
		public async Task RadiodnsSpi3_1GI_xmlGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "radiodns/spi/3.1/GI.xml";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the service information document.
		/// The service information (SI) document holds a definition of services provided by the service provider (e.g. MetaPub), including any relevant metadata and bearer details, such as:
		/// 
		/// * Names
		/// * Descriptions
		/// * Logos
		/// * Bearers (broadcast and IP)
		/// 
		/// MetaPub provides two SI documents. The _National SI document_ describes the distribution services provided by PRSS including basic service metadata, logos, and bearers. The current design defines two IP based services, although this may change in the future:
		/// 
		/// * Streams
		/// * Bearer ID: prss:streams
		/// * Service ID: streams
		/// * Files
		/// * Bearer ID: prss:files
		/// * Service ID: files
		/// 
		/// The _Station SI document_ describes the stations and broadcast services served by PRSS. Only stations and broadcast services that have opted into metadata publishing are listed in this document.
		/// 
		/// Based on [ETSI TS 102 818 v3.4.1](https://www.etsi.org/deliver/etsi_ts/102800_102899/102818/03.04.01_60/ts_102818v030401p.pdf) section 10.2.4, the SI document will be placed in a defined location on the service website. Using standard HTTP cache mechanisms, the SI document will only need to be fetched and processed occasionally.
		/// 
		/// The response will use standard HTTP cache-control headers to indicate when the document should be refreshed as well as an ETag to allow for lightweight change detection.
		/// 
		/// RadiodnsSpi3_1SI_xmlGet radiodns/spi/3.1/SI.xml
		/// </summary>
		/// <returns>The service information document is returned in the body of the response.</returns>
		public async Task RadiodnsSpi3_1SI_xmlGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "radiodns/spi/3.1/SI.xml";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the program information document.
		/// The program information (PI) document holds the linear and the on-demand schedule of programs for a service over a 24 hour period. This information provides an electronic program guide (EPG) to clients that defines the program metadata such as:
		/// 
		/// *   Names
		/// *   Descriptions
		/// *   Logos
		/// *   Links
		/// *   Genres
		/// *   Program Events (a.k.a. pieces)
		/// 
		/// MetaPub provides both _National PI documents_ and _Station PI documents_. For both documents, only programs with metadata publishing enabled are listed in the document. As per the RadioDNS specification, the authoritative list of services is defined in the corresponding SI document.
		/// 
		/// The National PI documents correspond to the services listed in the National SI document (streams and files). This EPG contains two types of programming, live and on-demand (a.k.a files). A "live with subsequent file (LWSF)" program may appear in both the streams and files services EPG data because it will both a live stream and an on-demand file. File programs with multi-day air windows will appear in the PI file on every day that the air window is open. That is, the EPG data for each day contains the information about programming available that day, even if the programming is also available on other days. The program ID can be used to resolve these duplicates down to a single instance when processing multiple services or multiple days of EPG data.
		/// 
		/// The Station PI documents correspond to the services listed in the Station SI document, and list program and schedule metadata for programs which are subscribed to by the given service. Note that stations may opt into "static" metadata publishing (station and broadcast service metadata) but not "dynamic" metadata publishing (program and schedule metadata). If this is the case, a service that is listed in the Station SI document will not have a corresponding PI document, and a 404 status code will be returned.
		/// 
		/// Each PI document will contain 24 hours of program guide information. The current day, the previous day, and the next day will contain detailed program event information (a.k.a. Content Depot pieces) while PI files outside of this range will only contain the program (a.k.a Content Depot episode) level information. This may change in the future with the use of an API key as defined by the RadioDNS specification to identify "trusted" clients. If metadata for any program in the guide(s) changes, the PI document will be regenerated. Using standard HTTP cache mechanisms, the PI document for the current day can be fetched frequently (e.g. every 5 minutes) to receive last minute changes while future and past days will only be fetched and processed occasionally (e.g. every two hours).
		/// 
		/// By obtaining the full 24 hour guide, clients such as middleware can build a local database/lookup table of program and program event information that allows for more specific program selection based on user configuration, automation events, and other possible inputs. In the event that MetaPub is unreachable for a short period of time, the client has the full guide to prevent any interruption to the on-air broadcast.
		/// 
		/// Construction of the URL to the PI document is described in [ETSI TS 102 818 v3.4.1](https://www.etsi.org/deliver/etsi_ts/102800_102899/102818/03.04.01_60/ts_102818v030401p.pdf) section 10.3. Currently, MetaPub only supports PI URLs constructed from SPI SI, as described in [ETSI TS 103 270 v1.4.1](https://www.etsi.org/deliver/etsi_ts/103200_103299/103270/01.04.01_60/ts_103270v010401p.pdf) section 7.
		/// 
		/// The response will use standard HTTP cache-control headers to indicate when the document should be refreshed as well as an ETag to allow for lightweight change detection.
		/// 
		/// RadiodnsSpi3_1Id_fqdn_sid_date_PI_xmlGet radiodns/spi/3.1/id/{fqdn}/{sid}/{date}_PI.xml
		/// </summary>
		/// <returns>Program information document for the given 24 hour period.</returns>
		public async Task RadiodnsSpi3_1Id_fqdn_sid_date_PI_xmlGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "radiodns/spi/3.1/id/{fqdn}/{sid}/{date}_PI.xml";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum ApiV2BroadcastservicesGetByPageStartAndPageSizeAndOrderByIdOrderById
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="asc")]
		asc = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="desc")]
		desc = 1,
	}
	
	public class ApiV2CddriveFolders_folder_idItemsGetByOffsetAndLimitReturn
	{
		
		/// <summary>
		/// The item instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public CDDriveItem[] Entries { get; set; }
		
		/// <summary>
		/// The maximum number of items to return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limit")]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		/// <summary>
		/// The start offset into the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="offset")]
		public System.Nullable<System.Int32> Offset { get; set; }
		
		/// <summary>
		/// The total number of entries available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalCount")]
		public System.Nullable<System.Int32> TotalCount { get; set; }
	}
	
	public class ApiV2MetapubProgram_informationBatchPostPostBody
	{
		
		/// <summary>
		/// The format of the metadata file defining the create or update actions to be performed on one or more EPG programs. For more information on how RadioDNS EPG maps to ContentDepot <a href="/api/epg-cd-mapping.html">click here </a>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public ProgramInformationBatchFormat Format { get; set; }
		
		/// <summary>
		/// An optional human readable name for the batch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The program information to associate the ingested metadata with. This is only required if the metadata format doesn't provide the program title and air date information directly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="program")]
		public ApiV2MetapubProgram_informationBatchPostPostBodyProgram Program { get; set; }
		
		/// <summary>
		/// The URI to the metadata file. Currently only the ```cddrive``` scheme is supported.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	public class ApiV2MetapubProgram_informationBatchPostPostBodyProgram
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="airDate")]
		public string AirDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
