//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// An entity representing a user's access schedule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessSchedule
	{
		
		/// <summary>
		/// An enum that represents a day of the week, weekdays, weekends, or all days.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AccessScheduleDayOfWeek DayOfWeek { get; set; }
		
		/// <summary>
		/// Gets or sets the end hour.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public double EndHour { get; set; }
		
		/// <summary>
		/// Gets or sets the id of this instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Id { get; set; }
		
		/// <summary>
		/// Gets or sets the start hour.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public double StartHour { get; set; }
		
		/// <summary>
		/// Gets or sets the id of the associated user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AccessScheduleDayOfWeek
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sunday")]
		Sunday = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Monday")]
		Monday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Tuesday")]
		Tuesday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Wednesday")]
		Wednesday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Thursday")]
		Thursday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Friday")]
		Friday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Saturday")]
		Saturday = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Everyday")]
		Everyday = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Weekday")]
		Weekday = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Weekend")]
		Weekend = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityLogEntry
	{
		
		/// <summary>
		/// Gets or sets the date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// Gets or sets the identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// Gets or sets the item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the overview.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Overview { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<ActivityLogEntrySeverity> Severity { get; set; }
		
		/// <summary>
		/// Gets or sets the short overview.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ShortOverview { get; set; }
		
		/// <summary>
		/// Gets or sets the type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		/// <summary>
		/// Gets or sets the user identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
		
		/// <summary>
		/// Gets or sets the user primary image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserPrimaryImageTag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ActivityLogEntrySeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Trace")]
		Trace = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Debug")]
		Debug = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Information")]
		Information = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Warning")]
		Warning = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Error")]
		Error = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Critical")]
		Critical = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityLogEntryQueryResult
	{
		
		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ActivityLogEntry[] Items { get; set; }
		
		/// <summary>
		/// The index of the first record in Items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// The total number of records available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	/// <summary>
	/// Add virtual folder dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AddVirtualFolderDto
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LibraryOptions LibraryOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LibraryOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AutomaticRefreshIntervalDays { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] DisabledLocalMetadataReaders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] DisabledSubtitleFetchers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableAutomaticSeriesGrouping { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableChapterImageExtraction { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableEmbeddedEpisodeInfos { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableEmbeddedTitles { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableInternetProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnablePhotos { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableRealtimeMonitor { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ExtractChapterImagesDuringLibraryScan { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] LocalMetadataReaderOrder { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] MetadataSavers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MediaPathInfo[] PathInfos { get; set; }
		
		/// <summary>
		/// Gets or sets the preferred metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PreferredMetadataLanguage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RequirePerfectSubtitleMatch { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SaveLocalMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SaveSubtitlesWithMedia { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SeasonZeroDisplayName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SkipSubtitlesIfAudioTrackMatches { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SkipSubtitlesIfEmbeddedSubtitlesPresent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SubtitleDownloadLanguages { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SubtitleFetcherOrder { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TypeOptions[] TypeOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaPathInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NetworkPath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TypeOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ImageFetcherOrder { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ImageFetchers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ImageOption[] ImageOptions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] MetadataFetcherOrder { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] MetadataFetchers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageOption
	{
		
		/// <summary>
		/// Gets or sets the limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum width.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinWidth { get; set; }
		
		/// <summary>
		/// Enum ImageType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<ImageOptionType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImageOptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Primary")]
		Primary = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Art")]
		Art = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Backdrop")]
		Backdrop = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Banner")]
		Banner = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Logo")]
		Logo = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Thumb")]
		Thumb = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Disc")]
		Disc = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Box")]
		Box = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Screenshot")]
		Screenshot = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Menu")]
		Menu = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Chapter")]
		Chapter = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BoxRear")]
		BoxRear = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Profile")]
		Profile = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AlbumInfo
	{
		
		/// <summary>
		/// Gets or sets the album artist.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] AlbumArtists { get; set; }
		
		/// <summary>
		/// Gets or sets the artist provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ArtistProviderIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SongInfo[] SongInfos { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SongInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Album { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AlbumArtists { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Artists { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AlbumInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AlbumInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllThemeMediaResult
	{
		
		/// <summary>
		/// Class ThemeMediaResult.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ThemeMediaResult SoundtrackSongsResult { get; set; }
		
		/// <summary>
		/// Class ThemeMediaResult.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ThemeMediaResult ThemeSongsResult { get; set; }
		
		/// <summary>
		/// Class ThemeMediaResult.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ThemeMediaResult ThemeVideosResult { get; set; }
	}
	
	/// <summary>
	/// Class ThemeMediaResult.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThemeMediaResult
	{
		
		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto[] Items { get; set; }
		
		/// <summary>
		/// Gets or sets the owner id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OwnerId { get; set; }
		
		/// <summary>
		/// The index of the first record in Items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// The total number of records available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	/// <summary>
	/// This is strictly used as a data transfer object from the api layer.
	///This holds information about a BaseItem in a format that is convenient for the client.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseItemDto
	{
		
		/// <summary>
		/// Gets or sets the air days.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DayOfWeek[] AirDays { get; set; }
		
		/// <summary>
		/// Gets or sets the air time.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AirTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AirsAfterSeasonNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AirsBeforeEpisodeNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AirsBeforeSeasonNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the album.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Album { get; set; }
		
		/// <summary>
		/// Gets or sets the album artist.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AlbumArtist { get; set; }
		
		/// <summary>
		/// Gets or sets the album artists.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NameGuidPair[] AlbumArtists { get; set; }
		
		/// <summary>
		/// Gets or sets the album count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AlbumCount { get; set; }
		
		/// <summary>
		/// Gets or sets the album id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AlbumId { get; set; }
		
		/// <summary>
		/// Gets or sets the album image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AlbumPrimaryImageTag { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> Altitude { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> Aperture { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ArtistCount { get; set; }
		
		/// <summary>
		/// Gets or sets the artist items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NameGuidPair[] ArtistItems { get; set; }
		
		/// <summary>
		/// Gets or sets the artists.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Artists { get; set; }
		
		/// <summary>
		/// Gets or sets the aspect ratio.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AspectRatio { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<BaseItemDtoAudio> Audio { get; set; }
		
		/// <summary>
		/// Gets or sets the backdrop image tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] BackdropImageTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CameraMake { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CameraModel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanDelete { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanDownload { get; set; }
		
		/// <summary>
		/// Gets or sets the channel identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the channel primary image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelPrimaryImageTag { get; set; }
		
		/// <summary>
		/// Enum ChannelType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<BaseItemDtoChannelType> ChannelType { get; set; }
		
		/// <summary>
		/// Gets or sets the chapters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChapterInfo[] Chapters { get; set; }
		
		/// <summary>
		/// Gets or sets the child count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ChildCount { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the collection.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CollectionType { get; set; }
		
		/// <summary>
		/// Gets or sets the community rating.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> CommunityRating { get; set; }
		
		/// <summary>
		/// Gets or sets the completion percentage.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> CompletionPercentage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		/// <summary>
		/// Gets or sets the critic rating.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> CriticRating { get; set; }
		
		/// <summary>
		/// Gets or sets the cumulative run time ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> CumulativeRunTimeTicks { get; set; }
		
		/// <summary>
		/// This is strictly used as a data transfer object from the api layer.
		///This holds information about a BaseItem in a format that is convenient for the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto CurrentProgram { get; set; }
		
		/// <summary>
		/// Gets or sets the custom rating.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CustomRating { get; set; }
		
		/// <summary>
		/// Gets or sets the date created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateCreated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateLastMediaAdded { get; set; }
		
		/// <summary>
		/// Gets or sets the display order.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DisplayOrder { get; set; }
		
		/// <summary>
		/// Gets or sets the display preferences id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DisplayPreferencesId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableMediaSourceDisplay { get; set; }
		
		/// <summary>
		/// Gets or sets the end date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// Gets or sets the episode count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> EpisodeCount { get; set; }
		
		/// <summary>
		/// Gets or sets the episode title.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string EpisodeTitle { get; set; }
		
		/// <summary>
		/// Gets or sets the etag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Etag { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ExposureTime { get; set; }
		
		/// <summary>
		/// Gets or sets the external urls.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ExternalUrl[] ExternalUrls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExtraType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> FocalLength { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ForcedSortName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NameGuidPair[] GenreItems { get; set; }
		
		/// <summary>
		/// Gets or sets the genres.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Genres { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasSubtitles { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Gets or sets the id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the blurhashes for the image tags.
		///Maps image type to dictionary mapping image tag to blurhash value.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDtoImageBlurHashes ImageBlurHashes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<BaseItemDtoImageOrientation> ImageOrientation { get; set; }
		
		/// <summary>
		/// Gets or sets the image tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ImageTags { get; set; }
		
		/// <summary>
		/// Gets or sets the index number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the index number end.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumberEnd { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is folder.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsFolder { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is HD.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsHD { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is kids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsKids { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is live.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsLive { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is movie.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsMovie { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is news.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsNews { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is place holder.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPlaceHolder { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is premiere.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPremiere { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is repeat.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsRepeat { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is series.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsSeries { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is sports.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsSports { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IsoSpeedRating { get; set; }
		
		/// <summary>
		/// Enum IsoType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<BaseItemDtoIsoType> IsoType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> Latitude { get; set; }
		
		/// <summary>
		/// Gets or sets the local trailer count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> LocalTrailerCount { get; set; }
		
		/// <summary>
		/// Enum LocationType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<BaseItemDtoLocationType> LocationType { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [enable internet providers].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> LockData { get; set; }
		
		/// <summary>
		/// Gets or sets the locked fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MetadataField[] LockedFields { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> Longitude { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MediaSourceCount { get; set; }
		
		/// <summary>
		/// Gets or sets the media versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MediaSourceInfo[] MediaSources { get; set; }
		
		/// <summary>
		/// Gets or sets the media streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MediaStream[] MediaStreams { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the media.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MediaType { get; set; }
		
		/// <summary>
		/// Gets or sets the movie count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MovieCount { get; set; }
		
		/// <summary>
		/// Gets or sets the music video count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MusicVideoCount { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Number { get; set; }
		
		/// <summary>
		/// Gets or sets the official rating.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OfficialRating { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OriginalTitle { get; set; }
		
		/// <summary>
		/// Gets or sets the overview.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Overview { get; set; }
		
		/// <summary>
		/// Gets or sets the parent art image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentArtImageTag { get; set; }
		
		/// <summary>
		/// If the item does not have a art, this will hold the Id of the Parent that has one.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentArtItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the parent backdrop image tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ParentBackdropImageTags { get; set; }
		
		/// <summary>
		/// If the item does not have any backdrops, this will hold the Id of the Parent that has one.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentBackdropItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the parent id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentId { get; set; }
		
		/// <summary>
		/// Gets or sets the parent index number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the parent logo image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentLogoImageTag { get; set; }
		
		/// <summary>
		/// If the item does not have a logo, this will hold the Id of the Parent that has one.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentLogoItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the parent primary image item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentPrimaryImageItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the parent primary image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentPrimaryImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the parent thumb image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentThumbImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the parent thumb item id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentThumbItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the part count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PartCount { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		/// <summary>
		/// Gets or sets the people.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemPerson[] People { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<BaseItemDtoPlayAccess> PlayAccess { get; set; }
		
		/// <summary>
		/// Gets or sets the playlist item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PreferredMetadataCountryCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PreferredMetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the premiere date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the primary image aspect ratio, after image enhancements.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> PrimaryImageAspectRatio { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ProductionLocations { get; set; }
		
		/// <summary>
		/// Gets or sets the production year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProductionYear { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProgramCount { get; set; }
		
		/// <summary>
		/// Gets or sets the program identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProgramId { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		/// <summary>
		/// Gets or sets the recursive item count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> RecursiveItemCount { get; set; }
		
		/// <summary>
		/// Gets or sets the trailer urls.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MediaUrl[] RemoteTrailers { get; set; }
		
		/// <summary>
		/// Gets or sets the run time ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> RunTimeTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the screenshot image tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ScreenshotImageTags { get; set; }
		
		/// <summary>
		/// Gets or sets the season identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeasonId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the season.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeasonName { get; set; }
		
		/// <summary>
		/// Gets or sets the series count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SeriesCount { get; set; }
		
		/// <summary>
		/// Gets or sets the series id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeriesId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the series.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeriesName { get; set; }
		
		/// <summary>
		/// Gets or sets the series primary image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeriesPrimaryImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the series studio.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeriesStudio { get; set; }
		
		/// <summary>
		/// Gets or sets the series thumb image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeriesThumbImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the series timer identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeriesTimerId { get; set; }
		
		/// <summary>
		/// Gets or sets the server identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ShutterSpeed { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Software { get; set; }
		
		/// <summary>
		/// Gets or sets the song count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SongCount { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the sort.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SortName { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SourceType { get; set; }
		
		/// <summary>
		/// Gets or sets the special feature count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SpecialFeatureCount { get; set; }
		
		/// <summary>
		/// The start date of the recording, in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
		
		/// <summary>
		/// Gets or sets the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Status { get; set; }
		
		/// <summary>
		/// Gets or sets the studios.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NameGuidPair[] Studios { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [supports synchronize].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsSync { get; set; }
		
		/// <summary>
		/// Gets or sets the taglines.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Taglines { get; set; }
		
		/// <summary>
		/// Gets or sets the tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Gets or sets the timer identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TimerId { get; set; }
		
		/// <summary>
		/// Gets or sets the trailer count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TrailerCount { get; set; }
		
		/// <summary>
		/// Gets or sets the type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		/// <summary>
		/// Class UserItemDataDto.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserItemDataDto UserData { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MediaSourceInfoVideo3DFormat Video3DFormat { get; set; }
		
		/// <summary>
		/// Enum VideoType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MediaSourceInfoVideoType VideoType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DayOfWeek
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sunday")]
		Sunday = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Monday")]
		Monday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Tuesday")]
		Tuesday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Wednesday")]
		Wednesday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Thursday")]
		Thursday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Friday")]
		Friday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Saturday")]
		Saturday = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NameGuidPair
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BaseItemDtoAudio
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Mono")]
		Mono = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Stereo")]
		Stereo = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Dolby")]
		Dolby = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DolbyDigital")]
		DolbyDigital = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Thx")]
		Thx = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Atmos")]
		Atmos = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BaseItemDtoChannelType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TV")]
		TV = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Radio")]
		Radio = 1,
	}
	
	/// <summary>
	/// Class ChapterInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChapterInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ImageDateModified { get; set; }
		
		/// <summary>
		/// Gets or sets the image path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ImagePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the start position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> StartPositionTicks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExternalUrl
	{
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	public class BaseItemDtoImageBlurHashes
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Art { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Backdrop { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Banner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Box { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> BoxRear { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Chapter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Disc { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Logo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Menu { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Primary { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Profile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Screenshot { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Thumb { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BaseItemDtoImageOrientation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TopLeft")]
		TopLeft = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TopRight")]
		TopRight = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BottomRight")]
		BottomRight = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BottomLeft")]
		BottomLeft = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LeftTop")]
		LeftTop = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RightTop")]
		RightTop = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RightBottom")]
		RightBottom = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LeftBottom")]
		LeftBottom = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BaseItemDtoIsoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Dvd")]
		Dvd = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BluRay")]
		BluRay = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BaseItemDtoLocationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FileSystem")]
		FileSystem = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Remote")]
		Remote = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Virtual")]
		Virtual = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Offline")]
		Offline = 3,
	}
	
	/// <summary>
	/// Enum MetadataFields.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MetadataField
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cast")]
		Cast = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Genres")]
		Genres = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ProductionLocations")]
		ProductionLocations = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Studios")]
		Studios = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Tags")]
		Tags = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Name")]
		Name = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Overview")]
		Overview = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Runtime")]
		Runtime = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OfficialRating")]
		OfficialRating = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaSourceInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AnalyzeDurationMs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Bitrate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BufferMs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DefaultAudioStreamIndex { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DefaultSubtitleStreamIndex { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ETag { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EncoderPath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<MediaSourceInfoEncoderProtocol> EncoderProtocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Formats { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> GenPtsInput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IgnoreDts { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IgnoreIndex { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsInfiniteStream { get; set; }
		
		/// <summary>
		/// Differentiate internet url vs local network.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsRemote { get; set; }
		
		/// <summary>
		/// Enum IsoType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDtoIsoType IsoType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveStreamId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MediaAttachment[] MediaAttachments { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MediaStream[] MediaStreams { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OpenToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MediaSourceInfoEncoderProtocol Protocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ReadAtNativeFramerate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> RequiredHttpHeaders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RequiresClosing { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RequiresLooping { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RequiresOpening { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> RunTimeTicks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsDirectPlay { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsDirectStream { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsProbing { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsTranscoding { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<MediaSourceInfoTimestamp> Timestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TranscodingContainer { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TranscodingSubProtocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TranscodingUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<MediaSourceInfoType> Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<MediaSourceInfoVideo3DFormat> Video3DFormat { get; set; }
		
		/// <summary>
		/// Enum VideoType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<MediaSourceInfoVideoType> VideoType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaSourceInfoEncoderProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="File")]
		File = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Http")]
		Http = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Rtmp")]
		Rtmp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Rtsp")]
		Rtsp = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Udp")]
		Udp = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Rtp")]
		Rtp = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Ftp")]
		Ftp = 6,
	}
	
	/// <summary>
	/// Class MediaAttachment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaAttachment
	{
		
		/// <summary>
		/// Gets or sets the codec.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Codec { get; set; }
		
		/// <summary>
		/// Gets or sets the codec tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CodecTag { get; set; }
		
		/// <summary>
		/// Gets or sets the comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		/// <summary>
		/// Gets or sets the delivery URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeliveryUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the filename.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string FileName { get; set; }
		
		/// <summary>
		/// Gets or sets the index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Index { get; set; }
		
		/// <summary>
		/// Gets or sets the MIME type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MimeType { get; set; }
	}
	
	/// <summary>
	/// Class MediaStream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaStream
	{
		
		/// <summary>
		/// Gets or sets the aspect ratio.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AspectRatio { get; set; }
		
		/// <summary>
		/// Gets or sets the average frame rate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> AverageFrameRate { get; set; }
		
		/// <summary>
		/// Gets or sets the bit depth.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BitDepth { get; set; }
		
		/// <summary>
		/// Gets or sets the bit rate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BitRate { get; set; }
		
		/// <summary>
		/// Gets or sets the channel layout.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelLayout { get; set; }
		
		/// <summary>
		/// Gets or sets the channels.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Channels { get; set; }
		
		/// <summary>
		/// Gets or sets the codec.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Codec { get; set; }
		
		/// <summary>
		/// Gets or sets the codec tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CodecTag { get; set; }
		
		/// <summary>
		/// Gets or sets the codec time base.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CodecTimeBase { get; set; }
		
		/// <summary>
		/// Gets or sets the color primaries.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ColorPrimaries { get; set; }
		
		/// <summary>
		/// Gets or sets the color range.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ColorRange { get; set; }
		
		/// <summary>
		/// Gets or sets the color space.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ColorSpace { get; set; }
		
		/// <summary>
		/// Gets or sets the color transfer.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ColorTransfer { get; set; }
		
		/// <summary>
		/// Gets or sets the comment.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<MediaStreamDeliveryMethod> DeliveryMethod { get; set; }
		
		/// <summary>
		/// Gets or sets the delivery URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeliveryUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DisplayTitle { get; set; }
		
		/// <summary>
		/// Gets or sets the height.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Gets or sets the index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Index { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAVC { get; set; }
		
		/// <summary>
		/// Gets a value indicating whether this instance is anamorphic.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAnamorphic { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is default.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsDefault { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is external.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsExternal { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is external URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsExternalUrl { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is forced.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsForced { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is interlaced.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsInterlaced { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsTextSubtitleStream { get; set; }
		
		/// <summary>
		/// Gets or sets the language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Language { get; set; }
		
		/// <summary>
		/// Gets or sets the level.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> Level { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NalLengthSize { get; set; }
		
		/// <summary>
		/// Gets or sets the length of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PacketLength { get; set; }
		
		/// <summary>
		/// Gets or sets the filename.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		/// <summary>
		/// Gets or sets the pixel format.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PixelFormat { get; set; }
		
		/// <summary>
		/// Gets or sets the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Profile { get; set; }
		
		/// <summary>
		/// Gets or sets the real frame rate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> RealFrameRate { get; set; }
		
		/// <summary>
		/// Gets or sets the reference frames.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> RefFrames { get; set; }
		
		/// <summary>
		/// Gets or sets the sample rate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SampleRate { get; set; }
		
		/// <summary>
		/// Gets or sets the score.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Score { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [supports external stream].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsExternalStream { get; set; }
		
		/// <summary>
		/// Gets or sets the time base.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TimeBase { get; set; }
		
		/// <summary>
		/// Gets or sets the title.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Title { get; set; }
		
		/// <summary>
		/// Enum MediaStreamType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<MediaStreamType> Type { get; set; }
		
		/// <summary>
		/// Gets or sets the video range.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VideoRange { get; set; }
		
		/// <summary>
		/// Gets or sets the width.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Width { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="localizedDefault")]
		public string LocalizedDefault { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="localizedForced")]
		public string LocalizedForced { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="localizedUndefined")]
		public string LocalizedUndefined { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaStreamDeliveryMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Encode")]
		Encode = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Embed")]
		Embed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="External")]
		External = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Hls")]
		Hls = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaStreamType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Audio")]
		Audio = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Video")]
		Video = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Subtitle")]
		Subtitle = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EmbeddedImage")]
		EmbeddedImage = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaSourceInfoTimestamp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Zero")]
		Zero = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Valid")]
		Valid = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaSourceInfoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Default")]
		Default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Grouping")]
		Grouping = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Placeholder")]
		Placeholder = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaSourceInfoVideo3DFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HalfSideBySide")]
		HalfSideBySide = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FullSideBySide")]
		FullSideBySide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FullTopAndBottom")]
		FullTopAndBottom = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HalfTopAndBottom")]
		HalfTopAndBottom = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MVC")]
		MVC = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaSourceInfoVideoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoFile")]
		VideoFile = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Iso")]
		Iso = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Dvd")]
		Dvd = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BluRay")]
		BluRay = 3,
	}
	
	/// <summary>
	/// This is used by the api to get information about a Person within a BaseItem.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseItemPerson
	{
		
		/// <summary>
		/// Gets or sets the identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the primary image blurhash.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemPersonImageBlurHashes ImageBlurHashes { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the primary image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PrimaryImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the role.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		/// <summary>
		/// Gets or sets the type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	public class BaseItemPersonImageBlurHashes
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Art { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Backdrop { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Banner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Box { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> BoxRear { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Chapter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Disc { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Logo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Menu { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Primary { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Profile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Screenshot { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Thumb { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BaseItemDtoPlayAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Full")]
		Full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaUrl
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Class UserItemDataDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserItemDataDto
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is favorite.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsFavorite { get; set; }
		
		/// <summary>
		/// Gets or sets the item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Gets or sets the last played date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastPlayedDate { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is likes.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Likes { get; set; }
		
		/// <summary>
		/// Gets or sets the play count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PlayCount { get; set; }
		
		/// <summary>
		/// Gets or sets the playback position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PlaybackPositionTicks { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Played { get; set; }
		
		/// <summary>
		/// Gets or sets the played percentage.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> PlayedPercentage { get; set; }
		
		/// <summary>
		/// Gets or sets the rating.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> Rating { get; set; }
		
		/// <summary>
		/// Gets or sets the unplayed item count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UnplayedItemCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Architecture
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="X86")]
		X86 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="X64")]
		X64 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Arm")]
		Arm = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Arm64")]
		Arm64 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Wasm")]
		Wasm = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArtistInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SongInfo[] SongInfos { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArtistInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ArtistInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	/// <summary>
	/// The authenticate user by name request body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthenticateUserByName
	{
		
		/// <summary>
		/// Gets or sets the sha1-hashed password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
		
		/// <summary>
		/// Gets or sets the plain text password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Pw { get; set; }
		
		/// <summary>
		/// Gets or sets the username.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthenticationInfo
	{
		
		/// <summary>
		/// Gets or sets the access token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AccessToken { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AppName { get; set; }
		
		/// <summary>
		/// Gets or sets the application version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AppVersion { get; set; }
		
		/// <summary>
		/// Gets or sets the date created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateCreated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateLastActivity { get; set; }
		
		/// <summary>
		/// Gets or sets the date revoked.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateRevoked { get; set; }
		
		/// <summary>
		/// Gets or sets the device identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeviceName { get; set; }
		
		/// <summary>
		/// Gets or sets the identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is active.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsActive { get; set; }
		
		/// <summary>
		/// Gets or sets the user identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthenticationInfoQueryResult
	{
		
		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AuthenticationInfo[] Items { get; set; }
		
		/// <summary>
		/// The index of the first record in Items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// The total number of records available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthenticationResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AccessToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Class SessionInfo.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SessionInfo SessionInfo { get; set; }
		
		/// <summary>
		/// Class UserDto.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserDto User { get; set; }
	}
	
	/// <summary>
	/// Class SessionInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SessionInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SessionUserInfo[] AdditionalUsers { get; set; }
		
		/// <summary>
		/// Gets or sets the application version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ApplicationVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClientCapabilities Capabilities { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Client { get; set; }
		
		/// <summary>
		/// Gets or sets the device id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeviceName { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DeviceType { get; set; }
		
		/// <summary>
		/// Class BaseItem.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItem FullNowPlayingItem { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasCustomDeviceName { get; set; }
		
		/// <summary>
		/// Gets or sets the id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets a value indicating whether this instance is active.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsActive { get; set; }
		
		/// <summary>
		/// Gets or sets the last activity date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastActivityDate { get; set; }
		
		/// <summary>
		/// Gets or sets the last playback check in.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastPlaybackCheckIn { get; set; }
		
		/// <summary>
		/// This is strictly used as a data transfer object from the api layer.
		///This holds information about a BaseItem in a format that is convenient for the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto NowPlayingItem { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public QueueItem[] NowPlayingQueue { get; set; }
		
		/// <summary>
		/// This is strictly used as a data transfer object from the api layer.
		///This holds information about a BaseItem in a format that is convenient for the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto NowViewingItem { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PlayerStateInfo PlayState { get; set; }
		
		/// <summary>
		/// Gets or sets the playable media types.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] PlayableMediaTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the remote end point.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string RemoteEndPoint { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Gets or sets the supported commands.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GeneralCommandType[] SupportedCommands { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsMediaControl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsRemoteControl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TranscodingInfo TranscodingInfo { get; set; }
		
		/// <summary>
		/// Gets or sets the user id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
		
		/// <summary>
		/// Gets or sets the username.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserPrimaryImageTag { get; set; }
	}
	
	/// <summary>
	/// Class SessionUserInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SessionUserInfo
	{
		
		/// <summary>
		/// Gets or sets the user identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClientCapabilities
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AppStoreUrl { get; set; }
		
		/// <summary>
		/// Defines the MediaBrowser.Model.Dlna.DeviceProfile.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeviceProfile DeviceProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IconUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageCallbackUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] PlayableMediaTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GeneralCommandType[] SupportedCommands { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsContentUploading { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsMediaControl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsPersistentIdentifier { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsSync { get; set; }
	}
	
	/// <summary>
	/// Defines the MediaBrowser.Model.Dlna.DeviceProfile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeviceProfile
	{
		
		/// <summary>
		/// Gets or sets the AlbumArtPn.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AlbumArtPn { get; set; }
		
		/// <summary>
		/// Gets or sets the CodecProfiles.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CodecProfile[] CodecProfiles { get; set; }
		
		/// <summary>
		/// Gets or sets the ContainerProfiles.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ContainerProfile[] ContainerProfiles { get; set; }
		
		/// <summary>
		/// Gets or sets the direct play profiles.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DirectPlayProfile[] DirectPlayProfiles { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether EnableAlbumArtInDidl.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableAlbumArtInDidl { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether EnableMSMediaReceiverRegistrar.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableMSMediaReceiverRegistrar { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether EnableSingleAlbumArtLimit.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSingleAlbumArtLimit { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether EnableSingleSubtitleLimit.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSingleSubtitleLimit { get; set; }
		
		/// <summary>
		/// Gets or sets the FriendlyName.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string FriendlyName { get; set; }
		
		/// <summary>
		/// Gets or sets the Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeviceIdentification Identification { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether IgnoreTranscodeByteRangeRequests.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IgnoreTranscodeByteRangeRequests { get; set; }
		
		/// <summary>
		/// Gets or sets the Manufacturer.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Manufacturer { get; set; }
		
		/// <summary>
		/// Gets or sets the ManufacturerUrl.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ManufacturerUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the MaxAlbumArtHeight.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxAlbumArtHeight { get; set; }
		
		/// <summary>
		/// Gets or sets the MaxAlbumArtWidth.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxAlbumArtWidth { get; set; }
		
		/// <summary>
		/// Gets or sets the MaxIconHeight.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxIconHeight { get; set; }
		
		/// <summary>
		/// Gets or sets the MaxIconWidth.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxIconWidth { get; set; }
		
		/// <summary>
		/// Gets or sets the MaxStaticBitrate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxStaticBitrate { get; set; }
		
		/// <summary>
		/// Gets or sets the MaxStaticMusicBitrate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxStaticMusicBitrate { get; set; }
		
		/// <summary>
		/// Gets or sets the MaxStreamingBitrate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxStreamingBitrate { get; set; }
		
		/// <summary>
		/// Gets or sets the ModelDescription.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ModelDescription { get; set; }
		
		/// <summary>
		/// Gets or sets the ModelName.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ModelName { get; set; }
		
		/// <summary>
		/// Gets or sets the ModelNumber.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ModelNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the ModelUrl.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ModelUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the MusicStreamingTranscodingBitrate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MusicStreamingTranscodingBitrate { get; set; }
		
		/// <summary>
		/// Gets or sets the Name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the ProtocolInfo.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProtocolInfo { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether RequiresPlainFolders.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RequiresPlainFolders { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether RequiresPlainVideoItems.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RequiresPlainVideoItems { get; set; }
		
		/// <summary>
		/// Gets or sets the ResponseProfiles.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ResponseProfile[] ResponseProfiles { get; set; }
		
		/// <summary>
		/// Gets or sets the SerialNumber.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SerialNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the content of the aggregationFlags element in the urn:schemas-sonycom:av namespace.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SonyAggregationFlags { get; set; }
		
		/// <summary>
		/// Gets or sets the SubtitleProfiles.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SubtitleProfile[] SubtitleProfiles { get; set; }
		
		/// <summary>
		/// Gets or sets the SupportedMediaTypes.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SupportedMediaTypes { get; set; }
		
		/// <summary>
		/// Gets or sets the TimelineOffsetSeconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TimelineOffsetSeconds { get; set; }
		
		/// <summary>
		/// Gets or sets the transcoding profiles.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TranscodingProfile[] TranscodingProfiles { get; set; }
		
		/// <summary>
		/// Gets or sets the UserId.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
		
		/// <summary>
		/// Gets or sets the XmlRootAttributes.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public XmlAttribute[] XmlRootAttributes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CodecProfile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ProfileCondition[] ApplyConditions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Codec { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProfileCondition[] Conditions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<CodecProfileType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProfileCondition
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<ProfileConditionCondition> Condition { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsRequired { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<ProfileConditionProperty> Property { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ProfileConditionCondition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Equals")]
		Equals = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotEquals")]
		NotEquals = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LessThanEqual")]
		LessThanEqual = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GreaterThanEqual")]
		GreaterThanEqual = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EqualsAny")]
		EqualsAny = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ProfileConditionProperty
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioChannels")]
		AudioChannels = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioBitrate")]
		AudioBitrate = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioProfile")]
		AudioProfile = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Width")]
		Width = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Height")]
		Height = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Has64BitOffsets")]
		Has64BitOffsets = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PacketLength")]
		PacketLength = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoBitDepth")]
		VideoBitDepth = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoBitrate")]
		VideoBitrate = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoFramerate")]
		VideoFramerate = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoLevel")]
		VideoLevel = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoProfile")]
		VideoProfile = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoTimestamp")]
		VideoTimestamp = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsAnamorphic")]
		IsAnamorphic = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RefFrames")]
		RefFrames = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NumAudioStreams")]
		NumAudioStreams = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NumVideoStreams")]
		NumVideoStreams = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsSecondaryAudio")]
		IsSecondaryAudio = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoCodecTag")]
		VideoCodecTag = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsAvc")]
		IsAvc = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsInterlaced")]
		IsInterlaced = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioSampleRate")]
		AudioSampleRate = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioBitDepth")]
		AudioBitDepth = 22,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CodecProfileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Video")]
		Video = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoAudio")]
		VideoAudio = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Audio")]
		Audio = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContainerProfile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ProfileCondition[] Conditions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<ContainerProfileType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ContainerProfileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Audio")]
		Audio = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Video")]
		Video = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Photo")]
		Photo = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DirectPlayProfile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AudioCodec { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ContainerProfileType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VideoCodec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeviceIdentification
	{
		
		/// <summary>
		/// Gets or sets the name of the friendly.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string FriendlyName { get; set; }
		
		/// <summary>
		/// Gets or sets the headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public HttpHeaderInfo[] Headers { get; set; }
		
		/// <summary>
		/// Gets or sets the manufacturer.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Manufacturer { get; set; }
		
		/// <summary>
		/// Gets or sets the manufacturer URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ManufacturerUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the model description.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ModelDescription { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the model.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ModelName { get; set; }
		
		/// <summary>
		/// Gets or sets the model number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ModelNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the model URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ModelUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the serial number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SerialNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpHeaderInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<HttpHeaderInfoMatch> Match { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum HttpHeaderInfoMatch
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Equals")]
		Equals = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Regex")]
		Regex = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Substring")]
		Substring = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResponseProfile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AudioCodec { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProfileCondition[] Conditions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MimeType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OrgPn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ContainerProfileType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VideoCodec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubtitleProfile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DidlMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Format { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MediaStreamDeliveryMethod Method { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TranscodingProfile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AudioCodec { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> BreakOnNonKeyFrames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<TranscodingProfileContext> Context { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CopyTimestamps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableMpegtsM2TsMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSubtitlesInManifest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EstimateContentLength { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MaxAudioChannels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinSegments { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Protocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SegmentLength { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<TranscodingProfileTranscodeSeekInfo> TranscodeSeekInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ContainerProfileType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VideoCodec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TranscodingProfileContext
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Streaming")]
		Streaming = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Static")]
		Static = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TranscodingProfileTranscodeSeekInfo
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Auto")]
		Auto = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Bytes")]
		Bytes = 1,
	}
	
	/// <summary>
	/// Defines the MediaBrowser.Model.Dlna.XmlAttribute.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class XmlAttribute
	{
		
		/// <summary>
		/// Gets or sets the name of the attribute.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the value of the attribute.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// This exists simply to identify a set of known commands.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GeneralCommandType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MoveUp")]
		MoveUp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MoveDown")]
		MoveDown = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MoveLeft")]
		MoveLeft = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MoveRight")]
		MoveRight = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PageUp")]
		PageUp = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PageDown")]
		PageDown = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PreviousLetter")]
		PreviousLetter = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NextLetter")]
		NextLetter = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ToggleOsd")]
		ToggleOsd = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ToggleContextMenu")]
		ToggleContextMenu = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Select")]
		Select = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Back")]
		Back = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TakeScreenshot")]
		TakeScreenshot = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SendKey")]
		SendKey = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SendString")]
		SendString = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GoHome")]
		GoHome = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GoToSettings")]
		GoToSettings = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VolumeUp")]
		VolumeUp = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VolumeDown")]
		VolumeDown = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Mute")]
		Mute = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unmute")]
		Unmute = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ToggleMute")]
		ToggleMute = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SetVolume")]
		SetVolume = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SetAudioStreamIndex")]
		SetAudioStreamIndex = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SetSubtitleStreamIndex")]
		SetSubtitleStreamIndex = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ToggleFullscreen")]
		ToggleFullscreen = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DisplayContent")]
		DisplayContent = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GoToSearch")]
		GoToSearch = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DisplayMessage")]
		DisplayMessage = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SetRepeatMode")]
		SetRepeatMode = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ChannelUp")]
		ChannelUp = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ChannelDown")]
		ChannelDown = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Guide")]
		Guide = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ToggleStats")]
		ToggleStats = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayMediaSource")]
		PlayMediaSource = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayTrailers")]
		PlayTrailers = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SetShuffleQueue")]
		SetShuffleQueue = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayState")]
		PlayState = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayNext")]
		PlayNext = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ToggleOsdMenu")]
		ToggleOsdMenu = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Play")]
		Play = 40,
	}
	
	/// <summary>
	/// Class BaseItem.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseItem
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateLastSaved { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ExtraIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Height { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsHD { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsShortcut { get; set; }
		
		/// <summary>
		/// Gets or sets the remote trailers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MediaUrl[] RemoteTrailers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ShortcutPath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsExternalTransfer { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueueItem
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerStateInfo
	{
		
		/// <summary>
		/// Gets or sets the index of the now playing audio stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AudioStreamIndex { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance can seek.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanSeek { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is muted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsMuted { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is paused.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPaused { get; set; }
		
		/// <summary>
		/// Gets or sets the now playing media version identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MediaSourceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<PlayerStateInfoPlayMethod> PlayMethod { get; set; }
		
		/// <summary>
		/// Gets or sets the now playing position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PositionTicks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<PlayerStateInfoRepeatMode> RepeatMode { get; set; }
		
		/// <summary>
		/// Gets or sets the index of the now playing subtitle stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SubtitleStreamIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the volume level.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VolumeLevel { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PlayerStateInfoPlayMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Transcode")]
		Transcode = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DirectStream")]
		DirectStream = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DirectPlay")]
		DirectPlay = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PlayerStateInfoRepeatMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatNone")]
		RepeatNone = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatAll")]
		RepeatAll = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatOne")]
		RepeatOne = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TranscodingInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AudioChannels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AudioCodec { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Bitrate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> CompletionPercentage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Container { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> Framerate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Height { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAudioDirect { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsVideoDirect { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TranscodeReason[] TranscodeReasons { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VideoCodec { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TranscodeReason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ContainerNotSupported")]
		ContainerNotSupported = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoCodecNotSupported")]
		VideoCodecNotSupported = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioCodecNotSupported")]
		AudioCodecNotSupported = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ContainerBitrateExceedsLimit")]
		ContainerBitrateExceedsLimit = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioBitrateNotSupported")]
		AudioBitrateNotSupported = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioChannelsNotSupported")]
		AudioChannelsNotSupported = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoResolutionNotSupported")]
		VideoResolutionNotSupported = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UnknownVideoStreamInfo")]
		UnknownVideoStreamInfo = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UnknownAudioStreamInfo")]
		UnknownAudioStreamInfo = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioProfileNotSupported")]
		AudioProfileNotSupported = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioSampleRateNotSupported")]
		AudioSampleRateNotSupported = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AnamorphicVideoNotSupported")]
		AnamorphicVideoNotSupported = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="InterlacedVideoNotSupported")]
		InterlacedVideoNotSupported = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SecondaryAudioNotSupported")]
		SecondaryAudioNotSupported = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RefFramesNotSupported")]
		RefFramesNotSupported = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoBitDepthNotSupported")]
		VideoBitDepthNotSupported = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoBitrateNotSupported")]
		VideoBitrateNotSupported = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoFramerateNotSupported")]
		VideoFramerateNotSupported = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoLevelNotSupported")]
		VideoLevelNotSupported = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoProfileNotSupported")]
		VideoProfileNotSupported = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioBitDepthNotSupported")]
		AudioBitDepthNotSupported = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SubtitleCodecNotSupported")]
		SubtitleCodecNotSupported = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DirectPlayError")]
		DirectPlayError = 22,
	}
	
	/// <summary>
	/// Class UserDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserDto
	{
		
		/// <summary>
		/// Class UserConfiguration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserConfiguration Configuration { get; set; }
		
		/// <summary>
		/// Gets or sets whether async login is enabled or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableAutoLogin { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance has configured easy password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasConfiguredEasyPassword { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance has configured password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasConfiguredPassword { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance has password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasPassword { get; set; }
		
		/// <summary>
		/// Gets or sets the id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the last activity date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastActivityDate { get; set; }
		
		/// <summary>
		/// Gets or sets the last login date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastLoginDate { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserPolicy Policy { get; set; }
		
		/// <summary>
		/// Gets or sets the primary image aspect ratio.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> PrimaryImageAspectRatio { get; set; }
		
		/// <summary>
		/// Gets or sets the primary image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PrimaryImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the server identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the server.
		///This is not used by the server and is for client-side usage only.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServerName { get; set; }
	}
	
	/// <summary>
	/// Class UserConfiguration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserConfiguration
	{
		
		/// <summary>
		/// Gets or sets the audio language preference.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AudioLanguagePreference { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DisplayCollectionsView { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DisplayMissingEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableLocalPassword { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableNextEpisodeAutoPlay { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] GroupedFolders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HidePlayedInLatest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] LatestItemsExcludes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] MyMediaExcludes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] OrderedViews { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [play default audio track].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> PlayDefaultAudioTrack { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RememberAudioSelections { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RememberSubtitleSelections { get; set; }
		
		/// <summary>
		/// Gets or sets the subtitle language preference.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SubtitleLanguagePreference { get; set; }
		
		/// <summary>
		/// An enum representing a subtitle playback mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<UserConfigurationSubtitleMode> SubtitleMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum UserConfigurationSubtitleMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Default")]
		Default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Always")]
		Always = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OnlyForced")]
		OnlyForced = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Smart")]
		Smart = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserPolicy
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessSchedule[] AccessSchedules { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AuthenticationProviderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UnratedItem[] BlockUnratedItems { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] BlockedChannels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] BlockedMediaFolders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] BlockedTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableAllChannels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableAllDevices { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableAllFolders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableAudioPlaybackTranscoding { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableContentDeletion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] EnableContentDeletionFromFolders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableContentDownloading { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableLiveTvAccess { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableLiveTvManagement { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableMediaConversion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableMediaPlayback { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnablePlaybackRemuxing { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnablePublicSharing { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableRemoteAccess { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableRemoteControlOfOtherUsers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSharedDeviceControl { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [enable synchronize].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSyncTranscoding { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableUserPreferenceAccess { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableVideoPlaybackTranscoding { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] EnabledChannels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] EnabledDevices { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] EnabledFolders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ForceRemoteSourceTranscoding { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> InvalidLoginAttemptCount { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is administrator.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAdministrator { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsDisabled { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is hidden.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsHidden { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> LoginAttemptsBeforeLockout { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxActiveSessions { get; set; }
		
		/// <summary>
		/// Gets or sets the max parental rating.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxParentalRating { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PasswordResetProviderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> RemoteClientBitrateLimit { get; set; }
		
		/// <summary>
		/// Enum SyncPlayUserAccessType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<UserPolicySyncPlayAccess> SyncPlayAccess { get; set; }
	}
	
	/// <summary>
	/// An enum representing an unrated item.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum UnratedItem
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Movie")]
		Movie = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Trailer")]
		Trailer = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Series")]
		Series = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Music")]
		Music = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Book")]
		Book = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LiveTvChannel")]
		LiveTvChannel = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LiveTvProgram")]
		LiveTvProgram = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ChannelContent")]
		ChannelContent = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Other")]
		Other = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum UserPolicySyncPlayAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CreateAndJoinGroups")]
		CreateAndJoinGroups = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="JoinGroups")]
		JoinGroups = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseItemDtoQueryResult
	{
		
		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto[] Items { get; set; }
		
		/// <summary>
		/// The index of the first record in Items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// The total number of records available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	/// <summary>
	/// Class BasePluginConfiguration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BasePluginConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BookInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SeriesName { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BookInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BookInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BoxSetInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BoxSetInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BoxSetInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BrandingOptions
	{
		
		/// <summary>
		/// Gets or sets the custom CSS.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CustomCss { get; set; }
		
		/// <summary>
		/// Gets or sets the login disclaimer.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LoginDisclaimer { get; set; }
	}
	
	/// <summary>
	/// Class BufferRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BufferRequestDto
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether the client playback is unpaused.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPlaying { get; set; }
		
		/// <summary>
		/// Gets or sets the playlist item identifier of the playing item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PositionTicks { get; set; }
		
		/// <summary>
		/// Gets or sets when the request has been made by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> When { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelFeatures
	{
		
		/// <summary>
		/// Gets or sets the automatic refresh levels.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AutoRefreshLevels { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance can filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanFilter { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance can search.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanSearch { get; set; }
		
		/// <summary>
		/// Gets or sets the content types.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChannelMediaContentType[] ContentTypes { get; set; }
		
		/// <summary>
		/// Gets or sets the default sort orders.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChannelItemSortField[] DefaultSortFields { get; set; }
		
		/// <summary>
		/// Gets or sets the identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Represents the maximum number of records the channel allows retrieving at a time.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxPageSize { get; set; }
		
		/// <summary>
		/// Gets or sets the media types.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChannelMediaType[] MediaTypes { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [supports content downloading].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsContentDownloading { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [supports latest media].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsLatestMedia { get; set; }
		
		/// <summary>
		/// Indicates if a sort ascending/descending toggle is supported or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsSortOrderToggle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelMediaContentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Clip")]
		Clip = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Podcast")]
		Podcast = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Trailer")]
		Trailer = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Movie")]
		Movie = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Episode")]
		Episode = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Song")]
		Song = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MovieExtra")]
		MovieExtra = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TvExtra")]
		TvExtra = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelItemSortField
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Name")]
		Name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CommunityRating")]
		CommunityRating = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PremiereDate")]
		PremiereDate = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DateCreated")]
		DateCreated = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Runtime")]
		Runtime = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayCount")]
		PlayCount = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CommunityPlayCount")]
		CommunityPlayCount = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelMediaType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Audio")]
		Audio = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Video")]
		Video = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Photo")]
		Photo = 2,
	}
	
	/// <summary>
	/// Channel mapping options dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMappingOptionsDto
	{
		
		/// <summary>
		/// Gets or sets list of mappings.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NameValuePair[] Mappings { get; set; }
		
		/// <summary>
		/// Gets or sets list of provider channels.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NameIdPair[] ProviderChannels { get; set; }
		
		/// <summary>
		/// Gets or sets provider name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProviderName { get; set; }
		
		/// <summary>
		/// Gets or sets list of tuner channels.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TunerChannelMapping[] TunerChannels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NameValuePair
	{
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the value.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NameIdPair
	{
		
		/// <summary>
		/// Gets or sets the identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TunerChannelMapping
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProviderChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProviderChannelName { get; set; }
	}
	
	/// <summary>
	/// Enum ChannelType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TV")]
		TV = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Radio")]
		Radio = 1,
	}
	
	/// <summary>
	/// Client capabilities dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClientCapabilitiesDto
	{
		
		/// <summary>
		/// Gets or sets the app store url.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AppStoreUrl { get; set; }
		
		/// <summary>
		/// Defines the MediaBrowser.Model.Dlna.DeviceProfile.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeviceProfile DeviceProfile { get; set; }
		
		/// <summary>
		/// Gets or sets the icon url.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IconUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the message callback url.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MessageCallbackUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the list of playable media types.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] PlayableMediaTypes { get; set; }
		
		/// <summary>
		/// Gets or sets the list of supported commands.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GeneralCommandType[] SupportedCommands { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether session supports content uploading.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsContentUploading { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether session supports media control.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsMediaControl { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether session supports a persistent identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsPersistentIdentifier { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether session supports sync.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsSync { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CodecType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Video")]
		Video = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoAudio")]
		VideoAudio = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Audio")]
		Audio = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CollectionCreationResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// The configuration page info.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationPageInfo
	{
		
		/// <summary>
		/// Enum ConfigurationPageType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<ConfigurationPageInfoConfigurationPageType> ConfigurationPageType { get; set; }
		
		/// <summary>
		/// Gets or sets the display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether the configurations page is enabled in the main menu.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableInMainMenu { get; set; }
		
		/// <summary>
		/// Gets or sets the menu icon.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MenuIcon { get; set; }
		
		/// <summary>
		/// Gets or sets the menu section.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MenuSection { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the plugin id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PluginId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ConfigurationPageInfoConfigurationPageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PluginConfiguration")]
		PluginConfiguration = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 1,
	}
	
	/// <summary>
	/// Enum ConfigurationPageType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ConfigurationPageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PluginConfiguration")]
		PluginConfiguration = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ControlResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsSuccessful { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Xml { get; set; }
	}
	
	/// <summary>
	/// Class CountryInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CountryInfo
	{
		
		/// <summary>
		/// Gets or sets the display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the three letter ISO region.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ThreeLetterISORegionName { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the two letter ISO region.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TwoLetterISORegionName { get; set; }
	}
	
	/// <summary>
	/// Create new playlist dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreatePlaylistDto
	{
		
		/// <summary>
		/// Gets or sets item ids to add to the playlist.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// Gets or sets the media type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MediaType { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the new playlist.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the user id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// The create user by name request body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateUserByName
	{
		
		/// <summary>
		/// Gets or sets the username.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
	}
	
	/// <summary>
	/// Class CultureDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CultureDto
	{
		
		/// <summary>
		/// Gets or sets the display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the three letter ISO language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ThreeLetterISOLanguageName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ThreeLetterISOLanguageNames { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the two letter ISO language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TwoLetterISOLanguageName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DayPattern
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Daily")]
		Daily = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Weekdays")]
		Weekdays = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Weekends")]
		Weekends = 2,
	}
	
	/// <summary>
	/// Default directory browser info.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DefaultDirectoryBrowserInfoDto
	{
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeviceInfo
	{
		
		/// <summary>
		/// Gets or sets the name of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AppName { get; set; }
		
		/// <summary>
		/// Gets or sets the application version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AppVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClientCapabilities Capabilities { get; set; }
		
		/// <summary>
		/// Gets or sets the date last modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateLastActivity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IconUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the last user identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LastUserId { get; set; }
		
		/// <summary>
		/// Gets or sets the last name of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LastUserName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeviceInfoQueryResult
	{
		
		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeviceInfo[] Items { get; set; }
		
		/// <summary>
		/// The index of the first record in Items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// The total number of records available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeviceOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CustomName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeviceProfileInfo
	{
		
		/// <summary>
		/// Gets or sets the identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<DeviceProfileInfoType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DeviceProfileInfoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="User")]
		User = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DeviceProfileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="User")]
		User = 1,
	}
	
	/// <summary>
	/// Defines the display preferences for any item that supports them (usually Folders).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisplayPreferencesDto
	{
		
		/// <summary>
		/// Gets or sets the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Client { get; set; }
		
		/// <summary>
		/// Gets or sets the custom prefs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> CustomPrefs { get; set; }
		
		/// <summary>
		/// Gets or sets the user id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the index by.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IndexBy { get; set; }
		
		/// <summary>
		/// Gets or sets the height of the primary image.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PrimaryImageHeight { get; set; }
		
		/// <summary>
		/// Gets or sets the width of the primary image.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PrimaryImageWidth { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [remember indexing].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RememberIndexing { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [remember sorting].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RememberSorting { get; set; }
		
		/// <summary>
		/// An enum representing the axis that should be scrolled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<DisplayPreferencesDtoScrollDirection> ScrollDirection { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to show backdrops on this item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ShowBackdrop { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [show sidebar].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ShowSidebar { get; set; }
		
		/// <summary>
		/// Gets or sets the sort by.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SortBy { get; set; }
		
		/// <summary>
		/// An enum representing the sorting order.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<DisplayPreferencesDtoSortOrder> SortOrder { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the view.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ViewType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DisplayPreferencesDtoScrollDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Horizontal")]
		Horizontal = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Vertical")]
		Vertical = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DisplayPreferencesDtoSortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Ascending")]
		Ascending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Descending")]
		Descending = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DlnaProfileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Audio")]
		Audio = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Video")]
		Video = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Photo")]
		Photo = 2,
	}
	
	/// <summary>
	/// An enum that represents a day of the week, weekdays, weekends, or all days.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DynamicDayOfWeek
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sunday")]
		Sunday = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Monday")]
		Monday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Tuesday")]
		Tuesday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Wednesday")]
		Wednesday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Thursday")]
		Thursday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Friday")]
		Friday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Saturday")]
		Saturday = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Everyday")]
		Everyday = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Weekday")]
		Weekday = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Weekend")]
		Weekend = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum EncodingContext
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Streaming")]
		Streaming = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Static")]
		Static = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EndPointInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsInNetwork { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsLocal { get; set; }
	}
	
	/// <summary>
	/// Represents the external id information for serialization to the client.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExternalIdInfo
	{
		
		/// <summary>
		/// Gets or sets the unique key for this id. This key should be unique across all providers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Gets or sets the display name of the external id provider (IE: IMDB, MusicBrainz, etc).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// The specific media type of an MediaBrowser.Model.Providers.ExternalIdInfo.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<ExternalIdInfoType> Type { get; set; }
		
		/// <summary>
		/// Gets or sets the URL format string.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UrlFormatString { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ExternalIdInfoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Album")]
		Album = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AlbumArtist")]
		AlbumArtist = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Artist")]
		Artist = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BoxSet")]
		BoxSet = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Episode")]
		Episode = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Movie")]
		Movie = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OtherArtist")]
		OtherArtist = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Person")]
		Person = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ReleaseGroup")]
		ReleaseGroup = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Season")]
		Season = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Series")]
		Series = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Track")]
		Track = 11,
	}
	
	/// <summary>
	/// The specific media type of an MediaBrowser.Model.Providers.ExternalIdInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ExternalIdMediaType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Album")]
		Album = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AlbumArtist")]
		AlbumArtist = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Artist")]
		Artist = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BoxSet")]
		BoxSet = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Episode")]
		Episode = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Movie")]
		Movie = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OtherArtist")]
		OtherArtist = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Person")]
		Person = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ReleaseGroup")]
		ReleaseGroup = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Season")]
		Season = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Series")]
		Series = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Track")]
		Track = 11,
	}
	
	/// <summary>
	/// Enum describing the location of the FFmpeg tool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FFmpegLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotFound")]
		NotFound = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SetByArgument")]
		SetByArgument = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom")]
		Custom = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 3,
	}
	
	/// <summary>
	/// Class FileSystemEntryInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileSystemEntryInfo
	{
		
		/// <summary>
		/// Gets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		/// <summary>
		/// Enum FileSystemEntryType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<FileSystemEntryInfoType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FileSystemEntryInfoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="File")]
		File = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Directory")]
		Directory = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NetworkComputer")]
		NetworkComputer = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NetworkShare")]
		NetworkShare = 3,
	}
	
	/// <summary>
	/// Enum FileSystemEntryType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FileSystemEntryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="File")]
		File = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Directory")]
		Directory = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NetworkComputer")]
		NetworkComputer = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NetworkShare")]
		NetworkShare = 3,
	}
	
	/// <summary>
	/// Class FontFile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FontFile
	{
		
		/// <summary>
		/// Gets or sets the date created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateCreated { get; set; }
		
		/// <summary>
		/// Gets or sets the date modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateModified { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the size.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ForgotPasswordAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ContactAdmin")]
		ContactAdmin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PinCode")]
		PinCode = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="InNetworkRequired")]
		InNetworkRequired = 2,
	}
	
	/// <summary>
	/// Forgot Password request body DTO.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForgotPasswordDto
	{
		
		/// <summary>
		/// Gets or sets the entered username to have its password reset.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string EnteredUsername { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForgotPasswordResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ForgotPasswordAction Action { get; set; }
		
		/// <summary>
		/// Gets or sets the pin expiration date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PinExpirationDate { get; set; }
		
		/// <summary>
		/// Gets or sets the pin file.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PinFile { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GeneralCommand
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> Arguments { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ControllingUserId { get; set; }
		
		/// <summary>
		/// This exists simply to identify a set of known commands.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GeneralCommandType Name { get; set; }
	}
	
	/// <summary>
	/// Get programs dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetProgramsDto
	{
		
		/// <summary>
		/// Gets or sets the channels to return guide information for.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ChannelIds { get; set; }
		
		/// <summary>
		/// Gets or sets the image types to include in the output.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageType[] EnableImageTypes { get; set; }
		
		/// <summary>
		/// Gets or sets include image information in output.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableImages { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether retrieve total record count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableTotalRecordCount { get; set; }
		
		/// <summary>
		/// Gets or sets include user data.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableUserData { get; set; }
		
		/// <summary>
		/// Gets or sets specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ItemFields[] Fields { get; set; }
		
		/// <summary>
		/// Gets or sets the genre ids to return guide information for.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] GenreIds { get; set; }
		
		/// <summary>
		/// Gets or sets the genres to return guide information for.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Genres { get; set; }
		
		/// <summary>
		/// Gets or sets filter by programs that have completed airing, or not.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasAired { get; set; }
		
		/// <summary>
		/// Gets or sets the max number of images to return, per image type.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ImageTypeLimit { get; set; }
		
		/// <summary>
		/// Gets or sets filter by programs that are currently airing, or not.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAiring { get; set; }
		
		/// <summary>
		/// Gets or sets filter for kids.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsKids { get; set; }
		
		/// <summary>
		/// Gets or sets filter for movies.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsMovie { get; set; }
		
		/// <summary>
		/// Gets or sets filter for news.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsNews { get; set; }
		
		/// <summary>
		/// Gets or sets filter for series.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsSeries { get; set; }
		
		/// <summary>
		/// Gets or sets filter for sports.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsSports { get; set; }
		
		/// <summary>
		/// Gets or sets filter by library series id.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LibrarySeriesId { get; set; }
		
		/// <summary>
		/// Gets or sets the maximum number of records to return.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		/// <summary>
		/// Gets or sets the maximum premiere end date.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> MaxEndDate { get; set; }
		
		/// <summary>
		/// Gets or sets the maximum premiere start date.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> MaxStartDate { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum premiere end date.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> MinEndDate { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum premiere start date.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> MinStartDate { get; set; }
		
		/// <summary>
		/// Gets or sets filter by series timer id.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeriesTimerId { get; set; }
		
		/// <summary>
		/// Gets or sets specify one or more sort orders, comma delimited. Options: Name, StartDate.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SortBy { get; set; }
		
		/// <summary>
		/// Gets or sets sort Order - Ascending,Descending.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SortOrder { get; set; }
		
		/// <summary>
		/// Gets or sets the record index to start at. All items with a lower index will be dropped from the results.
		///Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// Gets or sets optional. Filter by user id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// Enum ImageType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Primary")]
		Primary = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Art")]
		Art = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Backdrop")]
		Backdrop = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Banner")]
		Banner = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Logo")]
		Logo = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Thumb")]
		Thumb = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Disc")]
		Disc = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Box")]
		Box = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Screenshot")]
		Screenshot = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Menu")]
		Menu = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Chapter")]
		Chapter = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BoxRear")]
		BoxRear = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Profile")]
		Profile = 12,
	}
	
	/// <summary>
	/// Used to control the data that gets attached to DtoBaseItems.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ItemFields
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AirTime")]
		AirTime = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CanDelete")]
		CanDelete = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CanDownload")]
		CanDownload = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ChannelInfo")]
		ChannelInfo = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Chapters")]
		Chapters = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ChildCount")]
		ChildCount = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CumulativeRunTimeTicks")]
		CumulativeRunTimeTicks = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CustomRating")]
		CustomRating = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DateCreated")]
		DateCreated = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DateLastMediaAdded")]
		DateLastMediaAdded = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DisplayPreferencesId")]
		DisplayPreferencesId = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Etag")]
		Etag = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ExternalUrls")]
		ExternalUrls = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Genres")]
		Genres = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HomePageUrl")]
		HomePageUrl = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ItemCounts")]
		ItemCounts = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MediaSourceCount")]
		MediaSourceCount = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MediaSources")]
		MediaSources = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OriginalTitle")]
		OriginalTitle = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Overview")]
		Overview = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ParentId")]
		ParentId = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Path")]
		Path = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="People")]
		People = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayAccess")]
		PlayAccess = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ProductionLocations")]
		ProductionLocations = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ProviderIds")]
		ProviderIds = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PrimaryImageAspectRatio")]
		PrimaryImageAspectRatio = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RecursiveItemCount")]
		RecursiveItemCount = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Settings")]
		Settings = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ScreenshotImageTags")]
		ScreenshotImageTags = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SeriesPrimaryImage")]
		SeriesPrimaryImage = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SeriesStudio")]
		SeriesStudio = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SortName")]
		SortName = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SpecialEpisodeNumbers")]
		SpecialEpisodeNumbers = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Studios")]
		Studios = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BasicSyncInfo")]
		BasicSyncInfo = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SyncInfo")]
		SyncInfo = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Taglines")]
		Taglines = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Tags")]
		Tags = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RemoteTrailers")]
		RemoteTrailers = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MediaStreams")]
		MediaStreams = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SeasonUserData")]
		SeasonUserData = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ServiceName")]
		ServiceName = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ThemeSongIds")]
		ThemeSongIds = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ThemeVideoIds")]
		ThemeVideoIds = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ExternalEtag")]
		ExternalEtag = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PresentationUniqueKey")]
		PresentationUniqueKey = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="InheritedParentalRatingValue")]
		InheritedParentalRatingValue = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ExternalSeriesId")]
		ExternalSeriesId = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SeriesPresentationUniqueKey")]
		SeriesPresentationUniqueKey = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DateLastRefreshed")]
		DateLastRefreshed = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DateLastSaved")]
		DateLastSaved = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RefreshState")]
		RefreshState = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ChannelImage")]
		ChannelImage = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EnableMediaSourceDisplay")]
		EnableMediaSourceDisplay = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Width")]
		Width = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Height")]
		Height = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ExtraIds")]
		ExtraIds = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LocalTrailerCount")]
		LocalTrailerCount = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsHD")]
		IsHD = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SpecialFeatureCount")]
		SpecialFeatureCount = 60,
	}
	
	/// <summary>
	/// Class GroupInfoDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GroupInfoDto
	{
		
		/// <summary>
		/// Gets the group identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string GroupId { get; set; }
		
		/// <summary>
		/// Gets the group name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string GroupName { get; set; }
		
		/// <summary>
		/// Gets the date when this DTO has been created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Gets the participants.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Participants { get; set; }
		
		/// <summary>
		/// Enum GroupState.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<GroupInfoDtoState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GroupInfoDtoState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Idle")]
		Idle = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Waiting")]
		Waiting = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Paused")]
		Paused = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Playing")]
		Playing = 3,
	}
	
	/// <summary>
	/// Enum GroupQueueMode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GroupQueueMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Queue")]
		Queue = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="QueueNext")]
		QueueNext = 1,
	}
	
	/// <summary>
	/// Enum GroupRepeatMode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GroupRepeatMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatOne")]
		RepeatOne = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatAll")]
		RepeatAll = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatNone")]
		RepeatNone = 2,
	}
	
	/// <summary>
	/// Enum GroupShuffleMode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GroupShuffleMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sorted")]
		Sorted = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Shuffle")]
		Shuffle = 1,
	}
	
	/// <summary>
	/// Enum GroupState.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GroupStateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Idle")]
		Idle = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Waiting")]
		Waiting = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Paused")]
		Paused = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Playing")]
		Playing = 3,
	}
	
	/// <summary>
	/// Enum GroupUpdateType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GroupUpdateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UserJoined")]
		UserJoined = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UserLeft")]
		UserLeft = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GroupJoined")]
		GroupJoined = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GroupLeft")]
		GroupLeft = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="StateUpdate")]
		StateUpdate = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayQueue")]
		PlayQueue = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotInGroup")]
		NotInGroup = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GroupDoesNotExist")]
		GroupDoesNotExist = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CreateGroupDenied")]
		CreateGroupDenied = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="JoinGroupDenied")]
		JoinGroupDenied = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LibraryAccessDenied")]
		LibraryAccessDenied = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuideInfo
	{
		
		/// <summary>
		/// Gets or sets the end date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// Gets or sets the start date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum HeaderMatchType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Equals")]
		Equals = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Regex")]
		Regex = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Substring")]
		Substring = 2,
	}
	
	/// <summary>
	/// Defines the MediaBrowser.Common.Plugins.IPlugin.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IPlugin
	{
		
		/// <summary>
		/// Gets the path to the assembly file.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AssemblyFilePath { get; set; }
		
		/// <summary>
		/// Gets a value indicating whether the plugin can be uninstalled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanUninstall { get; set; }
		
		/// <summary>
		/// Gets the full path to the data folder, where the plugin can store any miscellaneous files needed.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string DataFolderPath { get; set; }
		
		/// <summary>
		/// Gets the Description.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Gets the unique id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets the name of the plugin.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Version Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Version
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Build { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Major { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MajorRevision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinorRevision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Revision { get; set; }
	}
	
	/// <summary>
	/// Class IgnoreWaitRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IgnoreWaitRequestDto
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether the client should be ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IgnoreWait { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageByNameInfo
	{
		
		/// <summary>
		/// Gets or sets the context.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Context { get; set; }
		
		/// <summary>
		/// Gets or sets the length of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> FileLength { get; set; }
		
		/// <summary>
		/// Gets or sets the format.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Format { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the theme.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Theme { get; set; }
	}
	
	/// <summary>
	/// Enum ImageOutputFormat.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImageFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Bmp")]
		Bmp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Gif")]
		Gif = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Jpg")]
		Jpg = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Png")]
		Png = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Webp")]
		Webp = 4,
	}
	
	/// <summary>
	/// Class ImageInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageInfo
	{
		
		/// <summary>
		/// Gets or sets the blurhash.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BlurHash { get; set; }
		
		/// <summary>
		/// Gets or sets the height.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Gets or sets the index of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ImageIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ImageTag { get; set; }
		
		/// <summary>
		/// Enum ImageType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageOptionType ImageType { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		/// <summary>
		/// Gets or sets the size.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// Gets or sets the width.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImageOrientation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TopLeft")]
		TopLeft = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TopRight")]
		TopRight = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BottomRight")]
		BottomRight = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BottomLeft")]
		BottomLeft = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LeftTop")]
		LeftTop = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RightTop")]
		RightTop = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RightBottom")]
		RightBottom = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LeftBottom")]
		LeftBottom = 7,
	}
	
	/// <summary>
	/// Class ImageProviderInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageProviderInfo
	{
		
		/// <summary>
		/// Gets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets the supported image types.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageType[] SupportedImages { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImageSavingConvention
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Legacy")]
		Legacy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Compatible")]
		Compatible = 1,
	}
	
	/// <summary>
	/// Class InstallationInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstallationInfo
	{
		
		/// <summary>
		/// Gets or sets the changelog for this version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Changelog { get; set; }
		
		/// <summary>
		/// Gets or sets a checksum for the binary.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Checksum { get; set; }
		
		/// <summary>
		/// Gets or sets the Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Guid { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the source URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SourceUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Version Version { get; set; }
	}
	
	/// <summary>
	/// Enum IsoType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum IsoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Dvd")]
		Dvd = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BluRay")]
		BluRay = 1,
	}
	
	/// <summary>
	/// Class LibrarySummary.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ItemCounts
	{
		
		/// <summary>
		/// Gets or sets the album count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AlbumCount { get; set; }
		
		/// <summary>
		/// Gets or sets the artist count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ArtistCount { get; set; }
		
		/// <summary>
		/// Gets or sets the book count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BookCount { get; set; }
		
		/// <summary>
		/// Gets or sets the box set count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BoxSetCount { get; set; }
		
		/// <summary>
		/// Gets or sets the episode count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> EpisodeCount { get; set; }
		
		/// <summary>
		/// Gets or sets the item count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ItemCount { get; set; }
		
		/// <summary>
		/// Gets or sets the movie count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MovieCount { get; set; }
		
		/// <summary>
		/// Gets or sets the music video count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MusicVideoCount { get; set; }
		
		/// <summary>
		/// Gets or sets the program count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProgramCount { get; set; }
		
		/// <summary>
		/// Gets or sets the series count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SeriesCount { get; set; }
		
		/// <summary>
		/// Gets or sets the song count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SongCount { get; set; }
		
		/// <summary>
		/// Gets or sets the trailer count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TrailerCount { get; set; }
	}
	
	/// <summary>
	/// Enum ItemFilter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ItemFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsFolder")]
		IsFolder = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsNotFolder")]
		IsNotFolder = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsUnplayed")]
		IsUnplayed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsPlayed")]
		IsPlayed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsFavorite")]
		IsFavorite = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsResumable")]
		IsResumable = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Likes")]
		Likes = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Dislikes")]
		Dislikes = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsFavoriteOrLikes")]
		IsFavoriteOrLikes = 8,
	}
	
	/// <summary>
	/// Class JoinGroupRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JoinGroupRequestDto
	{
		
		/// <summary>
		/// Gets or sets the group identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string GroupId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum KeepUntil
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UntilDeleted")]
		UntilDeleted = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UntilSpaceNeeded")]
		UntilSpaceNeeded = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UntilWatched")]
		UntilWatched = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UntilDate")]
		UntilDate = 3,
	}
	
	/// <summary>
	/// Library option info dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LibraryOptionInfoDto
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether default enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DefaultEnabled { get; set; }
		
		/// <summary>
		/// Gets or sets name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Library options result dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LibraryOptionsResultDto
	{
		
		/// <summary>
		/// Gets or sets the metadata readers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LibraryOptionInfoDto[] MetadataReaders { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata savers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LibraryOptionInfoDto[] MetadataSavers { get; set; }
		
		/// <summary>
		/// Gets or sets the subtitle fetchers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LibraryOptionInfoDto[] SubtitleFetchers { get; set; }
		
		/// <summary>
		/// Gets or sets the type options.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LibraryTypeOptionsDto[] TypeOptions { get; set; }
	}
	
	/// <summary>
	/// Library type options dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LibraryTypeOptionsDto
	{
		
		/// <summary>
		/// Gets or sets the default image options.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageOption[] DefaultImageOptions { get; set; }
		
		/// <summary>
		/// Gets or sets the image fetchers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LibraryOptionInfoDto[] ImageFetchers { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata fetchers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LibraryOptionInfoDto[] MetadataFetchers { get; set; }
		
		/// <summary>
		/// Gets or sets the supported image types.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageType[] SupportedImageTypes { get; set; }
		
		/// <summary>
		/// Gets or sets the type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Class LibraryUpdateInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LibraryUpdateInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] CollectionFolders { get; set; }
		
		/// <summary>
		/// Gets or sets the folders added to.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] FoldersAddedTo { get; set; }
		
		/// <summary>
		/// Gets or sets the folders removed from.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] FoldersRemovedFrom { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsEmpty { get; set; }
		
		/// <summary>
		/// Gets or sets the items added.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ItemsAdded { get; set; }
		
		/// <summary>
		/// Gets or sets the items removed.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ItemsRemoved { get; set; }
		
		/// <summary>
		/// Gets or sets the items updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ItemsUpdated { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListingsProviderInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public NameValuePair[] ChannelMappings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Country { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableAllTuners { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] EnabledTuners { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] KidsCategories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ListingsId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] MovieCategories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MoviePrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] NewsCategories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PreferredLanguage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SportsCategories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserAgent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Username { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ZipCode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LiveStreamResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public MediaSourceInfo MediaSource { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LiveTvInfo
	{
		
		/// <summary>
		/// Gets or sets the enabled users.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] EnabledUsers { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsEnabled { get; set; }
		
		/// <summary>
		/// Gets or sets the services.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public LiveTvServiceInfo[] Services { get; set; }
	}
	
	/// <summary>
	/// Class ServiceInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LiveTvServiceInfo
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance has update available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasUpdateAvailable { get; set; }
		
		/// <summary>
		/// Gets or sets the home page URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string HomePageUrl { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is visible.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsVisible { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<LiveTvServiceInfoStatus> Status { get; set; }
		
		/// <summary>
		/// Gets or sets the status message.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Tuners { get; set; }
		
		/// <summary>
		/// Gets or sets the version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum LiveTvServiceInfoStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Ok")]
		Ok = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unavailable")]
		Unavailable = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum LiveTvServiceStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Ok")]
		Ok = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unavailable")]
		Unavailable = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalizationOption
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Enum LocationType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum LocationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FileSystem")]
		FileSystem = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Remote")]
		Remote = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Virtual")]
		Virtual = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Offline")]
		Offline = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogFile
	{
		
		/// <summary>
		/// Gets or sets the date created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateCreated { get; set; }
		
		/// <summary>
		/// Gets or sets the date modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateModified { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the size.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum LogLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Trace")]
		Trace = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Debug")]
		Debug = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Information")]
		Information = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Warning")]
		Warning = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Error")]
		Error = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Critical")]
		Critical = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 6,
	}
	
	/// <summary>
	/// Media Encoder Path Dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaEncoderPathDto
	{
		
		/// <summary>
		/// Gets or sets media encoder path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		/// <summary>
		/// Gets or sets media encoder path type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PathType { get; set; }
	}
	
	/// <summary>
	/// Media Path dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaPathDto
	{
		
		/// <summary>
		/// Gets or sets the name of the library.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the path to add.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MediaPathInfo PathInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="File")]
		File = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Http")]
		Http = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Rtmp")]
		Rtmp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Rtsp")]
		Rtsp = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Udp")]
		Udp = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Rtp")]
		Rtp = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Ftp")]
		Ftp = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Default")]
		Default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Grouping")]
		Grouping = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Placeholder")]
		Placeholder = 2,
	}
	
	/// <summary>
	/// Media Update Info Dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaUpdateInfoDto
	{
		
		/// <summary>
		/// Gets or sets media path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		/// <summary>
		/// Gets or sets media update type.
		///Created, Modified, Deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UpdateType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetadataEditorInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NameValuePair[] ContentTypeOptions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CountryInfo[] Countries { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CultureDto[] Cultures { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExternalIdInfo[] ExternalIdInfos { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ParentalRating[] ParentalRatingOptions { get; set; }
	}
	
	/// <summary>
	/// Class ParentalRating.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ParentalRating
	{
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the value.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	/// <summary>
	/// Class MetadataOptions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetadataOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] DisabledImageFetchers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] DisabledMetadataFetchers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] DisabledMetadataSavers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ImageFetcherOrder { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] LocalMetadataReaderOrder { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] MetadataFetcherOrder { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MetadataRefreshMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ValidationOnly")]
		ValidationOnly = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Default")]
		Default = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FullRefresh")]
		FullRefresh = 3,
	}
	
	/// <summary>
	/// Class MovePlaylistItemRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MovePlaylistItemRequestDto
	{
		
		/// <summary>
		/// Gets or sets the new position.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NewIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the playlist identifier of the item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MovieInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MovieInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MovieInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MusicVideoInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Artists { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MusicVideoInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MusicVideoInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	/// <summary>
	/// Class NewGroupRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NewGroupRequestDto
	{
		
		/// <summary>
		/// Gets or sets the group name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string GroupName { get; set; }
	}
	
	/// <summary>
	/// Class NextItemRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NextItemRequestDto
	{
		
		/// <summary>
		/// Gets or sets the playing item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
	}
	
	/// <summary>
	/// The notification DTO.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationDto
	{
		
		/// <summary>
		/// Gets or sets the notification date.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// Gets or sets the notification's description. Defaults to an empty string.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Gets or sets the notification ID. Defaults to an empty string.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether the notification has been read. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsRead { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<NotificationDtoLevel> Level { get; set; }
		
		/// <summary>
		/// Gets or sets the notification's name. Defaults to an empty string.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the notification's URL. Defaults to an empty string.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
		
		/// <summary>
		/// Gets or sets the notification's user ID. Defaults to an empty string.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum NotificationDtoLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Normal")]
		Normal = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Warning")]
		Warning = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Error")]
		Error = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum NotificationLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Normal")]
		Normal = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Warning")]
		Warning = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Error")]
		Error = 2,
	}
	
	/// <summary>
	/// A list of notifications with the total record count for pagination.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationResultDto
	{
		
		/// <summary>
		/// Gets or sets the current page of notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public NotificationDto[] Notifications { get; set; }
		
		/// <summary>
		/// Gets or sets the total number of notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationTypeInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Category { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsBasedOnUserEvent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// The notification summary DTO.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationsSummaryDto
	{
		
		[System.Runtime.Serialization.DataMember()]
		public NotificationDtoLevel MaxUnreadNotificationLevel { get; set; }
		
		/// <summary>
		/// Gets or sets the number of unread notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UnreadCount { get; set; }
	}
	
	/// <summary>
	/// Class GroupUpdate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ObjectGroupUpdate
	{
		
		/// <summary>
		/// Gets the update data.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public object Data { get; set; }
		
		/// <summary>
		/// Gets the group identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string GroupId { get; set; }
		
		/// <summary>
		/// Enum GroupUpdateType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GroupUpdateType Type { get; set; }
	}
	
	/// <summary>
	/// Open live stream dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OpenLiveStreamDto
	{
		
		/// <summary>
		/// Gets or sets the audio stream index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AudioStreamIndex { get; set; }
		
		/// <summary>
		/// Defines the MediaBrowser.Model.Dlna.DeviceProfile.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeviceProfile DeviceProfile { get; set; }
		
		/// <summary>
		/// Gets or sets the device play protocols.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MediaProtocol[] DirectPlayProtocols { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to enable direct play.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableDirectPlay { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to enale direct stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableDirectStream { get; set; }
		
		/// <summary>
		/// Gets or sets the item id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the max audio channels.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxAudioChannels { get; set; }
		
		/// <summary>
		/// Gets or sets the max streaming bitrate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxStreamingBitrate { get; set; }
		
		/// <summary>
		/// Gets or sets the open token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OpenToken { get; set; }
		
		/// <summary>
		/// Gets or sets the play session id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaySessionId { get; set; }
		
		/// <summary>
		/// Gets or sets the start time in ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> StartTimeTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the subtitle stream index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SubtitleStreamIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the user id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// Class PackageInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PackageInfo
	{
		
		/// <summary>
		/// Gets or sets the category.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Gets or sets a long description of the plugin containing features or helpful explanations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Gets or sets the guid of the assembly associated with this plugin.
		///This is used to identify the proper item for automatic updates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guid")]
		public string Guid { get; set; }
		
		/// <summary>
		/// Gets or sets the image url for the package.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageUrl")]
		public string ImageUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets a short overview of what the plugin does.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overview")]
		public string Overview { get; set; }
		
		/// <summary>
		/// Gets or sets the owner.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public string Owner { get; set; }
		
		/// <summary>
		/// Gets or sets the versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="versions")]
		public VersionInfo[] Versions { get; set; }
	}
	
	/// <summary>
	/// Defines the MediaBrowser.Model.Updates.VersionInfo class.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VersionInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Version VersionNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the changelog for this version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="changelog")]
		public string Changelog { get; set; }
		
		/// <summary>
		/// Gets or sets a checksum for the binary.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checksum")]
		public string Checksum { get; set; }
		
		/// <summary>
		/// Gets or sets the repository name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repositoryName")]
		public string RepositoryName { get; set; }
		
		/// <summary>
		/// Gets or sets the repository url.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repositoryUrl")]
		public string RepositoryUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the source URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceUrl")]
		public string SourceUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the ABI that this version was built against.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetAbi")]
		public string TargetAbi { get; set; }
		
		/// <summary>
		/// Gets or sets a timestamp of when the binary was built.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public string Timestamp { get; set; }
		
		/// <summary>
		/// Gets or sets the version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Defines the MediaBrowser.Model.Configuration.PathSubstitution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PathSubstitution
	{
		
		/// <summary>
		/// Gets or sets the value to substitute.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string From { get; set; }
		
		/// <summary>
		/// Gets or sets the value to substitution with.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PersonLookupInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PersonLookupInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PersonLookupInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PinRedeemResult
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether this MediaBrowser.Model.Users.PinRedeemResult is success.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Success { get; set; }
		
		/// <summary>
		/// Gets or sets the users reset.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] UsersReset { get; set; }
	}
	
	/// <summary>
	/// Class PingRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PingRequestDto
	{
		
		/// <summary>
		/// Gets or sets the ping time.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> Ping { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PlayAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Full")]
		Full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 1,
	}
	
	/// <summary>
	/// Enum PlayCommand.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PlayCommand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayNow")]
		PlayNow = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayNext")]
		PlayNext = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayLast")]
		PlayLast = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayInstantMix")]
		PlayInstantMix = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayShuffle")]
		PlayShuffle = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PlayMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Transcode")]
		Transcode = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DirectStream")]
		DirectStream = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DirectPlay")]
		DirectPlay = 2,
	}
	
	/// <summary>
	/// Class PlayRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AudioStreamIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the controlling user identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ControllingUserId { get; set; }
		
		/// <summary>
		/// Gets or sets the item ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ItemIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MediaSourceId { get; set; }
		
		/// <summary>
		/// Enum PlayCommand.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PlayCommand PlayCommand { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the start position ticks that the first item should be played at.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> StartPositionTicks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SubtitleStreamIndex { get; set; }
	}
	
	/// <summary>
	/// Class PlayRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayRequestDto
	{
		
		/// <summary>
		/// Gets or sets the position of the playing item in the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PlayingItemPosition { get; set; }
		
		/// <summary>
		/// Gets or sets the playing queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] PlayingQueue { get; set; }
		
		/// <summary>
		/// Gets or sets the start position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> StartPositionTicks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PlaybackErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotAllowed")]
		NotAllowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NoCompatibleStream")]
		NoCompatibleStream = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RateLimitExceeded")]
		RateLimitExceeded = 2,
	}
	
	/// <summary>
	/// Plabyback info dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlaybackInfoDto
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether to allow audio stream copy.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AllowAudioStreamCopy { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to enable video stream copy.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AllowVideoStreamCopy { get; set; }
		
		/// <summary>
		/// Gets or sets the audio stream index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AudioStreamIndex { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to auto open the live stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AutoOpenLiveStream { get; set; }
		
		/// <summary>
		/// Defines the MediaBrowser.Model.Dlna.DeviceProfile.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeviceProfile DeviceProfile { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to enable direct play.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableDirectPlay { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to enable direct stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableDirectStream { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to enable transcoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableTranscoding { get; set; }
		
		/// <summary>
		/// Gets or sets the live stream id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LiveStreamId { get; set; }
		
		/// <summary>
		/// Gets or sets the max audio channels.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxAudioChannels { get; set; }
		
		/// <summary>
		/// Gets or sets the max streaming bitrate.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxStreamingBitrate { get; set; }
		
		/// <summary>
		/// Gets or sets the media source id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MediaSourceId { get; set; }
		
		/// <summary>
		/// Gets or sets the start time in ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> StartTimeTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the subtitle stream index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SubtitleStreamIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the playback userId.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// Class PlaybackInfoResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlaybackInfoResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PlaybackErrorCode ErrorCode { get; set; }
		
		/// <summary>
		/// Gets or sets the media sources.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public MediaSourceInfo[] MediaSources { get; set; }
		
		/// <summary>
		/// Gets or sets the play session identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaySessionId { get; set; }
	}
	
	/// <summary>
	/// Class PlaybackProgressInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlaybackProgressInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AspectRatio { get; set; }
		
		/// <summary>
		/// Gets or sets the index of the audio stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AudioStreamIndex { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Brightness { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance can seek.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanSeek { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is muted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsMuted { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is paused.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPaused { get; set; }
		
		/// <summary>
		/// This is strictly used as a data transfer object from the api layer.
		///This holds information about a BaseItem in a format that is convenient for the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto Item { get; set; }
		
		/// <summary>
		/// Gets or sets the item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the live stream identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LiveStreamId { get; set; }
		
		/// <summary>
		/// Gets or sets the media version identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MediaSourceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public QueueItem[] NowPlayingQueue { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PlayerStateInfoPlayMethod PlayMethod { get; set; }
		
		/// <summary>
		/// Gets or sets the play session identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaySessionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PlaybackStartTimeTicks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PositionTicks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PlayerStateInfoRepeatMode RepeatMode { get; set; }
		
		/// <summary>
		/// Gets or sets the session id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SessionId { get; set; }
		
		/// <summary>
		/// Gets or sets the index of the subtitle stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SubtitleStreamIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the volume level.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VolumeLevel { get; set; }
	}
	
	/// <summary>
	/// Class PlaybackStartInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlaybackStartInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AspectRatio { get; set; }
		
		/// <summary>
		/// Gets or sets the index of the audio stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AudioStreamIndex { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Brightness { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance can seek.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanSeek { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is muted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsMuted { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is paused.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPaused { get; set; }
		
		/// <summary>
		/// This is strictly used as a data transfer object from the api layer.
		///This holds information about a BaseItem in a format that is convenient for the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto Item { get; set; }
		
		/// <summary>
		/// Gets or sets the item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the live stream identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LiveStreamId { get; set; }
		
		/// <summary>
		/// Gets or sets the media version identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MediaSourceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public QueueItem[] NowPlayingQueue { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PlayerStateInfoPlayMethod PlayMethod { get; set; }
		
		/// <summary>
		/// Gets or sets the play session identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaySessionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PlaybackStartTimeTicks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PositionTicks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PlayerStateInfoRepeatMode RepeatMode { get; set; }
		
		/// <summary>
		/// Gets or sets the session id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SessionId { get; set; }
		
		/// <summary>
		/// Gets or sets the index of the subtitle stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SubtitleStreamIndex { get; set; }
		
		/// <summary>
		/// Gets or sets the volume level.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VolumeLevel { get; set; }
	}
	
	/// <summary>
	/// Class PlaybackStopInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlaybackStopInfo
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether this MediaBrowser.Model.Session.PlaybackStopInfo is failed.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Failed { get; set; }
		
		/// <summary>
		/// This is strictly used as a data transfer object from the api layer.
		///This holds information about a BaseItem in a format that is convenient for the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto Item { get; set; }
		
		/// <summary>
		/// Gets or sets the item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the live stream identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LiveStreamId { get; set; }
		
		/// <summary>
		/// Gets or sets the media version identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MediaSourceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextMediaType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public QueueItem[] NowPlayingQueue { get; set; }
		
		/// <summary>
		/// Gets or sets the play session identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaySessionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PositionTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the session id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SessionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlaylistCreationResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Enum PlaystateCommand.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PlaystateCommand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Stop")]
		Stop = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Pause")]
		Pause = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unpause")]
		Unpause = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NextTrack")]
		NextTrack = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PreviousTrack")]
		PreviousTrack = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Seek")]
		Seek = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Rewind")]
		Rewind = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FastForward")]
		FastForward = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PlayPause")]
		PlayPause = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlaystateRequest
	{
		
		/// <summary>
		/// Enum PlaystateCommand.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PlaystateCommand Command { get; set; }
		
		/// <summary>
		/// Gets or sets the controlling user identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ControllingUserId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> SeekPositionTicks { get; set; }
	}
	
	/// <summary>
	/// This is a serializable stub class that is used by the api to provide information about installed plugins.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PluginInfo
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether the plugin can be uninstalled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanUninstall { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the configuration file.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ConfigurationFileName { get; set; }
		
		/// <summary>
		/// Gets or sets the description.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this plugin has a valid image.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasImage { get; set; }
		
		/// <summary>
		/// Gets or sets the unique id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Plugin load status.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<PluginInfoStatus> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Version Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PluginInfoStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Active")]
		Active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Restart")]
		Restart = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Deleted")]
		Deleted = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Superceded")]
		Superceded = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Malfunctioned")]
		Malfunctioned = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotSupported")]
		NotSupported = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Disabled")]
		Disabled = 6,
	}
	
	/// <summary>
	/// Plugin security info.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PluginSecurityInfo
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether is mb supporter.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsMbSupporter { get; set; }
		
		/// <summary>
		/// Gets or sets the supporter key.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SupporterKey { get; set; }
	}
	
	/// <summary>
	/// Plugin load status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PluginStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Active")]
		Active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Restart")]
		Restart = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Deleted")]
		Deleted = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Superceded")]
		Superceded = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Malfunctioned")]
		Malfunctioned = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotSupported")]
		NotSupported = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Disabled")]
		Disabled = 6,
	}
	
	/// <summary>
	/// Class PreviousItemRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreviousItemRequestDto
	{
		
		/// <summary>
		/// Gets or sets the playing item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProblemDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ProfileConditionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Equals")]
		Equals = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotEquals")]
		NotEquals = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LessThanEqual")]
		LessThanEqual = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GreaterThanEqual")]
		GreaterThanEqual = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EqualsAny")]
		EqualsAny = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ProfileConditionValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioChannels")]
		AudioChannels = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioBitrate")]
		AudioBitrate = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioProfile")]
		AudioProfile = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Width")]
		Width = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Height")]
		Height = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Has64BitOffsets")]
		Has64BitOffsets = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PacketLength")]
		PacketLength = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoBitDepth")]
		VideoBitDepth = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoBitrate")]
		VideoBitrate = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoFramerate")]
		VideoFramerate = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoLevel")]
		VideoLevel = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoProfile")]
		VideoProfile = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoTimestamp")]
		VideoTimestamp = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsAnamorphic")]
		IsAnamorphic = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RefFrames")]
		RefFrames = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NumAudioStreams")]
		NumAudioStreams = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NumVideoStreams")]
		NumVideoStreams = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsSecondaryAudio")]
		IsSecondaryAudio = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoCodecTag")]
		VideoCodecTag = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsAvc")]
		IsAvc = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IsInterlaced")]
		IsInterlaced = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioSampleRate")]
		AudioSampleRate = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AudioBitDepth")]
		AudioBitDepth = 22,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ProgramAudio
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Mono")]
		Mono = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Stereo")]
		Stereo = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Dolby")]
		Dolby = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DolbyDigital")]
		DolbyDigital = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Thx")]
		Thx = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Atmos")]
		Atmos = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicSystemInfo
	{
		
		/// <summary>
		/// Gets or sets the id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the local address.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LocalAddress { get; set; }
		
		/// <summary>
		/// Gets or sets the operating system.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OperatingSystem { get; set; }
		
		/// <summary>
		/// Gets or sets the product name. This is the AssemblyProduct name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProductName { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServerName { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether the startup wizard is completed.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> StartupWizardCompleted { get; set; }
		
		/// <summary>
		/// Gets or sets the server version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryFilters
	{
		
		[System.Runtime.Serialization.DataMember()]
		public NameGuidPair[] Genres { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryFiltersLegacy
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Genres { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] OfficialRatings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public int[] Years { get; set; }
	}
	
	/// <summary>
	/// Class QueueRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueueRequestDto
	{
		
		/// <summary>
		/// Gets or sets the items to enqueue.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ItemIds { get; set; }
		
		/// <summary>
		/// Enum GroupQueueMode.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GroupQueueMode Mode { get; set; }
	}
	
	/// <summary>
	/// The quick connect request body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QuickConnectDto
	{
		
		/// <summary>
		/// Gets or sets the quick connect token.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// Stores the result of an incoming quick connect request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QuickConnectResult
	{
		
		/// <summary>
		/// Gets a value indicating whether this request is authorized.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Authenticated { get; set; }
		
		/// <summary>
		/// Gets or sets the private access token.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Authentication { get; set; }
		
		/// <summary>
		/// Gets or sets the user facing code used so the user can quickly differentiate this request from others.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Code { get; set; }
		
		/// <summary>
		/// Gets or sets the DateTime that this request was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateAdded { get; set; }
		
		/// <summary>
		/// Gets or sets an error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Error { get; set; }
		
		/// <summary>
		/// Gets or sets the secret value used to uniquely identify this request. Can be used to retrieve authentication information.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Secret { get; set; }
	}
	
	/// <summary>
	/// Quick connect state.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum QuickConnectState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unavailable")]
		Unavailable = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Available")]
		Available = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Active")]
		Active = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RatingType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Score")]
		Score = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Likes")]
		Likes = 1,
	}
	
	/// <summary>
	/// Class ReadyRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReadyRequestDto
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether the client playback is unpaused.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPlaying { get; set; }
		
		/// <summary>
		/// Gets or sets the playlist item identifier of the playing item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PositionTicks { get; set; }
		
		/// <summary>
		/// Gets or sets when the request has been made by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> When { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RecommendationDto
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BaselineItemName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CategoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<RecommendationDtoRecommendationType> RecommendationType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RecommendationDtoRecommendationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SimilarToRecentlyPlayed")]
		SimilarToRecentlyPlayed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SimilarToLikedItem")]
		SimilarToLikedItem = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HasDirectorFromRecentlyPlayed")]
		HasDirectorFromRecentlyPlayed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HasActorFromRecentlyPlayed")]
		HasActorFromRecentlyPlayed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HasLikedDirector")]
		HasLikedDirector = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HasLikedActor")]
		HasLikedActor = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RecommendationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SimilarToRecentlyPlayed")]
		SimilarToRecentlyPlayed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SimilarToLikedItem")]
		SimilarToLikedItem = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HasDirectorFromRecentlyPlayed")]
		HasDirectorFromRecentlyPlayed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HasActorFromRecentlyPlayed")]
		HasActorFromRecentlyPlayed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HasLikedDirector")]
		HasLikedDirector = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HasLikedActor")]
		HasLikedActor = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RecordingStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="New")]
		New = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="InProgress")]
		InProgress = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Completed")]
		Completed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cancelled")]
		Cancelled = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ConflictedOk")]
		ConflictedOk = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ConflictedNotOk")]
		ConflictedNotOk = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Error")]
		Error = 6,
	}
	
	/// <summary>
	/// Class RemoteImageInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemoteImageInfo
	{
		
		/// <summary>
		/// Gets or sets the community rating.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> CommunityRating { get; set; }
		
		/// <summary>
		/// Gets or sets the height.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Gets or sets the language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Language { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProviderName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RatingType RatingType { get; set; }
		
		/// <summary>
		/// Gets a url used for previewing a smaller version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ThumbnailUrl { get; set; }
		
		/// <summary>
		/// Enum ImageType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ImageOptionType Type { get; set; }
		
		/// <summary>
		/// Gets or sets the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
		
		/// <summary>
		/// Gets or sets the vote count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VoteCount { get; set; }
		
		/// <summary>
		/// Gets or sets the width.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	/// <summary>
	/// Class RemoteImageResult.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemoteImageResult
	{
		
		/// <summary>
		/// Gets or sets the images.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public RemoteImageInfo[] Images { get; set; }
		
		/// <summary>
		/// Gets or sets the providers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Providers { get; set; }
		
		/// <summary>
		/// Gets or sets the total record count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemoteSearchResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RemoteSearchResult AlbumArtist { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RemoteSearchResult[] Artists { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ImageUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumberEnd { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Overview { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProductionYear { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemoteSubtitleInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Author { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Single> CommunityRating { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> DateCreated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DownloadCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Format { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsHashMatch { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProviderName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ThreeLetterISOLanguageName { get; set; }
	}
	
	/// <summary>
	/// Class RemoveFromPlaylistRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemoveFromPlaylistRequestDto
	{
		
		/// <summary>
		/// Gets or sets the playlist identifiers ot the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] PlaylistItemIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RepeatMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatNone")]
		RepeatNone = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatAll")]
		RepeatAll = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RepeatOne")]
		RepeatOne = 2,
	}
	
	/// <summary>
	/// Class RepositoryInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RepositoryInfo
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether the repository is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// An enum representing the axis that should be scrolled.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ScrollDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Horizontal")]
		Horizontal = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Vertical")]
		Vertical = 1,
	}
	
	/// <summary>
	/// Class SearchHintResult.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SearchHint
	{
		
		/// <summary>
		/// Gets or sets the album.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Album { get; set; }
		
		/// <summary>
		/// Gets or sets the album artist.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AlbumArtist { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AlbumId { get; set; }
		
		/// <summary>
		/// Gets or sets the artists.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Artists { get; set; }
		
		/// <summary>
		/// Gets or sets the backdrop image item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackdropImageItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the backdrop image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string BackdropImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the channel identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// Gets or sets the episode count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> EpisodeCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the index number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsFolder { get; set; }
		
		/// <summary>
		/// Gets or sets the item id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the matched term.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MatchedTerm { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the media.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MediaType { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the parent index number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the primary image aspect ratio.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> PrimaryImageAspectRatio { get; set; }
		
		/// <summary>
		/// Gets or sets the image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PrimaryImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the production year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProductionYear { get; set; }
		
		/// <summary>
		/// Gets or sets the run time ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> RunTimeTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the series.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Series { get; set; }
		
		/// <summary>
		/// Gets or sets the song count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SongCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Status { get; set; }
		
		/// <summary>
		/// Gets or sets the thumb image item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ThumbImageItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the thumb image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ThumbImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Class SearchHintResult.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SearchHintResult
	{
		
		/// <summary>
		/// Gets or sets the search hints.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SearchHint[] SearchHints { get; set; }
		
		/// <summary>
		/// Gets or sets the total record count.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	/// <summary>
	/// Class SeekRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SeekRequestDto
	{
		
		/// <summary>
		/// Gets or sets the position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PositionTicks { get; set; }
	}
	
	/// <summary>
	/// Class SendCommand.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendCommand
	{
		
		/// <summary>
		/// Enum SendCommandType.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<SendCommandCommand> Command { get; set; }
		
		/// <summary>
		/// Gets the UTC time when this command has been emitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EmittedAt { get; set; }
		
		/// <summary>
		/// Gets the group identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string GroupId { get; set; }
		
		/// <summary>
		/// Gets the playlist identifier of the playing item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
		
		/// <summary>
		/// Gets the position ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> PositionTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the UTC time when to execute the command.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> When { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SendCommandCommand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unpause")]
		Unpause = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Pause")]
		Pause = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Stop")]
		Stop = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Seek")]
		Seek = 3,
	}
	
	/// <summary>
	/// Enum SendCommandType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SendCommandType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unpause")]
		Unpause = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Pause")]
		Pause = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Stop")]
		Stop = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Seek")]
		Seek = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SeriesInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SeriesInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SeriesInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	/// <summary>
	/// Enum SeriesStatus.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SeriesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Continuing")]
		Continuing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Ended")]
		Ended = 1,
	}
	
	/// <summary>
	/// Class SeriesTimerInfoDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SeriesTimerInfoDto
	{
		
		/// <summary>
		/// ChannelId of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelId { get; set; }
		
		/// <summary>
		/// ChannelName of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelPrimaryImageTag { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DayPattern DayPattern { get; set; }
		
		/// <summary>
		/// Gets or sets the days.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DayOfWeek[] Days { get; set; }
		
		/// <summary>
		/// The end date of the recording, in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// Gets or sets the external channel identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ExternalChannelId { get; set; }
		
		/// <summary>
		/// Gets or sets the external identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
		
		/// <summary>
		/// Gets or sets the external program identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ExternalProgramId { get; set; }
		
		/// <summary>
		/// Id of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the image tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ImageTags { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is post padding required.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPostPaddingRequired { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is pre padding required.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPrePaddingRequired { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeepUntil KeepUntil { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> KeepUpTo { get; set; }
		
		/// <summary>
		/// Name of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Description of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Overview { get; set; }
		
		/// <summary>
		/// Gets or sets the parent backdrop image tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ParentBackdropImageTags { get; set; }
		
		/// <summary>
		/// If the item does not have any backdrops, this will hold the Id of the Parent that has one.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentBackdropItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the parent primary image item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentPrimaryImageItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the parent primary image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentPrimaryImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the parent thumb image tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentThumbImageTag { get; set; }
		
		/// <summary>
		/// Gets or sets the parent thumb item id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentThumbItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the post padding seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PostPaddingSeconds { get; set; }
		
		/// <summary>
		/// Gets or sets the pre padding seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PrePaddingSeconds { get; set; }
		
		/// <summary>
		/// Gets or sets the priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// Gets or sets the program identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProgramId { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [record any channel].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RecordAnyChannel { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [record any time].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RecordAnyTime { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [record new only].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RecordNewOnly { get; set; }
		
		/// <summary>
		/// Gets or sets the server identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServiceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SkipEpisodesInLibrary { get; set; }
		
		/// <summary>
		/// The start date of the recording, in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SeriesTimerInfoDtoQueryResult
	{
		
		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SeriesTimerInfoDto[] Items { get; set; }
		
		/// <summary>
		/// The index of the first record in Items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// The total number of records available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	/// <summary>
	/// Represents the server configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServerConfiguration
	{
		
		/// <summary>
		/// Gets or sets the number of days we should retain activity logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ActivityLogRetentionDays { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether Autodiscovery is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AutoDiscovery { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether Autodiscovery tracing is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AutoDiscoveryTracing { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the cache path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CachePath { get; set; }
		
		/// <summary>
		/// Gets or sets the password required to access the X.509 certificate data in the file specified by MediaBrowser.Model.Configuration.ServerConfiguration.CertificatePath.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CertificatePassword { get; set; }
		
		/// <summary>
		/// Gets or sets the filesystem path of an X.509 certificate to use for SSL.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CertificatePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] CodecsUsed { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NameValuePair[] ContentTypes { get; set; }
		
		/// <summary>
		/// Gets or sets the cors hosts.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] CorsHosts { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DisableLiveTvChannelUserDataName { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether plugin image should be disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DisablePluginImages { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DisplaySpecialsWithinSeasons { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [enable case sensitive item ids].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableCaseSensitiveItemIds { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [enable dashboard response caching].
		///Allows potential contributors without visual studio to modify production dashboard code and test changes.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableDashboardResponseCaching { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableExternalContentInSuggestions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableFolderView { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableGroupingIntoCollections { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to use HTTPS.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableHttps { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether IPV4 capability is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableIPV4 { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether IPV6 capability is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableIPV6 { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to enable prometheus metrics exporting.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableMetrics { get; set; }
		
		/// <summary>
		/// Gets a value indicating whether multi-socket binding is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableMultiSocketBinding { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableNewOmdbSupport { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableNormalizedItemByNameIds { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether access outside of the LAN is permitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableRemoteAccess { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether detailed ssdp logs are sent to the console/log.
		///"Emby.Dlna": "Debug" must be set in logging.default.json for this property to work.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSSDPTracing { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSimpleArtistDetection { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether slow server responses should be logged as a warning.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSlowResponseWarning { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to enable automatic port forwarding.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableUPnP { get; set; }
		
		/// <summary>
		/// Gets or sets the time (in seconds) between the pings of SSDP gateway monitor.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> GatewayMonitorPeriod { get; set; }
		
		/// <summary>
		/// Gets or sets the ports that HDHomerun uses.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string HDHomerunPortRange { get; set; }
		
		/// <summary>
		/// Gets or sets the HTTP server port number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> HttpServerPortNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the HTTPS server port number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> HttpsPortNumber { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether address names that match MediaBrowser.Model.Configuration.ServerConfiguration.VirtualInterfaceNames should be Ignore for the purposes of binding.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IgnoreVirtualInterfaces { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ImageExtractionTimeoutMs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ImageSavingConvention ImageSavingConvention { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is port authorized.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPortAuthorized { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether <seealso cref="P:MediaBrowser.Model.Configuration.ServerConfiguration.RemoteIPFilter" /> contains a blacklist or a whitelist. Default is a whitelist.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsRemoteIPFilterBlacklist { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is first run.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsStartupWizardCompleted { get; set; }
		
		/// <summary>
		/// Gets or sets the known proxies.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] KnownProxies { get; set; }
		
		/// <summary>
		/// Gets or sets the how many metadata refreshes can run concurrently.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> LibraryMetadataRefreshConcurrency { get; set; }
		
		/// <summary>
		/// Gets or sets the delay in seconds that we will wait after a file system change to try and discover what has been added/removed
		///Some delay is necessary with some items because their creation is not atomic.  It involves the creation of several
		///different directories and files.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> LibraryMonitorDelay { get; set; }
		
		/// <summary>
		/// Gets or sets the how the library scan fans out.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> LibraryScanFanoutConcurrency { get; set; }
		
		/// <summary>
		/// Gets or sets the interface addresses which Jellyfin will bind to. If empty, all interfaces will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] LocalNetworkAddresses { get; set; }
		
		/// <summary>
		/// Gets or sets the subnets that are deemed to make up the LAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] LocalNetworkSubnets { get; set; }
		
		/// <summary>
		/// Gets or sets the number of days we should retain log files.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> LogFileRetentionDays { get; set; }
		
		/// <summary>
		/// Gets or sets the remaining minutes of a book that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxAudiobookResume { get; set; }
		
		/// <summary>
		/// Gets or sets the maximum percentage of an item that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResumePct { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MetadataNetworkPath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MetadataOptions[] MetadataOptions { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataPath { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum minutes of a book that must be played in order for playstate to be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinAudiobookResume { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum duration that an item must have in order to be eligible for playstate updates..
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinResumeDurationSeconds { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum percentage of an item that must be played in order for playstate to be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinResumePct { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PathSubstitution[] PathSubstitutions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RepositoryInfo[] PluginRepositories { get; set; }
		
		/// <summary>
		/// Gets or sets the preferred metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PreferredMetadataLanguage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Version PreviousVersion { get; set; }
		
		/// <summary>
		/// Gets or sets the stringified PreviousVersion to be stored/loaded,
		///because System.Version itself isn't xml-serializable.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PreviousVersionStr { get; set; }
		
		/// <summary>
		/// Gets or sets the public HTTPS port.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PublicHttpsPort { get; set; }
		
		/// <summary>
		/// Gets or sets the public mapped port.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PublicPort { get; set; }
		
		/// <summary>
		/// Gets or sets PublishedServerUri to advertise for specific subnets.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] PublishedServerUriBySubnet { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether quick connect is available for use on this server.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> QuickConnectAvailable { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> RemoteClientBitrateLimit { get; set; }
		
		/// <summary>
		/// Gets or sets the filter for remote IP connectivity. Used in conjuntion with <seealso cref="P:MediaBrowser.Model.Configuration.ServerConfiguration.IsRemoteIPFilterBlacklist" />.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] RemoteIPFilter { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether older plugins should automatically be deleted from the plugin folder.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RemoveOldPlugins { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether the server should force connections over HTTPS.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> RequireHttps { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether an IP address is to be used to filter the detailed ssdp logs that are being sent to the console/log.
		///If the setting "Emby.Dlna": "Debug" msut be set in logging.default.json for this property to work.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SSDPTracingFilter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SaveMetadataHidden { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SkipDeserializationForBasicTypes { get; set; }
		
		/// <summary>
		/// Gets or sets the threshold for the slow response time warning in ms.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> SlowResponseThresholdMs { get; set; }
		
		/// <summary>
		/// Gets or sets characters to be removed from strings to create a sort name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] SortRemoveCharacters { get; set; }
		
		/// <summary>
		/// Gets or sets words to be removed from strings to create a sort name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] SortRemoveWords { get; set; }
		
		/// <summary>
		/// Gets or sets characters to be replaced with a ' ' in strings to create a sort name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] SortReplaceCharacters { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether all IPv6 interfaces should be treated as on the internal network.
		///Depending on the address range implemented ULA ranges might not be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> TrustAllIP6Interfaces { get; set; }
		
		/// <summary>
		/// Gets or sets client udp port range.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UDPPortRange { get; set; }
		
		/// <summary>
		/// Gets or sets the number of times SSDP UDP messages are sent.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UDPSendCount { get; set; }
		
		/// <summary>
		/// Gets or sets the delay between each groups of SSDP messages (in ms).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UDPSendDelay { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UICulture { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether the http port should be mapped as part of UPnP automatic port forwarding.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UPnPCreateHttpPortMap { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] UninstalledPlugins { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating the interfaces that should be ignored. The list can be comma separated. <seealso cref="P:MediaBrowser.Model.Configuration.ServerConfiguration.IgnoreVirtualInterfaces" />.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VirtualInterfaceNames { get; set; }
	}
	
	/// <summary>
	/// Set channel mapping dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetChannelMappingDto
	{
		
		/// <summary>
		/// Gets or sets the provider channel id.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ProviderChannelId { get; set; }
		
		/// <summary>
		/// Gets or sets the provider id.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ProviderId { get; set; }
		
		/// <summary>
		/// Gets or sets the tuner channel id.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TunerChannelId { get; set; }
	}
	
	/// <summary>
	/// Class SetPlaylistItemRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetPlaylistItemRequestDto
	{
		
		/// <summary>
		/// Gets or sets the playlist identifier of the playing item.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PlaylistItemId { get; set; }
	}
	
	/// <summary>
	/// Class SetRepeatModeRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetRepeatModeRequestDto
	{
		
		/// <summary>
		/// Enum GroupRepeatMode.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GroupRepeatMode Mode { get; set; }
	}
	
	/// <summary>
	/// Class SetShuffleModeRequestDto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetShuffleModeRequestDto
	{
		
		/// <summary>
		/// Enum GroupShuffleMode.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public GroupShuffleMode Mode { get; set; }
	}
	
	/// <summary>
	/// An enum representing the sorting order.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Ascending")]
		Ascending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Descending")]
		Descending = 1,
	}
	
	/// <summary>
	/// Special view option dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SpecialViewOptionDto
	{
		
		/// <summary>
		/// Gets or sets view option id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets view option name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The startup configuration DTO.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartupConfigurationDto
	{
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the preferred language for the metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PreferredMetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets UI language culture.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string UICulture { get; set; }
	}
	
	/// <summary>
	/// Startup remote access dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartupRemoteAccessDto
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether enable automatic port mapping.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnableAutomaticPortMapping { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether enable remote access.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnableRemoteAccess { get; set; }
	}
	
	/// <summary>
	/// The startup user DTO.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartupUserDto
	{
		
		/// <summary>
		/// Gets or sets the username.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the user's password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SubtitleDeliveryMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Encode")]
		Encode = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Embed")]
		Embed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="External")]
		External = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Hls")]
		Hls = 3,
	}
	
	/// <summary>
	/// An enum representing a subtitle playback mode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SubtitlePlaybackMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Default")]
		Default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Always")]
		Always = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OnlyForced")]
		OnlyForced = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Smart")]
		Smart = 4,
	}
	
	/// <summary>
	/// Enum SyncPlayUserAccessType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SyncPlayUserAccessType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CreateAndJoinGroups")]
		CreateAndJoinGroups = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="JoinGroups")]
		JoinGroups = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 2,
	}
	
	/// <summary>
	/// Class SystemInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SystemInfo
	{
		
		/// <summary>
		/// Gets or sets the cache path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CachePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanLaunchWebBrowser { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance can self restart.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> CanSelfRestart { get; set; }
		
		/// <summary>
		/// Gets or sets the completed installations.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public InstallationInfo[] CompletedInstallations { get; set; }
		
		/// <summary>
		/// Enum describing the location of the FFmpeg tool.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<SystemInfoEncoderLocation> EncoderLocation { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance has pending restart.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasPendingRestart { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance has update available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> HasUpdateAvailable { get; set; }
		
		/// <summary>
		/// Gets or sets the id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the internal metadata path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string InternalMetadataPath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsShuttingDown { get; set; }
		
		/// <summary>
		/// Gets or sets the items by name path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemsByNamePath { get; set; }
		
		/// <summary>
		/// Gets or sets the local address.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LocalAddress { get; set; }
		
		/// <summary>
		/// Gets or sets the log path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LogPath { get; set; }
		
		/// <summary>
		/// Gets or sets the operating system.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OperatingSystem { get; set; }
		
		/// <summary>
		/// Gets or sets the display name of the operating system.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string OperatingSystemDisplayName { get; set; }
		
		/// <summary>
		/// Get or sets the package name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PackageName { get; set; }
		
		/// <summary>
		/// Gets or sets the product name. This is the AssemblyProduct name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProductName { get; set; }
		
		/// <summary>
		/// Gets or sets the program data path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProgramDataPath { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServerName { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether the startup wizard is completed.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> StartupWizardCompleted { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether [supports library monitor].
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SupportsLibraryMonitor { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Architecture SystemArchitecture { get; set; }
		
		/// <summary>
		/// Gets or sets the transcode path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TranscodingTempPath { get; set; }
		
		/// <summary>
		/// Gets or sets the server version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
		
		/// <summary>
		/// Gets or sets the web UI resources path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string WebPath { get; set; }
		
		/// <summary>
		/// Gets or sets the web socket port number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> WebSocketPortNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SystemInfoEncoderLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotFound")]
		NotFound = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SetByArgument")]
		SetByArgument = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom")]
		Custom = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 3,
	}
	
	/// <summary>
	/// Enum TaskCompletionStatus.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TaskCompletionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Completed")]
		Completed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Failed")]
		Failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cancelled")]
		Cancelled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Aborted")]
		Aborted = 3,
	}
	
	/// <summary>
	/// Class TaskInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskInfo
	{
		
		/// <summary>
		/// Gets or sets the category.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Category { get; set; }
		
		/// <summary>
		/// Gets or sets the progress.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> CurrentProgressPercentage { get; set; }
		
		/// <summary>
		/// Gets or sets the description.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Gets or sets the id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is hidden.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsHidden { get; set; }
		
		/// <summary>
		/// Gets or sets the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Class TaskExecutionInfo.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TaskResult LastExecutionResult { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Enum TaskState.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<TaskInfoState> State { get; set; }
		
		/// <summary>
		/// Gets or sets the triggers.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TaskTriggerInfo[] Triggers { get; set; }
	}
	
	/// <summary>
	/// Class TaskExecutionInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskResult
	{
		
		/// <summary>
		/// Gets or sets the end time UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndTimeUtc { get; set; }
		
		/// <summary>
		/// Gets or sets the error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ErrorMessage { get; set; }
		
		/// <summary>
		/// Gets or sets the id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Gets or sets the long error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LongErrorMessage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the start time UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartTimeUtc { get; set; }
		
		/// <summary>
		/// Enum TaskCompletionStatus.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TaskCompletionStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TaskInfoState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Idle")]
		Idle = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cancelling")]
		Cancelling = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Running")]
		Running = 2,
	}
	
	/// <summary>
	/// Class TaskTriggerInfo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskTriggerInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DayOfWeek DayOfWeek { get; set; }
		
		/// <summary>
		/// Gets or sets the interval.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> IntervalTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the maximum runtime ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> MaxRuntimeTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the time of day.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> TimeOfDayTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the type.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Enum TaskState.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TaskState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Idle")]
		Idle = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cancelling")]
		Cancelling = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Running")]
		Running = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimerEventInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProgramId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimerInfoDto
	{
		
		/// <summary>
		/// ChannelId of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelId { get; set; }
		
		/// <summary>
		/// ChannelName of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelPrimaryImageTag { get; set; }
		
		/// <summary>
		/// The end date of the recording, in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// Gets or sets the external channel identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ExternalChannelId { get; set; }
		
		/// <summary>
		/// Gets or sets the external identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
		
		/// <summary>
		/// Gets or sets the external program identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ExternalProgramId { get; set; }
		
		/// <summary>
		/// Gets or sets the external series timer identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ExternalSeriesTimerId { get; set; }
		
		/// <summary>
		/// Id of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is post padding required.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPostPaddingRequired { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether this instance is pre padding required.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsPrePaddingRequired { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeepUntil KeepUntil { get; set; }
		
		/// <summary>
		/// Name of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Description of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Overview { get; set; }
		
		/// <summary>
		/// Gets or sets the parent backdrop image tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] ParentBackdropImageTags { get; set; }
		
		/// <summary>
		/// If the item does not have any backdrops, this will hold the Id of the Parent that has one.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ParentBackdropItemId { get; set; }
		
		/// <summary>
		/// Gets or sets the post padding seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PostPaddingSeconds { get; set; }
		
		/// <summary>
		/// Gets or sets the pre padding seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PrePaddingSeconds { get; set; }
		
		/// <summary>
		/// Gets or sets the priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// Gets or sets the program identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ProgramId { get; set; }
		
		/// <summary>
		/// This is strictly used as a data transfer object from the api layer.
		///This holds information about a BaseItem in a format that is convenient for the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BaseItemDto ProgramInfo { get; set; }
		
		/// <summary>
		/// Gets or sets the run time ticks.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int64> RunTimeTicks { get; set; }
		
		/// <summary>
		/// Gets or sets the series timer identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SeriesTimerId { get; set; }
		
		/// <summary>
		/// Gets or sets the server identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ServiceName { get; set; }
		
		/// <summary>
		/// The start date of the recording, in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RecordingStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimerInfoDtoQueryResult
	{
		
		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TimerInfoDto[] Items { get; set; }
		
		/// <summary>
		/// The index of the first record in Items.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartIndex { get; set; }
		
		/// <summary>
		/// The total number of records available.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalRecordCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrailerInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata country code.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataCountryCode { get; set; }
		
		/// <summary>
		/// Gets or sets the metadata language.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MetadataLanguage { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ParentIndexNumber { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> PremiereDate { get; set; }
		
		/// <summary>
		/// Gets or sets the provider ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> ProviderIds { get; set; }
		
		/// <summary>
		/// Gets or sets the year.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrailerInfoRemoteSearchQuery
	{
		
		/// <summary>
		/// Gets or sets a value indicating whether disabled providers should be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IncludeDisabledProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TrailerInfo SearchInfo { get; set; }
		
		/// <summary>
		/// Will only search within the given provider when set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SearchProviderName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TranscodeSeekInfo
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Auto")]
		Auto = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Bytes")]
		Bytes = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TransportStreamTimestamp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="None")]
		None = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Zero")]
		Zero = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Valid")]
		Valid = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TunerHostInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AllowHWTranscoding { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DeviceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableStreamLooping { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FriendlyName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ImportFavoritesOnly { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Source { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TunerCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserAgent { get; set; }
	}
	
	/// <summary>
	/// Update library options dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateLibraryOptionsDto
	{
		
		/// <summary>
		/// Gets or sets the library item id.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LibraryOptions LibraryOptions { get; set; }
	}
	
	/// <summary>
	/// The update user easy password request body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateUserEasyPassword
	{
		
		/// <summary>
		/// Gets or sets the new sha1-hashed password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string NewPassword { get; set; }
		
		/// <summary>
		/// Gets or sets the new password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string NewPw { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to reset the password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ResetPassword { get; set; }
	}
	
	/// <summary>
	/// The update user password request body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateUserPassword
	{
		
		/// <summary>
		/// Gets or sets the current sha1-hashed password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CurrentPassword { get; set; }
		
		/// <summary>
		/// Gets or sets the current plain text password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CurrentPw { get; set; }
		
		/// <summary>
		/// Gets or sets the new plain text password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string NewPw { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether to reset the password.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ResetPassword { get; set; }
	}
	
	/// <summary>
	/// Upload subtitles dto.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UploadSubtitleDto
	{
		
		/// <summary>
		/// Gets or sets the subtitle data.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Data { get; set; }
		
		/// <summary>
		/// Gets or sets the subtitle format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Format { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether the subtitle is forced.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsForced { get; set; }
		
		/// <summary>
		/// Gets or sets the subtitle language.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Language { get; set; }
	}
	
	/// <summary>
	/// Class UtcTimeResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UtcTimeResponse
	{
		
		/// <summary>
		/// Gets the UTC time when request has been received.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> RequestReceptionTime { get; set; }
		
		/// <summary>
		/// Gets the UTC time when response has been sent.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ResponseTransmissionTime { get; set; }
	}
	
	/// <summary>
	/// Validate path object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidatePathDto
	{
		
		/// <summary>
		/// Gets or sets is path file.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsFile { get; set; }
		
		/// <summary>
		/// Gets or sets the path.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		/// <summary>
		/// Gets or sets a value indicating whether validate if path is writable.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ValidateWritable { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Video3DFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HalfSideBySide")]
		HalfSideBySide = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FullSideBySide")]
		FullSideBySide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FullTopAndBottom")]
		FullTopAndBottom = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HalfTopAndBottom")]
		HalfTopAndBottom = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MVC")]
		MVC = 4,
	}
	
	/// <summary>
	/// Enum VideoType.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VideoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoFile")]
		VideoFile = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Iso")]
		Iso = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Dvd")]
		Dvd = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BluRay")]
		BluRay = 3,
	}
	
	/// <summary>
	/// Used to hold information about a user's list of configured virtual folders.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualFolderInfo
	{
		
		/// <summary>
		/// Gets or sets the type of the collection.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string CollectionType { get; set; }
		
		/// <summary>
		/// Gets or sets the item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string ItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LibraryOptions LibraryOptions { get; set; }
		
		/// <summary>
		/// Gets or sets the locations.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] Locations { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the primary image item identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string PrimaryImageItemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> RefreshProgress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RefreshStatus { get; set; }
	}
	
	/// <summary>
	/// Provides the MAC address and port for wake-on-LAN functionality.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WakeOnLanInfo
	{
		
		/// <summary>
		/// Gets the MAC address of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string MacAddress { get; set; }
		
		/// <summary>
		/// Gets or sets the wake-on-LAN port.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Creates an instant playlist based on a given song.
		/// GetInstantMixFromAlbum Albums/{id}/InstantMix
		/// </summary>
		/// <param name="id">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <returns>Instant playlist returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetInstantMixFromAlbumAsync(string id, string userId, int limit, ItemFields[] fields, bool enableImages, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Albums/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/InstantMix&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableImages="+enableImages+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets similar items.
		/// GetSimilarAlbums Albums/{itemId}/Similar
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="excludeArtistIds">Exclude artist ids.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.</param>
		/// <returns>Similar items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetSimilarAlbumsAsync(string itemId, string[] excludeArtistIds, string userId, int limit, ItemFields[] fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Albums/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Similar&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all artists from a given item, folder, or the entire library.
		/// GetArtists Artists
		/// </summary>
		/// <param name="minCommunityRating">Optional filter by minimum community rating.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="searchTerm">Optional. Search term.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="filters">Optional. Specify additional filters to apply.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not.</param>
		/// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited.</param>
		/// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.</param>
		/// <param name="genreIds">Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.</param>
		/// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.</param>
		/// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.</param>
		/// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.</param>
		/// <param name="enableUserData">Optional, include user data.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person.</param>
		/// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person ids.</param>
		/// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.</param>
		/// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.</param>
		/// <param name="studioIds">Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.</param>
		/// <param name="userId">User id.</param>
		/// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string.</param>
		/// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string.</param>
		/// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <param name="enableTotalRecordCount">Total record count.</param>
		/// <returns>Artists returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetArtistsAsync(
					double minCommunityRating, 
					int startIndex, 
					int limit, 
					string searchTerm, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					string[] includeItemTypes, 
					ItemFilter[] filters, 
					bool isFavorite, 
					string[] mediaTypes, 
					string[] genres, 
					string[] genreIds, 
					string[] officialRatings, 
					string[] tags, 
					int[] years, 
					bool enableUserData, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string person, 
					string[] personIds, 
					string[] personTypes, 
					string[] studios, 
					string[] studioIds, 
					string userId, 
					string nameStartsWithOrGreater, 
					string nameStartsWith, 
					string nameLessThan, 
					bool enableImages, 
					bool enableTotalRecordCount, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Artists?minCommunityRating="+minCommunityRating+"&startIndex="+startIndex+"&limit="+limit+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", filters.Select(z => $"filters={z}"))+"&isFavorite="+isFavorite+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", genres.Select(z => $"genres={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", genreIds.Select(z => $"genreIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", officialRatings.Select(z => $"officialRatings={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", years.Select(z => $"years={z}"))+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&person=" + (person==null? "" : System.Uri.EscapeDataString(person))+"&"+string.Join("&", personIds.Select(z => $"personIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", personTypes.Select(z => $"personTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", studios.Select(z => $"studios={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", studioIds.Select(z => $"studioIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&nameStartsWithOrGreater=" + (nameStartsWithOrGreater==null? "" : System.Uri.EscapeDataString(nameStartsWithOrGreater))+"&nameStartsWith=" + (nameStartsWith==null? "" : System.Uri.EscapeDataString(nameStartsWith))+"&nameLessThan=" + (nameLessThan==null? "" : System.Uri.EscapeDataString(nameLessThan))+"&enableImages="+enableImages+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all album artists from a given item, folder, or the entire library.
		/// GetAlbumArtists Artists/AlbumArtists
		/// </summary>
		/// <param name="minCommunityRating">Optional filter by minimum community rating.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="searchTerm">Optional. Search term.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="filters">Optional. Specify additional filters to apply.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not.</param>
		/// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited.</param>
		/// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.</param>
		/// <param name="genreIds">Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.</param>
		/// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.</param>
		/// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.</param>
		/// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.</param>
		/// <param name="enableUserData">Optional, include user data.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person.</param>
		/// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person ids.</param>
		/// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.</param>
		/// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.</param>
		/// <param name="studioIds">Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.</param>
		/// <param name="userId">User id.</param>
		/// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string.</param>
		/// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string.</param>
		/// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <param name="enableTotalRecordCount">Total record count.</param>
		/// <returns>Album artists returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetAlbumArtistsAsync(
					double minCommunityRating, 
					int startIndex, 
					int limit, 
					string searchTerm, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					string[] includeItemTypes, 
					ItemFilter[] filters, 
					bool isFavorite, 
					string[] mediaTypes, 
					string[] genres, 
					string[] genreIds, 
					string[] officialRatings, 
					string[] tags, 
					int[] years, 
					bool enableUserData, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string person, 
					string[] personIds, 
					string[] personTypes, 
					string[] studios, 
					string[] studioIds, 
					string userId, 
					string nameStartsWithOrGreater, 
					string nameStartsWith, 
					string nameLessThan, 
					bool enableImages, 
					bool enableTotalRecordCount, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Artists/AlbumArtists?minCommunityRating="+minCommunityRating+"&startIndex="+startIndex+"&limit="+limit+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", filters.Select(z => $"filters={z}"))+"&isFavorite="+isFavorite+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", genres.Select(z => $"genres={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", genreIds.Select(z => $"genreIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", officialRatings.Select(z => $"officialRatings={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", years.Select(z => $"years={z}"))+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&person=" + (person==null? "" : System.Uri.EscapeDataString(person))+"&"+string.Join("&", personIds.Select(z => $"personIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", personTypes.Select(z => $"personTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", studios.Select(z => $"studios={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", studioIds.Select(z => $"studioIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&nameStartsWithOrGreater=" + (nameStartsWithOrGreater==null? "" : System.Uri.EscapeDataString(nameStartsWithOrGreater))+"&nameStartsWith=" + (nameStartsWith==null? "" : System.Uri.EscapeDataString(nameStartsWith))+"&nameLessThan=" + (nameLessThan==null? "" : System.Uri.EscapeDataString(nameLessThan))+"&enableImages="+enableImages+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an instant playlist based on a given song.
		/// GetInstantMixFromArtists Artists/{id}/InstantMix
		/// </summary>
		/// <param name="id">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <returns>Instant playlist returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetInstantMixFromArtistsAsync(string id, string userId, int limit, ItemFields[] fields, bool enableImages, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Artists/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/InstantMix&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableImages="+enableImages+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets similar items.
		/// GetSimilarArtists Artists/{itemId}/Similar
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="excludeArtistIds">Exclude artist ids.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.</param>
		/// <returns>Similar items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetSimilarArtistsAsync(string itemId, string[] excludeArtistIds, string userId, int limit, ItemFields[] fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Artists/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Similar&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an artist by name.
		/// GetArtistByName Artists/{name}
		/// </summary>
		/// <param name="name">Studio name.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <returns>Artist returned.</returns>
		public async Task<BaseItemDto> GetArtistByNameAsync(string name, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Artists/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artist image by name.
		/// GetArtistImage Artists/{name}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="name">Artist name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetArtistImageAsync(
					string name, 
					ImageOptionType imageType, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					int imageIndex, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Artists/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"/"+imageIndex+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the specified audio segment for an audio item.
		/// GetHlsAudioSegmentLegacyAac Audio/{itemId}/hls/{segmentId}/stream.aac
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="segmentId">The segment id.</param>
		/// <returns>Hls audio segment returned.</returns>
		public async Task GetHlsAudioSegmentLegacyAacAsync(string itemId, string segmentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Audio/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/hls/"+ (segmentId==null? "" : System.Uri.EscapeDataString(segmentId))+"/stream.aac";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the specified audio segment for an audio item.
		/// GetHlsAudioSegmentLegacyMp3 Audio/{itemId}/hls/{segmentId}/stream.mp3
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="segmentId">The segment id.</param>
		/// <returns>Hls audio segment returned.</returns>
		public async Task GetHlsAudioSegmentLegacyMp3Async(string itemId, string segmentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Audio/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/hls/"+ (segmentId==null? "" : System.Uri.EscapeDataString(segmentId))+"/stream.mp3";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a video stream using HTTP live streaming.
		/// GetHlsAudioSegment Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="playlistId">The playlist id.</param>
		/// <param name="segmentId">The segment id.</param>
		/// <param name="container">The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment length.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="maxStreamingBitrate">Optional. The maximum streaming bitrate.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <returns>Video stream returned.</returns>
		public async Task GetHlsAudioSegmentAsync(
					string itemId, 
					string playlistId, 
					int segmentId, 
					string container, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int maxStreamingBitrate, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Audio/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/hls1/"+ (playlistId==null? "" : System.Uri.EscapeDataString(playlistId))+"/"+segmentId+"."+ (container==null? "" : System.Uri.EscapeDataString(container))+"&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&maxStreamingBitrate="+maxStreamingBitrate+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an audio stream using HTTP live streaming.
		/// GetVariantHlsAudioPlaylist Audio/{itemId}/main.m3u8
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment length.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="maxStreamingBitrate">Optional. The maximum streaming bitrate.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <returns>Audio stream returned.</returns>
		public async Task GetVariantHlsAudioPlaylistAsync(
					string itemId, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int maxStreamingBitrate, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Audio/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/main.m3u8&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&maxStreamingBitrate="+maxStreamingBitrate+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an audio hls playlist stream.
		/// GetMasterHlsAudioPlaylist Audio/{itemId}/master.m3u8
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment length.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="maxStreamingBitrate">Optional. The maximum streaming bitrate.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <param name="enableAdaptiveBitrateStreaming">Enable adaptive bitrate streaming.</param>
		/// <returns>Audio stream returned.</returns>
		public async Task GetMasterHlsAudioPlaylistAsync(
					string itemId, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int maxStreamingBitrate, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					bool enableAdaptiveBitrateStreaming, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Audio/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/master.m3u8&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&maxStreamingBitrate="+maxStreamingBitrate+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions+"&enableAdaptiveBitrateStreaming="+enableAdaptiveBitrateStreaming;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an audio stream.
		/// GetAudioStream Audio/{itemId}/stream
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="container">The audio container.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment length.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <returns>Audio stream returned.</returns>
		public async Task GetAudioStreamAsync(
					string itemId, 
					string container, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Audio/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/stream&container=" + (container==null? "" : System.Uri.EscapeDataString(container))+"&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an audio stream.
		/// GetAudioStreamByContainer Audio/{itemId}/stream.{container}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="container">The audio container.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment lenght.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamporphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <returns>Audio stream returned.</returns>
		public async Task GetAudioStreamByContainerAsync(
					string itemId, 
					string container, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Audio/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/stream."+ (container==null? "" : System.Uri.EscapeDataString(container))+"&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an audio stream.
		/// GetUniversalAudioStream Audio/{itemId}/universal
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="container">Optional. The audio container.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="userId">Optional. The user id.</param>
		/// <param name="audioCodec">Optional. The audio codec to transcode to.</param>
		/// <param name="maxAudioChannels">Optional. The maximum number of audio channels.</param>
		/// <param name="transcodingAudioChannels">Optional. The number of how many audio channels to transcode to.</param>
		/// <param name="maxStreamingBitrate">Optional. The maximum streaming bitrate.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="transcodingContainer">Optional. The container to transcode to.</param>
		/// <param name="transcodingProtocol">Optional. The transcoding protocol.</param>
		/// <param name="maxAudioSampleRate">Optional. The maximum audio sample rate.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="enableRemoteMedia">Optional. Whether to enable remote media.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="enableRedirection">Whether to enable redirection. Defaults to true.</param>
		/// <returns>Audio stream returned.</returns>
		public async Task GetUniversalAudioStreamAsync(
					string itemId, 
					string[] container, 
					string mediaSourceId, 
					string deviceId, 
					string userId, 
					string audioCodec, 
					int maxAudioChannels, 
					int transcodingAudioChannels, 
					int maxStreamingBitrate, 
					int audioBitRate, 
					long startTimeTicks, 
					string transcodingContainer, 
					string transcodingProtocol, 
					int maxAudioSampleRate, 
					int maxAudioBitDepth, 
					bool enableRemoteMedia, 
					bool breakOnNonKeyFrames, 
					bool enableRedirection, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Audio/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/universal&"+string.Join("&", container.Select(z => $"container={System.Uri.EscapeDataString(z.ToString())}"))+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&maxAudioChannels="+maxAudioChannels+"&transcodingAudioChannels="+transcodingAudioChannels+"&maxStreamingBitrate="+maxStreamingBitrate+"&audioBitRate="+audioBitRate+"&startTimeTicks="+startTimeTicks+"&transcodingContainer=" + (transcodingContainer==null? "" : System.Uri.EscapeDataString(transcodingContainer))+"&transcodingProtocol=" + (transcodingProtocol==null? "" : System.Uri.EscapeDataString(transcodingProtocol))+"&maxAudioSampleRate="+maxAudioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&enableRemoteMedia="+enableRemoteMedia+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&enableRedirection="+enableRedirection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all keys.
		/// GetKeys Auth/Keys
		/// </summary>
		/// <returns>Api keys retrieved.</returns>
		public async Task<AuthenticationInfoQueryResult> GetKeysAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Auth/Keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AuthenticationInfoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new api key.
		/// CreateKey Auth/Keys
		/// </summary>
		/// <param name="app">Name of the app using the authentication key.</param>
		public async Task CreateKeyAsync(string app, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Auth/Keys?app=" + (app==null? "" : System.Uri.EscapeDataString(app));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove an api key.
		/// RevokeKey Auth/Keys/{key}
		/// </summary>
		/// <param name="key">The access token to delete.</param>
		public async Task RevokeKeyAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Auth/Keys/"+ (key==null? "" : System.Uri.EscapeDataString(key));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all password reset providers.
		/// GetPasswordResetProviders Auth/PasswordResetProviders
		/// </summary>
		/// <returns>Password reset providers retrieved.</returns>
		public async Task<NameIdPair[]> GetPasswordResetProvidersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Auth/PasswordResetProviders";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NameIdPair[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all auth providers.
		/// GetAuthProviders Auth/Providers
		/// </summary>
		/// <returns>Auth providers retrieved.</returns>
		public async Task<NameIdPair[]> GetAuthProvidersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Auth/Providers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NameIdPair[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets branding configuration.
		/// GetBrandingOptions Branding/Configuration
		/// </summary>
		/// <returns>Branding configuration returned.</returns>
		public async Task<BrandingOptions> GetBrandingOptionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Branding/Configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BrandingOptions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets branding css.
		/// GetBrandingCss Branding/Css
		/// </summary>
		/// <returns>Branding css returned.</returns>
		public async Task<string> GetBrandingCssAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Branding/Css";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets branding css.
		/// GetBrandingCss_2 Branding/Css.css
		/// </summary>
		/// <returns>Branding css returned.</returns>
		public async Task<string> GetBrandingCss_2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Branding/Css.css";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available channels.
		/// GetChannels Channels
		/// </summary>
		/// <param name="userId">User Id to filter by. Use System.Guid.Empty to not filter by user.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="supportsLatestItems">Optional. Filter by channels that support getting latest items.</param>
		/// <param name="supportsMediaDeletion">Optional. Filter by channels that support media deletion.</param>
		/// <param name="isFavorite">Optional. Filter by channels that are favorite.</param>
		/// <returns>Channels returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetChannelsAsync(string userId, int startIndex, int limit, bool supportsLatestItems, bool supportsMediaDeletion, bool isFavorite, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Channels?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&startIndex="+startIndex+"&limit="+limit+"&supportsLatestItems="+supportsLatestItems+"&supportsMediaDeletion="+supportsMediaDeletion+"&isFavorite="+isFavorite;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all channel features.
		/// GetAllChannelFeatures Channels/Features
		/// </summary>
		/// <returns>All channel features returned.</returns>
		public async Task<ChannelFeatures[]> GetAllChannelFeaturesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Channels/Features";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ChannelFeatures[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets latest channel items.
		/// GetLatestChannelItems Channels/Items/Latest
		/// </summary>
		/// <param name="userId">Optional. User Id.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="filters">Optional. Specify additional filters to apply.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="channelIds">Optional. Specify one or more channel id's, comma delimited.</param>
		/// <returns>Latest channel items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetLatestChannelItemsAsync(string userId, int startIndex, int limit, ItemFilter[] filters, ItemFields[] fields, string[] channelIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Channels/Items/Latest?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&startIndex="+startIndex+"&limit="+limit+"&"+string.Join("&", filters.Select(z => $"filters={z}"))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", channelIds.Select(z => $"channelIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get channel features.
		/// GetChannelFeatures Channels/{channelId}/Features
		/// </summary>
		/// <param name="channelId">Channel id.</param>
		/// <returns>Channel features returned.</returns>
		public async Task<ChannelFeatures> GetChannelFeaturesAsync(string channelId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Channels/"+ (channelId==null? "" : System.Uri.EscapeDataString(channelId))+"/Features";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ChannelFeatures>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get channel items.
		/// GetChannelItems Channels/{channelId}/Items
		/// </summary>
		/// <param name="channelId">Channel Id.</param>
		/// <param name="folderId">Optional. Folder Id.</param>
		/// <param name="userId">Optional. User Id.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="sortOrder">Optional. Sort Order - Ascending,Descending.</param>
		/// <param name="filters">Optional. Specify additional filters to apply.</param>
		/// <param name="sortBy">Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <returns>Channel items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetChannelItemsAsync(string channelId, string folderId, string userId, int startIndex, int limit, string sortOrder, ItemFilter[] filters, string sortBy, ItemFields[] fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Channels/"+ (channelId==null? "" : System.Uri.EscapeDataString(channelId))+"/Items&folderId=" + (folderId==null? "" : System.Uri.EscapeDataString(folderId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&startIndex="+startIndex+"&limit="+limit+"&sortOrder=" + (sortOrder==null? "" : System.Uri.EscapeDataString(sortOrder))+"&"+string.Join("&", filters.Select(z => $"filters={z}"))+"&sortBy=" + (sortBy==null? "" : System.Uri.EscapeDataString(sortBy))+"&"+string.Join("&", fields.Select(z => $"fields={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new collection.
		/// CreateCollection Collections
		/// </summary>
		/// <param name="name">The name of the collection.</param>
		/// <param name="ids">Item Ids to add to the collection.</param>
		/// <param name="parentId">Optional. Create the collection within a specific folder.</param>
		/// <param name="isLocked">Whether or not to lock the new collection.</param>
		/// <returns>Collection created.</returns>
		public async Task<CollectionCreationResult> CreateCollectionAsync(string name, string[] ids, string parentId, bool isLocked, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Collections?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&isLocked="+isLocked;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CollectionCreationResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes items from a collection.
		/// RemoveFromCollection Collections/{collectionId}/Items
		/// </summary>
		/// <param name="collectionId">The collection id.</param>
		/// <param name="ids">Item ids, comma delimited.</param>
		public async Task RemoveFromCollectionAsync(string collectionId, string[] ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Collections/"+ (collectionId==null? "" : System.Uri.EscapeDataString(collectionId))+"/Items&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds items to a collection.
		/// AddToCollection Collections/{collectionId}/Items
		/// </summary>
		/// <param name="collectionId">The collection id.</param>
		/// <param name="ids">Item ids, comma delimited.</param>
		public async Task AddToCollectionAsync(string collectionId, string[] ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Collections/"+ (collectionId==null? "" : System.Uri.EscapeDataString(collectionId))+"/Items&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a device.
		/// DeleteDevice Devices
		/// </summary>
		/// <param name="id">Device Id.</param>
		public async Task DeleteDeviceAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Devices?id=" + (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Devices.
		/// GetDevices Devices
		/// </summary>
		/// <param name="supportsSync">Gets or sets a value indicating whether [supports synchronize].</param>
		/// <param name="userId">Gets or sets the user identifier.</param>
		/// <returns>Devices retrieved.</returns>
		public async Task<DeviceInfoQueryResult> GetDevicesAsync(bool supportsSync, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Devices?supportsSync="+supportsSync+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeviceInfoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get info for a device.
		/// GetDeviceInfo Devices/Info
		/// </summary>
		/// <param name="id">Device Id.</param>
		/// <returns>Device info retrieved.</returns>
		public async Task<DeviceInfo> GetDeviceInfoAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Devices/Info?id=" + (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeviceInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get options for a device.
		/// GetDeviceOptions Devices/Options
		/// </summary>
		/// <param name="id">Device Id.</param>
		/// <returns>Device options retrieved.</returns>
		public async Task<DeviceOptions> GetDeviceOptionsAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Devices/Options?id=" + (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeviceOptions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update device options.
		/// UpdateDeviceOptions Devices/Options
		/// </summary>
		/// <param name="id">Device Id.</param>
		/// <param name="requestBody">Device Options.</param>
		public async Task UpdateDeviceOptionsAsync(string id, DeviceOptions requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Devices/Options?id=" + (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Display Preferences.
		/// GetDisplayPreferences DisplayPreferences/{displayPreferencesId}
		/// </summary>
		/// <param name="displayPreferencesId">Display preferences id.</param>
		/// <param name="userId">User id.</param>
		/// <param name="client">Client.</param>
		/// <returns>Display preferences retrieved.</returns>
		public async Task<DisplayPreferencesDto> GetDisplayPreferencesAsync(string displayPreferencesId, string userId, string client, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "DisplayPreferences/"+ (displayPreferencesId==null? "" : System.Uri.EscapeDataString(displayPreferencesId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&client=" + (client==null? "" : System.Uri.EscapeDataString(client));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DisplayPreferencesDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update Display Preferences.
		/// UpdateDisplayPreferences DisplayPreferences/{displayPreferencesId}
		/// </summary>
		/// <param name="displayPreferencesId">Display preferences id.</param>
		/// <param name="userId">User Id.</param>
		/// <param name="client">Client.</param>
		/// <param name="requestBody">New Display Preferences object.</param>
		public async Task UpdateDisplayPreferencesAsync(string displayPreferencesId, string userId, string client, DisplayPreferencesDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "DisplayPreferences/"+ (displayPreferencesId==null? "" : System.Uri.EscapeDataString(displayPreferencesId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&client=" + (client==null? "" : System.Uri.EscapeDataString(client));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get profile infos.
		/// GetProfileInfos Dlna/ProfileInfos
		/// </summary>
		/// <returns>Device profile infos returned.</returns>
		public async Task<DeviceProfileInfo[]> GetProfileInfosAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/ProfileInfos";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeviceProfileInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a profile.
		/// CreateProfile Dlna/Profiles
		/// </summary>
		/// <param name="requestBody">Device profile.</param>
		public async Task CreateProfileAsync(DeviceProfile requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/Profiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the default profile.
		/// GetDefaultProfile Dlna/Profiles/Default
		/// </summary>
		/// <returns>Default device profile returned.</returns>
		public async Task<DeviceProfile> GetDefaultProfileAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/Profiles/Default";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeviceProfile>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a profile.
		/// DeleteProfile Dlna/Profiles/{profileId}
		/// </summary>
		/// <param name="profileId">Profile id.</param>
		public async Task DeleteProfileAsync(string profileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/Profiles/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a single profile.
		/// GetProfile Dlna/Profiles/{profileId}
		/// </summary>
		/// <param name="profileId">Profile Id.</param>
		/// <returns>Device profile returned.</returns>
		public async Task<DeviceProfile> GetProfileAsync(string profileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/Profiles/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeviceProfile>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a profile.
		/// UpdateProfile Dlna/Profiles/{profileId}
		/// </summary>
		/// <param name="profileId">Profile id.</param>
		/// <param name="requestBody">Device profile.</param>
		public async Task UpdateProfileAsync(string profileId, DeviceProfile requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/Profiles/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a server icon.
		/// GetIcon Dlna/icons/{fileName}
		/// </summary>
		/// <param name="fileName">The icon filename.</param>
		/// <returns>Request processed.</returns>
		public async Task GetIconAsync(string fileName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/icons/"+ (fileName==null? "" : System.Uri.EscapeDataString(fileName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna media receiver registrar xml.
		/// GetConnectionManager Dlna/{serverId}/ConnectionManager
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna media receiver registrar xml returned.</returns>
		public async Task GetConnectionManagerAsync(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/ConnectionManager";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna media receiver registrar xml.
		/// GetConnectionManager_2 Dlna/{serverId}/ConnectionManager/ConnectionManager
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna media receiver registrar xml returned.</returns>
		public async Task GetConnectionManager_2Async(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/ConnectionManager/ConnectionManager";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna media receiver registrar xml.
		/// GetConnectionManager_3 Dlna/{serverId}/ConnectionManager/ConnectionManager.xml
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna media receiver registrar xml returned.</returns>
		public async Task GetConnectionManager_3Async(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/ConnectionManager/ConnectionManager.xml";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Process a connection manager control request.
		/// ProcessConnectionManagerControlRequest Dlna/{serverId}/ConnectionManager/Control
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Request processed.</returns>
		public async Task ProcessConnectionManagerControlRequestAsync(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/ConnectionManager/Control";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna content directory xml.
		/// GetContentDirectory Dlna/{serverId}/ContentDirectory
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna content directory returned.</returns>
		public async Task GetContentDirectoryAsync(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/ContentDirectory";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna content directory xml.
		/// GetContentDirectory_2 Dlna/{serverId}/ContentDirectory/ContentDirectory
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna content directory returned.</returns>
		public async Task GetContentDirectory_2Async(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/ContentDirectory/ContentDirectory";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna content directory xml.
		/// GetContentDirectory_3 Dlna/{serverId}/ContentDirectory/ContentDirectory.xml
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna content directory returned.</returns>
		public async Task GetContentDirectory_3Async(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/ContentDirectory/ContentDirectory.xml";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Process a content directory control request.
		/// ProcessContentDirectoryControlRequest Dlna/{serverId}/ContentDirectory/Control
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Request processed.</returns>
		public async Task ProcessContentDirectoryControlRequestAsync(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/ContentDirectory/Control";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna media receiver registrar xml.
		/// GetMediaReceiverRegistrar Dlna/{serverId}/MediaReceiverRegistrar
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna media receiver registrar xml returned.</returns>
		public async Task GetMediaReceiverRegistrarAsync(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/MediaReceiverRegistrar";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Process a media receiver registrar control request.
		/// ProcessMediaReceiverRegistrarControlRequest Dlna/{serverId}/MediaReceiverRegistrar/Control
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Request processed.</returns>
		public async Task ProcessMediaReceiverRegistrarControlRequestAsync(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/MediaReceiverRegistrar/Control";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna media receiver registrar xml.
		/// GetMediaReceiverRegistrar_2 Dlna/{serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna media receiver registrar xml returned.</returns>
		public async Task GetMediaReceiverRegistrar_2Async(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/MediaReceiverRegistrar/MediaReceiverRegistrar";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets Dlna media receiver registrar xml.
		/// GetMediaReceiverRegistrar_3 Dlna/{serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar.xml
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Dlna media receiver registrar xml returned.</returns>
		public async Task GetMediaReceiverRegistrar_3Async(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/MediaReceiverRegistrar/MediaReceiverRegistrar.xml";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Description Xml.
		/// GetDescriptionXml Dlna/{serverId}/description
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Description xml returned.</returns>
		public async Task GetDescriptionXmlAsync(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/description";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Description Xml.
		/// GetDescriptionXml_2 Dlna/{serverId}/description.xml
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <returns>Description xml returned.</returns>
		public async Task GetDescriptionXml_2Async(string serverId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/description.xml";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a server icon.
		/// GetIconId Dlna/{serverId}/icons/{fileName}
		/// </summary>
		/// <param name="serverId">Server UUID.</param>
		/// <param name="fileName">The icon filename.</param>
		/// <returns>Request processed.</returns>
		public async Task GetIconIdAsync(string serverId, string fileName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Dlna/"+ (serverId==null? "" : System.Uri.EscapeDataString(serverId))+"/icons/"+ (fileName==null? "" : System.Uri.EscapeDataString(fileName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Default directory browser.
		/// GetDefaultDirectoryBrowser Environment/DefaultDirectoryBrowser
		/// </summary>
		/// <returns>Default directory browser returned.</returns>
		public async Task<DefaultDirectoryBrowserInfoDto> GetDefaultDirectoryBrowserAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Environment/DefaultDirectoryBrowser";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefaultDirectoryBrowserInfoDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the contents of a given directory in the file system.
		/// GetDirectoryContents Environment/DirectoryContents
		/// </summary>
		/// <param name="path">The path.</param>
		/// <param name="includeFiles">An optional filter to include or exclude files from the results. true/false.</param>
		/// <param name="includeDirectories">An optional filter to include or exclude folders from the results. true/false.</param>
		/// <returns>Directory contents returned.</returns>
		public async Task<FileSystemEntryInfo[]> GetDirectoryContentsAsync(string path, bool includeFiles, bool includeDirectories, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Environment/DirectoryContents?path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&includeFiles="+includeFiles+"&includeDirectories="+includeDirectories;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FileSystemEntryInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available drives from the server's file system.
		/// GetDrives Environment/Drives
		/// </summary>
		/// <returns>List of entries returned.</returns>
		public async Task<FileSystemEntryInfo[]> GetDrivesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Environment/Drives";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FileSystemEntryInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets network paths.
		/// GetNetworkShares Environment/NetworkShares
		/// </summary>
		/// <returns>Empty array returned.</returns>
		public async Task<FileSystemEntryInfo[]> GetNetworkSharesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Environment/NetworkShares";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FileSystemEntryInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the parent path of a given path.
		/// GetParentPath Environment/ParentPath
		/// </summary>
		/// <param name="path">The path.</param>
		/// <returns>Success</returns>
		public async Task<string> GetParentPathAsync(string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Environment/ParentPath?path=" + (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Validates path.
		/// ValidatePath Environment/ValidatePath
		/// </summary>
		/// <param name="requestBody">Validate request object.</param>
		public async Task ValidatePathAsync(ValidatePathDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Environment/ValidatePath";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a list of available fallback font files.
		/// GetFallbackFontList FallbackFont/Fonts
		/// </summary>
		/// <returns>Information retrieved.</returns>
		public async Task<FontFile[]> GetFallbackFontListAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "FallbackFont/Fonts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FontFile[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a fallback font file.
		/// GetFallbackFont FallbackFont/Fonts/{name}
		/// </summary>
		/// <param name="name">The name of the fallback font file to get.</param>
		/// <returns>Fallback font file retrieved.</returns>
		public async Task GetFallbackFontAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "FallbackFont/Fonts/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all genres from a given item, folder, or the entire library.
		/// GetGenres Genres
		/// </summary>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="searchTerm">The search term.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="userId">User id.</param>
		/// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string.</param>
		/// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string.</param>
		/// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <param name="enableTotalRecordCount">Optional. Include total record count.</param>
		/// <returns>Genres returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetGenresAsync(
					int startIndex, 
					int limit, 
					string searchTerm, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					string[] includeItemTypes, 
					bool isFavorite, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string userId, 
					string nameStartsWithOrGreater, 
					string nameStartsWith, 
					string nameLessThan, 
					bool enableImages, 
					bool enableTotalRecordCount, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Genres?startIndex="+startIndex+"&limit="+limit+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&isFavorite="+isFavorite+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&nameStartsWithOrGreater=" + (nameStartsWithOrGreater==null? "" : System.Uri.EscapeDataString(nameStartsWithOrGreater))+"&nameStartsWith=" + (nameStartsWith==null? "" : System.Uri.EscapeDataString(nameStartsWith))+"&nameLessThan=" + (nameLessThan==null? "" : System.Uri.EscapeDataString(nameLessThan))+"&enableImages="+enableImages+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a genre, by name.
		/// GetGenre Genres/{genreName}
		/// </summary>
		/// <param name="genreName">The genre name.</param>
		/// <param name="userId">The user id.</param>
		/// <returns>Genres returned.</returns>
		public async Task<BaseItemDto> GetGenreAsync(string genreName, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Genres/"+ (genreName==null? "" : System.Uri.EscapeDataString(genreName))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get genre image by name.
		/// GetGenreImage Genres/{name}/Images/{imageType}
		/// </summary>
		/// <param name="name">Genre name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetGenreImageAsync(
					string name, 
					ImageOptionType imageType, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					int imageIndex, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Genres/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer))+"&imageIndex="+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get genre image by name.
		/// GetGenreImageByIndex Genres/{name}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="name">Genre name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetGenreImageByIndexAsync(
					string name, 
					ImageOptionType imageType, 
					int imageIndex, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Genres/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"/"+imageIndex+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the current UTC time.
		/// GetUtcTime GetUtcTime
		/// </summary>
		/// <returns>Time returned.</returns>
		public async Task<UtcTimeResponse> GetUtcTimeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "GetUtcTime";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UtcTimeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all general images.
		/// GetGeneralImages Images/General
		/// </summary>
		/// <returns>Retrieved list of images.</returns>
		public async Task<ImageByNameInfo[]> GetGeneralImagesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Images/General";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageByNameInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get General Image.
		/// GetGeneralImage Images/General/{name}/{type}
		/// </summary>
		/// <param name="name">The name of the image.</param>
		/// <param name="type">Image Type (primary, backdrop, logo, etc).</param>
		/// <returns>Image stream retrieved.</returns>
		public async Task GetGeneralImageAsync(string name, string type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Images/General/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/"+ (type==null? "" : System.Uri.EscapeDataString(type));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all media info images.
		/// GetMediaInfoImages Images/MediaInfo
		/// </summary>
		/// <returns>Image list retrieved.</returns>
		public async Task<ImageByNameInfo[]> GetMediaInfoImagesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Images/MediaInfo";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageByNameInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get media info image.
		/// GetMediaInfoImage Images/MediaInfo/{theme}/{name}
		/// </summary>
		/// <param name="theme">The theme to get the image from.</param>
		/// <param name="name">The name of the image.</param>
		/// <returns>Image stream retrieved.</returns>
		public async Task GetMediaInfoImageAsync(string theme, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Images/MediaInfo/"+ (theme==null? "" : System.Uri.EscapeDataString(theme))+"/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all general images.
		/// GetRatingImages Images/Ratings
		/// </summary>
		/// <returns>Retrieved list of images.</returns>
		public async Task<ImageByNameInfo[]> GetRatingImagesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Images/Ratings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageByNameInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get rating image.
		/// GetRatingImage Images/Ratings/{theme}/{name}
		/// </summary>
		/// <param name="theme">The theme to get the image from.</param>
		/// <param name="name">The name of the image.</param>
		/// <returns>Image stream retrieved.</returns>
		public async Task GetRatingImageAsync(string theme, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Images/Ratings/"+ (theme==null? "" : System.Uri.EscapeDataString(theme))+"/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a remote image.
		/// GetRemoteImage Images/Remote
		/// </summary>
		/// <param name="imageUrl">The image url.</param>
		/// <returns>Remote image returned.</returns>
		public async Task GetRemoteImageAsync(string imageUrl, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Images/Remote?imageUrl=" + (imageUrl==null? "" : System.Uri.EscapeDataString(imageUrl));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes items from the library and filesystem.
		/// DeleteItems Items
		/// </summary>
		/// <param name="ids">The item ids.</param>
		public async Task DeleteItemsAsync(string[] ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items?"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets items based on a query.
		/// GetItems Items
		/// </summary>
		/// <param name="userId">The user id supplied as query parameter.</param>
		/// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).</param>
		/// <param name="hasThemeSong">Optional filter by items with theme songs.</param>
		/// <param name="hasThemeVideo">Optional filter by items with theme videos.</param>
		/// <param name="hasSubtitles">Optional filter by items with subtitles.</param>
		/// <param name="hasSpecialFeature">Optional filter by items with special features.</param>
		/// <param name="hasTrailer">Optional filter by items with trailers.</param>
		/// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item.</param>
		/// <param name="parentIndexNumber">Optional filter by parent index number.</param>
		/// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating.</param>
		/// <param name="isHd">Optional filter by items that are HD or not.</param>
		/// <param name="is4K">Optional filter by items that are 4K or not.</param>
		/// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.</param>
		/// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.</param>
		/// <param name="isMissing">Optional filter by items that are missing episodes or not.</param>
		/// <param name="isUnaired">Optional filter by items that are unaired episodes or not.</param>
		/// <param name="minCommunityRating">Optional filter by minimum community rating.</param>
		/// <param name="minCriticRating">Optional filter by minimum critic rating.</param>
		/// <param name="minPremiereDate">Optional. The minimum premiere date. Format = ISO.</param>
		/// <param name="minDateLastSaved">Optional. The minimum last saved date. Format = ISO.</param>
		/// <param name="minDateLastSavedForUser">Optional. The minimum last saved date for the current user. Format = ISO.</param>
		/// <param name="maxPremiereDate">Optional. The maximum premiere date. Format = ISO.</param>
		/// <param name="hasOverview">Optional filter by items that have an overview or not.</param>
		/// <param name="hasImdbId">Optional filter by items that have an imdb id or not.</param>
		/// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not.</param>
		/// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not.</param>
		/// <param name="excludeItemIds">Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false.</param>
		/// <param name="searchTerm">Optional. Filter based on a search term.</param>
		/// <param name="sortOrder">Sort Order - Ascending,Descending.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.</param>
		/// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not.</param>
		/// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited.</param>
		/// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.</param>
		/// <param name="sortBy">Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.</param>
		/// <param name="isPlayed">Optional filter by items that are played, or not.</param>
		/// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.</param>
		/// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.</param>
		/// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.</param>
		/// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.</param>
		/// <param name="enableUserData">Optional, include user data.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person.</param>
		/// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person id.</param>
		/// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.</param>
		/// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.</param>
		/// <param name="artists">Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.</param>
		/// <param name="excludeArtistIds">Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.</param>
		/// <param name="artistIds">Optional. If specified, results will be filtered to include only those containing the specified artist id.</param>
		/// <param name="albumArtistIds">Optional. If specified, results will be filtered to include only those containing the specified album artist id.</param>
		/// <param name="contributingArtistIds">Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.</param>
		/// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.</param>
		/// <param name="albumIds">Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.</param>
		/// <param name="ids">Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.</param>
		/// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.</param>
		/// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).</param>
		/// <param name="isLocked">Optional filter by items that are locked.</param>
		/// <param name="isPlaceHolder">Optional filter by items that are placeholders.</param>
		/// <param name="hasOfficialRating">Optional filter by items that have official ratings.</param>
		/// <param name="collapseBoxSetItems">Whether or not to hide items behind their boxsets.</param>
		/// <param name="minWidth">Optional. Filter by the minimum width of the item.</param>
		/// <param name="minHeight">Optional. Filter by the minimum height of the item.</param>
		/// <param name="maxWidth">Optional. Filter by the maximum width of the item.</param>
		/// <param name="maxHeight">Optional. Filter by the maximum height of the item.</param>
		/// <param name="is3D">Optional filter by items that are 3D, or not.</param>
		/// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimited.</param>
		/// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string.</param>
		/// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string.</param>
		/// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string.</param>
		/// <param name="studioIds">Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.</param>
		/// <param name="genreIds">Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.</param>
		/// <param name="enableTotalRecordCount">Optional. Enable the total record count.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <returns>Success</returns>
		public async Task<BaseItemDtoQueryResult> GetItemsAsync(
					string userId, 
					string maxOfficialRating, 
					bool hasThemeSong, 
					bool hasThemeVideo, 
					bool hasSubtitles, 
					bool hasSpecialFeature, 
					bool hasTrailer, 
					string adjacentTo, 
					int parentIndexNumber, 
					bool hasParentalRating, 
					bool isHd, 
					bool is4K, 
					LocationType[] locationTypes, 
					LocationType[] excludeLocationTypes, 
					bool isMissing, 
					bool isUnaired, 
					double minCommunityRating, 
					double minCriticRating, 
					System.DateTimeOffset minPremiereDate, 
					System.DateTimeOffset minDateLastSaved, 
					System.DateTimeOffset minDateLastSavedForUser, 
					System.DateTimeOffset maxPremiereDate, 
					bool hasOverview, 
					bool hasImdbId, 
					bool hasTmdbId, 
					bool hasTvdbId, 
					string[] excludeItemIds, 
					int startIndex, 
					int limit, 
					bool recursive, 
					string searchTerm, 
					string sortOrder, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					string[] includeItemTypes, 
					ItemFilter[] filters, 
					bool isFavorite, 
					string[] mediaTypes, 
					ImageType[] imageTypes, 
					string sortBy, 
					bool isPlayed, 
					string[] genres, 
					string[] officialRatings, 
					string[] tags, 
					int[] years, 
					bool enableUserData, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string person, 
					string[] personIds, 
					string[] personTypes, 
					string[] studios, 
					string[] artists, 
					string[] excludeArtistIds, 
					string[] artistIds, 
					string[] albumArtistIds, 
					string[] contributingArtistIds, 
					string[] albums, 
					string[] albumIds, 
					string[] ids, 
					VideoType[] videoTypes, 
					string minOfficialRating, 
					bool isLocked, 
					bool isPlaceHolder, 
					bool hasOfficialRating, 
					bool collapseBoxSetItems, 
					int minWidth, 
					int minHeight, 
					int maxWidth, 
					int maxHeight, 
					bool is3D, 
					SeriesStatus[] seriesStatus, 
					string nameStartsWithOrGreater, 
					string nameStartsWith, 
					string nameLessThan, 
					string[] studioIds, 
					string[] genreIds, 
					bool enableTotalRecordCount, 
					bool enableImages, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&maxOfficialRating=" + (maxOfficialRating==null? "" : System.Uri.EscapeDataString(maxOfficialRating))+"&hasThemeSong="+hasThemeSong+"&hasThemeVideo="+hasThemeVideo+"&hasSubtitles="+hasSubtitles+"&hasSpecialFeature="+hasSpecialFeature+"&hasTrailer="+hasTrailer+"&adjacentTo=" + (adjacentTo==null? "" : System.Uri.EscapeDataString(adjacentTo))+"&parentIndexNumber="+parentIndexNumber+"&hasParentalRating="+hasParentalRating+"&isHd="+isHd+"&is4K="+is4K+"&"+string.Join("&", locationTypes.Select(z => $"locationTypes={z}"))+"&"+string.Join("&", excludeLocationTypes.Select(z => $"excludeLocationTypes={z}"))+"&isMissing="+isMissing+"&isUnaired="+isUnaired+"&minCommunityRating="+minCommunityRating+"&minCriticRating="+minCriticRating+"&minPremiereDate=" + minPremiereDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&minDateLastSaved=" + minDateLastSaved.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&minDateLastSavedForUser=" + minDateLastSavedForUser.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxPremiereDate=" + maxPremiereDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&hasOverview="+hasOverview+"&hasImdbId="+hasImdbId+"&hasTmdbId="+hasTmdbId+"&hasTvdbId="+hasTvdbId+"&"+string.Join("&", excludeItemIds.Select(z => $"excludeItemIds={System.Uri.EscapeDataString(z.ToString())}"))+"&startIndex="+startIndex+"&limit="+limit+"&recursive="+recursive+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&sortOrder=" + (sortOrder==null? "" : System.Uri.EscapeDataString(sortOrder))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", filters.Select(z => $"filters={z}"))+"&isFavorite="+isFavorite+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", imageTypes.Select(z => $"imageTypes={z}"))+"&sortBy=" + (sortBy==null? "" : System.Uri.EscapeDataString(sortBy))+"&isPlayed="+isPlayed+"&"+string.Join("&", genres.Select(z => $"genres={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", officialRatings.Select(z => $"officialRatings={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", years.Select(z => $"years={z}"))+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&person=" + (person==null? "" : System.Uri.EscapeDataString(person))+"&"+string.Join("&", personIds.Select(z => $"personIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", personTypes.Select(z => $"personTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", studios.Select(z => $"studios={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", artists.Select(z => $"artists={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", artistIds.Select(z => $"artistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albumArtistIds.Select(z => $"albumArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", contributingArtistIds.Select(z => $"contributingArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albums.Select(z => $"albums={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albumIds.Select(z => $"albumIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", videoTypes.Select(z => $"videoTypes={z}"))+"&minOfficialRating=" + (minOfficialRating==null? "" : System.Uri.EscapeDataString(minOfficialRating))+"&isLocked="+isLocked+"&isPlaceHolder="+isPlaceHolder+"&hasOfficialRating="+hasOfficialRating+"&collapseBoxSetItems="+collapseBoxSetItems+"&minWidth="+minWidth+"&minHeight="+minHeight+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&is3D="+is3D+"&"+string.Join("&", seriesStatus.Select(z => $"seriesStatus={z}"))+"&nameStartsWithOrGreater=" + (nameStartsWithOrGreater==null? "" : System.Uri.EscapeDataString(nameStartsWithOrGreater))+"&nameStartsWith=" + (nameStartsWith==null? "" : System.Uri.EscapeDataString(nameStartsWith))+"&nameLessThan=" + (nameLessThan==null? "" : System.Uri.EscapeDataString(nameLessThan))+"&"+string.Join("&", studioIds.Select(z => $"studioIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", genreIds.Select(z => $"genreIds={System.Uri.EscapeDataString(z.ToString())}"))+"&enableTotalRecordCount="+enableTotalRecordCount+"&enableImages="+enableImages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get item counts.
		/// GetItemCounts Items/Counts
		/// </summary>
		/// <param name="userId">Optional. Get counts from a specific user's library.</param>
		/// <param name="isFavorite">Optional. Get counts of favorite items.</param>
		/// <returns>Item counts returned.</returns>
		public async Task<ItemCounts> GetItemCountsAsync(string userId, bool isFavorite, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/Counts?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&isFavorite="+isFavorite;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ItemCounts>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets legacy query filters.
		/// GetQueryFiltersLegacy Items/Filters
		/// </summary>
		/// <param name="userId">Optional. User id.</param>
		/// <param name="parentId">Optional. Parent id.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="mediaTypes">Optional. Filter by MediaType. Allows multiple, comma delimited.</param>
		/// <returns>Legacy filters retrieved.</returns>
		public async Task<QueryFiltersLegacy> GetQueryFiltersLegacyAsync(string userId, string parentId, string[] includeItemTypes, string[] mediaTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/Filters?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<QueryFiltersLegacy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets query filters.
		/// GetQueryFilters Items/Filters2
		/// </summary>
		/// <param name="userId">Optional. User id.</param>
		/// <param name="parentId">Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="isAiring">Optional. Is item airing.</param>
		/// <param name="isMovie">Optional. Is item movie.</param>
		/// <param name="isSports">Optional. Is item sports.</param>
		/// <param name="isKids">Optional. Is item kids.</param>
		/// <param name="isNews">Optional. Is item news.</param>
		/// <param name="isSeries">Optional. Is item series.</param>
		/// <param name="recursive">Optional. Search recursive.</param>
		/// <returns>Filters retrieved.</returns>
		public async Task<QueryFilters> GetQueryFiltersAsync(string userId, string parentId, string[] includeItemTypes, bool isAiring, bool isMovie, bool isSports, bool isKids, bool isNews, bool isSeries, bool recursive, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/Filters2?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&isAiring="+isAiring+"&isMovie="+isMovie+"&isSports="+isSports+"&isKids="+isKids+"&isNews="+isNews+"&isSeries="+isSeries+"&recursive="+recursive;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<QueryFilters>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Applies search criteria to an item and refreshes metadata.
		/// ApplySearchCriteria Items/RemoteSearch/Apply/{itemId}
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="replaceAllImages">Optional. Whether or not to replace all images. Default: True.</param>
		/// <param name="requestBody">The remote search result.</param>
		public async Task ApplySearchCriteriaAsync(string itemId, bool replaceAllImages, RemoteSearchResult requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/Apply/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"&replaceAllImages="+replaceAllImages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get book remote search.
		/// GetBookRemoteSearchResults Items/RemoteSearch/Book
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Book remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetBookRemoteSearchResultsAsync(BookInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/Book";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get box set remote search.
		/// GetBoxSetRemoteSearchResults Items/RemoteSearch/BoxSet
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Box set remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetBoxSetRemoteSearchResultsAsync(BoxSetInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/BoxSet";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a remote image.
		/// GetRemoteSearchImage Items/RemoteSearch/Image
		/// </summary>
		/// <param name="imageUrl">The image url.</param>
		/// <param name="providerName">The provider name.</param>
		/// <returns>Remote image retrieved.</returns>
		public async Task GetRemoteSearchImageAsync(string imageUrl, string providerName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/Image?imageUrl=" + (imageUrl==null? "" : System.Uri.EscapeDataString(imageUrl))+"&providerName=" + (providerName==null? "" : System.Uri.EscapeDataString(providerName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get movie remote search.
		/// GetMovieRemoteSearchResults Items/RemoteSearch/Movie
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Movie remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetMovieRemoteSearchResultsAsync(MovieInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/Movie";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get music album remote search.
		/// GetMusicAlbumRemoteSearchResults Items/RemoteSearch/MusicAlbum
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Music album remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetMusicAlbumRemoteSearchResultsAsync(AlbumInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/MusicAlbum";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get music artist remote search.
		/// GetMusicArtistRemoteSearchResults Items/RemoteSearch/MusicArtist
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Music artist remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetMusicArtistRemoteSearchResultsAsync(ArtistInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/MusicArtist";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get music video remote search.
		/// GetMusicVideoRemoteSearchResults Items/RemoteSearch/MusicVideo
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Music video remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetMusicVideoRemoteSearchResultsAsync(MusicVideoInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/MusicVideo";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get person remote search.
		/// GetPersonRemoteSearchResults Items/RemoteSearch/Person
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Person remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetPersonRemoteSearchResultsAsync(PersonLookupInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/Person";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get series remote search.
		/// GetSeriesRemoteSearchResults Items/RemoteSearch/Series
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Series remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetSeriesRemoteSearchResultsAsync(SeriesInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/Series";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get trailer remote search.
		/// GetTrailerRemoteSearchResults Items/RemoteSearch/Trailer
		/// </summary>
		/// <param name="requestBody">Remote search query.</param>
		/// <returns>Trailer remote search executed.</returns>
		public async Task<RemoteSearchResult[]> GetTrailerRemoteSearchResultsAsync(TrailerInfoRemoteSearchQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/RemoteSearch/Trailer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates an instant playlist based on a given song.
		/// GetInstantMixFromItem Items/{id}/InstantMix
		/// </summary>
		/// <param name="id">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <returns>Instant playlist returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetInstantMixFromItemAsync(string id, string userId, int limit, ItemFields[] fields, bool enableImages, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/InstantMix&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableImages="+enableImages+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an item from the library and filesystem.
		/// DeleteItem Items/{itemId}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		public async Task DeleteItemAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an item.
		/// UpdateItem Items/{itemId}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="requestBody">The new item properties.</param>
		public async Task UpdateItemAsync(string itemId, BaseItemDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets all parents of an item.
		/// GetAncestors Items/{itemId}/Ancestors
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <returns>Item parents returned.</returns>
		public async Task<BaseItemDto[]> GetAncestorsAsync(string itemId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Ancestors&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an item's content type.
		/// UpdateItemContentType Items/{itemId}/ContentType
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="contentType">The content type of the item.</param>
		public async Task UpdateItemContentTypeAsync(string itemId, string contentType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/ContentType&contentType=" + (contentType==null? "" : System.Uri.EscapeDataString(contentType));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets critic review for an item.
		/// GetCriticReviews Items/{itemId}/CriticReviews
		/// </summary>
		/// <returns>Critic reviews returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetCriticReviewsAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/CriticReviews";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Downloads item media.
		/// GetDownload Items/{itemId}/Download
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <returns>Media downloaded.</returns>
		public async Task GetDownloadAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Download";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the item's external id info.
		/// GetExternalIdInfos Items/{itemId}/ExternalIdInfos
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <returns>External id info retrieved.</returns>
		public async Task<ExternalIdInfo[]> GetExternalIdInfosAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/ExternalIdInfos";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExternalIdInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the original file of an item.
		/// GetFile Items/{itemId}/File
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <returns>File stream returned.</returns>
		public async Task GetFileAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/File";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get item image infos.
		/// GetItemImageInfos Items/{itemId}/Images
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <returns>Item images returned.</returns>
		public async Task<ImageInfo[]> GetItemImageInfosAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an item's image.
		/// DeleteItemImage Items/{itemId}/Images/{imageType}
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">The image index.</param>
		public async Task DeleteItemImageAsync(string itemId, ImageOptionType imageType, int imageIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images/"+imageType+"&imageIndex="+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the item's image.
		/// GetItemImage Items/{itemId}/Images/{imageType}
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="format">Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetItemImageAsync(
					string itemId, 
					ImageOptionType imageType, 
					int maxWidth, 
					int maxHeight, 
					int width, 
					int height, 
					int quality, 
					string tag, 
					bool cropWhitespace, 
					ImageFormat format, 
					bool addPlayedIndicator, 
					double percentPlayed, 
					int unplayedCount, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					int imageIndex, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images/"+imageType+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&width="+width+"&height="+height+"&quality="+quality+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&cropWhitespace="+cropWhitespace+"&format=" + format+"&addPlayedIndicator="+addPlayedIndicator+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer))+"&imageIndex="+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set item image.
		/// SetItemImage Items/{itemId}/Images/{imageType}
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="imageType">Image type.</param>
		public async Task SetItemImageAsync(string itemId, ImageOptionType imageType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images/"+imageType;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an item's image.
		/// DeleteItemImageByIndex Items/{itemId}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">The image index.</param>
		public async Task DeleteItemImageByIndexAsync(string itemId, ImageOptionType imageType, int imageIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images/"+imageType+"/"+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the item's image.
		/// GetItemImageByIndex Items/{itemId}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="format">Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetItemImageByIndexAsync(
					string itemId, 
					ImageOptionType imageType, 
					int imageIndex, 
					int maxWidth, 
					int maxHeight, 
					int width, 
					int height, 
					int quality, 
					string tag, 
					bool cropWhitespace, 
					ImageFormat format, 
					bool addPlayedIndicator, 
					double percentPlayed, 
					int unplayedCount, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images/"+imageType+"/"+imageIndex+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&width="+width+"&height="+height+"&quality="+quality+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&cropWhitespace="+cropWhitespace+"&format=" + format+"&addPlayedIndicator="+addPlayedIndicator+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set item image.
		/// SetItemImageByIndex Items/{itemId}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">(Unused) Image index.</param>
		public async Task SetItemImageByIndexAsync(string itemId, ImageOptionType imageType, int imageIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images/"+imageType+"/"+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the index for an item image.
		/// UpdateItemImageIndex Items/{itemId}/Images/{imageType}/{imageIndex}/Index
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">Old image index.</param>
		/// <param name="newIndex">New image index.</param>
		public async Task UpdateItemImageIndexAsync(string itemId, ImageOptionType imageType, int imageIndex, int newIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images/"+imageType+"/"+imageIndex+"/Index&newIndex="+newIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the item's image.
		/// GetItemImage2 Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetItemImage2Async(
					string itemId, 
					ImageOptionType imageType, 
					int maxWidth, 
					int maxHeight, 
					int width, 
					int height, 
					int quality, 
					string tag, 
					bool cropWhitespace, 
					ImageFormat format, 
					bool addPlayedIndicator, 
					double percentPlayed, 
					int unplayedCount, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					int imageIndex, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Images/"+imageType+"/"+imageIndex+"/"+ (tag==null? "" : System.Uri.EscapeDataString(tag))+"/"+format+"/"+maxWidth+"/"+maxHeight+"/"+percentPlayed+"/"+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets metadata editor info for an item.
		/// GetMetadataEditorInfo Items/{itemId}/MetadataEditor
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <returns>Item metadata editor returned.</returns>
		public async Task<MetadataEditorInfo> GetMetadataEditorInfoAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/MetadataEditor";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MetadataEditorInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets live playback media info for an item.
		/// GetPlaybackInfo Items/{itemId}/PlaybackInfo
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="userId">The user id.</param>
		/// <returns>Playback info returned.</returns>
		public async Task<PlaybackInfoResponse> GetPlaybackInfoAsync(string itemId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/PlaybackInfo&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlaybackInfoResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets live playback media info for an item.
		/// For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
		/// GetPostedPlaybackInfo Items/{itemId}/PlaybackInfo
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="userId">The user id.</param>
		/// <param name="maxStreamingBitrate">The maximum streaming bitrate.</param>
		/// <param name="startTimeTicks">The start time in ticks.</param>
		/// <param name="audioStreamIndex">The audio stream index.</param>
		/// <param name="subtitleStreamIndex">The subtitle stream index.</param>
		/// <param name="maxAudioChannels">The maximum number of audio channels.</param>
		/// <param name="mediaSourceId">The media source id.</param>
		/// <param name="liveStreamId">The livestream id.</param>
		/// <param name="autoOpenLiveStream">Whether to auto open the livestream.</param>
		/// <param name="enableDirectPlay">Whether to enable direct play. Default: true.</param>
		/// <param name="enableDirectStream">Whether to enable direct stream. Default: true.</param>
		/// <param name="enableTranscoding">Whether to enable transcoding. Default: true.</param>
		/// <param name="allowVideoStreamCopy">Whether to allow to copy the video stream. Default: true.</param>
		/// <param name="allowAudioStreamCopy">Whether to allow to copy the audio stream. Default: true.</param>
		/// <param name="requestBody">The playback info.</param>
		/// <returns>Playback info returned.</returns>
		public async Task<PlaybackInfoResponse> GetPostedPlaybackInfoAsync(
					string itemId, 
					string userId, 
					int maxStreamingBitrate, 
					long startTimeTicks, 
					int audioStreamIndex, 
					int subtitleStreamIndex, 
					int maxAudioChannels, 
					string mediaSourceId, 
					string liveStreamId, 
					bool autoOpenLiveStream, 
					bool enableDirectPlay, 
					bool enableDirectStream, 
					bool enableTranscoding, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					PlaybackInfoDto requestBody, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/PlaybackInfo&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&maxStreamingBitrate="+maxStreamingBitrate+"&startTimeTicks="+startTimeTicks+"&audioStreamIndex="+audioStreamIndex+"&subtitleStreamIndex="+subtitleStreamIndex+"&maxAudioChannels="+maxAudioChannels+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&autoOpenLiveStream="+autoOpenLiveStream+"&enableDirectPlay="+enableDirectPlay+"&enableDirectStream="+enableDirectStream+"&enableTranscoding="+enableTranscoding+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlaybackInfoResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Refreshes metadata for an item.
		/// Post Items/{itemId}/Refresh
		/// </summary>
		/// <param name="itemId">Item id.</param>
		/// <param name="metadataRefreshMode">(Optional) Specifies the metadata refresh mode.</param>
		/// <param name="imageRefreshMode">(Optional) Specifies the image refresh mode.</param>
		/// <param name="replaceAllMetadata">(Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.</param>
		/// <param name="replaceAllImages">(Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.</param>
		public async Task PostAsync(string itemId, MetadataRefreshMode metadataRefreshMode, MetadataRefreshMode imageRefreshMode, bool replaceAllMetadata, bool replaceAllImages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Refresh&metadataRefreshMode=" + metadataRefreshMode+"&imageRefreshMode=" + imageRefreshMode+"&replaceAllMetadata="+replaceAllMetadata+"&replaceAllImages="+replaceAllImages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available remote images for an item.
		/// GetRemoteImages Items/{itemId}/RemoteImages
		/// </summary>
		/// <param name="itemId">Item Id.</param>
		/// <param name="type">The image type.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="providerName">Optional. The image provider to use.</param>
		/// <param name="includeAllLanguages">Optional. Include all languages.</param>
		/// <returns>Remote Images returned.</returns>
		public async Task<RemoteImageResult> GetRemoteImagesAsync(string itemId, ImageOptionType type, int startIndex, int limit, string providerName, bool includeAllLanguages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/RemoteImages&type=" + type+"&startIndex="+startIndex+"&limit="+limit+"&providerName=" + (providerName==null? "" : System.Uri.EscapeDataString(providerName))+"&includeAllLanguages="+includeAllLanguages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteImageResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Downloads a remote image for an item.
		/// DownloadRemoteImage Items/{itemId}/RemoteImages/Download
		/// </summary>
		/// <param name="itemId">Item Id.</param>
		/// <param name="type">The image type.</param>
		/// <param name="imageUrl">The image url.</param>
		public async Task DownloadRemoteImageAsync(string itemId, ImageOptionType type, string imageUrl, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/RemoteImages/Download&type=" + type+"&imageUrl=" + (imageUrl==null? "" : System.Uri.EscapeDataString(imageUrl));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available remote image providers for an item.
		/// GetRemoteImageProviders Items/{itemId}/RemoteImages/Providers
		/// </summary>
		/// <param name="itemId">Item Id.</param>
		/// <returns>Returned remote image providers.</returns>
		public async Task<ImageProviderInfo[]> GetRemoteImageProvidersAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/RemoteImages/Providers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageProviderInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search remote subtitles.
		/// SearchRemoteSubtitles Items/{itemId}/RemoteSearch/Subtitles/{language}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="language">The language of the subtitles.</param>
		/// <param name="isPerfectMatch">Optional. Only show subtitles which are a perfect match.</param>
		/// <returns>Subtitles retrieved.</returns>
		public async Task<RemoteSubtitleInfo[]> SearchRemoteSubtitlesAsync(string itemId, string language, bool isPerfectMatch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/RemoteSearch/Subtitles/"+ (language==null? "" : System.Uri.EscapeDataString(language))+"&isPerfectMatch="+isPerfectMatch;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoteSubtitleInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Downloads a remote subtitle.
		/// DownloadRemoteSubtitles Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="subtitleId">The subtitle id.</param>
		public async Task DownloadRemoteSubtitlesAsync(string itemId, string subtitleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/RemoteSearch/Subtitles/"+ (subtitleId==null? "" : System.Uri.EscapeDataString(subtitleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets similar items.
		/// GetSimilarItems Items/{itemId}/Similar
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="excludeArtistIds">Exclude artist ids.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.</param>
		/// <returns>Similar items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetSimilarItemsAsync(string itemId, string[] excludeArtistIds, string userId, int limit, ItemFields[] fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Similar&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get theme songs and videos for an item.
		/// GetThemeMedia Items/{itemId}/ThemeMedia
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="inheritFromParent">Optional. Determines whether or not parent items should be searched for theme media.</param>
		/// <returns>Theme songs and videos returned.</returns>
		public async Task<AllThemeMediaResult> GetThemeMediaAsync(string itemId, string userId, bool inheritFromParent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/ThemeMedia&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&inheritFromParent="+inheritFromParent;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AllThemeMediaResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get theme songs for an item.
		/// GetThemeSongs Items/{itemId}/ThemeSongs
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="inheritFromParent">Optional. Determines whether or not parent items should be searched for theme media.</param>
		/// <returns>Theme songs returned.</returns>
		public async Task<ThemeMediaResult> GetThemeSongsAsync(string itemId, string userId, bool inheritFromParent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/ThemeSongs&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&inheritFromParent="+inheritFromParent;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ThemeMediaResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get theme videos for an item.
		/// GetThemeVideos Items/{itemId}/ThemeVideos
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="inheritFromParent">Optional. Determines whether or not parent items should be searched for theme media.</param>
		/// <returns>Theme videos returned.</returns>
		public async Task<ThemeMediaResult> GetThemeVideosAsync(string itemId, string userId, bool inheritFromParent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/ThemeVideos&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&inheritFromParent="+inheritFromParent;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ThemeMediaResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the library options info.
		/// GetLibraryOptionsInfo Libraries/AvailableOptions
		/// </summary>
		/// <param name="libraryContentType">Library content type.</param>
		/// <param name="isNewLibrary">Whether this is a new library.</param>
		/// <returns>Library options info returned.</returns>
		public async Task<LibraryOptionsResultDto> GetLibraryOptionsInfoAsync(string libraryContentType, bool isNewLibrary, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Libraries/AvailableOptions?libraryContentType=" + (libraryContentType==null? "" : System.Uri.EscapeDataString(libraryContentType))+"&isNewLibrary="+isNewLibrary;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LibraryOptionsResultDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports that new movies have been added by an external source.
		/// PostUpdatedMedia Library/Media/Updated
		/// </summary>
		/// <param name="requestBody">A list of updated media paths.</param>
		public async Task PostUpdatedMediaAsync(MediaUpdateInfoDto[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/Media/Updated";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets all user media folders.
		/// GetMediaFolders Library/MediaFolders
		/// </summary>
		/// <param name="isHidden">Optional. Filter by folders that are marked hidden, or not.</param>
		/// <returns>Media folders returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetMediaFoldersAsync(bool isHidden, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/MediaFolders?isHidden="+isHidden;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports that new movies have been added by an external source.
		/// PostAddedMovies Library/Movies/Added
		/// </summary>
		/// <param name="tmdbId">The tmdbId.</param>
		/// <param name="imdbId">The imdbId.</param>
		public async Task PostAddedMoviesAsync(string tmdbId, string imdbId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/Movies/Added?tmdbId=" + (tmdbId==null? "" : System.Uri.EscapeDataString(tmdbId))+"&imdbId=" + (imdbId==null? "" : System.Uri.EscapeDataString(imdbId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports that new movies have been added by an external source.
		/// PostUpdatedMovies Library/Movies/Updated
		/// </summary>
		/// <param name="tmdbId">The tmdbId.</param>
		/// <param name="imdbId">The imdbId.</param>
		public async Task PostUpdatedMoviesAsync(string tmdbId, string imdbId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/Movies/Updated?tmdbId=" + (tmdbId==null? "" : System.Uri.EscapeDataString(tmdbId))+"&imdbId=" + (imdbId==null? "" : System.Uri.EscapeDataString(imdbId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of physical paths from virtual folders.
		/// GetPhysicalPaths Library/PhysicalPaths
		/// </summary>
		/// <returns>Physical paths returned.</returns>
		public async Task<string[]> GetPhysicalPathsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/PhysicalPaths";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts a library scan.
		/// RefreshLibrary Library/Refresh
		/// </summary>
		public async Task RefreshLibraryAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/Refresh";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports that new episodes of a series have been added by an external source.
		/// PostAddedSeries Library/Series/Added
		/// </summary>
		/// <param name="tvdbId">The tvdbId.</param>
		public async Task PostAddedSeriesAsync(string tvdbId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/Series/Added?tvdbId=" + (tvdbId==null? "" : System.Uri.EscapeDataString(tvdbId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports that new episodes of a series have been added by an external source.
		/// PostUpdatedSeries Library/Series/Updated
		/// </summary>
		/// <param name="tvdbId">The tvdbId.</param>
		public async Task PostUpdatedSeriesAsync(string tvdbId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/Series/Updated?tvdbId=" + (tvdbId==null? "" : System.Uri.EscapeDataString(tvdbId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a virtual folder.
		/// RemoveVirtualFolder Library/VirtualFolders
		/// </summary>
		/// <param name="name">The name of the folder.</param>
		/// <param name="refreshLibrary">Whether to refresh the library.</param>
		public async Task RemoveVirtualFolderAsync(string name, bool refreshLibrary, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/VirtualFolders?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&refreshLibrary="+refreshLibrary;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all virtual folders.
		/// GetVirtualFolders Library/VirtualFolders
		/// </summary>
		/// <returns>Virtual folders retrieved.</returns>
		public async Task<VirtualFolderInfo[]> GetVirtualFoldersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/VirtualFolders";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualFolderInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a virtual folder.
		/// AddVirtualFolder Library/VirtualFolders
		/// </summary>
		/// <param name="name">The name of the virtual folder.</param>
		/// <param name="collectionType">The type of the collection.</param>
		/// <param name="paths">The paths of the virtual folder.</param>
		/// <param name="refreshLibrary">Whether to refresh the library.</param>
		/// <param name="requestBody">The library options.</param>
		public async Task AddVirtualFolderAsync(string name, string collectionType, string[] paths, bool refreshLibrary, AddVirtualFolderDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/VirtualFolders?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&collectionType=" + (collectionType==null? "" : System.Uri.EscapeDataString(collectionType))+"&"+string.Join("&", paths.Select(z => $"paths={System.Uri.EscapeDataString(z.ToString())}"))+"&refreshLibrary="+refreshLibrary;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update library options.
		/// UpdateLibraryOptions Library/VirtualFolders/LibraryOptions
		/// </summary>
		/// <param name="requestBody">The library name and options.</param>
		public async Task UpdateLibraryOptionsAsync(UpdateLibraryOptionsDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/VirtualFolders/LibraryOptions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Renames a virtual folder.
		/// RenameVirtualFolder Library/VirtualFolders/Name
		/// </summary>
		/// <param name="name">The name of the virtual folder.</param>
		/// <param name="newName">The new name.</param>
		/// <param name="refreshLibrary">Whether to refresh the library.</param>
		public async Task RenameVirtualFolderAsync(string name, string newName, bool refreshLibrary, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/VirtualFolders/Name?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&newName=" + (newName==null? "" : System.Uri.EscapeDataString(newName))+"&refreshLibrary="+refreshLibrary;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a media path.
		/// RemoveMediaPath Library/VirtualFolders/Paths
		/// </summary>
		/// <param name="name">The name of the library.</param>
		/// <param name="path">The path to remove.</param>
		/// <param name="refreshLibrary">Whether to refresh the library.</param>
		public async Task RemoveMediaPathAsync(string name, string path, bool refreshLibrary, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/VirtualFolders/Paths?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&refreshLibrary="+refreshLibrary;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a media path to a library.
		/// AddMediaPath Library/VirtualFolders/Paths
		/// </summary>
		/// <param name="refreshLibrary">Whether to refresh the library.</param>
		/// <param name="requestBody">The media path dto.</param>
		public async Task AddMediaPathAsync(bool refreshLibrary, MediaPathDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/VirtualFolders/Paths?refreshLibrary="+refreshLibrary;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a media path.
		/// UpdateMediaPath Library/VirtualFolders/Paths/Update
		/// </summary>
		/// <param name="name">The name of the library.</param>
		/// <param name="requestBody">The path info.</param>
		public async Task UpdateMediaPathAsync(string name, MediaPathInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Library/VirtualFolders/Paths/Update?name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Closes a media source.
		/// CloseLiveStream LiveStreams/Close
		/// </summary>
		/// <param name="liveStreamId">The livestream id.</param>
		public async Task CloseLiveStreamAsync(string liveStreamId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveStreams/Close?liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Opens a media source.
		/// OpenLiveStream LiveStreams/Open
		/// </summary>
		/// <param name="openToken">The open token.</param>
		/// <param name="userId">The user id.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="maxStreamingBitrate">The maximum streaming bitrate.</param>
		/// <param name="startTimeTicks">The start time in ticks.</param>
		/// <param name="audioStreamIndex">The audio stream index.</param>
		/// <param name="subtitleStreamIndex">The subtitle stream index.</param>
		/// <param name="maxAudioChannels">The maximum number of audio channels.</param>
		/// <param name="itemId">The item id.</param>
		/// <param name="enableDirectPlay">Whether to enable direct play. Default: true.</param>
		/// <param name="enableDirectStream">Whether to enable direct stream. Default: true.</param>
		/// <param name="requestBody">The open live stream dto.</param>
		/// <returns>Media source opened.</returns>
		public async Task<LiveStreamResponse> OpenLiveStreamAsync(string openToken, string userId, string playSessionId, int maxStreamingBitrate, long startTimeTicks, int audioStreamIndex, int subtitleStreamIndex, int maxAudioChannels, string itemId, bool enableDirectPlay, bool enableDirectStream, OpenLiveStreamDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveStreams/Open?openToken=" + (openToken==null? "" : System.Uri.EscapeDataString(openToken))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&maxStreamingBitrate="+maxStreamingBitrate+"&startTimeTicks="+startTimeTicks+"&audioStreamIndex="+audioStreamIndex+"&subtitleStreamIndex="+subtitleStreamIndex+"&maxAudioChannels="+maxAudioChannels+"&itemId=" + (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"&enableDirectPlay="+enableDirectPlay+"&enableDirectStream="+enableDirectStream;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LiveStreamResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get channel mapping options.
		/// GetChannelMappingOptions LiveTv/ChannelMappingOptions
		/// </summary>
		/// <param name="providerId">Provider id.</param>
		/// <returns>Channel mapping options returned.</returns>
		public async Task<ChannelMappingOptionsDto> GetChannelMappingOptionsAsync(string providerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/ChannelMappingOptions?providerId=" + (providerId==null? "" : System.Uri.EscapeDataString(providerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ChannelMappingOptionsDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set channel mappings.
		/// SetChannelMapping LiveTv/ChannelMappings
		/// </summary>
		/// <param name="requestBody">The set channel mapping dto.</param>
		/// <returns>Created channel mapping returned.</returns>
		public async Task<TunerChannelMapping> SetChannelMappingAsync(SetChannelMappingDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/ChannelMappings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TunerChannelMapping>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets available live tv channels.
		/// GetLiveTvChannels LiveTv/Channels
		/// </summary>
		/// <param name="type">Optional. Filter by channel type.</param>
		/// <param name="userId">Optional. Filter by user and attach user data.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="isMovie">Optional. Filter for movies.</param>
		/// <param name="isSeries">Optional. Filter for series.</param>
		/// <param name="isNews">Optional. Filter for news.</param>
		/// <param name="isKids">Optional. Filter for kids.</param>
		/// <param name="isSports">Optional. Filter for sports.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="isFavorite">Optional. Filter by channels that are favorites, or not.</param>
		/// <param name="isLiked">Optional. Filter by channels that are liked, or not.</param>
		/// <param name="isDisliked">Optional. Filter by channels that are disliked, or not.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">"Optional. The image types to include in the output.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="sortBy">Optional. Key to sort by.</param>
		/// <param name="sortOrder">Optional. Sort order.</param>
		/// <param name="enableFavoriteSorting">Optional. Incorporate favorite and like status into channel sorting.</param>
		/// <param name="addCurrentProgram">Optional. Adds current program info to each channel.</param>
		/// <returns>Available live tv channels returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetLiveTvChannelsAsync(
					BaseItemDtoChannelType type, 
					string userId, 
					int startIndex, 
					bool isMovie, 
					bool isSeries, 
					bool isNews, 
					bool isKids, 
					bool isSports, 
					int limit, 
					bool isFavorite, 
					bool isLiked, 
					bool isDisliked, 
					bool enableImages, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					ItemFields[] fields, 
					bool enableUserData, 
					string[] sortBy, 
					DisplayPreferencesDtoSortOrder sortOrder, 
					bool enableFavoriteSorting, 
					bool addCurrentProgram, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Channels?type=" + type+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&startIndex="+startIndex+"&isMovie="+isMovie+"&isSeries="+isSeries+"&isNews="+isNews+"&isKids="+isKids+"&isSports="+isSports+"&limit="+limit+"&isFavorite="+isFavorite+"&isLiked="+isLiked+"&isDisliked="+isDisliked+"&enableImages="+enableImages+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableUserData="+enableUserData+"&"+string.Join("&", sortBy.Select(z => $"sortBy={System.Uri.EscapeDataString(z.ToString())}"))+"&sortOrder=" + sortOrder+"&enableFavoriteSorting="+enableFavoriteSorting+"&addCurrentProgram="+addCurrentProgram;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a live tv channel.
		/// GetChannel LiveTv/Channels/{channelId}
		/// </summary>
		/// <param name="channelId">Channel id.</param>
		/// <param name="userId">Optional. Attach user data.</param>
		/// <returns>Live tv channel returned.</returns>
		public async Task<BaseItemDto> GetChannelAsync(string channelId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Channels/"+ (channelId==null? "" : System.Uri.EscapeDataString(channelId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get guid info.
		/// GetGuideInfo LiveTv/GuideInfo
		/// </summary>
		/// <returns>Guid info returned.</returns>
		public async Task<GuideInfo> GetGuideInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/GuideInfo";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GuideInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available live tv services.
		/// GetLiveTvInfo LiveTv/Info
		/// </summary>
		/// <returns>Available live tv services returned.</returns>
		public async Task<LiveTvInfo> GetLiveTvInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Info";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LiveTvInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete listing provider.
		/// DeleteListingProvider LiveTv/ListingProviders
		/// </summary>
		/// <param name="id">Listing provider id.</param>
		public async Task DeleteListingProviderAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/ListingProviders?id=" + (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a listings provider.
		/// AddListingProvider LiveTv/ListingProviders
		/// </summary>
		/// <param name="pw">Password.</param>
		/// <param name="validateListings">Validate listings.</param>
		/// <param name="validateLogin">Validate login.</param>
		/// <param name="requestBody">New listings info.</param>
		/// <returns>Created listings provider returned.</returns>
		public async Task<ListingsProviderInfo> AddListingProviderAsync(string pw, bool validateListings, bool validateLogin, ListingsProviderInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/ListingProviders?pw=" + (pw==null? "" : System.Uri.EscapeDataString(pw))+"&validateListings="+validateListings+"&validateLogin="+validateLogin;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListingsProviderInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets default listings provider info.
		/// GetDefaultListingProvider LiveTv/ListingProviders/Default
		/// </summary>
		/// <returns>Default listings provider info returned.</returns>
		public async Task<ListingsProviderInfo> GetDefaultListingProviderAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/ListingProviders/Default";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListingsProviderInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available lineups.
		/// GetLineups LiveTv/ListingProviders/Lineups
		/// </summary>
		/// <param name="id">Provider id.</param>
		/// <param name="type">Provider type.</param>
		/// <param name="location">Location.</param>
		/// <param name="country">Country.</param>
		/// <returns>Available lineups returned.</returns>
		public async Task<NameIdPair[]> GetLineupsAsync(string id, string type, string location, string country, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/ListingProviders/Lineups?id=" + (id==null? "" : System.Uri.EscapeDataString(id))+"&type=" + (type==null? "" : System.Uri.EscapeDataString(type))+"&location=" + (location==null? "" : System.Uri.EscapeDataString(location))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NameIdPair[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available countries.
		/// GetSchedulesDirectCountries LiveTv/ListingProviders/SchedulesDirect/Countries
		/// </summary>
		/// <returns>Available countries returned.</returns>
		public async Task<string> GetSchedulesDirectCountriesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/ListingProviders/SchedulesDirect/Countries";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a live tv recording stream.
		/// GetLiveRecordingFile LiveTv/LiveRecordings/{recordingId}/stream
		/// </summary>
		/// <param name="recordingId">Recording id.</param>
		/// <returns>Recording stream returned.</returns>
		public async Task GetLiveRecordingFileAsync(string recordingId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/LiveRecordings/"+ (recordingId==null? "" : System.Uri.EscapeDataString(recordingId))+"/stream";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a live tv channel stream.
		/// GetLiveStreamFile LiveTv/LiveStreamFiles/{streamId}/stream.{container}
		/// </summary>
		/// <param name="streamId">Stream id.</param>
		/// <param name="container">Container type.</param>
		/// <returns>Stream returned.</returns>
		public async Task GetLiveStreamFileAsync(string streamId, string container, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/LiveStreamFiles/"+ (streamId==null? "" : System.Uri.EscapeDataString(streamId))+"/stream."+ (container==null? "" : System.Uri.EscapeDataString(container));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available live tv epgs.
		/// GetLiveTvPrograms LiveTv/Programs
		/// </summary>
		/// <param name="channelIds">The channels to return guide information for.</param>
		/// <param name="userId">Optional. Filter by user id.</param>
		/// <param name="minStartDate">Optional. The minimum premiere start date.</param>
		/// <param name="hasAired">Optional. Filter by programs that have completed airing, or not.</param>
		/// <param name="isAiring">Optional. Filter by programs that are currently airing, or not.</param>
		/// <param name="maxStartDate">Optional. The maximum premiere start date.</param>
		/// <param name="minEndDate">Optional. The minimum premiere end date.</param>
		/// <param name="maxEndDate">Optional. The maximum premiere end date.</param>
		/// <param name="isMovie">Optional. Filter for movies.</param>
		/// <param name="isSeries">Optional. Filter for series.</param>
		/// <param name="isNews">Optional. Filter for news.</param>
		/// <param name="isKids">Optional. Filter for kids.</param>
		/// <param name="isSports">Optional. Filter for sports.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="sortBy">Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.</param>
		/// <param name="sortOrder">Sort Order - Ascending,Descending.</param>
		/// <param name="genres">The genres to return guide information for.</param>
		/// <param name="genreIds">The genre ids to return guide information for.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="seriesTimerId">Optional. Filter by series timer id.</param>
		/// <param name="librarySeriesId">Optional. Filter by library series id.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableTotalRecordCount">Retrieve total record count.</param>
		/// <returns>Live tv epgs returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetLiveTvProgramsAsync(
					string[] channelIds, 
					string userId, 
					System.DateTimeOffset minStartDate, 
					bool hasAired, 
					bool isAiring, 
					System.DateTimeOffset maxStartDate, 
					System.DateTimeOffset minEndDate, 
					System.DateTimeOffset maxEndDate, 
					bool isMovie, 
					bool isSeries, 
					bool isNews, 
					bool isKids, 
					bool isSports, 
					int startIndex, 
					int limit, 
					string sortBy, 
					string sortOrder, 
					string[] genres, 
					string[] genreIds, 
					bool enableImages, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					bool enableUserData, 
					string seriesTimerId, 
					string librarySeriesId, 
					ItemFields[] fields, 
					bool enableTotalRecordCount, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Programs?"+string.Join("&", channelIds.Select(z => $"channelIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&minStartDate=" + minStartDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&hasAired="+hasAired+"&isAiring="+isAiring+"&maxStartDate=" + maxStartDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&minEndDate=" + minEndDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxEndDate=" + maxEndDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&isMovie="+isMovie+"&isSeries="+isSeries+"&isNews="+isNews+"&isKids="+isKids+"&isSports="+isSports+"&startIndex="+startIndex+"&limit="+limit+"&sortBy=" + (sortBy==null? "" : System.Uri.EscapeDataString(sortBy))+"&sortOrder=" + (sortOrder==null? "" : System.Uri.EscapeDataString(sortOrder))+"&"+string.Join("&", genres.Select(z => $"genres={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", genreIds.Select(z => $"genreIds={System.Uri.EscapeDataString(z.ToString())}"))+"&enableImages="+enableImages+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&enableUserData="+enableUserData+"&seriesTimerId=" + (seriesTimerId==null? "" : System.Uri.EscapeDataString(seriesTimerId))+"&librarySeriesId=" + (librarySeriesId==null? "" : System.Uri.EscapeDataString(librarySeriesId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available live tv epgs.
		/// GetPrograms LiveTv/Programs
		/// </summary>
		/// <param name="requestBody">Request body.</param>
		/// <returns>Live tv epgs returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetProgramsAsync(GetProgramsDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Programs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets recommended live tv epgs.
		/// GetRecommendedPrograms LiveTv/Programs/Recommended
		/// </summary>
		/// <param name="userId">Optional. filter by user id.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="isAiring">Optional. Filter by programs that are currently airing, or not.</param>
		/// <param name="hasAired">Optional. Filter by programs that have completed airing, or not.</param>
		/// <param name="isSeries">Optional. Filter for series.</param>
		/// <param name="isMovie">Optional. Filter for movies.</param>
		/// <param name="isNews">Optional. Filter for news.</param>
		/// <param name="isKids">Optional. Filter for kids.</param>
		/// <param name="isSports">Optional. Filter for sports.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="genreIds">The genres to return guide information for.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableUserData">Optional. include user data.</param>
		/// <param name="enableTotalRecordCount">Retrieve total record count.</param>
		/// <returns>Recommended epgs returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetRecommendedProgramsAsync(
					string userId, 
					int limit, 
					bool isAiring, 
					bool hasAired, 
					bool isSeries, 
					bool isMovie, 
					bool isNews, 
					bool isKids, 
					bool isSports, 
					bool enableImages, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string[] genreIds, 
					ItemFields[] fields, 
					bool enableUserData, 
					bool enableTotalRecordCount, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Programs/Recommended?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&isAiring="+isAiring+"&hasAired="+hasAired+"&isSeries="+isSeries+"&isMovie="+isMovie+"&isNews="+isNews+"&isKids="+isKids+"&isSports="+isSports+"&enableImages="+enableImages+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&"+string.Join("&", genreIds.Select(z => $"genreIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableUserData="+enableUserData+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a live tv program.
		/// GetProgram LiveTv/Programs/{programId}
		/// </summary>
		/// <param name="programId">Program id.</param>
		/// <param name="userId">Optional. Attach user data.</param>
		/// <returns>Program returned.</returns>
		public async Task<BaseItemDto> GetProgramAsync(string programId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Programs/"+ (programId==null? "" : System.Uri.EscapeDataString(programId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets live tv recordings.
		/// GetRecordings LiveTv/Recordings
		/// </summary>
		/// <param name="channelId">Optional. Filter by channel id.</param>
		/// <param name="userId">Optional. Filter by user and attach user data.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="status">Optional. Filter by recording status.</param>
		/// <param name="isInProgress">Optional. Filter by recordings that are in progress, or not.</param>
		/// <param name="seriesTimerId">Optional. Filter by recordings belonging to a series timer.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="isMovie">Optional. Filter for movies.</param>
		/// <param name="isSeries">Optional. Filter for series.</param>
		/// <param name="isKids">Optional. Filter for kids.</param>
		/// <param name="isSports">Optional. Filter for sports.</param>
		/// <param name="isNews">Optional. Filter for news.</param>
		/// <param name="isLibraryItem">Optional. Filter for is library item.</param>
		/// <param name="enableTotalRecordCount">Optional. Return total record count.</param>
		/// <returns>Live tv recordings returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetRecordingsAsync(
					string channelId, 
					string userId, 
					int startIndex, 
					int limit, 
					RecordingStatus status, 
					bool isInProgress, 
					string seriesTimerId, 
					bool enableImages, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					ItemFields[] fields, 
					bool enableUserData, 
					bool isMovie, 
					bool isSeries, 
					bool isKids, 
					bool isSports, 
					bool isNews, 
					bool isLibraryItem, 
					bool enableTotalRecordCount, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Recordings?channelId=" + (channelId==null? "" : System.Uri.EscapeDataString(channelId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&startIndex="+startIndex+"&limit="+limit+"&status=" + status+"&isInProgress="+isInProgress+"&seriesTimerId=" + (seriesTimerId==null? "" : System.Uri.EscapeDataString(seriesTimerId))+"&enableImages="+enableImages+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableUserData="+enableUserData+"&isMovie="+isMovie+"&isSeries="+isSeries+"&isKids="+isKids+"&isSports="+isSports+"&isNews="+isNews+"&isLibraryItem="+isLibraryItem+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets recording folders.
		/// GetRecordingFolders LiveTv/Recordings/Folders
		/// </summary>
		/// <param name="userId">Optional. Filter by user and attach user data.</param>
		/// <returns>Recording folders returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetRecordingFoldersAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Recordings/Folders?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets live tv recording groups.
		/// GetRecordingGroups LiveTv/Recordings/Groups
		/// </summary>
		/// <param name="userId">Optional. Filter by user and attach user data.</param>
		/// <returns>Recording groups returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetRecordingGroupsAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Recordings/Groups?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get recording group.
		/// GetRecordingGroup LiveTv/Recordings/Groups/{groupId}
		/// </summary>
		/// <param name="groupId">Group id.</param>
		public async Task GetRecordingGroupAsync(string groupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Recordings/Groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets live tv recording series.
		/// GetRecordingsSeries LiveTv/Recordings/Series
		/// </summary>
		/// <param name="channelId">Optional. Filter by channel id.</param>
		/// <param name="userId">Optional. Filter by user and attach user data.</param>
		/// <param name="groupId">Optional. Filter by recording group.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="status">Optional. Filter by recording status.</param>
		/// <param name="isInProgress">Optional. Filter by recordings that are in progress, or not.</param>
		/// <param name="seriesTimerId">Optional. Filter by recordings belonging to a series timer.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="enableTotalRecordCount">Optional. Return total record count.</param>
		/// <returns>Live tv recordings returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetRecordingsSeriesAsync(string channelId, string userId, string groupId, int startIndex, int limit, RecordingStatus status, bool isInProgress, string seriesTimerId, bool enableImages, int imageTypeLimit, ImageType[] enableImageTypes, ItemFields[] fields, bool enableUserData, bool enableTotalRecordCount, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Recordings/Series?channelId=" + (channelId==null? "" : System.Uri.EscapeDataString(channelId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&groupId=" + (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"&startIndex="+startIndex+"&limit="+limit+"&status=" + status+"&isInProgress="+isInProgress+"&seriesTimerId=" + (seriesTimerId==null? "" : System.Uri.EscapeDataString(seriesTimerId))+"&enableImages="+enableImages+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableUserData="+enableUserData+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a live tv recording.
		/// DeleteRecording LiveTv/Recordings/{recordingId}
		/// </summary>
		/// <param name="recordingId">Recording id.</param>
		public async Task DeleteRecordingAsync(string recordingId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Recordings/"+ (recordingId==null? "" : System.Uri.EscapeDataString(recordingId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a live tv recording.
		/// GetRecording LiveTv/Recordings/{recordingId}
		/// </summary>
		/// <param name="recordingId">Recording id.</param>
		/// <param name="userId">Optional. Attach user data.</param>
		/// <returns>Recording returned.</returns>
		public async Task<BaseItemDto> GetRecordingAsync(string recordingId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Recordings/"+ (recordingId==null? "" : System.Uri.EscapeDataString(recordingId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets live tv series timers.
		/// GetSeriesTimers LiveTv/SeriesTimers
		/// </summary>
		/// <param name="sortBy">Optional. Sort by SortName or Priority.</param>
		/// <param name="sortOrder">Optional. Sort in Ascending or Descending order.</param>
		/// <returns>Timers returned.</returns>
		public async Task<SeriesTimerInfoDtoQueryResult> GetSeriesTimersAsync(string sortBy, DisplayPreferencesDtoSortOrder sortOrder, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/SeriesTimers?sortBy=" + (sortBy==null? "" : System.Uri.EscapeDataString(sortBy))+"&sortOrder=" + sortOrder;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SeriesTimerInfoDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a live tv series timer.
		/// CreateSeriesTimer LiveTv/SeriesTimers
		/// </summary>
		/// <param name="requestBody">New series timer info.</param>
		public async Task CreateSeriesTimerAsync(SeriesTimerInfoDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/SeriesTimers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Cancels a live tv series timer.
		/// CancelSeriesTimer LiveTv/SeriesTimers/{timerId}
		/// </summary>
		/// <param name="timerId">Timer id.</param>
		public async Task CancelSeriesTimerAsync(string timerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/SeriesTimers/"+ (timerId==null? "" : System.Uri.EscapeDataString(timerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a live tv series timer.
		/// GetSeriesTimer LiveTv/SeriesTimers/{timerId}
		/// </summary>
		/// <param name="timerId">Timer id.</param>
		/// <returns>Series timer returned.</returns>
		public async Task<SeriesTimerInfoDto> GetSeriesTimerAsync(string timerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/SeriesTimers/"+ (timerId==null? "" : System.Uri.EscapeDataString(timerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SeriesTimerInfoDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a live tv series timer.
		/// UpdateSeriesTimer LiveTv/SeriesTimers/{timerId}
		/// </summary>
		/// <param name="timerId">Timer id.</param>
		/// <param name="requestBody">New series timer info.</param>
		public async Task UpdateSeriesTimerAsync(string timerId, SeriesTimerInfoDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/SeriesTimers/"+ (timerId==null? "" : System.Uri.EscapeDataString(timerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the live tv timers.
		/// GetTimers LiveTv/Timers
		/// </summary>
		/// <param name="channelId">Optional. Filter by channel id.</param>
		/// <param name="seriesTimerId">Optional. Filter by timers belonging to a series timer.</param>
		/// <param name="isActive">Optional. Filter by timers that are active.</param>
		/// <param name="isScheduled">Optional. Filter by timers that are scheduled.</param>
		/// <returns>Success</returns>
		public async Task<TimerInfoDtoQueryResult> GetTimersAsync(string channelId, string seriesTimerId, bool isActive, bool isScheduled, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Timers?channelId=" + (channelId==null? "" : System.Uri.EscapeDataString(channelId))+"&seriesTimerId=" + (seriesTimerId==null? "" : System.Uri.EscapeDataString(seriesTimerId))+"&isActive="+isActive+"&isScheduled="+isScheduled;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TimerInfoDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a live tv timer.
		/// CreateTimer LiveTv/Timers
		/// </summary>
		/// <param name="requestBody">New timer info.</param>
		public async Task CreateTimerAsync(TimerInfoDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Timers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the default values for a new timer.
		/// GetDefaultTimer LiveTv/Timers/Defaults
		/// </summary>
		/// <param name="programId">Optional. To attach default values based on a program.</param>
		/// <returns>Default values returned.</returns>
		public async Task<SeriesTimerInfoDto> GetDefaultTimerAsync(string programId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Timers/Defaults?programId=" + (programId==null? "" : System.Uri.EscapeDataString(programId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SeriesTimerInfoDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cancels a live tv timer.
		/// CancelTimer LiveTv/Timers/{timerId}
		/// </summary>
		/// <param name="timerId">Timer id.</param>
		public async Task CancelTimerAsync(string timerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Timers/"+ (timerId==null? "" : System.Uri.EscapeDataString(timerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a timer.
		/// GetTimer LiveTv/Timers/{timerId}
		/// </summary>
		/// <param name="timerId">Timer id.</param>
		/// <returns>Timer returned.</returns>
		public async Task<TimerInfoDto> GetTimerAsync(string timerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Timers/"+ (timerId==null? "" : System.Uri.EscapeDataString(timerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TimerInfoDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a live tv timer.
		/// UpdateTimer LiveTv/Timers/{timerId}
		/// </summary>
		/// <param name="timerId">Timer id.</param>
		/// <param name="requestBody">New timer info.</param>
		public async Task UpdateTimerAsync(string timerId, TimerInfoDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Timers/"+ (timerId==null? "" : System.Uri.EscapeDataString(timerId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a tuner host.
		/// DeleteTunerHost LiveTv/TunerHosts
		/// </summary>
		/// <param name="id">Tuner host id.</param>
		public async Task DeleteTunerHostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/TunerHosts?id=" + (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a tuner host.
		/// AddTunerHost LiveTv/TunerHosts
		/// </summary>
		/// <param name="requestBody">New tuner host.</param>
		/// <returns>Created tuner host returned.</returns>
		public async Task<TunerHostInfo> AddTunerHostAsync(TunerHostInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/TunerHosts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TunerHostInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get tuner host types.
		/// GetTunerHostTypes LiveTv/TunerHosts/Types
		/// </summary>
		/// <returns>Tuner host types returned.</returns>
		public async Task<NameIdPair[]> GetTunerHostTypesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/TunerHosts/Types";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NameIdPair[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Discover tuners.
		/// DiscoverTuners LiveTv/Tuners/Discover
		/// </summary>
		/// <param name="newDevicesOnly">Only discover new tuners.</param>
		/// <returns>Tuners returned.</returns>
		public async Task<TunerHostInfo[]> DiscoverTunersAsync(bool newDevicesOnly, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Tuners/Discover?newDevicesOnly="+newDevicesOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TunerHostInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Discover tuners.
		/// DiscvoverTuners LiveTv/Tuners/Discvover
		/// </summary>
		/// <param name="newDevicesOnly">Only discover new tuners.</param>
		/// <returns>Tuners returned.</returns>
		public async Task<TunerHostInfo[]> DiscvoverTunersAsync(bool newDevicesOnly, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Tuners/Discvover?newDevicesOnly="+newDevicesOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TunerHostInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resets a tv tuner.
		/// ResetTuner LiveTv/Tuners/{tunerId}/Reset
		/// </summary>
		/// <param name="tunerId">Tuner id.</param>
		public async Task ResetTunerAsync(string tunerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "LiveTv/Tuners/"+ (tunerId==null? "" : System.Uri.EscapeDataString(tunerId))+"/Reset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets known countries.
		/// GetCountries Localization/Countries
		/// </summary>
		/// <returns>Known countries returned.</returns>
		public async Task<CountryInfo[]> GetCountriesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Localization/Countries";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CountryInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets known cultures.
		/// GetCultures Localization/Cultures
		/// </summary>
		/// <returns>Known cultures returned.</returns>
		public async Task<CultureDto[]> GetCulturesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Localization/Cultures";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CultureDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets localization options.
		/// GetLocalizationOptions Localization/Options
		/// </summary>
		/// <returns>Localization options returned.</returns>
		public async Task<LocalizationOption[]> GetLocalizationOptionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Localization/Options";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LocalizationOption[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets known parental ratings.
		/// GetParentalRatings Localization/ParentalRatings
		/// </summary>
		/// <returns>Known parental ratings returned.</returns>
		public async Task<ParentalRating[]> GetParentalRatingsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Localization/ParentalRatings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ParentalRating[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets movie recommendations.
		/// GetMovieRecommendations Movies/Recommendations
		/// </summary>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. The fields to return.</param>
		/// <param name="categoryLimit">The max number of categories to return.</param>
		/// <param name="itemLimit">The max number of items to return per category.</param>
		/// <returns>Movie recommendations returned.</returns>
		public async Task<RecommendationDto[]> GetMovieRecommendationsAsync(string userId, string parentId, ItemFields[] fields, int categoryLimit, int itemLimit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Movies/Recommendations?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&categoryLimit="+categoryLimit+"&itemLimit="+itemLimit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RecommendationDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets similar items.
		/// GetSimilarMovies Movies/{itemId}/Similar
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="excludeArtistIds">Exclude artist ids.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.</param>
		/// <returns>Similar items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetSimilarMoviesAsync(string itemId, string[] excludeArtistIds, string userId, int limit, ItemFields[] fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Movies/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Similar&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all music genres from a given item, folder, or the entire library.
		/// GetMusicGenres MusicGenres
		/// </summary>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="searchTerm">The search term.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="userId">User id.</param>
		/// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string.</param>
		/// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string.</param>
		/// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <param name="enableTotalRecordCount">Optional. Include total record count.</param>
		/// <returns>Music genres returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetMusicGenresAsync(
					int startIndex, 
					int limit, 
					string searchTerm, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					string[] includeItemTypes, 
					bool isFavorite, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string userId, 
					string nameStartsWithOrGreater, 
					string nameStartsWith, 
					string nameLessThan, 
					bool enableImages, 
					bool enableTotalRecordCount, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "MusicGenres?startIndex="+startIndex+"&limit="+limit+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&isFavorite="+isFavorite+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&nameStartsWithOrGreater=" + (nameStartsWithOrGreater==null? "" : System.Uri.EscapeDataString(nameStartsWithOrGreater))+"&nameStartsWith=" + (nameStartsWith==null? "" : System.Uri.EscapeDataString(nameStartsWith))+"&nameLessThan=" + (nameLessThan==null? "" : System.Uri.EscapeDataString(nameLessThan))+"&enableImages="+enableImages+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a music genre, by name.
		/// GetMusicGenre MusicGenres/{genreName}
		/// </summary>
		/// <param name="genreName">The genre name.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <returns>Success</returns>
		public async Task<BaseItemDto> GetMusicGenreAsync(string genreName, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "MusicGenres/"+ (genreName==null? "" : System.Uri.EscapeDataString(genreName))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an instant playlist based on a given song.
		/// GetInstantMixFromMusicGenres MusicGenres/{id}/InstantMix
		/// </summary>
		/// <param name="id">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <returns>Instant playlist returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetInstantMixFromMusicGenresAsync(string id, string userId, int limit, ItemFields[] fields, bool enableImages, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "MusicGenres/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/InstantMix&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableImages="+enableImages+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get music genre image by name.
		/// GetMusicGenreImage MusicGenres/{name}/Images/{imageType}
		/// </summary>
		/// <param name="name">Music genre name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetMusicGenreImageAsync(
					string name, 
					ImageOptionType imageType, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					int imageIndex, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "MusicGenres/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer))+"&imageIndex="+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get music genre image by name.
		/// GetMusicGenreImageByIndex MusicGenres/{name}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="name">Music genre name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetMusicGenreImageByIndexAsync(
					string name, 
					ImageOptionType imageType, 
					int imageIndex, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "MusicGenres/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"/"+imageIndex+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an instant playlist based on a given song.
		/// GetInstantMixFromMusicGenre MusicGenres/{name}/InstantMix
		/// </summary>
		/// <param name="name">The genre name.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <returns>Instant playlist returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetInstantMixFromMusicGenreAsync(string name, string userId, int limit, ItemFields[] fields, bool enableImages, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "MusicGenres/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/InstantMix&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableImages="+enableImages+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sends a notification to all admins.
		/// CreateAdminNotification Notifications/Admin
		/// </summary>
		/// <param name="url">The URL of the notification.</param>
		/// <param name="level">The level of the notification.</param>
		/// <param name="name">The name of the notification.</param>
		/// <param name="description">The description of the notification.</param>
		public async Task CreateAdminNotificationAsync(string url, NotificationDtoLevel level, string name, string description, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Notifications/Admin?url=" + (url==null? "" : System.Uri.EscapeDataString(url))+"&level=" + level+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&description=" + (description==null? "" : System.Uri.EscapeDataString(description));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets notification services.
		/// GetNotificationServices Notifications/Services
		/// </summary>
		/// <returns>All notification services returned.</returns>
		public async Task<NameIdPair[]> GetNotificationServicesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Notifications/Services";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NameIdPair[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets notification types.
		/// GetNotificationTypes Notifications/Types
		/// </summary>
		/// <returns>All notification types returned.</returns>
		public async Task<NotificationTypeInfo[]> GetNotificationTypesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Notifications/Types";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NotificationTypeInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a user's notifications.
		/// GetNotifications Notifications/{userId}
		/// </summary>
		/// <returns>Notifications returned.</returns>
		public async Task<NotificationResultDto> GetNotificationsAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Notifications/"+ (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NotificationResultDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets notifications as read.
		/// SetRead Notifications/{userId}/Read
		/// </summary>
		public async Task SetReadAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Notifications/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Read";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a user's notification summary.
		/// GetNotificationsSummary Notifications/{userId}/Summary
		/// </summary>
		/// <returns>Summary of user's notifications returned.</returns>
		public async Task<NotificationsSummaryDto> GetNotificationsSummaryAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Notifications/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Summary";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NotificationsSummaryDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets notifications as unread.
		/// SetUnread Notifications/{userId}/Unread
		/// </summary>
		public async Task SetUnreadAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Notifications/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Unread";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets available packages.
		/// GetPackages Packages
		/// </summary>
		/// <returns>Available packages returned.</returns>
		public async Task<PackageInfo[]> GetPackagesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Packages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PackageInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Installs a package.
		/// InstallPackage Packages/Installed/{name}
		/// </summary>
		/// <param name="name">Package name.</param>
		/// <param name="assemblyGuid">GUID of the associated assembly.</param>
		/// <param name="version">Optional version. Defaults to latest version.</param>
		/// <param name="repositoryUrl">Optional. Specify the repository to install from.</param>
		public async Task InstallPackageAsync(string name, string assemblyGuid, string version, string repositoryUrl, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Packages/Installed/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&assemblyGuid=" + (assemblyGuid==null? "" : System.Uri.EscapeDataString(assemblyGuid))+"&version=" + (version==null? "" : System.Uri.EscapeDataString(version))+"&repositoryUrl=" + (repositoryUrl==null? "" : System.Uri.EscapeDataString(repositoryUrl));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cancels a package installation.
		/// CancelPackageInstallation Packages/Installing/{packageId}
		/// </summary>
		/// <param name="packageId">Installation Id.</param>
		public async Task CancelPackageInstallationAsync(string packageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Packages/Installing/"+ (packageId==null? "" : System.Uri.EscapeDataString(packageId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a package by name or assembly GUID.
		/// GetPackageInfo Packages/{name}
		/// </summary>
		/// <param name="name">The name of the package.</param>
		/// <param name="assemblyGuid">The GUID of the associated assembly.</param>
		/// <returns>Package retrieved.</returns>
		public async Task<PackageInfo> GetPackageInfoAsync(string name, string assemblyGuid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Packages/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&assemblyGuid=" + (assemblyGuid==null? "" : System.Uri.EscapeDataString(assemblyGuid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PackageInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all persons.
		/// GetPersons Persons
		/// </summary>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="searchTerm">The search term.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="filters">Optional. Specify additional filters to apply.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. userId is required.</param>
		/// <param name="enableUserData">Optional, include user data.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="excludePersonTypes">Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.</param>
		/// <param name="personTypes">Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.</param>
		/// <param name="appearsInItemId">Optional. If specified, person results will be filtered on items related to said persons.</param>
		/// <param name="userId">User id.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <returns>Persons returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetPersonsAsync(int limit, string searchTerm, ItemFields[] fields, ItemFilter[] filters, bool isFavorite, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, string[] excludePersonTypes, string[] personTypes, string appearsInItemId, string userId, bool enableImages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Persons?limit="+limit+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", filters.Select(z => $"filters={z}"))+"&isFavorite="+isFavorite+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&"+string.Join("&", excludePersonTypes.Select(z => $"excludePersonTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", personTypes.Select(z => $"personTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&appearsInItemId=" + (appearsInItemId==null? "" : System.Uri.EscapeDataString(appearsInItemId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&enableImages="+enableImages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get person by name.
		/// GetPerson Persons/{name}
		/// </summary>
		/// <param name="name">Person name.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <returns>Person returned.</returns>
		public async Task<BaseItemDto> GetPersonAsync(string name, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Persons/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get person image by name.
		/// GetPersonImage Persons/{name}/Images/{imageType}
		/// </summary>
		/// <param name="name">Person name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetPersonImageAsync(
					string name, 
					ImageOptionType imageType, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					int imageIndex, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Persons/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer))+"&imageIndex="+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get person image by name.
		/// GetPersonImageByIndex Persons/{name}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="name">Person name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetPersonImageByIndexAsync(
					string name, 
					ImageOptionType imageType, 
					int imageIndex, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Persons/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"/"+imageIndex+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Tests the network with a request with the size of the bitrate.
		/// GetBitrateTestBytes Playback/BitrateTest
		/// </summary>
		/// <param name="size">The bitrate. Defaults to 102400.</param>
		/// <returns>Test buffer returned.</returns>
		public async Task GetBitrateTestBytesAsync(int size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Playback/BitrateTest?size="+size;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new playlist.
		/// For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
		/// CreatePlaylist Playlists
		/// </summary>
		/// <param name="name">The playlist name.</param>
		/// <param name="ids">The item ids.</param>
		/// <param name="userId">The user id.</param>
		/// <param name="mediaType">The media type.</param>
		/// <param name="requestBody">The create playlist payload.</param>
		/// <returns>Success</returns>
		public async Task<PlaylistCreationResult> CreatePlaylistAsync(string name, string[] ids, string userId, string mediaType, CreatePlaylistDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Playlists?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&mediaType=" + (mediaType==null? "" : System.Uri.EscapeDataString(mediaType));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlaylistCreationResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates an instant playlist based on a given song.
		/// GetInstantMixFromPlaylist Playlists/{id}/InstantMix
		/// </summary>
		/// <param name="id">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <returns>Instant playlist returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetInstantMixFromPlaylistAsync(string id, string userId, int limit, ItemFields[] fields, bool enableImages, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Playlists/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/InstantMix&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableImages="+enableImages+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes items from a playlist.
		/// RemoveFromPlaylist Playlists/{playlistId}/Items
		/// </summary>
		/// <param name="playlistId">The playlist id.</param>
		/// <param name="entryIds">The item ids, comma delimited.</param>
		public async Task RemoveFromPlaylistAsync(string playlistId, string[] entryIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Playlists/"+ (playlistId==null? "" : System.Uri.EscapeDataString(playlistId))+"/Items&"+string.Join("&", entryIds.Select(z => $"entryIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the original items of a playlist.
		/// GetPlaylistItems Playlists/{playlistId}/Items
		/// </summary>
		/// <param name="playlistId">The playlist id.</param>
		/// <param name="userId">User id.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <returns>Original playlist returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetPlaylistItemsAsync(string playlistId, string userId, int startIndex, int limit, ItemFields[] fields, bool enableImages, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Playlists/"+ (playlistId==null? "" : System.Uri.EscapeDataString(playlistId))+"/Items&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&startIndex="+startIndex+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableImages="+enableImages+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds items to a playlist.
		/// AddToPlaylist Playlists/{playlistId}/Items
		/// </summary>
		/// <param name="playlistId">The playlist id.</param>
		/// <param name="ids">Item id, comma delimited.</param>
		/// <param name="userId">The userId.</param>
		public async Task AddToPlaylistAsync(string playlistId, string[] ids, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Playlists/"+ (playlistId==null? "" : System.Uri.EscapeDataString(playlistId))+"/Items&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves a playlist item.
		/// MoveItem Playlists/{playlistId}/Items/{itemId}/Move/{newIndex}
		/// </summary>
		/// <param name="playlistId">The playlist id.</param>
		/// <param name="itemId">The item id.</param>
		/// <param name="newIndex">The new index.</param>
		public async Task MoveItemAsync(string playlistId, string itemId, int newIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Playlists/"+ (playlistId==null? "" : System.Uri.EscapeDataString(playlistId))+"/Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Move/"+newIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of currently installed plugins.
		/// GetPlugins Plugins
		/// </summary>
		/// <returns>Installed plugins returned.</returns>
		public async Task<PluginInfo[]> GetPluginsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PluginInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates plugin security info.
		/// UpdatePluginSecurityInfo Plugins/SecurityInfo
		/// </summary>
		/// <param name="requestBody">Plugin security info.</param>
		public async Task UpdatePluginSecurityInfoAsync(PluginSecurityInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/SecurityInfo";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Uninstalls a plugin.
		/// UninstallPlugin Plugins/{pluginId}
		/// </summary>
		/// <param name="pluginId">Plugin id.</param>
		public async Task UninstallPluginAsync(string pluginId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/"+ (pluginId==null? "" : System.Uri.EscapeDataString(pluginId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets plugin configuration.
		/// GetPluginConfiguration Plugins/{pluginId}/Configuration
		/// </summary>
		/// <param name="pluginId">Plugin id.</param>
		/// <returns>Plugin configuration returned.</returns>
		public async Task<BasePluginConfiguration> GetPluginConfigurationAsync(string pluginId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/"+ (pluginId==null? "" : System.Uri.EscapeDataString(pluginId))+"/Configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BasePluginConfiguration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates plugin configuration.
		/// Accepts plugin configuration as JSON body.
		/// UpdatePluginConfiguration Plugins/{pluginId}/Configuration
		/// </summary>
		/// <param name="pluginId">Plugin id.</param>
		public async Task UpdatePluginConfigurationAsync(string pluginId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/"+ (pluginId==null? "" : System.Uri.EscapeDataString(pluginId))+"/Configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a plugin's manifest.
		/// GetPluginManifest Plugins/{pluginId}/Manifest
		/// </summary>
		/// <param name="pluginId">Plugin id.</param>
		public async Task GetPluginManifestAsync(string pluginId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/"+ (pluginId==null? "" : System.Uri.EscapeDataString(pluginId))+"/Manifest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Uninstalls a plugin by version.
		/// UninstallPluginByVersion Plugins/{pluginId}/{version}
		/// </summary>
		/// <param name="pluginId">Plugin id.</param>
		/// <param name="version">Plugin version.</param>
		public async Task UninstallPluginByVersionAsync(string pluginId, Version version, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/"+ (pluginId==null? "" : System.Uri.EscapeDataString(pluginId))+"/"+version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable a plugin.
		/// DisablePlugin Plugins/{pluginId}/{version}/Disable
		/// </summary>
		/// <param name="pluginId">Plugin id.</param>
		/// <param name="version">Plugin version.</param>
		public async Task DisablePluginAsync(string pluginId, Version version, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/"+ (pluginId==null? "" : System.Uri.EscapeDataString(pluginId))+"/"+version+"/Disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enables a disabled plugin.
		/// EnablePlugin Plugins/{pluginId}/{version}/Enable
		/// </summary>
		/// <param name="pluginId">Plugin id.</param>
		/// <param name="version">Plugin version.</param>
		public async Task EnablePluginAsync(string pluginId, Version version, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/"+ (pluginId==null? "" : System.Uri.EscapeDataString(pluginId))+"/"+version+"/Enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a plugin's image.
		/// GetPluginImage Plugins/{pluginId}/{version}/Image
		/// </summary>
		/// <param name="pluginId">Plugin id.</param>
		/// <param name="version">Plugin version.</param>
		/// <returns>Plugin image returned.</returns>
		public async Task GetPluginImageAsync(string pluginId, Version version, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Plugins/"+ (pluginId==null? "" : System.Uri.EscapeDataString(pluginId))+"/"+version+"/Image";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the remote subtitles.
		/// GetRemoteSubtitles Providers/Subtitles/Subtitles/{id}
		/// </summary>
		/// <param name="id">The item id.</param>
		/// <returns>File returned.</returns>
		public async Task GetRemoteSubtitlesAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Providers/Subtitles/Subtitles/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Temporarily activates quick connect for five minutes.
		/// Activate QuickConnect/Activate
		/// </summary>
		public async Task ActivateAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "QuickConnect/Activate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Authorizes a pending quick connect request.
		/// Authorize QuickConnect/Authorize
		/// </summary>
		/// <param name="code">Quick connect code to authorize.</param>
		/// <returns>Quick connect result authorized successfully.</returns>
		public async Task<bool> AuthorizeAsync(string code, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "QuickConnect/Authorize?code=" + (code==null? "" : System.Uri.EscapeDataString(code));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<bool>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enables or disables quick connect.
		/// Available QuickConnect/Available
		/// </summary>
		/// <param name="status">New MediaBrowser.Model.QuickConnect.QuickConnectState.</param>
		public async Task AvailableAsync(QuickConnectState status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "QuickConnect/Available?status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Attempts to retrieve authentication information.
		/// Connect QuickConnect/Connect
		/// </summary>
		/// <param name="secret">Secret previously returned from the Initiate endpoint.</param>
		/// <returns>Quick connect result returned.</returns>
		public async Task<QuickConnectResult> ConnectAsync(string secret, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "QuickConnect/Connect?secret=" + (secret==null? "" : System.Uri.EscapeDataString(secret));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<QuickConnectResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deauthorize all quick connect devices for the current user.
		/// Deauthorize QuickConnect/Deauthorize
		/// </summary>
		/// <returns>All quick connect devices were deleted.</returns>
		public async Task<int> DeauthorizeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "QuickConnect/Deauthorize";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiate a new quick connect request.
		/// Initiate QuickConnect/Initiate
		/// </summary>
		/// <returns>Quick connect request successfully created.</returns>
		public async Task<QuickConnectResult> InitiateAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "QuickConnect/Initiate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<QuickConnectResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the current quick connect state.
		/// GetStatus QuickConnect/Status
		/// </summary>
		/// <returns>Quick connect state returned.</returns>
		public async Task<QuickConnectState> GetStatusAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "QuickConnect/Status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<QuickConnectState>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all package repositories.
		/// GetRepositories Repositories
		/// </summary>
		/// <returns>Package repositories returned.</returns>
		public async Task<RepositoryInfo[]> GetRepositoriesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Repositories";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RepositoryInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the enabled and existing package repositories.
		/// SetRepositories Repositories
		/// </summary>
		/// <param name="requestBody">The list of package repositories.</param>
		public async Task SetRepositoriesAsync(RepositoryInfo[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Repositories";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get tasks.
		/// GetTasks ScheduledTasks
		/// </summary>
		/// <param name="isHidden">Optional filter tasks that are hidden, or not.</param>
		/// <param name="isEnabled">Optional filter tasks that are enabled, or not.</param>
		/// <returns>Scheduled tasks retrieved.</returns>
		public async Task<TaskInfo[]> GetTasksAsync(bool isHidden, bool isEnabled, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ScheduledTasks?isHidden="+isHidden+"&isEnabled="+isEnabled;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stop specified task.
		/// StopTask ScheduledTasks/Running/{taskId}
		/// </summary>
		/// <param name="taskId">Task Id.</param>
		public async Task StopTaskAsync(string taskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ScheduledTasks/Running/"+ (taskId==null? "" : System.Uri.EscapeDataString(taskId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start specified task.
		/// StartTask ScheduledTasks/Running/{taskId}
		/// </summary>
		/// <param name="taskId">Task Id.</param>
		public async Task StartTaskAsync(string taskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ScheduledTasks/Running/"+ (taskId==null? "" : System.Uri.EscapeDataString(taskId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get task by id.
		/// GetTask ScheduledTasks/{taskId}
		/// </summary>
		/// <param name="taskId">Task Id.</param>
		/// <returns>Task retrieved.</returns>
		public async Task<TaskInfo> GetTaskAsync(string taskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ScheduledTasks/"+ (taskId==null? "" : System.Uri.EscapeDataString(taskId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update specified task triggers.
		/// UpdateTask ScheduledTasks/{taskId}/Triggers
		/// </summary>
		/// <param name="taskId">Task Id.</param>
		/// <param name="requestBody">Triggers.</param>
		public async Task UpdateTaskAsync(string taskId, TaskTriggerInfo[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ScheduledTasks/"+ (taskId==null? "" : System.Uri.EscapeDataString(taskId))+"/Triggers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the search hint result.
		/// Get Search/Hints
		/// </summary>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="userId">Optional. Supply a user id to search within a user's library or omit to search all.</param>
		/// <param name="searchTerm">The search term to filter on.</param>
		/// <param name="includeItemTypes">If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.</param>
		/// <param name="excludeItemTypes">If specified, results with these item types are filtered out. This allows multiple, comma delimeted.</param>
		/// <param name="mediaTypes">If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.</param>
		/// <param name="parentId">If specified, only children of the parent are returned.</param>
		/// <param name="isMovie">Optional filter for movies.</param>
		/// <param name="isSeries">Optional filter for series.</param>
		/// <param name="isNews">Optional filter for news.</param>
		/// <param name="isKids">Optional filter for kids.</param>
		/// <param name="isSports">Optional filter for sports.</param>
		/// <param name="includePeople">Optional filter whether to include people.</param>
		/// <param name="includeMedia">Optional filter whether to include media.</param>
		/// <param name="includeGenres">Optional filter whether to include genres.</param>
		/// <param name="includeStudios">Optional filter whether to include studios.</param>
		/// <param name="includeArtists">Optional filter whether to include artists.</param>
		/// <returns>Search hint returned.</returns>
		public async Task<SearchHintResult> GetAsync(
					int startIndex, 
					int limit, 
					string userId, 
					string searchTerm, 
					string[] includeItemTypes, 
					string[] excludeItemTypes, 
					string[] mediaTypes, 
					string parentId, 
					bool isMovie, 
					bool isSeries, 
					bool isNews, 
					bool isKids, 
					bool isSports, 
					bool includePeople, 
					bool includeMedia, 
					bool includeGenres, 
					bool includeStudios, 
					bool includeArtists, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Search/Hints?startIndex="+startIndex+"&limit="+limit+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&isMovie="+isMovie+"&isSeries="+isSeries+"&isNews="+isNews+"&isKids="+isKids+"&isSports="+isSports+"&includePeople="+includePeople+"&includeMedia="+includeMedia+"&includeGenres="+includeGenres+"&includeStudios="+includeStudios+"&includeArtists="+includeArtists;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchHintResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of sessions.
		/// GetSessions Sessions
		/// </summary>
		/// <param name="controllableByUserId">Filter by sessions that a given user is allowed to remote control.</param>
		/// <param name="deviceId">Filter by device Id.</param>
		/// <param name="activeWithinSeconds">Optional. Filter by sessions that were active in the last n seconds.</param>
		/// <returns>List of sessions returned.</returns>
		public async Task<SessionInfo[]> GetSessionsAsync(string controllableByUserId, string deviceId, int activeWithinSeconds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions?controllableByUserId=" + (controllableByUserId==null? "" : System.Uri.EscapeDataString(controllableByUserId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&activeWithinSeconds="+activeWithinSeconds;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SessionInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates capabilities for a device.
		/// PostCapabilities Sessions/Capabilities
		/// </summary>
		/// <param name="id">The session id.</param>
		/// <param name="playableMediaTypes">A list of playable media types, comma delimited. Audio, Video, Book, Photo.</param>
		/// <param name="supportedCommands">A list of supported remote control commands, comma delimited.</param>
		/// <param name="supportsMediaControl">Determines whether media can be played remotely..</param>
		/// <param name="supportsSync">Determines whether sync is supported.</param>
		/// <param name="supportsPersistentIdentifier">Determines whether the device supports a unique identifier.</param>
		public async Task PostCapabilitiesAsync(string id, string[] playableMediaTypes, GeneralCommandType[] supportedCommands, bool supportsMediaControl, bool supportsSync, bool supportsPersistentIdentifier, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/Capabilities?id=" + (id==null? "" : System.Uri.EscapeDataString(id))+"&"+string.Join("&", playableMediaTypes.Select(z => $"playableMediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", supportedCommands.Select(z => $"supportedCommands={z}"))+"&supportsMediaControl="+supportsMediaControl+"&supportsSync="+supportsSync+"&supportsPersistentIdentifier="+supportsPersistentIdentifier;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates capabilities for a device.
		/// PostFullCapabilities Sessions/Capabilities/Full
		/// </summary>
		/// <param name="id">The session id.</param>
		/// <param name="requestBody">The MediaBrowser.Model.Session.ClientCapabilities.</param>
		public async Task PostFullCapabilitiesAsync(string id, ClientCapabilitiesDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/Capabilities/Full?id=" + (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reports that a session has ended.
		/// ReportSessionEnded Sessions/Logout
		/// </summary>
		public async Task ReportSessionEndedAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/Logout";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports playback has started within a session.
		/// ReportPlaybackStart Sessions/Playing
		/// </summary>
		/// <param name="requestBody">The playback start info.</param>
		public async Task ReportPlaybackStartAsync(PlaybackStartInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/Playing";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Pings a playback session.
		/// PingPlaybackSession Sessions/Playing/Ping
		/// </summary>
		/// <param name="playSessionId">Playback session id.</param>
		public async Task PingPlaybackSessionAsync(string playSessionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/Playing/Ping?playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports playback progress within a session.
		/// ReportPlaybackProgress Sessions/Playing/Progress
		/// </summary>
		/// <param name="requestBody">The playback progress info.</param>
		public async Task ReportPlaybackProgressAsync(PlaybackProgressInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/Playing/Progress";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reports playback has stopped within a session.
		/// ReportPlaybackStopped Sessions/Playing/Stopped
		/// </summary>
		/// <param name="requestBody">The playback stop info.</param>
		public async Task ReportPlaybackStoppedAsync(PlaybackStopInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/Playing/Stopped";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reports that a session is viewing an item.
		/// ReportViewing Sessions/Viewing
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="itemId">The item id.</param>
		public async Task ReportViewingAsync(string sessionId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/Viewing?sessionId=" + (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"&itemId=" + (itemId==null? "" : System.Uri.EscapeDataString(itemId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Issues a full general command to a client.
		/// SendFullGeneralCommand Sessions/{sessionId}/Command
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="requestBody">The MediaBrowser.Model.Session.GeneralCommand.</param>
		public async Task SendFullGeneralCommandAsync(string sessionId, GeneralCommand requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/Command";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Issues a general command to a client.
		/// SendGeneralCommand Sessions/{sessionId}/Command/{command}
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="command">The command to send.</param>
		public async Task SendGeneralCommandAsync(string sessionId, GeneralCommandType command, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/Command/"+command;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Issues a command to a client to display a message to the user.
		/// SendMessageCommand Sessions/{sessionId}/Message
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="text">The message test.</param>
		/// <param name="header">The message header.</param>
		/// <param name="timeoutMs">The message timeout. If omitted the user will have to confirm viewing the message.</param>
		public async Task SendMessageCommandAsync(string sessionId, string text, string header, long timeoutMs, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/Message&text=" + (text==null? "" : System.Uri.EscapeDataString(text))+"&header=" + (header==null? "" : System.Uri.EscapeDataString(header))+"&timeoutMs="+timeoutMs;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Instructs a session to play an item.
		/// Play Sessions/{sessionId}/Playing
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="playCommand">The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.</param>
		/// <param name="itemIds">The ids of the items to play, comma delimited.</param>
		/// <param name="startPositionTicks">The starting position of the first item.</param>
		public async Task PlayAsync(string sessionId, PlayCommand playCommand, string[] itemIds, long startPositionTicks, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/Playing&playCommand=" + playCommand+"&"+string.Join("&", itemIds.Select(z => $"itemIds={System.Uri.EscapeDataString(z.ToString())}"))+"&startPositionTicks="+startPositionTicks;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Issues a playstate command to a client.
		/// SendPlaystateCommand Sessions/{sessionId}/Playing/{command}
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="command">The MediaBrowser.Model.Session.PlaystateCommand.</param>
		/// <param name="seekPositionTicks">The optional position ticks.</param>
		/// <param name="controllingUserId">The optional controlling user id.</param>
		public async Task SendPlaystateCommandAsync(string sessionId, PlaystateCommand command, long seekPositionTicks, string controllingUserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/Playing/"+command+"&seekPositionTicks="+seekPositionTicks+"&controllingUserId=" + (controllingUserId==null? "" : System.Uri.EscapeDataString(controllingUserId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Issues a system command to a client.
		/// SendSystemCommand Sessions/{sessionId}/System/{command}
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="command">The command to send.</param>
		public async Task SendSystemCommandAsync(string sessionId, GeneralCommandType command, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/System/"+command;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes an additional user from a session.
		/// RemoveUserFromSession Sessions/{sessionId}/User/{userId}
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="userId">The user id.</param>
		public async Task RemoveUserFromSessionAsync(string sessionId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/User/"+ (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds an additional user to a session.
		/// AddUserToSession Sessions/{sessionId}/User/{userId}
		/// </summary>
		/// <param name="sessionId">The session id.</param>
		/// <param name="userId">The user id.</param>
		public async Task AddUserToSessionAsync(string sessionId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/User/"+ (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Instructs a session to browse to an item or view.
		/// DisplayContent Sessions/{sessionId}/Viewing
		/// </summary>
		/// <param name="sessionId">The session Id.</param>
		/// <param name="itemType">The type of item to browse to.</param>
		/// <param name="itemId">The Id of the item.</param>
		/// <param name="itemName">The name of the item.</param>
		public async Task DisplayContentAsync(string sessionId, string itemType, string itemId, string itemName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Sessions/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId))+"/Viewing&itemType=" + (itemType==null? "" : System.Uri.EscapeDataString(itemType))+"&itemId=" + (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"&itemName=" + (itemName==null? "" : System.Uri.EscapeDataString(itemName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of next up episodes.
		/// GetNextUp Shows/NextUp
		/// </summary>
		/// <param name="userId">The user id of the user to get the next up episodes for.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="seriesId">Optional. Filter by series id.</param>
		/// <param name="parentId">Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="enableImges">Optional. Include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="enableTotalRecordCount">Whether to enable the total records count. Defaults to true.</param>
		/// <returns>Success</returns>
		public async Task<BaseItemDtoQueryResult> GetNextUpAsync(string userId, int startIndex, int limit, ItemFields[] fields, string seriesId, string parentId, bool enableImges, int imageTypeLimit, ImageType[] enableImageTypes, bool enableUserData, bool enableTotalRecordCount, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Shows/NextUp?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&startIndex="+startIndex+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&seriesId=" + (seriesId==null? "" : System.Uri.EscapeDataString(seriesId))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&enableImges="+enableImges+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&enableUserData="+enableUserData+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of upcoming episodes.
		/// GetUpcomingEpisodes Shows/Upcoming
		/// </summary>
		/// <param name="userId">The user id of the user to get the upcoming episodes for.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="parentId">Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="enableImges">Optional. Include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <returns>Success</returns>
		public async Task<BaseItemDtoQueryResult> GetUpcomingEpisodesAsync(string userId, int startIndex, int limit, ItemFields[] fields, string parentId, bool enableImges, int imageTypeLimit, ImageType[] enableImageTypes, bool enableUserData, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Shows/Upcoming?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&startIndex="+startIndex+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&enableImges="+enableImges+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&enableUserData="+enableUserData;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets similar items.
		/// GetSimilarShows Shows/{itemId}/Similar
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="excludeArtistIds">Exclude artist ids.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.</param>
		/// <returns>Similar items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetSimilarShowsAsync(string itemId, string[] excludeArtistIds, string userId, int limit, ItemFields[] fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Shows/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Similar&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets episodes for a tv season.
		/// GetEpisodes Shows/{seriesId}/Episodes
		/// </summary>
		/// <param name="seriesId">The series id.</param>
		/// <param name="userId">The user id.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.</param>
		/// <param name="season">Optional filter by season number.</param>
		/// <param name="seasonId">Optional. Filter by season id.</param>
		/// <param name="isMissing">Optional. Filter by items that are missing episodes or not.</param>
		/// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item.</param>
		/// <param name="startItemId">Optional. Skip through the list until a given item is found.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="sortBy">Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.</param>
		/// <returns>Success</returns>
		public async Task<BaseItemDtoQueryResult> GetEpisodesAsync(
					string seriesId, 
					string userId, 
					ItemFields[] fields, 
					int season, 
					string seasonId, 
					bool isMissing, 
					string adjacentTo, 
					string startItemId, 
					int startIndex, 
					int limit, 
					bool enableImages, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					bool enableUserData, 
					string sortBy, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Shows/"+ (seriesId==null? "" : System.Uri.EscapeDataString(seriesId))+"/Episodes&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&season="+season+"&seasonId=" + (seasonId==null? "" : System.Uri.EscapeDataString(seasonId))+"&isMissing="+isMissing+"&adjacentTo=" + (adjacentTo==null? "" : System.Uri.EscapeDataString(adjacentTo))+"&startItemId=" + (startItemId==null? "" : System.Uri.EscapeDataString(startItemId))+"&startIndex="+startIndex+"&limit="+limit+"&enableImages="+enableImages+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&enableUserData="+enableUserData+"&sortBy=" + (sortBy==null? "" : System.Uri.EscapeDataString(sortBy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets seasons for a tv series.
		/// GetSeasons Shows/{seriesId}/Seasons
		/// </summary>
		/// <param name="seriesId">The series id.</param>
		/// <param name="userId">The user id.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.</param>
		/// <param name="isSpecialSeason">Optional. Filter by special season.</param>
		/// <param name="isMissing">Optional. Filter by items that are missing episodes or not.</param>
		/// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <returns>Success</returns>
		public async Task<BaseItemDtoQueryResult> GetSeasonsAsync(string seriesId, string userId, ItemFields[] fields, bool isSpecialSeason, bool isMissing, string adjacentTo, bool enableImages, int imageTypeLimit, ImageType[] enableImageTypes, bool enableUserData, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Shows/"+ (seriesId==null? "" : System.Uri.EscapeDataString(seriesId))+"/Seasons&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&isSpecialSeason="+isSpecialSeason+"&isMissing="+isMissing+"&adjacentTo=" + (adjacentTo==null? "" : System.Uri.EscapeDataString(adjacentTo))+"&enableImages="+enableImages+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&enableUserData="+enableUserData;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an instant playlist based on a given song.
		/// GetInstantMixFromSong Songs/{id}/InstantMix
		/// </summary>
		/// <param name="id">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <returns>Instant playlist returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetInstantMixFromSongAsync(string id, string userId, int limit, ItemFields[] fields, bool enableImages, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Songs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/InstantMix&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&enableImages="+enableImages+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Completes the startup wizard.
		/// CompleteWizard Startup/Complete
		/// </summary>
		public async Task CompleteWizardAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Startup/Complete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the initial startup wizard configuration.
		/// GetStartupConfiguration Startup/Configuration
		/// </summary>
		/// <returns>Initial startup wizard configuration retrieved.</returns>
		public async Task<StartupConfigurationDto> GetStartupConfigurationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Startup/Configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartupConfigurationDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the initial startup wizard configuration.
		/// UpdateInitialConfiguration Startup/Configuration
		/// </summary>
		/// <param name="requestBody">The updated startup configuration.</param>
		public async Task UpdateInitialConfigurationAsync(StartupConfigurationDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Startup/Configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the first user.
		/// GetFirstUser_2 Startup/FirstUser
		/// </summary>
		/// <returns>Initial user retrieved.</returns>
		public async Task<StartupUserDto> GetFirstUser_2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Startup/FirstUser";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartupUserDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets remote access and UPnP.
		/// SetRemoteAccess Startup/RemoteAccess
		/// </summary>
		/// <param name="requestBody">The startup remote access dto.</param>
		public async Task SetRemoteAccessAsync(StartupRemoteAccessDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Startup/RemoteAccess";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the first user.
		/// GetFirstUser Startup/User
		/// </summary>
		/// <returns>Initial user retrieved.</returns>
		public async Task<StartupUserDto> GetFirstUserAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Startup/User";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartupUserDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the user name and password.
		/// UpdateStartupUser Startup/User
		/// </summary>
		/// <param name="requestBody">The DTO containing username and password.</param>
		public async Task UpdateStartupUserAsync(StartupUserDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Startup/User";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets all studios from a given item, folder, or the entire library.
		/// GetStudios Studios
		/// </summary>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="searchTerm">Optional. Search term.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not.</param>
		/// <param name="enableUserData">Optional, include user data.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="userId">User id.</param>
		/// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string.</param>
		/// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string.</param>
		/// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <param name="enableTotalRecordCount">Total record count.</param>
		/// <returns>Studios returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetStudiosAsync(
					int startIndex, 
					int limit, 
					string searchTerm, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					string[] includeItemTypes, 
					bool isFavorite, 
					bool enableUserData, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string userId, 
					string nameStartsWithOrGreater, 
					string nameStartsWith, 
					string nameLessThan, 
					bool enableImages, 
					bool enableTotalRecordCount, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Studios?startIndex="+startIndex+"&limit="+limit+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&isFavorite="+isFavorite+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&nameStartsWithOrGreater=" + (nameStartsWithOrGreater==null? "" : System.Uri.EscapeDataString(nameStartsWithOrGreater))+"&nameStartsWith=" + (nameStartsWith==null? "" : System.Uri.EscapeDataString(nameStartsWith))+"&nameLessThan=" + (nameLessThan==null? "" : System.Uri.EscapeDataString(nameLessThan))+"&enableImages="+enableImages+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a studio by name.
		/// GetStudio Studios/{name}
		/// </summary>
		/// <param name="name">Studio name.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <returns>Studio returned.</returns>
		public async Task<BaseItemDto> GetStudioAsync(string name, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Studios/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get studio image by name.
		/// GetStudioImage Studios/{name}/Images/{imageType}
		/// </summary>
		/// <param name="name">Studio name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetStudioImageAsync(
					string name, 
					ImageOptionType imageType, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					int imageIndex, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Studios/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer))+"&imageIndex="+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get studio image by name.
		/// GetStudioImageByIndex Studios/{name}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="name">Studio name.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetStudioImageByIndexAsync(
					string name, 
					ImageOptionType imageType, 
					int imageIndex, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Studios/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/Images/"+imageType+"/"+imageIndex+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Notify SyncPlay group that member is buffering.
		/// SyncPlayBuffering SyncPlay/Buffering
		/// </summary>
		/// <param name="requestBody">The player status.</param>
		public async Task SyncPlayBufferingAsync(BufferRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Buffering";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Join an existing SyncPlay group.
		/// SyncPlayJoinGroup SyncPlay/Join
		/// </summary>
		/// <param name="requestBody">The group to join.</param>
		public async Task SyncPlayJoinGroupAsync(JoinGroupRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Join";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Leave the joined SyncPlay group.
		/// SyncPlayLeaveGroup SyncPlay/Leave
		/// </summary>
		public async Task SyncPlayLeaveGroupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Leave";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all SyncPlay groups.
		/// SyncPlayGetGroups SyncPlay/List
		/// </summary>
		/// <returns>Groups returned.</returns>
		public async Task<GroupInfoDto[]> SyncPlayGetGroupsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/List";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GroupInfoDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request to move an item in the playlist in SyncPlay group.
		/// SyncPlayMovePlaylistItem SyncPlay/MovePlaylistItem
		/// </summary>
		/// <param name="requestBody">The new position for the item.</param>
		public async Task SyncPlayMovePlaylistItemAsync(MovePlaylistItemRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/MovePlaylistItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a new SyncPlay group.
		/// SyncPlayCreateGroup SyncPlay/New
		/// </summary>
		/// <param name="requestBody">The settings of the new group.</param>
		public async Task SyncPlayCreateGroupAsync(NewGroupRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/New";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request next item in SyncPlay group.
		/// SyncPlayNextItem SyncPlay/NextItem
		/// </summary>
		/// <param name="requestBody">The current item information.</param>
		public async Task SyncPlayNextItemAsync(NextItemRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/NextItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request pause in SyncPlay group.
		/// SyncPlayPause SyncPlay/Pause
		/// </summary>
		public async Task SyncPlayPauseAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Pause";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update session ping.
		/// SyncPlayPing SyncPlay/Ping
		/// </summary>
		/// <param name="requestBody">The new ping.</param>
		public async Task SyncPlayPingAsync(PingRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Ping";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request previous item in SyncPlay group.
		/// SyncPlayPreviousItem SyncPlay/PreviousItem
		/// </summary>
		/// <param name="requestBody">The current item information.</param>
		public async Task SyncPlayPreviousItemAsync(PreviousItemRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/PreviousItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request to queue items to the playlist of a SyncPlay group.
		/// SyncPlayQueue SyncPlay/Queue
		/// </summary>
		/// <param name="requestBody">The items to add.</param>
		public async Task SyncPlayQueueAsync(QueueRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Queue";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Notify SyncPlay group that member is ready for playback.
		/// SyncPlayReady SyncPlay/Ready
		/// </summary>
		/// <param name="requestBody">The player status.</param>
		public async Task SyncPlayReadyAsync(ReadyRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Ready";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request to remove items from the playlist in SyncPlay group.
		/// SyncPlayRemoveFromPlaylist SyncPlay/RemoveFromPlaylist
		/// </summary>
		/// <param name="requestBody">The items to remove.</param>
		public async Task SyncPlayRemoveFromPlaylistAsync(RemoveFromPlaylistRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/RemoveFromPlaylist";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request seek in SyncPlay group.
		/// SyncPlaySeek SyncPlay/Seek
		/// </summary>
		/// <param name="requestBody">The new playback position.</param>
		public async Task SyncPlaySeekAsync(SeekRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Seek";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request SyncPlay group to ignore member during group-wait.
		/// SyncPlaySetIgnoreWait SyncPlay/SetIgnoreWait
		/// </summary>
		/// <param name="requestBody">The settings to set.</param>
		public async Task SyncPlaySetIgnoreWaitAsync(IgnoreWaitRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/SetIgnoreWait";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request to set new playlist in SyncPlay group.
		/// SyncPlaySetNewQueue SyncPlay/SetNewQueue
		/// </summary>
		/// <param name="requestBody">The new playlist to play in the group.</param>
		public async Task SyncPlaySetNewQueueAsync(PlayRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/SetNewQueue";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request to change playlist item in SyncPlay group.
		/// SyncPlaySetPlaylistItem SyncPlay/SetPlaylistItem
		/// </summary>
		/// <param name="requestBody">The new item to play.</param>
		public async Task SyncPlaySetPlaylistItemAsync(SetPlaylistItemRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/SetPlaylistItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request to set repeat mode in SyncPlay group.
		/// SyncPlaySetRepeatMode SyncPlay/SetRepeatMode
		/// </summary>
		/// <param name="requestBody">The new repeat mode.</param>
		public async Task SyncPlaySetRepeatModeAsync(SetRepeatModeRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/SetRepeatMode";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request to set shuffle mode in SyncPlay group.
		/// SyncPlaySetShuffleMode SyncPlay/SetShuffleMode
		/// </summary>
		/// <param name="requestBody">The new shuffle mode.</param>
		public async Task SyncPlaySetShuffleModeAsync(SetShuffleModeRequestDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/SetShuffleMode";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request stop in SyncPlay group.
		/// SyncPlayStop SyncPlay/Stop
		/// </summary>
		public async Task SyncPlayStopAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request unpause in SyncPlay group.
		/// SyncPlayUnpause SyncPlay/Unpause
		/// </summary>
		public async Task SyncPlayUnpauseAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "SyncPlay/Unpause";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets activity log entries.
		/// GetLogEntries System/ActivityLog/Entries
		/// </summary>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="minDate">Optional. The minimum date. Format = ISO.</param>
		/// <param name="hasUserId">Optional. Filter log entries if it has user id, or not.</param>
		/// <returns>Activity log returned.</returns>
		public async Task<ActivityLogEntryQueryResult> GetLogEntriesAsync(int startIndex, int limit, System.DateTimeOffset minDate, bool hasUserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/ActivityLog/Entries?startIndex="+startIndex+"&limit="+limit+"&minDate=" + minDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&hasUserId="+hasUserId;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActivityLogEntryQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets application configuration.
		/// GetConfiguration System/Configuration
		/// </summary>
		/// <returns>Application configuration returned.</returns>
		public async Task<ServerConfiguration> GetConfigurationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ServerConfiguration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates application configuration.
		/// UpdateConfiguration System/Configuration
		/// </summary>
		/// <param name="requestBody">Configuration.</param>
		public async Task UpdateConfigurationAsync(ServerConfiguration requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a default MetadataOptions object.
		/// GetDefaultMetadataOptions System/Configuration/MetadataOptions/Default
		/// </summary>
		/// <returns>Metadata options returned.</returns>
		public async Task<MetadataOptions> GetDefaultMetadataOptionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Configuration/MetadataOptions/Default";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MetadataOptions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a named configuration.
		/// GetNamedConfiguration System/Configuration/{key}
		/// </summary>
		/// <param name="key">Configuration key.</param>
		/// <returns>Configuration returned.</returns>
		public async Task<string> GetNamedConfigurationAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Configuration/"+ (key==null? "" : System.Uri.EscapeDataString(key));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates named configuration.
		/// UpdateNamedConfiguration System/Configuration/{key}
		/// </summary>
		/// <param name="key">Configuration key.</param>
		public async Task UpdateNamedConfigurationAsync(string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Configuration/"+ (key==null? "" : System.Uri.EscapeDataString(key));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about the request endpoint.
		/// GetEndpointInfo System/Endpoint
		/// </summary>
		/// <returns>Information retrieved.</returns>
		public async Task<EndPointInfo> GetEndpointInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Endpoint";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EndPointInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about the server.
		/// GetSystemInfo System/Info
		/// </summary>
		/// <returns>Information retrieved.</returns>
		public async Task<SystemInfo> GetSystemInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Info";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SystemInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets public information about the server.
		/// GetPublicSystemInfo System/Info/Public
		/// </summary>
		/// <returns>Information retrieved.</returns>
		public async Task<PublicSystemInfo> GetPublicSystemInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Info/Public";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublicSystemInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of available server log files.
		/// GetServerLogs System/Logs
		/// </summary>
		/// <returns>Information retrieved.</returns>
		public async Task<LogFile[]> GetServerLogsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Logs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LogFile[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a log file.
		/// GetLogFile System/Logs/Log
		/// </summary>
		/// <param name="name">The name of the log file to get.</param>
		/// <returns>Log file retrieved.</returns>
		public async Task<string> GetLogFileAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Logs/Log?name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(responseMessageStream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the path to the media encoder.
		/// UpdateMediaEncoderPath System/MediaEncoder/Path
		/// </summary>
		/// <param name="requestBody">Media encoder path form body.</param>
		public async Task UpdateMediaEncoderPathAsync(MediaEncoderPathDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/MediaEncoder/Path";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Pings the system.
		/// GetPingSystem System/Ping
		/// </summary>
		/// <returns>Information retrieved.</returns>
		public async Task<string> GetPingSystemAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Ping";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Pings the system.
		/// PostPingSystem System/Ping
		/// </summary>
		/// <returns>Information retrieved.</returns>
		public async Task<string> PostPingSystemAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Ping";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Restarts the application.
		/// RestartApplication System/Restart
		/// </summary>
		public async Task RestartApplicationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Restart";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Shuts down the application.
		/// ShutdownApplication System/Shutdown
		/// </summary>
		public async Task ShutdownApplicationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/Shutdown";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets wake on lan information.
		/// GetWakeOnLanInfo System/WakeOnLanInfo
		/// </summary>
		/// <returns>Information retrieved.</returns>
		public async Task<WakeOnLanInfo[]> GetWakeOnLanInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "System/WakeOnLanInfo";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WakeOnLanInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Finds movies and trailers similar to a given trailer.
		/// GetTrailers Trailers
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).</param>
		/// <param name="hasThemeSong">Optional filter by items with theme songs.</param>
		/// <param name="hasThemeVideo">Optional filter by items with theme videos.</param>
		/// <param name="hasSubtitles">Optional filter by items with subtitles.</param>
		/// <param name="hasSpecialFeature">Optional filter by items with special features.</param>
		/// <param name="hasTrailer">Optional filter by items with trailers.</param>
		/// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item.</param>
		/// <param name="parentIndexNumber">Optional filter by parent index number.</param>
		/// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating.</param>
		/// <param name="isHd">Optional filter by items that are HD or not.</param>
		/// <param name="is4K">Optional filter by items that are 4K or not.</param>
		/// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.</param>
		/// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.</param>
		/// <param name="isMissing">Optional filter by items that are missing episodes or not.</param>
		/// <param name="isUnaired">Optional filter by items that are unaired episodes or not.</param>
		/// <param name="minCommunityRating">Optional filter by minimum community rating.</param>
		/// <param name="minCriticRating">Optional filter by minimum critic rating.</param>
		/// <param name="minPremiereDate">Optional. The minimum premiere date. Format = ISO.</param>
		/// <param name="minDateLastSaved">Optional. The minimum last saved date. Format = ISO.</param>
		/// <param name="minDateLastSavedForUser">Optional. The minimum last saved date for the current user. Format = ISO.</param>
		/// <param name="maxPremiereDate">Optional. The maximum premiere date. Format = ISO.</param>
		/// <param name="hasOverview">Optional filter by items that have an overview or not.</param>
		/// <param name="hasImdbId">Optional filter by items that have an imdb id or not.</param>
		/// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not.</param>
		/// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not.</param>
		/// <param name="excludeItemIds">Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false.</param>
		/// <param name="searchTerm">Optional. Filter based on a search term.</param>
		/// <param name="sortOrder">Sort Order - Ascending,Descending.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not.</param>
		/// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited.</param>
		/// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.</param>
		/// <param name="sortBy">Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.</param>
		/// <param name="isPlayed">Optional filter by items that are played, or not.</param>
		/// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.</param>
		/// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.</param>
		/// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.</param>
		/// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.</param>
		/// <param name="enableUserData">Optional, include user data.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person.</param>
		/// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person id.</param>
		/// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.</param>
		/// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.</param>
		/// <param name="artists">Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.</param>
		/// <param name="excludeArtistIds">Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.</param>
		/// <param name="artistIds">Optional. If specified, results will be filtered to include only those containing the specified artist id.</param>
		/// <param name="albumArtistIds">Optional. If specified, results will be filtered to include only those containing the specified album artist id.</param>
		/// <param name="contributingArtistIds">Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.</param>
		/// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.</param>
		/// <param name="albumIds">Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.</param>
		/// <param name="ids">Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.</param>
		/// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.</param>
		/// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).</param>
		/// <param name="isLocked">Optional filter by items that are locked.</param>
		/// <param name="isPlaceHolder">Optional filter by items that are placeholders.</param>
		/// <param name="hasOfficialRating">Optional filter by items that have official ratings.</param>
		/// <param name="collapseBoxSetItems">Whether or not to hide items behind their boxsets.</param>
		/// <param name="minWidth">Optional. Filter by the minimum width of the item.</param>
		/// <param name="minHeight">Optional. Filter by the minimum height of the item.</param>
		/// <param name="maxWidth">Optional. Filter by the maximum width of the item.</param>
		/// <param name="maxHeight">Optional. Filter by the maximum height of the item.</param>
		/// <param name="is3D">Optional filter by items that are 3D, or not.</param>
		/// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimited.</param>
		/// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string.</param>
		/// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string.</param>
		/// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string.</param>
		/// <param name="studioIds">Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.</param>
		/// <param name="genreIds">Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.</param>
		/// <param name="enableTotalRecordCount">Optional. Enable the total record count.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <returns>Success</returns>
		public async Task<BaseItemDtoQueryResult> GetTrailersAsync(
					string userId, 
					string maxOfficialRating, 
					bool hasThemeSong, 
					bool hasThemeVideo, 
					bool hasSubtitles, 
					bool hasSpecialFeature, 
					bool hasTrailer, 
					string adjacentTo, 
					int parentIndexNumber, 
					bool hasParentalRating, 
					bool isHd, 
					bool is4K, 
					LocationType[] locationTypes, 
					LocationType[] excludeLocationTypes, 
					bool isMissing, 
					bool isUnaired, 
					double minCommunityRating, 
					double minCriticRating, 
					System.DateTimeOffset minPremiereDate, 
					System.DateTimeOffset minDateLastSaved, 
					System.DateTimeOffset minDateLastSavedForUser, 
					System.DateTimeOffset maxPremiereDate, 
					bool hasOverview, 
					bool hasImdbId, 
					bool hasTmdbId, 
					bool hasTvdbId, 
					string[] excludeItemIds, 
					int startIndex, 
					int limit, 
					bool recursive, 
					string searchTerm, 
					string sortOrder, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					ItemFilter[] filters, 
					bool isFavorite, 
					string[] mediaTypes, 
					ImageType[] imageTypes, 
					string sortBy, 
					bool isPlayed, 
					string[] genres, 
					string[] officialRatings, 
					string[] tags, 
					int[] years, 
					bool enableUserData, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string person, 
					string[] personIds, 
					string[] personTypes, 
					string[] studios, 
					string[] artists, 
					string[] excludeArtistIds, 
					string[] artistIds, 
					string[] albumArtistIds, 
					string[] contributingArtistIds, 
					string[] albums, 
					string[] albumIds, 
					string[] ids, 
					VideoType[] videoTypes, 
					string minOfficialRating, 
					bool isLocked, 
					bool isPlaceHolder, 
					bool hasOfficialRating, 
					bool collapseBoxSetItems, 
					int minWidth, 
					int minHeight, 
					int maxWidth, 
					int maxHeight, 
					bool is3D, 
					SeriesStatus[] seriesStatus, 
					string nameStartsWithOrGreater, 
					string nameStartsWith, 
					string nameLessThan, 
					string[] studioIds, 
					string[] genreIds, 
					bool enableTotalRecordCount, 
					bool enableImages, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Trailers?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&maxOfficialRating=" + (maxOfficialRating==null? "" : System.Uri.EscapeDataString(maxOfficialRating))+"&hasThemeSong="+hasThemeSong+"&hasThemeVideo="+hasThemeVideo+"&hasSubtitles="+hasSubtitles+"&hasSpecialFeature="+hasSpecialFeature+"&hasTrailer="+hasTrailer+"&adjacentTo=" + (adjacentTo==null? "" : System.Uri.EscapeDataString(adjacentTo))+"&parentIndexNumber="+parentIndexNumber+"&hasParentalRating="+hasParentalRating+"&isHd="+isHd+"&is4K="+is4K+"&"+string.Join("&", locationTypes.Select(z => $"locationTypes={z}"))+"&"+string.Join("&", excludeLocationTypes.Select(z => $"excludeLocationTypes={z}"))+"&isMissing="+isMissing+"&isUnaired="+isUnaired+"&minCommunityRating="+minCommunityRating+"&minCriticRating="+minCriticRating+"&minPremiereDate=" + minPremiereDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&minDateLastSaved=" + minDateLastSaved.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&minDateLastSavedForUser=" + minDateLastSavedForUser.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxPremiereDate=" + maxPremiereDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&hasOverview="+hasOverview+"&hasImdbId="+hasImdbId+"&hasTmdbId="+hasTmdbId+"&hasTvdbId="+hasTvdbId+"&"+string.Join("&", excludeItemIds.Select(z => $"excludeItemIds={System.Uri.EscapeDataString(z.ToString())}"))+"&startIndex="+startIndex+"&limit="+limit+"&recursive="+recursive+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&sortOrder=" + (sortOrder==null? "" : System.Uri.EscapeDataString(sortOrder))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", filters.Select(z => $"filters={z}"))+"&isFavorite="+isFavorite+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", imageTypes.Select(z => $"imageTypes={z}"))+"&sortBy=" + (sortBy==null? "" : System.Uri.EscapeDataString(sortBy))+"&isPlayed="+isPlayed+"&"+string.Join("&", genres.Select(z => $"genres={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", officialRatings.Select(z => $"officialRatings={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", years.Select(z => $"years={z}"))+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&person=" + (person==null? "" : System.Uri.EscapeDataString(person))+"&"+string.Join("&", personIds.Select(z => $"personIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", personTypes.Select(z => $"personTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", studios.Select(z => $"studios={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", artists.Select(z => $"artists={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", artistIds.Select(z => $"artistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albumArtistIds.Select(z => $"albumArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", contributingArtistIds.Select(z => $"contributingArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albums.Select(z => $"albums={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albumIds.Select(z => $"albumIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", videoTypes.Select(z => $"videoTypes={z}"))+"&minOfficialRating=" + (minOfficialRating==null? "" : System.Uri.EscapeDataString(minOfficialRating))+"&isLocked="+isLocked+"&isPlaceHolder="+isPlaceHolder+"&hasOfficialRating="+hasOfficialRating+"&collapseBoxSetItems="+collapseBoxSetItems+"&minWidth="+minWidth+"&minHeight="+minHeight+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&is3D="+is3D+"&"+string.Join("&", seriesStatus.Select(z => $"seriesStatus={z}"))+"&nameStartsWithOrGreater=" + (nameStartsWithOrGreater==null? "" : System.Uri.EscapeDataString(nameStartsWithOrGreater))+"&nameStartsWith=" + (nameStartsWith==null? "" : System.Uri.EscapeDataString(nameStartsWith))+"&nameLessThan=" + (nameLessThan==null? "" : System.Uri.EscapeDataString(nameLessThan))+"&"+string.Join("&", studioIds.Select(z => $"studioIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", genreIds.Select(z => $"genreIds={System.Uri.EscapeDataString(z.ToString())}"))+"&enableTotalRecordCount="+enableTotalRecordCount+"&enableImages="+enableImages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets similar items.
		/// GetSimilarTrailers Trailers/{itemId}/Similar
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="excludeArtistIds">Exclude artist ids.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.</param>
		/// <returns>Similar items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetSimilarTrailersAsync(string itemId, string[] excludeArtistIds, string userId, int limit, ItemFields[] fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Trailers/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Similar&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&limit="+limit+"&"+string.Join("&", fields.Select(z => $"fields={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of users.
		/// GetUsers Users
		/// </summary>
		/// <param name="isHidden">Optional filter by IsHidden=true or false.</param>
		/// <param name="isDisabled">Optional filter by IsDisabled=true or false.</param>
		/// <returns>Users returned.</returns>
		public async Task<UserDto[]> GetUsersAsync(bool isHidden, bool isDisabled, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users?isHidden="+isHidden+"&isDisabled="+isDisabled;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Authenticates a user by name.
		/// AuthenticateUserByName Users/AuthenticateByName
		/// </summary>
		/// <param name="requestBody">The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.</param>
		/// <returns>User authenticated.</returns>
		public async Task<AuthenticationResult> AuthenticateUserByNameAsync(AuthenticateUserByName requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/AuthenticateByName";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AuthenticationResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Authenticates a user with quick connect.
		/// AuthenticateWithQuickConnect Users/AuthenticateWithQuickConnect
		/// </summary>
		/// <param name="requestBody">The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.</param>
		/// <returns>User authenticated.</returns>
		public async Task<AuthenticationResult> AuthenticateWithQuickConnectAsync(QuickConnectDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/AuthenticateWithQuickConnect";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AuthenticationResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Initiates the forgot password process for a local user.
		/// ForgotPassword Users/ForgotPassword
		/// </summary>
		/// <param name="requestBody">The forgot password request containing the entered username.</param>
		/// <returns>Password reset process started.</returns>
		public async Task<ForgotPasswordResult> ForgotPasswordAsync(ForgotPasswordDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/ForgotPassword";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ForgotPasswordResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Redeems a forgot password pin.
		/// ForgotPasswordPin Users/ForgotPassword/Pin
		/// </summary>
		/// <param name="requestBody">The pin.</param>
		/// <returns>Pin reset process started.</returns>
		public async Task<PinRedeemResult> ForgotPasswordPinAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/ForgotPassword/Pin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PinRedeemResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the user based on auth token.
		/// GetCurrentUser Users/Me
		/// </summary>
		/// <returns>User returned.</returns>
		public async Task<UserDto> GetCurrentUserAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/Me";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a user.
		/// CreateUserByName Users/New
		/// </summary>
		/// <param name="requestBody">The create user by name request body.</param>
		/// <returns>User created.</returns>
		public async Task<UserDto> CreateUserByNameAsync(CreateUserByName requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/New";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a list of publicly visible users for display on a login screen.
		/// GetPublicUsers Users/Public
		/// </summary>
		/// <returns>Public users returned.</returns>
		public async Task<UserDto[]> GetPublicUsersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/Public";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a user.
		/// DeleteUser Users/{userId}
		/// </summary>
		/// <param name="userId">The user id.</param>
		public async Task DeleteUserAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a user by Id.
		/// GetUserById Users/{userId}
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <returns>User returned.</returns>
		public async Task<UserDto> GetUserByIdAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a user.
		/// UpdateUser Users/{userId}
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="requestBody">The updated user model.</param>
		public async Task UpdateUserAsync(string userId, UserDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Authenticates a user.
		/// AuthenticateUser Users/{userId}/Authenticate
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="pw">The password as plain text.</param>
		/// <param name="password">The password sha1-hash.</param>
		/// <returns>User authenticated.</returns>
		public async Task<AuthenticationResult> AuthenticateUserAsync(string userId, string pw, string password, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Authenticate&pw=" + (pw==null? "" : System.Uri.EscapeDataString(pw))+"&password=" + (password==null? "" : System.Uri.EscapeDataString(password));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AuthenticationResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a user configuration.
		/// UpdateUserConfiguration Users/{userId}/Configuration
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="requestBody">The new user configuration.</param>
		public async Task UpdateUserConfigurationAsync(string userId, UserConfiguration requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a user's easy password.
		/// UpdateUserEasyPassword Users/{userId}/EasyPassword
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="requestBody">The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.</param>
		public async Task UpdateUserEasyPasswordAsync(string userId, UpdateUserEasyPassword requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/EasyPassword";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Unmarks item as a favorite.
		/// UnmarkFavoriteItem Users/{userId}/FavoriteItems/{itemId}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <returns>Item unmarked as favorite.</returns>
		public async Task<UserItemDataDto> UnmarkFavoriteItemAsync(string userId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/FavoriteItems/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserItemDataDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Marks an item as a favorite.
		/// MarkFavoriteItem Users/{userId}/FavoriteItems/{itemId}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <returns>Item marked as favorite.</returns>
		public async Task<UserItemDataDto> MarkFavoriteItemAsync(string userId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/FavoriteItems/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserItemDataDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get user view grouping options.
		/// GetGroupingOptions Users/{userId}/GroupingOptions
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <returns>User view grouping options returned.</returns>
		public async Task<SpecialViewOptionDto[]> GetGroupingOptionsAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/GroupingOptions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SpecialViewOptionDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the user's image.
		/// DeleteUserImage Users/{userId}/Images/{imageType}
		/// </summary>
		/// <param name="userId">User Id.</param>
		/// <param name="imageType">(Unused) Image type.</param>
		/// <param name="index">(Unused) Image index.</param>
		public async Task DeleteUserImageAsync(string userId, ImageOptionType imageType, int index, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Images/"+imageType+"&index="+index;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get user profile image.
		/// GetUserImage Users/{userId}/Images/{imageType}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetUserImageAsync(
					string userId, 
					ImageOptionType imageType, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					int imageIndex, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Images/"+imageType+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer))+"&imageIndex="+imageIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the user image.
		/// PostUserImage Users/{userId}/Images/{imageType}
		/// </summary>
		/// <param name="userId">User Id.</param>
		/// <param name="imageType">(Unused) Image type.</param>
		/// <param name="index">(Unused) Image index.</param>
		public async Task PostUserImageAsync(string userId, ImageOptionType imageType, int index, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Images/"+imageType+"&index="+index;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get user profile image.
		/// GetUserImageByIndex Users/{userId}/Images/{imageType}/{imageIndex}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="imageType">Image type.</param>
		/// <param name="imageIndex">Image index.</param>
		/// <param name="tag">Optional. Supply the cache tag from the item object to receive strong caching headers.</param>
		/// <param name="format">Determines the output format of the image - original,gif,jpg,png.</param>
		/// <param name="maxWidth">The maximum image width to return.</param>
		/// <param name="maxHeight">The maximum image height to return.</param>
		/// <param name="percentPlayed">Optional. Percent to render for the percent played overlay.</param>
		/// <param name="unplayedCount">Optional. Unplayed count overlay to render.</param>
		/// <param name="width">The fixed image width to return.</param>
		/// <param name="height">The fixed image height to return.</param>
		/// <param name="quality">Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.</param>
		/// <param name="cropWhitespace">Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.</param>
		/// <param name="addPlayedIndicator">Optional. Add a played indicator.</param>
		/// <param name="blur">Optional. Blur image.</param>
		/// <param name="backgroundColor">Optional. Apply a background color for transparent images.</param>
		/// <param name="foregroundLayer">Optional. Apply a foreground layer on top of the image.</param>
		/// <returns>Image stream returned.</returns>
		public async Task GetUserImageByIndexAsync(
					string userId, 
					ImageOptionType imageType, 
					int imageIndex, 
					string tag, 
					ImageFormat format, 
					int maxWidth, 
					int maxHeight, 
					double percentPlayed, 
					int unplayedCount, 
					int width, 
					int height, 
					int quality, 
					bool cropWhitespace, 
					bool addPlayedIndicator, 
					int blur, 
					string backgroundColor, 
					string foregroundLayer, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Images/"+imageType+"/"+imageIndex+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&format=" + format+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&percentPlayed="+percentPlayed+"&unplayedCount="+unplayedCount+"&width="+width+"&height="+height+"&quality="+quality+"&cropWhitespace="+cropWhitespace+"&addPlayedIndicator="+addPlayedIndicator+"&blur="+blur+"&backgroundColor=" + (backgroundColor==null? "" : System.Uri.EscapeDataString(backgroundColor))+"&foregroundLayer=" + (foregroundLayer==null? "" : System.Uri.EscapeDataString(foregroundLayer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the user's image.
		/// DeleteUserImageByIndex Users/{userId}/Images/{imageType}/{index}
		/// </summary>
		/// <param name="userId">User Id.</param>
		/// <param name="imageType">(Unused) Image type.</param>
		/// <param name="index">(Unused) Image index.</param>
		public async Task DeleteUserImageByIndexAsync(string userId, ImageOptionType imageType, int index, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Images/"+imageType+"/"+index;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the user image.
		/// PostUserImageByIndex Users/{userId}/Images/{imageType}/{index}
		/// </summary>
		/// <param name="userId">User Id.</param>
		/// <param name="imageType">(Unused) Image type.</param>
		/// <param name="index">(Unused) Image index.</param>
		public async Task PostUserImageByIndexAsync(string userId, ImageOptionType imageType, int index, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Images/"+imageType+"/"+index;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets items based on a query.
		/// GetItemsByUserId Users/{userId}/Items
		/// </summary>
		/// <param name="userId">The user id supplied as query parameter.</param>
		/// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).</param>
		/// <param name="hasThemeSong">Optional filter by items with theme songs.</param>
		/// <param name="hasThemeVideo">Optional filter by items with theme videos.</param>
		/// <param name="hasSubtitles">Optional filter by items with subtitles.</param>
		/// <param name="hasSpecialFeature">Optional filter by items with special features.</param>
		/// <param name="hasTrailer">Optional filter by items with trailers.</param>
		/// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item.</param>
		/// <param name="parentIndexNumber">Optional filter by parent index number.</param>
		/// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating.</param>
		/// <param name="isHd">Optional filter by items that are HD or not.</param>
		/// <param name="is4K">Optional filter by items that are 4K or not.</param>
		/// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.</param>
		/// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.</param>
		/// <param name="isMissing">Optional filter by items that are missing episodes or not.</param>
		/// <param name="isUnaired">Optional filter by items that are unaired episodes or not.</param>
		/// <param name="minCommunityRating">Optional filter by minimum community rating.</param>
		/// <param name="minCriticRating">Optional filter by minimum critic rating.</param>
		/// <param name="minPremiereDate">Optional. The minimum premiere date. Format = ISO.</param>
		/// <param name="minDateLastSaved">Optional. The minimum last saved date. Format = ISO.</param>
		/// <param name="minDateLastSavedForUser">Optional. The minimum last saved date for the current user. Format = ISO.</param>
		/// <param name="maxPremiereDate">Optional. The maximum premiere date. Format = ISO.</param>
		/// <param name="hasOverview">Optional filter by items that have an overview or not.</param>
		/// <param name="hasImdbId">Optional filter by items that have an imdb id or not.</param>
		/// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not.</param>
		/// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not.</param>
		/// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.</param>
		/// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false.</param>
		/// <param name="searchTerm">Optional. Filter based on a search term.</param>
		/// <param name="sortOrder">Sort Order - Ascending,Descending.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.</param>
		/// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.</param>
		/// <param name="isFavorite">Optional filter by items that are marked as favorite, or not.</param>
		/// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited.</param>
		/// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.</param>
		/// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.</param>
		/// <param name="isPlayed">Optional filter by items that are played, or not.</param>
		/// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.</param>
		/// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.</param>
		/// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.</param>
		/// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.</param>
		/// <param name="enableUserData">Optional, include user data.</param>
		/// <param name="imageTypeLimit">Optional, the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person.</param>
		/// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person id.</param>
		/// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.</param>
		/// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.</param>
		/// <param name="artists">Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.</param>
		/// <param name="excludeArtistIds">Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.</param>
		/// <param name="artistIds">Optional. If specified, results will be filtered to include only those containing the specified artist id.</param>
		/// <param name="albumArtistIds">Optional. If specified, results will be filtered to include only those containing the specified album artist id.</param>
		/// <param name="contributingArtistIds">Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.</param>
		/// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.</param>
		/// <param name="albumIds">Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.</param>
		/// <param name="ids">Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.</param>
		/// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.</param>
		/// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).</param>
		/// <param name="isLocked">Optional filter by items that are locked.</param>
		/// <param name="isPlaceHolder">Optional filter by items that are placeholders.</param>
		/// <param name="hasOfficialRating">Optional filter by items that have official ratings.</param>
		/// <param name="collapseBoxSetItems">Whether or not to hide items behind their boxsets.</param>
		/// <param name="minWidth">Optional. Filter by the minimum width of the item.</param>
		/// <param name="minHeight">Optional. Filter by the minimum height of the item.</param>
		/// <param name="maxWidth">Optional. Filter by the maximum width of the item.</param>
		/// <param name="maxHeight">Optional. Filter by the maximum height of the item.</param>
		/// <param name="is3D">Optional filter by items that are 3D, or not.</param>
		/// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted.</param>
		/// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string.</param>
		/// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string.</param>
		/// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string.</param>
		/// <param name="studioIds">Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.</param>
		/// <param name="genreIds">Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.</param>
		/// <param name="enableTotalRecordCount">Optional. Enable the total record count.</param>
		/// <param name="enableImages">Optional, include image information in output.</param>
		/// <returns>Success</returns>
		public async Task<BaseItemDtoQueryResult> GetItemsByUserIdAsync(
					string userId, 
					string maxOfficialRating, 
					bool hasThemeSong, 
					bool hasThemeVideo, 
					bool hasSubtitles, 
					bool hasSpecialFeature, 
					bool hasTrailer, 
					string adjacentTo, 
					int parentIndexNumber, 
					bool hasParentalRating, 
					bool isHd, 
					bool is4K, 
					LocationType[] locationTypes, 
					LocationType[] excludeLocationTypes, 
					bool isMissing, 
					bool isUnaired, 
					double minCommunityRating, 
					double minCriticRating, 
					System.DateTimeOffset minPremiereDate, 
					System.DateTimeOffset minDateLastSaved, 
					System.DateTimeOffset minDateLastSavedForUser, 
					System.DateTimeOffset maxPremiereDate, 
					bool hasOverview, 
					bool hasImdbId, 
					bool hasTmdbId, 
					bool hasTvdbId, 
					string[] excludeItemIds, 
					int startIndex, 
					int limit, 
					bool recursive, 
					string searchTerm, 
					string sortOrder, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					string[] includeItemTypes, 
					ItemFilter[] filters, 
					bool isFavorite, 
					string[] mediaTypes, 
					ImageType[] imageTypes, 
					string sortBy, 
					bool isPlayed, 
					string[] genres, 
					string[] officialRatings, 
					string[] tags, 
					int[] years, 
					bool enableUserData, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string person, 
					string[] personIds, 
					string[] personTypes, 
					string[] studios, 
					string[] artists, 
					string[] excludeArtistIds, 
					string[] artistIds, 
					string[] albumArtistIds, 
					string[] contributingArtistIds, 
					string[] albums, 
					string[] albumIds, 
					string[] ids, 
					VideoType[] videoTypes, 
					string minOfficialRating, 
					bool isLocked, 
					bool isPlaceHolder, 
					bool hasOfficialRating, 
					bool collapseBoxSetItems, 
					int minWidth, 
					int minHeight, 
					int maxWidth, 
					int maxHeight, 
					bool is3D, 
					SeriesStatus[] seriesStatus, 
					string nameStartsWithOrGreater, 
					string nameStartsWith, 
					string nameLessThan, 
					string[] studioIds, 
					string[] genreIds, 
					bool enableTotalRecordCount, 
					bool enableImages, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items&maxOfficialRating=" + (maxOfficialRating==null? "" : System.Uri.EscapeDataString(maxOfficialRating))+"&hasThemeSong="+hasThemeSong+"&hasThemeVideo="+hasThemeVideo+"&hasSubtitles="+hasSubtitles+"&hasSpecialFeature="+hasSpecialFeature+"&hasTrailer="+hasTrailer+"&adjacentTo=" + (adjacentTo==null? "" : System.Uri.EscapeDataString(adjacentTo))+"&parentIndexNumber="+parentIndexNumber+"&hasParentalRating="+hasParentalRating+"&isHd="+isHd+"&is4K="+is4K+"&"+string.Join("&", locationTypes.Select(z => $"locationTypes={z}"))+"&"+string.Join("&", excludeLocationTypes.Select(z => $"excludeLocationTypes={z}"))+"&isMissing="+isMissing+"&isUnaired="+isUnaired+"&minCommunityRating="+minCommunityRating+"&minCriticRating="+minCriticRating+"&minPremiereDate=" + minPremiereDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&minDateLastSaved=" + minDateLastSaved.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&minDateLastSavedForUser=" + minDateLastSavedForUser.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxPremiereDate=" + maxPremiereDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&hasOverview="+hasOverview+"&hasImdbId="+hasImdbId+"&hasTmdbId="+hasTmdbId+"&hasTvdbId="+hasTvdbId+"&"+string.Join("&", excludeItemIds.Select(z => $"excludeItemIds={System.Uri.EscapeDataString(z.ToString())}"))+"&startIndex="+startIndex+"&limit="+limit+"&recursive="+recursive+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&sortOrder=" + (sortOrder==null? "" : System.Uri.EscapeDataString(sortOrder))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", filters.Select(z => $"filters={z}"))+"&isFavorite="+isFavorite+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", imageTypes.Select(z => $"imageTypes={z}"))+"&sortBy=" + (sortBy==null? "" : System.Uri.EscapeDataString(sortBy))+"&isPlayed="+isPlayed+"&"+string.Join("&", genres.Select(z => $"genres={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", officialRatings.Select(z => $"officialRatings={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", years.Select(z => $"years={z}"))+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&person=" + (person==null? "" : System.Uri.EscapeDataString(person))+"&"+string.Join("&", personIds.Select(z => $"personIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", personTypes.Select(z => $"personTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", studios.Select(z => $"studios={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", artists.Select(z => $"artists={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", excludeArtistIds.Select(z => $"excludeArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", artistIds.Select(z => $"artistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albumArtistIds.Select(z => $"albumArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", contributingArtistIds.Select(z => $"contributingArtistIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albums.Select(z => $"albums={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", albumIds.Select(z => $"albumIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", videoTypes.Select(z => $"videoTypes={z}"))+"&minOfficialRating=" + (minOfficialRating==null? "" : System.Uri.EscapeDataString(minOfficialRating))+"&isLocked="+isLocked+"&isPlaceHolder="+isPlaceHolder+"&hasOfficialRating="+hasOfficialRating+"&collapseBoxSetItems="+collapseBoxSetItems+"&minWidth="+minWidth+"&minHeight="+minHeight+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&is3D="+is3D+"&"+string.Join("&", seriesStatus.Select(z => $"seriesStatus={z}"))+"&nameStartsWithOrGreater=" + (nameStartsWithOrGreater==null? "" : System.Uri.EscapeDataString(nameStartsWithOrGreater))+"&nameStartsWith=" + (nameStartsWith==null? "" : System.Uri.EscapeDataString(nameStartsWith))+"&nameLessThan=" + (nameLessThan==null? "" : System.Uri.EscapeDataString(nameLessThan))+"&"+string.Join("&", studioIds.Select(z => $"studioIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", genreIds.Select(z => $"genreIds={System.Uri.EscapeDataString(z.ToString())}"))+"&enableTotalRecordCount="+enableTotalRecordCount+"&enableImages="+enableImages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets latest media.
		/// GetLatestMedia Users/{userId}/Items/Latest
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="isPlayed">Filter by items that are played, or not.</param>
		/// <param name="enableImages">Optional. include image information in output.</param>
		/// <param name="imageTypeLimit">Optional. the max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="enableUserData">Optional. include user data.</param>
		/// <param name="limit">Return item limit.</param>
		/// <param name="groupItems">Whether or not to group items into a parent container.</param>
		/// <returns>Latest media returned.</returns>
		public async Task<BaseItemDto[]> GetLatestMediaAsync(string userId, string parentId, ItemFields[] fields, string[] includeItemTypes, bool isPlayed, bool enableImages, int imageTypeLimit, ImageType[] enableImageTypes, bool enableUserData, int limit, bool groupItems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/Latest&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&isPlayed="+isPlayed+"&enableImages="+enableImages+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&enableUserData="+enableUserData+"&limit="+limit+"&groupItems="+groupItems;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets items based on a query.
		/// GetResumeItems Users/{userId}/Items/Resume
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="startIndex">The start index.</param>
		/// <param name="limit">The item limit.</param>
		/// <param name="searchTerm">The search term.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.</param>
		/// <param name="mediaTypes">Optional. Filter by MediaType. Allows multiple, comma delimited.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.</param>
		/// <param name="enableTotalRecordCount">Optional. Enable the total record count.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <returns>Items returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetResumeItemsAsync(string userId, int startIndex, int limit, string searchTerm, string parentId, ItemFields[] fields, string[] mediaTypes, bool enableUserData, int imageTypeLimit, ImageType[] enableImageTypes, string[] excludeItemTypes, string[] includeItemTypes, bool enableTotalRecordCount, bool enableImages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/Resume&startIndex="+startIndex+"&limit="+limit+"&searchTerm=" + (searchTerm==null? "" : System.Uri.EscapeDataString(searchTerm))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&enableTotalRecordCount="+enableTotalRecordCount+"&enableImages="+enableImages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the root folder from a user's library.
		/// GetRootFolder Users/{userId}/Items/Root
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <returns>Root folder returned.</returns>
		public async Task<BaseItemDto> GetRootFolderAsync(string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/Root";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an item from a user's library.
		/// GetItem Users/{userId}/Items/{itemId}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <returns>Item returned.</returns>
		public async Task<BaseItemDto> GetItemAsync(string userId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets intros to play before the main media item plays.
		/// GetIntros Users/{userId}/Items/{itemId}/Intros
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <returns>Intros returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetIntrosAsync(string userId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Intros";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets local trailers for an item.
		/// GetLocalTrailers Users/{userId}/Items/{itemId}/LocalTrailers
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <returns>An Microsoft.AspNetCore.Mvc.OkResult containing the item's local trailers.</returns>
		public async Task<BaseItemDto[]> GetLocalTrailersAsync(string userId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/LocalTrailers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a user's saved personal rating for an item.
		/// DeleteUserItemRating Users/{userId}/Items/{itemId}/Rating
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <returns>Personal rating removed.</returns>
		public async Task<UserItemDataDto> DeleteUserItemRatingAsync(string userId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Rating";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserItemDataDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a user's rating for an item.
		/// UpdateUserItemRating Users/{userId}/Items/{itemId}/Rating
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <param name="likes">Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.</param>
		/// <returns>Item rating updated.</returns>
		public async Task<UserItemDataDto> UpdateUserItemRatingAsync(string userId, string itemId, bool likes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Rating&likes="+likes;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserItemDataDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets special features for an item.
		/// GetSpecialFeatures Users/{userId}/Items/{itemId}/SpecialFeatures
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <returns>Special features returned.</returns>
		public async Task<BaseItemDto[]> GetSpecialFeaturesAsync(string userId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Items/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/SpecialFeatures";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a user's password.
		/// UpdateUserPassword Users/{userId}/Password
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="requestBody">The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.</param>
		public async Task UpdateUserPasswordAsync(string userId, UpdateUserPassword requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Password";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Marks an item as unplayed for user.
		/// MarkUnplayedItem Users/{userId}/PlayedItems/{itemId}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <returns>Item marked as unplayed.</returns>
		public async Task<UserItemDataDto> MarkUnplayedItemAsync(string userId, string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/PlayedItems/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserItemDataDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Marks an item as played for user.
		/// MarkPlayedItem Users/{userId}/PlayedItems/{itemId}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <param name="datePlayed">Optional. The date the item was played.</param>
		/// <returns>Item marked as played.</returns>
		public async Task<UserItemDataDto> MarkPlayedItemAsync(string userId, string itemId, System.DateTimeOffset datePlayed, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/PlayedItems/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"&datePlayed=" + datePlayed.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserItemDataDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports that a user has stopped playing an item.
		/// OnPlaybackStopped Users/{userId}/PlayingItems/{itemId}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <param name="mediaSourceId">The id of the MediaSource.</param>
		/// <param name="nextMediaType">The next media type that will play.</param>
		/// <param name="positionTicks">Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="playSessionId">The play session id.</param>
		public async Task OnPlaybackStoppedAsync(string userId, string itemId, string mediaSourceId, string nextMediaType, long positionTicks, string liveStreamId, string playSessionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/PlayingItems/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&nextMediaType=" + (nextMediaType==null? "" : System.Uri.EscapeDataString(nextMediaType))+"&positionTicks="+positionTicks+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports that a user has begun playing an item.
		/// OnPlaybackStart Users/{userId}/PlayingItems/{itemId}
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <param name="mediaSourceId">The id of the MediaSource.</param>
		/// <param name="audioStreamIndex">The audio stream index.</param>
		/// <param name="subtitleStreamIndex">The subtitle stream index.</param>
		/// <param name="playMethod">The play method.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="canSeek">Indicates if the client can seek.</param>
		public async Task OnPlaybackStartAsync(string userId, string itemId, string mediaSourceId, int audioStreamIndex, int subtitleStreamIndex, PlayerStateInfoPlayMethod playMethod, string liveStreamId, string playSessionId, bool canSeek, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/PlayingItems/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&audioStreamIndex="+audioStreamIndex+"&subtitleStreamIndex="+subtitleStreamIndex+"&playMethod=" + playMethod+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&canSeek="+canSeek;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reports a user's playback progress.
		/// OnPlaybackProgress Users/{userId}/PlayingItems/{itemId}/Progress
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="itemId">Item id.</param>
		/// <param name="mediaSourceId">The id of the MediaSource.</param>
		/// <param name="positionTicks">Optional. The current position, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="audioStreamIndex">The audio stream index.</param>
		/// <param name="subtitleStreamIndex">The subtitle stream index.</param>
		/// <param name="volumeLevel">Scale of 0-100.</param>
		/// <param name="playMethod">The play method.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="repeatMode">The repeat mode.</param>
		/// <param name="isPaused">Indicates if the player is paused.</param>
		/// <param name="isMuted">Indicates if the player is muted.</param>
		public async Task OnPlaybackProgressAsync(string userId, string itemId, string mediaSourceId, long positionTicks, int audioStreamIndex, int subtitleStreamIndex, int volumeLevel, PlayerStateInfoPlayMethod playMethod, string liveStreamId, string playSessionId, PlayerStateInfoRepeatMode repeatMode, bool isPaused, bool isMuted, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/PlayingItems/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Progress&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&positionTicks="+positionTicks+"&audioStreamIndex="+audioStreamIndex+"&subtitleStreamIndex="+subtitleStreamIndex+"&volumeLevel="+volumeLevel+"&playMethod=" + playMethod+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&repeatMode=" + repeatMode+"&isPaused="+isPaused+"&isMuted="+isMuted;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a user policy.
		/// UpdateUserPolicy Users/{userId}/Policy
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="requestBody">The new user policy.</param>
		public async Task UpdateUserPolicyAsync(string userId, UserPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets suggestions.
		/// GetSuggestions Users/{userId}/Suggestions
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="mediaType">The media types.</param>
		/// <param name="type">The type.</param>
		/// <param name="startIndex">Optional. The start index.</param>
		/// <param name="limit">Optional. The limit.</param>
		/// <param name="enableTotalRecordCount">Whether to enable the total record count.</param>
		/// <returns>Suggestions returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetSuggestionsAsync(string userId, string[] mediaType, string[] type, int startIndex, int limit, bool enableTotalRecordCount, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Suggestions&"+string.Join("&", mediaType.Select(z => $"mediaType={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", type.Select(z => $"type={System.Uri.EscapeDataString(z.ToString())}"))+"&startIndex="+startIndex+"&limit="+limit+"&enableTotalRecordCount="+enableTotalRecordCount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get user views.
		/// GetUserViews Users/{userId}/Views
		/// </summary>
		/// <param name="userId">User id.</param>
		/// <param name="includeExternalContent">Whether or not to include external views such as channels or live tv.</param>
		/// <param name="presetViews">Preset views.</param>
		/// <param name="includeHidden">Whether or not to include hidden content.</param>
		/// <returns>User views returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetUserViewsAsync(string userId, bool includeExternalContent, string[] presetViews, bool includeHidden, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/Views&includeExternalContent="+includeExternalContent+"&"+string.Join("&", presetViews.Select(z => $"presetViews={System.Uri.EscapeDataString(z.ToString())}"))+"&includeHidden="+includeHidden;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stops an active encoding.
		/// StopEncodingProcess Videos/ActiveEncodings
		/// </summary>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="playSessionId">The play session id.</param>
		public async Task StopEncodingProcessAsync(string deviceId, string playSessionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/ActiveEncodings?deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Merges videos into a single record.
		/// MergeVersions Videos/MergeVersions
		/// </summary>
		/// <param name="ids">Item id list. This allows multiple, comma delimited.</param>
		public async Task MergeVersionsAsync(string[] ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/MergeVersions?"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets additional parts for a video.
		/// GetAdditionalPart Videos/{itemId}/AdditionalParts
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <returns>Additional parts returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetAdditionalPartAsync(string itemId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/AdditionalParts&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes alternate video sources.
		/// DeleteAlternateSources Videos/{itemId}/AlternateSources
		/// </summary>
		/// <param name="itemId">The item id.</param>
		public async Task DeleteAlternateSourcesAsync(string itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/AlternateSources";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Upload an external subtitle file.
		/// UploadSubtitle Videos/{itemId}/Subtitles
		/// </summary>
		/// <param name="itemId">The item the subtitle belongs to.</param>
		/// <param name="requestBody">The request body.</param>
		public async Task UploadSubtitleAsync(string itemId, UploadSubtitleDto requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Subtitles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an external subtitle file.
		/// DeleteSubtitle Videos/{itemId}/Subtitles/{index}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="index">The index of the subtitle file.</param>
		public async Task DeleteSubtitleAsync(string itemId, int index, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/Subtitles/"+index;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a hls video playlist.
		/// GetHlsPlaylistLegacy Videos/{itemId}/hls/{playlistId}/stream.m3u8
		/// </summary>
		/// <param name="itemId">The video id.</param>
		/// <param name="playlistId">The playlist id.</param>
		/// <returns>Hls video playlist returned.</returns>
		public async Task GetHlsPlaylistLegacyAsync(string itemId, string playlistId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/hls/"+ (playlistId==null? "" : System.Uri.EscapeDataString(playlistId))+"/stream.m3u8";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a hls video segment.
		/// GetHlsVideoSegmentLegacy Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="playlistId">The playlist id.</param>
		/// <param name="segmentId">The segment id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <returns>Hls video segment returned.</returns>
		public async Task GetHlsVideoSegmentLegacyAsync(string itemId, string playlistId, string segmentId, string segmentContainer, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/hls/"+ (playlistId==null? "" : System.Uri.EscapeDataString(playlistId))+"/"+ (segmentId==null? "" : System.Uri.EscapeDataString(segmentId))+"."+ (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a video stream using HTTP live streaming.
		/// GetHlsVideoSegment Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="playlistId">The playlist id.</param>
		/// <param name="segmentId">The segment id.</param>
		/// <param name="container">The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment lenght.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <returns>Video stream returned.</returns>
		public async Task GetHlsVideoSegmentAsync(
					string itemId, 
					string playlistId, 
					int segmentId, 
					string container, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/hls1/"+ (playlistId==null? "" : System.Uri.EscapeDataString(playlistId))+"/"+segmentId+"."+ (container==null? "" : System.Uri.EscapeDataString(container))+"&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a hls live stream.
		/// GetLiveHlsStream Videos/{itemId}/live.m3u8
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="container">The audio container.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment lenght.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <param name="maxWidth">Optional. The max width.</param>
		/// <param name="maxHeight">Optional. The max height.</param>
		/// <param name="enableSubtitlesInManifest">Optional. Whether to enable subtitles in the manifest.</param>
		/// <returns>Hls live stream retrieved.</returns>
		public async Task GetLiveHlsStreamAsync(
					string itemId, 
					string container, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					int maxWidth, 
					int maxHeight, 
					bool enableSubtitlesInManifest, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/live.m3u8&container=" + (container==null? "" : System.Uri.EscapeDataString(container))+"&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions+"&maxWidth="+maxWidth+"&maxHeight="+maxHeight+"&enableSubtitlesInManifest="+enableSubtitlesInManifest;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a video stream using HTTP live streaming.
		/// GetVariantHlsVideoPlaylist Videos/{itemId}/main.m3u8
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment length.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <returns>Video stream returned.</returns>
		public async Task GetVariantHlsVideoPlaylistAsync(
					string itemId, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/main.m3u8&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a video hls playlist stream.
		/// GetMasterHlsVideoPlaylist Videos/{itemId}/master.m3u8
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment length.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <param name="enableAdaptiveBitrateStreaming">Enable adaptive bitrate streaming.</param>
		/// <returns>Video stream returned.</returns>
		public async Task GetMasterHlsVideoPlaylistAsync(
					string itemId, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					bool enableAdaptiveBitrateStreaming, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/master.m3u8&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions+"&enableAdaptiveBitrateStreaming="+enableAdaptiveBitrateStreaming;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a video stream.
		/// GetVideoStream Videos/{itemId}/stream
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="container">The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment length.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamorphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <returns>Video stream returned.</returns>
		public async Task GetVideoStreamAsync(
					string itemId, 
					string container, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/stream&container=" + (container==null? "" : System.Uri.EscapeDataString(container))+"&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets subtitles in a specified format.
		/// GetSubtitle Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/Stream.{format}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="mediaSourceId">The media source id.</param>
		/// <param name="index">The subtitle stream index.</param>
		/// <param name="format">The format of the returned subtitle.</param>
		/// <param name="endPositionTicks">Optional. The end position of the subtitle in ticks.</param>
		/// <param name="copyTimestamps">Optional. Whether to copy the timestamps.</param>
		/// <param name="addVttTimeMap">Optional. Whether to add a VTT time map.</param>
		/// <param name="startPositionTicks">Optional. The start position of the subtitle in ticks.</param>
		/// <returns>File returned.</returns>
		public async Task GetSubtitleAsync(string itemId, string mediaSourceId, int index, string format, long endPositionTicks, bool copyTimestamps, bool addVttTimeMap, long startPositionTicks, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/"+ (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"/Subtitles/"+index+"/Stream."+ (format==null? "" : System.Uri.EscapeDataString(format))+"&endPositionTicks="+endPositionTicks+"&copyTimestamps="+copyTimestamps+"&addVttTimeMap="+addVttTimeMap+"&startPositionTicks="+startPositionTicks;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an HLS subtitle playlist.
		/// GetSubtitlePlaylist Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="index">The subtitle stream index.</param>
		/// <param name="mediaSourceId">The media source id.</param>
		/// <param name="segmentLength">The subtitle segment length.</param>
		/// <returns>Subtitle playlist retrieved.</returns>
		public async Task GetSubtitlePlaylistAsync(string itemId, int index, string mediaSourceId, int segmentLength, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/"+ (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"/Subtitles/"+index+"/subtitles.m3u8&segmentLength="+segmentLength;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets subtitles in a specified format.
		/// GetSubtitleWithTicks Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/{startPositionTicks}/Stream.{format}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="mediaSourceId">The media source id.</param>
		/// <param name="index">The subtitle stream index.</param>
		/// <param name="startPositionTicks">Optional. The start position of the subtitle in ticks.</param>
		/// <param name="format">The format of the returned subtitle.</param>
		/// <param name="endPositionTicks">Optional. The end position of the subtitle in ticks.</param>
		/// <param name="copyTimestamps">Optional. Whether to copy the timestamps.</param>
		/// <param name="addVttTimeMap">Optional. Whether to add a VTT time map.</param>
		/// <returns>File returned.</returns>
		public async Task GetSubtitleWithTicksAsync(string itemId, string mediaSourceId, int index, long startPositionTicks, string format, long endPositionTicks, bool copyTimestamps, bool addVttTimeMap, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/"+ (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"/Subtitles/"+index+"/"+startPositionTicks+"/Stream."+ (format==null? "" : System.Uri.EscapeDataString(format))+"&endPositionTicks="+endPositionTicks+"&copyTimestamps="+copyTimestamps+"&addVttTimeMap="+addVttTimeMap;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a video stream.
		/// GetVideoStreamByContainer Videos/{itemId}/{stream}.{container}
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="container">The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.</param>
		/// <param name="_static">Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.</param>
		/// <param name="_params">The streaming parameters.</param>
		/// <param name="tag">The tag.</param>
		/// <param name="deviceProfileId">Optional. The dlna device profile id to utilize.</param>
		/// <param name="playSessionId">The play session id.</param>
		/// <param name="segmentContainer">The segment container.</param>
		/// <param name="segmentLength">The segment lenght.</param>
		/// <param name="minSegments">The minimum number of segments.</param>
		/// <param name="mediaSourceId">The media version id, if playing an alternate version.</param>
		/// <param name="deviceId">The device id of the client requesting. Used to stop encoding processes when needed.</param>
		/// <param name="audioCodec">Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.</param>
		/// <param name="enableAutoStreamCopy">Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.</param>
		/// <param name="allowVideoStreamCopy">Whether or not to allow copying of the video stream url.</param>
		/// <param name="allowAudioStreamCopy">Whether or not to allow copying of the audio stream url.</param>
		/// <param name="breakOnNonKeyFrames">Optional. Whether to break on non key frames.</param>
		/// <param name="audioSampleRate">Optional. Specify a specific audio sample rate, e.g. 44100.</param>
		/// <param name="maxAudioBitDepth">Optional. The maximum audio bit depth.</param>
		/// <param name="audioBitRate">Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.</param>
		/// <param name="audioChannels">Optional. Specify a specific number of audio channels to encode to, e.g. 2.</param>
		/// <param name="maxAudioChannels">Optional. Specify a maximum number of audio channels to encode to, e.g. 2.</param>
		/// <param name="profile">Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.</param>
		/// <param name="level">Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.</param>
		/// <param name="framerate">Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="maxFramerate">Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.</param>
		/// <param name="copyTimestamps">Whether or not to copy timestamps when transcoding with an offset. Defaults to false.</param>
		/// <param name="startTimeTicks">Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.</param>
		/// <param name="width">Optional. The fixed horizontal resolution of the encoded video.</param>
		/// <param name="height">Optional. The fixed vertical resolution of the encoded video.</param>
		/// <param name="videoBitRate">Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.</param>
		/// <param name="subtitleStreamIndex">Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.</param>
		/// <param name="subtitleMethod">Optional. Specify the subtitle delivery method.</param>
		/// <param name="maxRefFrames">Optional.</param>
		/// <param name="maxVideoBitDepth">Optional. The maximum video bit depth.</param>
		/// <param name="requireAvc">Optional. Whether to require avc.</param>
		/// <param name="deInterlace">Optional. Whether to deinterlace the video.</param>
		/// <param name="requireNonAnamorphic">Optional. Whether to require a non anamporphic stream.</param>
		/// <param name="transcodingMaxAudioChannels">Optional. The maximum number of audio channels to transcode.</param>
		/// <param name="cpuCoreLimit">Optional. The limit of how many cpu cores to use.</param>
		/// <param name="liveStreamId">The live stream id.</param>
		/// <param name="enableMpegtsM2TsMode">Optional. Whether to enable the MpegtsM2Ts mode.</param>
		/// <param name="videoCodec">Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.</param>
		/// <param name="subtitleCodec">Optional. Specify a subtitle codec to encode to.</param>
		/// <param name="transcodeReasons">Optional. The transcoding reason.</param>
		/// <param name="audioStreamIndex">Optional. The index of the audio stream to use. If omitted the first audio stream will be used.</param>
		/// <param name="videoStreamIndex">Optional. The index of the video stream to use. If omitted the first video stream will be used.</param>
		/// <param name="context">Optional. The MediaBrowser.Model.Dlna.EncodingContext.</param>
		/// <param name="streamOptions">Optional. The streaming options.</param>
		/// <returns>Video stream returned.</returns>
		public async Task GetVideoStreamByContainerAsync(
					string itemId, 
					string container, 
					bool _static, 
					string _params, 
					string tag, 
					string deviceProfileId, 
					string playSessionId, 
					string segmentContainer, 
					int segmentLength, 
					int minSegments, 
					string mediaSourceId, 
					string deviceId, 
					string audioCodec, 
					bool enableAutoStreamCopy, 
					bool allowVideoStreamCopy, 
					bool allowAudioStreamCopy, 
					bool breakOnNonKeyFrames, 
					int audioSampleRate, 
					int maxAudioBitDepth, 
					int audioBitRate, 
					int audioChannels, 
					int maxAudioChannels, 
					string profile, 
					string level, 
					float framerate, 
					float maxFramerate, 
					bool copyTimestamps, 
					long startTimeTicks, 
					int width, 
					int height, 
					int videoBitRate, 
					int subtitleStreamIndex, 
					MediaStreamDeliveryMethod subtitleMethod, 
					int maxRefFrames, 
					int maxVideoBitDepth, 
					bool requireAvc, 
					bool deInterlace, 
					bool requireNonAnamorphic, 
					int transcodingMaxAudioChannels, 
					int cpuCoreLimit, 
					string liveStreamId, 
					bool enableMpegtsM2TsMode, 
					string videoCodec, 
					string subtitleCodec, 
					string transcodeReasons, 
					int audioStreamIndex, 
					int videoStreamIndex, 
					TranscodingProfileContext context, 
					System.Collections.Generic.Dictionary<string, string> streamOptions, 
					string stream, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (itemId==null? "" : System.Uri.EscapeDataString(itemId))+"/"+ (stream==null? "" : System.Uri.EscapeDataString(stream))+"."+ (container==null? "" : System.Uri.EscapeDataString(container))+"&static="+_static+"&params=" + (_params==null? "" : System.Uri.EscapeDataString(_params))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&deviceProfileId=" + (deviceProfileId==null? "" : System.Uri.EscapeDataString(deviceProfileId))+"&playSessionId=" + (playSessionId==null? "" : System.Uri.EscapeDataString(playSessionId))+"&segmentContainer=" + (segmentContainer==null? "" : System.Uri.EscapeDataString(segmentContainer))+"&segmentLength="+segmentLength+"&minSegments="+minSegments+"&mediaSourceId=" + (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"&deviceId=" + (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"&audioCodec=" + (audioCodec==null? "" : System.Uri.EscapeDataString(audioCodec))+"&enableAutoStreamCopy="+enableAutoStreamCopy+"&allowVideoStreamCopy="+allowVideoStreamCopy+"&allowAudioStreamCopy="+allowAudioStreamCopy+"&breakOnNonKeyFrames="+breakOnNonKeyFrames+"&audioSampleRate="+audioSampleRate+"&maxAudioBitDepth="+maxAudioBitDepth+"&audioBitRate="+audioBitRate+"&audioChannels="+audioChannels+"&maxAudioChannels="+maxAudioChannels+"&profile=" + (profile==null? "" : System.Uri.EscapeDataString(profile))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&framerate="+framerate+"&maxFramerate="+maxFramerate+"&copyTimestamps="+copyTimestamps+"&startTimeTicks="+startTimeTicks+"&width="+width+"&height="+height+"&videoBitRate="+videoBitRate+"&subtitleStreamIndex="+subtitleStreamIndex+"&subtitleMethod=" + subtitleMethod+"&maxRefFrames="+maxRefFrames+"&maxVideoBitDepth="+maxVideoBitDepth+"&requireAvc="+requireAvc+"&deInterlace="+deInterlace+"&requireNonAnamorphic="+requireNonAnamorphic+"&transcodingMaxAudioChannels="+transcodingMaxAudioChannels+"&cpuCoreLimit="+cpuCoreLimit+"&liveStreamId=" + (liveStreamId==null? "" : System.Uri.EscapeDataString(liveStreamId))+"&enableMpegtsM2TsMode="+enableMpegtsM2TsMode+"&videoCodec=" + (videoCodec==null? "" : System.Uri.EscapeDataString(videoCodec))+"&subtitleCodec=" + (subtitleCodec==null? "" : System.Uri.EscapeDataString(subtitleCodec))+"&transcodeReasons=" + (transcodeReasons==null? "" : System.Uri.EscapeDataString(transcodeReasons))+"&audioStreamIndex="+audioStreamIndex+"&videoStreamIndex="+videoStreamIndex+"&context=" + context+"&streamOptions=" + streamOptions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get video attachment.
		/// GetAttachment Videos/{videoId}/{mediaSourceId}/Attachments/{index}
		/// </summary>
		/// <param name="videoId">Video ID.</param>
		/// <param name="mediaSourceId">Media Source ID.</param>
		/// <param name="index">Attachment Index.</param>
		/// <returns>Attachment retrieved.</returns>
		public async Task GetAttachmentAsync(string videoId, string mediaSourceId, int index, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Videos/"+ (videoId==null? "" : System.Uri.EscapeDataString(videoId))+"/"+ (mediaSourceId==null? "" : System.Uri.EscapeDataString(mediaSourceId))+"/Attachments/"+index;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get years.
		/// GetYears Years
		/// </summary>
		/// <param name="startIndex">Skips over a given number of items within the results. Use for paging.</param>
		/// <param name="limit">Optional. The maximum number of records to return.</param>
		/// <param name="sortOrder">Sort Order - Ascending,Descending.</param>
		/// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root.</param>
		/// <param name="fields">Optional. Specify additional fields of information to return in the output.</param>
		/// <param name="excludeItemTypes">Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.</param>
		/// <param name="includeItemTypes">Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.</param>
		/// <param name="mediaTypes">Optional. Filter by MediaType. Allows multiple, comma delimited.</param>
		/// <param name="sortBy">Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.</param>
		/// <param name="enableUserData">Optional. Include user data.</param>
		/// <param name="imageTypeLimit">Optional. The max number of images to return, per image type.</param>
		/// <param name="enableImageTypes">Optional. The image types to include in the output.</param>
		/// <param name="userId">User Id.</param>
		/// <param name="recursive">Search recursively.</param>
		/// <param name="enableImages">Optional. Include image information in output.</param>
		/// <returns>Year query returned.</returns>
		public async Task<BaseItemDtoQueryResult> GetYearsAsync(
					int startIndex, 
					int limit, 
					string sortOrder, 
					string parentId, 
					ItemFields[] fields, 
					string[] excludeItemTypes, 
					string[] includeItemTypes, 
					string[] mediaTypes, 
					string sortBy, 
					bool enableUserData, 
					int imageTypeLimit, 
					ImageType[] enableImageTypes, 
					string userId, 
					bool recursive, 
					bool enableImages, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Years?startIndex="+startIndex+"&limit="+limit+"&sortOrder=" + (sortOrder==null? "" : System.Uri.EscapeDataString(sortOrder))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&"+string.Join("&", fields.Select(z => $"fields={z}"))+"&"+string.Join("&", excludeItemTypes.Select(z => $"excludeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includeItemTypes.Select(z => $"includeItemTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", mediaTypes.Select(z => $"mediaTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&sortBy=" + (sortBy==null? "" : System.Uri.EscapeDataString(sortBy))+"&enableUserData="+enableUserData+"&imageTypeLimit="+imageTypeLimit+"&"+string.Join("&", enableImageTypes.Select(z => $"enableImageTypes={z}"))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&recursive="+recursive+"&enableImages="+enableImages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDtoQueryResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a year.
		/// GetYear Years/{year}
		/// </summary>
		/// <param name="year">The year.</param>
		/// <param name="userId">Optional. Filter by user id, and attach user data.</param>
		/// <returns>Year returned.</returns>
		public async Task<BaseItemDto> GetYearAsync(int year, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "Years/"+year+"?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BaseItemDto>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a dashboard configuration page.
		/// GetDashboardConfigurationPage web/ConfigurationPage
		/// </summary>
		/// <param name="name">The name of the page.</param>
		/// <returns>ConfigurationPage returned.</returns>
		public async Task GetDashboardConfigurationPageAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "web/ConfigurationPage?name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the configuration pages.
		/// GetConfigurationPages web/ConfigurationPages
		/// </summary>
		/// <param name="enableInMainMenu">Whether to enable in the main menu.</param>
		/// <param name="pageType">The Jellyfin.Api.Models.ConfigurationPageInfo.</param>
		/// <returns>ConfigurationPages returned.</returns>
		public async Task<ConfigurationPageInfo[]> GetConfigurationPagesAsync(bool enableInMainMenu, ConfigurationPageInfoConfigurationPageType pageType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "web/ConfigurationPages?enableInMainMenu="+enableInMainMenu+"&pageType=" + pageType;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ConfigurationPageInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
