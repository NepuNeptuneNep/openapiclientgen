//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetItemOutput
	{
		
		/// <summary>
		/// Table names and the respective item attributes from the tables.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchGetResponseMap Responses { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchGetRequestMap UnprocessedKeys { get; set; }
	}
	
	/// <summary>
	/// Table names and the respective item attributes from the tables.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetResponseMap
	{
	}
	
	/// <summary>
	/// A map of the table name and corresponding items to get by primary key. While requesting items, each table name can be invoked only once per operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetRequestMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetItemInput
	{
		
		/// <summary>
		/// A map of the table name and corresponding items to get by primary key. While requesting items, each table name can be invoked only once per operation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BatchGetRequestMap RequestItems { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedThroughputExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RequestLimitExceeded
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalServerError
	{
	}
	
	/// <summary>
	/// A container for <code>BatchWriteItem</code> response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchWriteItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BatchWriteResponseMap Responses { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchWriteItemRequestMap UnprocessedItems { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchWriteResponseMap
	{
	}
	
	/// <summary>
	/// <p>A map of table name to list-of-write-requests.</p> <p>Key: The table name corresponding to the list of requests</p> <p>Value: Essentially a list of request items. Each request item could contain either a <code>PutRequest</code> or <code>DeleteRequest</code>. Never both.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchWriteItemRequestMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchWriteItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BatchWriteItemRequestMap RequestItems { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription TableDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TableDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// The KeySchema identifies the primary key as a one attribute primary key (hash) or a composite two attribute (hash-and-range) primary key. Single attribute primary keys have one index value: a <code>HashKeyElement</code>. A composite hash-and-range primary key contains two attribute values: a <code>HashKeyElement</code> and a <code>RangeKeyElement</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public KeySchema KeySchema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<TableDescriptionTableStatus> TableStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> CreationDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughputDescription ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TableSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ItemCount { get; set; }
	}
	
	/// <summary>
	/// The KeySchema identifies the primary key as a one attribute primary key (hash) or a composite two attribute (hash-and-range) primary key. Single attribute primary keys have one index value: a <code>HashKeyElement</code>. A composite hash-and-range primary key contains two attribute values: a <code>HashKeyElement</code> and a <code>RangeKeyElement</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeySchema
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement HashKeyElement { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement RangeKeyElement { get; set; }
	}
	
	/// <summary>
	/// <code>KeySchemaElement</code> is the primary key (hash or hash-and-range) structure for the table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeySchemaElement
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AttributeName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ScalarAttributeType AttributeType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ScalarAttributeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		S = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		N = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		B = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TableDescriptionTableStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedThroughputDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastIncreaseDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> LastDecreaseDateTime { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> NumberOfDecreasesToday { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> ReadCapacityUnits { get; set; }
		
		/// <summary>
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> WriteCapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// The KeySchema identifies the primary key as a one attribute primary key (hash) or a composite two attribute (hash-and-range) primary key. Single attribute primary keys have one index value: a <code>HashKeyElement</code>. A composite hash-and-range primary key contains two attribute values: a <code>HashKeyElement</code> and a <code>RangeKeyElement</code>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySchema KeySchema { get; set; }
		
		/// <summary>
		/// Provisioned throughput reserves the required read and write resources for your table in terms of <code>ReadCapacityUnits</code> and <code>WriteCapacityUnits</code>. Values for provisioned throughput depend upon your expected read/write rates, item size, and consistency. Provide the expected number of read and write operations, assuming an item size of 1k and strictly consistent reads. For 2k item size, double the value. For 3k, triple the value, etc. Eventually-consistent reads consume half the resources of strictly consistent reads.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
	}
	
	/// <summary>
	/// Provisioned throughput reserves the required read and write resources for your table in terms of <code>ReadCapacityUnits</code> and <code>WriteCapacityUnits</code>. Values for provisioned throughput depend upon your expected read/write rates, item size, and consistency. Provide the expected number of read and write operations, assuming an item size of 1k and strictly consistent reads. For 2k item size, double the value. For 3k, triple the value, etc. Eventually-consistent reads consume half the resources of strictly consistent reads.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedThroughput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int ReadCapacityUnits { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int WriteCapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceInUseException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Attributes { get; set; }
		
		/// <summary>
		/// The number of Capacity Units of the provisioned throughput of the table consumed during the operation. <code>GetItem</code>, <code>BatchGetItem</code>, <code>BatchWriteItem</code>, <code>Query</code>, and <code>Scan</code> operations consume <code>ReadCapacityUnits</code>, while <code>PutItem</code>, <code>UpdateItem</code>, and <code>DeleteItem</code> operations consume <code>WriteCapacityUnits</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ConsumedCapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// The primary key that uniquely identifies each item in a table. A primary key can be a one attribute (hash) primary key or a two attribute (hash-and-range) primary key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		/// <summary>
		/// Designates an attribute for a conditional modification. The <code>Expected</code> parameter allows you to provide an attribute name, and whether or not Amazon DynamoDB should check to see if the attribute has a particular value before modifying it.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ExpectedAttributeMap Expected { get; set; }
		
		/// <summary>
		/// <p>Use this parameter if you want to get the attribute name-value pairs before or after they are modified. For <code>PUT</code> operations, the possible parameter values are <code>NONE</code> (default) or <code>ALL_OLD</code>. For update operations, the possible parameter values are <code>NONE</code> (default) or <code>ALL_OLD</code>, <code>UPDATED_OLD</code>, <code>ALL_NEW</code> or <code>UPDATED_NEW</code>.</p> <ul> <li><code>NONE</code>: Nothing is returned.</li> <li><code>ALL_OLD</code>: Returns the attributes of the item as they were before the operation.</li> <li><code>UPDATED_OLD</code>: Returns the values of the updated attributes, only, as they were before the operation.</li> <li><code>ALL_NEW</code>: Returns all the attributes and their new values after the operation.</li> <li><code>UPDATED_NEW</code>: Returns the values of the updated attributes, only, as they are after the operation.</li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<DeleteItemInputReturnValues> ReturnValues { get; set; }
	}
	
	/// <summary>
	/// The primary key that uniquely identifies each item in a table. A primary key can be a one attribute (hash) primary key or a two attribute (hash-and-range) primary key.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Key
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue HashKeyElement { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue RangeKeyElement { get; set; }
	}
	
	/// <summary>
	/// AttributeValue can be <code>String</code>, <code>Number</code>, <code>Binary</code>, <code>StringSet</code>, <code>NumberSet</code>, <code>BinarySet</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeValue
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string S { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string N { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string B { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SS { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] NS { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] BS { get; set; }
	}
	
	/// <summary>
	/// Designates an attribute for a conditional modification. The <code>Expected</code> parameter allows you to provide an attribute name, and whether or not Amazon DynamoDB should check to see if the attribute has a particular value before modifying it.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpectedAttributeMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DeleteItemInputReturnValues
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_OLD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATED_OLD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_NEW = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATED_NEW = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConditionalCheckFailedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription TableDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription Table { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Item { get; set; }
		
		/// <summary>
		/// The number of Capacity Units of the provisioned throughput of the table consumed during the operation. <code>GetItem</code>, <code>BatchGetItem</code>, <code>BatchWriteItem</code>, <code>Query</code>, and <code>Scan</code> operations consume <code>ReadCapacityUnits</code>, while <code>PutItem</code>, <code>UpdateItem</code>, and <code>DeleteItem</code> operations consume <code>WriteCapacityUnits</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ConsumedCapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// The primary key that uniquely identifies each item in a table. A primary key can be a one attribute (hash) primary key or a two attribute (hash-and-range) primary key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		/// <summary>
		/// List of <code>Attribute</code> names. If attribute names are not specified then all attributes will be returned. If some attributes are not found, they will not appear in the result.
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AttributesToGet { get; set; }
		
		/// <summary>
		/// If set to <code>true</code>, then a consistent read is issued. Otherwise eventually-consistent is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTablesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] TableNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LastEvaluatedTableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTablesInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ExclusiveStartTableName { get; set; }
		
		/// <summary>
		/// A number of maximum table names to return.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Attributes { get; set; }
		
		/// <summary>
		/// The number of Capacity Units of the provisioned throughput of the table consumed during the operation. <code>GetItem</code>, <code>BatchGetItem</code>, <code>BatchWriteItem</code>, <code>Query</code>, and <code>Scan</code> operations consume <code>ReadCapacityUnits</code>, while <code>PutItem</code>, <code>UpdateItem</code>, and <code>DeleteItem</code> operations consume <code>WriteCapacityUnits</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ConsumedCapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// A map of the attributes for the item, and must include the primary key values that define the item. Other attribute name-value pairs can be provided for the item.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PutItemInputAttributeMap Item { get; set; }
		
		/// <summary>
		/// Designates an attribute for a conditional modification. The <code>Expected</code> parameter allows you to provide an attribute name, and whether or not Amazon DynamoDB should check to see if the attribute has a particular value before modifying it.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ExpectedAttributeMap Expected { get; set; }
		
		/// <summary>
		/// <p>Use this parameter if you want to get the attribute name-value pairs before or after they are modified. For <code>PUT</code> operations, the possible parameter values are <code>NONE</code> (default) or <code>ALL_OLD</code>. For update operations, the possible parameter values are <code>NONE</code> (default) or <code>ALL_OLD</code>, <code>UPDATED_OLD</code>, <code>ALL_NEW</code> or <code>UPDATED_NEW</code>.</p> <ul> <li><code>NONE</code>: Nothing is returned.</li> <li><code>ALL_OLD</code>: Returns the attributes of the item as they were before the operation.</li> <li><code>UPDATED_OLD</code>: Returns the values of the updated attributes, only, as they were before the operation.</li> <li><code>ALL_NEW</code>: Returns all the attributes and their new values after the operation.</li> <li><code>UPDATED_NEW</code>: Returns the values of the updated attributes, only, as they are after the operation.</li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeleteItemInputReturnValues ReturnValues { get; set; }
	}
	
	/// <summary>
	/// A map of the attributes for the item, and must include the primary key values that define the item. Other attribute name-value pairs can be provided for the item.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutItemInputAttributeMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Count { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key LastEvaluatedKey { get; set; }
		
		/// <summary>
		/// The number of Capacity Units of the provisioned throughput of the table consumed during the operation. <code>GetItem</code>, <code>BatchGetItem</code>, <code>BatchWriteItem</code>, <code>Query</code>, and <code>Scan</code> operations consume <code>ReadCapacityUnits</code>, while <code>PutItem</code>, <code>UpdateItem</code>, and <code>DeleteItem</code> operations consume <code>WriteCapacityUnits</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ConsumedCapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// List of <code>Attribute</code> names. If attribute names are not specified then all attributes will be returned. If some attributes are not found, they will not appear in the result.
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AttributesToGet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		/// <summary>
		/// If set to <code>true</code>, then a consistent read is issued. Otherwise eventually-consistent is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue HashKeyValue { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Condition RangeKeyCondition { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ScanIndexForward { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key ExclusiveStartKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Condition
	{
		
		/// <summary>
		/// A list of attribute values to be used with a comparison operator for a scan or query operation. For comparisons that require more than one value, such as a <code>BETWEEN</code> comparison, the AttributeValueList contains two attribute values and the comparison operator.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue[] AttributeValueList { get; set; }
		
		/// <summary>
		/// <p>A comparison operator is an enumeration of several operations:</p> <ul> <li><code>EQ</code> for <em>equal</em>.</li> <li><code>NE</code> for <em>not equal</em>.</li> <li><code>IN</code> checks for exact matches.</li> <li><code>LE</code> for <em>less than or equal to</em>.</li> <li><code>LT</code> for <em>less than</em>.</li> <li><code>GE</code> for <em>greater than or equal to</em>.</li> <li><code>GT</code> for <em>greater than</em>.</li> <li><code>BETWEEN</code> for <em>between</em>.</li> <li><code>NOT_NULL</code> for <em>exists</em>.</li> <li><code>NULL</code> for <em>not exists</em>.</li> <li><code>CONTAINS</code> for substring or value in a set.</li> <li><code>NOT_CONTAINS</code> for absence of a substring or absence of a value in a set.</li> <li><code>BEGINS_WITH</code> for a substring prefix.</li> </ul> <p>Scan operations support all available comparison operators.</p> <p>Query operations support a subset of the available comparison operators: EQ, LE, LT, GE, GT, BETWEEN, and BEGINS_WITH.</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConditionComparisonOperator ComparisonOperator { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConditionComparisonOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EQ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GT = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BETWEEN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_NULL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NULL = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTAINS = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_CONTAINS = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BEGINS_WITH = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScanOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Count { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScannedCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key LastEvaluatedKey { get; set; }
		
		/// <summary>
		/// The number of Capacity Units of the provisioned throughput of the table consumed during the operation. <code>GetItem</code>, <code>BatchGetItem</code>, <code>BatchWriteItem</code>, <code>Query</code>, and <code>Scan</code> operations consume <code>ReadCapacityUnits</code>, while <code>PutItem</code>, <code>UpdateItem</code>, and <code>DeleteItem</code> operations consume <code>WriteCapacityUnits</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ConsumedCapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScanInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// List of <code>Attribute</code> names. If attribute names are not specified then all attributes will be returned. If some attributes are not found, they will not appear in the result.
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AttributesToGet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Count { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FilterConditionMap ScanFilter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key ExclusiveStartKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilterConditionMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Attributes { get; set; }
		
		/// <summary>
		/// The number of Capacity Units of the provisioned throughput of the table consumed during the operation. <code>GetItem</code>, <code>BatchGetItem</code>, <code>BatchWriteItem</code>, <code>Query</code>, and <code>Scan</code> operations consume <code>ReadCapacityUnits</code>, while <code>PutItem</code>, <code>UpdateItem</code>, and <code>DeleteItem</code> operations consume <code>WriteCapacityUnits</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ConsumedCapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// The primary key that uniquely identifies each item in a table. A primary key can be a one attribute (hash) primary key or a two attribute (hash-and-range) primary key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		/// <summary>
		/// Map of attribute name to the new value and action for the update. The attribute names specify the attributes to modify, and cannot contain any primary key attributes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AttributeUpdates AttributeUpdates { get; set; }
		
		/// <summary>
		/// Designates an attribute for a conditional modification. The <code>Expected</code> parameter allows you to provide an attribute name, and whether or not Amazon DynamoDB should check to see if the attribute has a particular value before modifying it.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ExpectedAttributeMap Expected { get; set; }
		
		/// <summary>
		/// <p>Use this parameter if you want to get the attribute name-value pairs before or after they are modified. For <code>PUT</code> operations, the possible parameter values are <code>NONE</code> (default) or <code>ALL_OLD</code>. For update operations, the possible parameter values are <code>NONE</code> (default) or <code>ALL_OLD</code>, <code>UPDATED_OLD</code>, <code>ALL_NEW</code> or <code>UPDATED_NEW</code>.</p> <ul> <li><code>NONE</code>: Nothing is returned.</li> <li><code>ALL_OLD</code>: Returns the attributes of the item as they were before the operation.</li> <li><code>UPDATED_OLD</code>: Returns the values of the updated attributes, only, as they were before the operation.</li> <li><code>ALL_NEW</code>: Returns all the attributes and their new values after the operation.</li> <li><code>UPDATED_NEW</code>: Returns the values of the updated attributes, only, as they are after the operation.</li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeleteItemInputReturnValues ReturnValues { get; set; }
	}
	
	/// <summary>
	/// Map of attribute name to the new value and action for the update. The attribute names specify the attributes to modify, and cannot contain any primary key attributes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeUpdates
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription TableDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Provisioned throughput reserves the required read and write resources for your table in terms of <code>ReadCapacityUnits</code> and <code>WriteCapacityUnits</code>. Values for provisioned throughput depend upon your expected read/write rates, item size, and consistency. Provide the expected number of read and write operations, assuming an item size of 1k and strictly consistent reads. For 2k item size, double the value. For 3k, triple the value, etc. Eventually-consistent reads consume half the resources of strictly consistent reads.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
	}
	
	/// <summary>
	/// The type of action for an item update operation. Only use the add action for numbers or sets; the specified value is added to the existing value. If a set of values is specified, the values are added to the existing set. Adds the specified attribute. If the attribute exists, it is replaced by the new value. If no value is specified, this removes the attribute and its value. If a set of values is specified, then the values in the specified set are removed from the old set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AttributeAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE = 2,
	}
	
	/// <summary>
	/// Specifies the attribute to update and how to perform the update. Possible values: <code>PUT</code> (default), <code>ADD</code> or <code>DELETE</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeValueUpdate
	{
		
		/// <summary>
		/// AttributeValue can be <code>String</code>, <code>Number</code>, <code>Binary</code>, <code>StringSet</code>, <code>NumberSet</code>, <code>BinarySet</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue Value { get; set; }
		
		/// <summary>
		/// The type of action for an item update operation. Only use the add action for numbers or sets; the specified value is added to the existing value. If a set of values is specified, the values are added to the existing set. Adds the specified attribute. If the attribute exists, it is replaced by the new value. If no value is specified, this removes the attribute and its value. If a set of values is specified, then the values in the specified set are removed from the old set.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AttributeAction Action { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeysAndAttributes
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// Maximum items: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public Key[] Keys { get; set; }
		
		/// <summary>
		/// List of <code>Attribute</code> names. If attribute names are not specified then all attributes will be returned. If some attributes are not found, they will not appear in the result.
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AttributesToGet { get; set; }
		
		/// <summary>
		/// If set to <code>true</code>, then a consistent read is issued. Otherwise eventually-consistent is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
	}
	
	/// <summary>
	/// The item attributes from a response in a specific table, along with the read resources consumed on the table during the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap[] Items { get; set; }
		
		/// <summary>
		/// The number of Capacity Units of the provisioned throughput of the table consumed during the operation. <code>GetItem</code>, <code>BatchGetItem</code>, <code>BatchWriteItem</code>, <code>Query</code>, and <code>Scan</code> operations consume <code>ReadCapacityUnits</code>, while <code>PutItem</code>, <code>UpdateItem</code>, and <code>DeleteItem</code> operations consume <code>WriteCapacityUnits</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ConsumedCapacityUnits { get; set; }
	}
	
	/// <summary>
	/// This structure is a Union of PutRequest and DeleteRequest. It can contain exactly one of <code>PutRequest</code> or <code>DeleteRequest</code>. Never Both. This is enforced in the code.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WriteRequest
	{
		
		/// <summary>
		/// A container for a Put BatchWrite request
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutRequest PutRequest { get; set; }
		
		/// <summary>
		/// A container for a Delete BatchWrite request
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DeleteRequest DeleteRequest { get; set; }
	}
	
	/// <summary>
	/// A container for a Put BatchWrite request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PutItemInputAttributeMap Item { get; set; }
	}
	
	/// <summary>
	/// A container for a Delete BatchWrite request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchWriteResponse
	{
		
		/// <summary>
		/// The number of Capacity Units of the provisioned throughput of the table consumed during the operation. <code>GetItem</code>, <code>BatchGetItem</code>, <code>BatchWriteItem</code>, <code>Query</code>, and <code>Scan</code> operations consume <code>ReadCapacityUnits</code>, while <code>PutItem</code>, <code>UpdateItem</code>, and <code>DeleteItem</code> operations consume <code>WriteCapacityUnits</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ConsumedCapacityUnits { get; set; }
	}
	
	/// <summary>
	/// <p>A comparison operator is an enumeration of several operations:</p> <ul> <li><code>EQ</code> for <em>equal</em>.</li> <li><code>NE</code> for <em>not equal</em>.</li> <li><code>IN</code> checks for exact matches.</li> <li><code>LE</code> for <em>less than or equal to</em>.</li> <li><code>LT</code> for <em>less than</em>.</li> <li><code>GE</code> for <em>greater than or equal to</em>.</li> <li><code>GT</code> for <em>greater than</em>.</li> <li><code>BETWEEN</code> for <em>between</em>.</li> <li><code>NOT_NULL</code> for <em>exists</em>.</li> <li><code>NULL</code> for <em>not exists</em>.</li> <li><code>CONTAINS</code> for substring or value in a set.</li> <li><code>NOT_CONTAINS</code> for absence of a substring or absence of a value in a set.</li> <li><code>BEGINS_WITH</code> for a substring prefix.</li> </ul> <p>Scan operations support all available comparison operators.</p> <p>Query operations support a subset of the available comparison operators: EQ, LE, LT, GE, GT, BETWEEN, and BEGINS_WITH.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ComparisonOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EQ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GT = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BETWEEN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_NULL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NULL = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTAINS = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_CONTAINS = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BEGINS_WITH = 12,
	}
	
	/// <summary>
	/// <p>Use this parameter if you want to get the attribute name-value pairs before or after they are modified. For <code>PUT</code> operations, the possible parameter values are <code>NONE</code> (default) or <code>ALL_OLD</code>. For update operations, the possible parameter values are <code>NONE</code> (default) or <code>ALL_OLD</code>, <code>UPDATED_OLD</code>, <code>ALL_NEW</code> or <code>UPDATED_NEW</code>.</p> <ul> <li><code>NONE</code>: Nothing is returned.</li> <li><code>ALL_OLD</code>: Returns the attributes of the item as they were before the operation.</li> <li><code>UPDATED_OLD</code>: Returns the values of the updated attributes, only, as they were before the operation.</li> <li><code>ALL_NEW</code>: Returns all the attributes and their new values after the operation.</li> <li><code>UPDATED_NEW</code>: Returns the values of the updated attributes, only, as they are after the operation.</li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReturnValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_OLD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATED_OLD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_NEW = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATED_NEW = 4,
	}
	
	/// <summary>
	/// Allows you to provide an attribute name, and whether or not Amazon DynamoDB should check to see if the attribute value already exists; or if the attribute value exists and has a particular value before changing it.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpectedAttributeValue
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue Value { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Exists { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TableStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 3,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// <p>Retrieves the attributes for multiple items from multiple tables using their primary keys.</p> <p>The maximum number of item attributes that can be retrieved for a single operation is 100. Also, the number of items retrieved is constrained by a 1 MB the size limit. If the response size limit is exceeded or a partial result is returned due to an internal processing failure, Amazon DynamoDB returns an <code>UnprocessedKeys</code> value so you can retry the operation starting with the next item to get.</p> <p>Amazon DynamoDB automatically adjusts the number of items returned per page to enforce this limit. For example, even if you ask to retrieve 100 items, but each individual item is 50k in size, the system returns 20 items and an appropriate <code>UnprocessedKeys</code> value so you can get the next page of results. If necessary, your application needs its own logic to assemble the pages of results into one set.</p>
		/// BatchGetItem #X-Amz-Target=DynamoDB_20111205.BatchGetItem
		/// </summary>
		/// <param name="RequestItems">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<BatchGetItemOutput> BatchGetItemAsync(string RequestItems, BatchGetItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.BatchGetItem?RequestItems=" + (RequestItems==null? "" : System.Uri.EscapeDataString(RequestItems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchGetItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Allows to execute a batch of Put and/or Delete Requests for many tables in a single call. A total of 25 requests are allowed.</p> <p>There are no transaction guarantees provided by this API. It does not allow conditional puts nor does it support return values.</p>
		/// BatchWriteItem #X-Amz-Target=DynamoDB_20111205.BatchWriteItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchWriteItemOutput> BatchWriteItemAsync(BatchWriteItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.BatchWriteItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchWriteItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Adds a new table to your account.</p> <p>The table name must be unique among those associated with the AWS Account issuing the request, and the AWS Region that receives the request (e.g. <code>us-east-1</code>).</p> <p>The <code>CreateTable</code> operation triggers an asynchronous workflow to begin creating the table. Amazon DynamoDB immediately returns the state of the table (<code>CREATING</code>) until the table is in the <code>ACTIVE</code> state. Once the table is in the <code>ACTIVE</code> state, you can perform data plane operations.</p>
		/// CreateTable #X-Amz-Target=DynamoDB_20111205.CreateTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateTableOutput> CreateTableAsync(CreateTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.CreateTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a single item in a table by primary key.</p> <p>You can perform a conditional delete operation that deletes the item if it exists, or if it has an expected attribute value.</p>
		/// DeleteItem #X-Amz-Target=DynamoDB_20111205.DeleteItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteItemOutput> DeleteItemAsync(DeleteItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.DeleteItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a table and all of its items.</p> <p>If the table is in the <code>ACTIVE</code> state, you can delete it. If a table is in <code>CREATING</code> or <code>UPDATING</code> states then Amazon DynamoDB returns a <code>ResourceInUseException</code>. If the specified table does not exist, Amazon DynamoDB returns a <code>ResourceNotFoundException</code>.</p>
		/// DeleteTable #X-Amz-Target=DynamoDB_20111205.DeleteTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteTableOutput> DeleteTableAsync(DeleteTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.DeleteTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves information about the table, including the current status of the table, the primary key schema and when the table was created.</p> <p>If the table does not exist, Amazon DynamoDB returns a <code>ResourceNotFoundException</code>.</p>
		/// DescribeTable #X-Amz-Target=DynamoDB_20111205.DescribeTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeTableOutput> DescribeTableAsync(DescribeTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.DescribeTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves a set of Attributes for an item that matches the primary key.</p> <p>The <code>GetItem</code> operation provides an eventually-consistent read by default. If eventually-consistent reads are not acceptable for your application, use <code>ConsistentRead</code>. Although this operation might take longer than a standard read, it always returns the last updated value.</p>
		/// GetItem #X-Amz-Target=DynamoDB_20111205.GetItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetItemOutput> GetItemAsync(GetItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.GetItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a paginated list of table names created by the AWS Account of the caller in the AWS Region (e.g. <code>us-east-1</code>).
		/// ListTables #X-Amz-Target=DynamoDB_20111205.ListTables
		/// </summary>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="ExclusiveStartTableName">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListTablesOutput> ListTablesAsync(string Limit, string ExclusiveStartTableName, ListTablesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.ListTables?Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&ExclusiveStartTableName=" + (ExclusiveStartTableName==null? "" : System.Uri.EscapeDataString(ExclusiveStartTableName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTablesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a new item, or replaces an old item with a new item (including all the attributes).</p> <p>If an item already exists in the specified table with the same primary key, the new item completely replaces the existing item. You can perform a conditional put (insert a new item if one with the specified primary key doesn't exist), or replace an existing item if it has certain attribute values.</p>
		/// PutItem #X-Amz-Target=DynamoDB_20111205.PutItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutItemOutput> PutItemAsync(PutItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.PutItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the values of one or more items and its attributes by primary key (composite primary key, only).</p> <p>Narrow the scope of the query using comparison operators on the <code>RangeKeyValue</code> of the composite key. Use the <code>ScanIndexForward</code> parameter to get results in forward or reverse order by range key.</p>
		/// Query #X-Amz-Target=DynamoDB_20111205.Query
		/// </summary>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="ExclusiveStartKey">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<QueryOutput> QueryAsync(string Limit, string ExclusiveStartKey, QueryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.Query?Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&ExclusiveStartKey=" + (ExclusiveStartKey==null? "" : System.Uri.EscapeDataString(ExclusiveStartKey));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<QueryOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves one or more items and its attributes by performing a full scan of a table.</p> <p>Provide a <code>ScanFilter</code> to get more specific results.</p>
		/// Scan #X-Amz-Target=DynamoDB_20111205.Scan
		/// </summary>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="ExclusiveStartKey">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ScanOutput> ScanAsync(string Limit, string ExclusiveStartKey, ScanInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.Scan?Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&ExclusiveStartKey=" + (ExclusiveStartKey==null? "" : System.Uri.EscapeDataString(ExclusiveStartKey));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScanOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Edits an existing item's attributes.</p> <p>You can perform a conditional update (insert a new attribute name-value pair if it doesn't exist, or replace an existing name-value pair if it has certain expected attribute values).</p>
		/// UpdateItem #X-Amz-Target=DynamoDB_20111205.UpdateItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateItemOutput> UpdateItemAsync(UpdateItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.UpdateItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Updates the provisioned throughput for the given table.</p> <p>Setting the throughput for a table helps you manage performance and is part of the Provisioned Throughput feature of Amazon DynamoDB.</p>
		/// UpdateTable #X-Amz-Target=DynamoDB_20111205.UpdateTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateTableOutput> UpdateTableAsync(UpdateTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20111205.UpdateTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum BatchGetItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.BatchGetItem")]
		DynamoDB_20111205_BatchGetItem = 0,
	}
	
	public enum BatchWriteItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.BatchWriteItem")]
		DynamoDB_20111205_BatchWriteItem = 0,
	}
	
	public enum CreateTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.CreateTable")]
		DynamoDB_20111205_CreateTable = 0,
	}
	
	public enum DeleteItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.DeleteItem")]
		DynamoDB_20111205_DeleteItem = 0,
	}
	
	public enum DeleteTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.DeleteTable")]
		DynamoDB_20111205_DeleteTable = 0,
	}
	
	public enum DescribeTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.DescribeTable")]
		DynamoDB_20111205_DescribeTable = 0,
	}
	
	public enum GetItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.GetItem")]
		DynamoDB_20111205_GetItem = 0,
	}
	
	public enum ListTablesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.ListTables")]
		DynamoDB_20111205_ListTables = 0,
	}
	
	public enum PutItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.PutItem")]
		DynamoDB_20111205_PutItem = 0,
	}
	
	public enum QueryX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.Query")]
		DynamoDB_20111205_Query = 0,
	}
	
	public enum ScanX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.Scan")]
		DynamoDB_20111205_Scan = 0,
	}
	
	public enum UpdateItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.UpdateItem")]
		DynamoDB_20111205_UpdateItem = 0,
	}
	
	public enum UpdateTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20111205.UpdateTable")]
		DynamoDB_20111205_UpdateTable = 0,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
