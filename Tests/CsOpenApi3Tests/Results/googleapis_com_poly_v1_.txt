//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Represents and describes an asset in the Poly library. An asset is a 3D model or scene created using [Tilt Brush](//www.tiltbrush.com), [Blocks](//vr.google.com/blocks/), or any 3D program that produces a file that can be upload to Poly.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Asset
	{
		
		/// <summary>
		/// The author's publicly visible name. Use this name when giving credit to the author. For more information, see [Licensing](/poly/discover/licensing).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorName")]
		public string AuthorName { get; set; }
		
		/// <summary>
		/// For published assets, the time when the asset was published. For unpublished assets, the time when the asset was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// The human-readable description, set by the asset's author.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The human-readable name, set by the asset's author.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// A list of Formats where each format describes one representation of the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formats")]
		public Format[] Formats { get; set; }
		
		/// <summary>
		/// Whether this asset has been curated by the Poly team.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isCurated")]
		public System.Nullable<System.Boolean> IsCurated { get; set; }
		
		/// <summary>
		/// The license under which the author has made the asset available for use, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="license")]
		public System.Nullable<AssetLicense> License { get; set; }
		
		/// <summary>
		/// Application-defined opaque metadata for this asset. This field is only returned when querying for the signed-in user's own assets, not for public assets. This string is limited to 1K chars. It is up to the creator of the asset to define the format for this string (for example, JSON).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// The unique identifier for the asset in the form: `assets/{ASSET_ID}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Hints for displaying the asset, based on information available when the asset was uploaded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="presentationParams")]
		public PresentationParams PresentationParams { get; set; }
		
		/// <summary>
		/// Info about the sources of this asset (i.e. assets that were remixed to create this asset).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remixInfo")]
		public RemixInfo RemixInfo { get; set; }
		
		/// <summary>
		/// Represents a file in Poly, which can be a root, resource, or thumbnail file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnail")]
		public File Thumbnail { get; set; }
		
		/// <summary>
		/// The time when the asset was last modified. For published assets, whose contents are immutable, the update time changes only when metadata properties, such as visibility, are updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// The visibility of the asset and who can access it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<AssetVisibility> Visibility { get; set; }
	}
	
	/// <summary>
	/// The same asset can be represented in different formats, for example, a [WaveFront .obj](//en.wikipedia.org/wiki/Wavefront_.obj_file) file with its corresponding .mtl file or a [Khronos glTF](//www.khronos.org/gltf) file with its corresponding .glb binary data. A format refers to a specific representation of an asset and contains all information needed to retrieve and describe this representation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Format
	{
		
		/// <summary>
		/// Information on the complexity of this Format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formatComplexity")]
		public FormatComplexity FormatComplexity { get; set; }
		
		/// <summary>
		/// A short string that identifies the format type of this representation. Possible values are: `FBX`, `GLTF`, `GLTF2`, `OBJ`, and `TILT`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formatType")]
		public string FormatType { get; set; }
		
		/// <summary>
		/// A list of dependencies of the root element. May include, but is not limited to, materials, textures, and shader programs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public File[] Resources { get; set; }
		
		/// <summary>
		/// Represents a file in Poly, which can be a root, resource, or thumbnail file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="root")]
		public File Root { get; set; }
	}
	
	/// <summary>
	/// Information on the complexity of this Format.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FormatComplexity
	{
		
		/// <summary>
		/// A non-negative integer that represents the level of detail (LOD) of this format relative to other formats of the same asset with the same format_type. This hint allows you to sort formats from the most-detailed (0) to least-detailed (integers greater than 0).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lodHint")]
		public System.Nullable<System.Int32> LodHint { get; set; }
		
		/// <summary>
		/// The estimated number of triangles.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="triangleCount")]
		public string TriangleCount { get; set; }
	}
	
	/// <summary>
	/// Represents a file in Poly, which can be a root, resource, or thumbnail file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class File
	{
		
		/// <summary>
		/// The MIME content-type, such as `image/png`. For more information, see [MIME types](//developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
		
		/// <summary>
		/// The path of the resource file relative to the root file. For root or thumbnail files, this is just the filename.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePath")]
		public string RelativePath { get; set; }
		
		/// <summary>
		/// The URL where the file data can be retrieved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetLicense
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNKNOWN")]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATIVE_COMMONS_BY")]
		CREATIVE_COMMONS_BY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL_RIGHTS_RESERVED")]
		ALL_RIGHTS_RESERVED = 2,
	}
	
	/// <summary>
	/// Hints for displaying the asset, based on information available when the asset was uploaded.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PresentationParams
	{
		
		/// <summary>
		/// A background color which could be used for displaying the 3D asset in a 'thumbnail' or 'palette' style view. Authors have the option to set this background color when publishing or editing their asset. This is represented as a six-digit hexademical triplet specifying the RGB components of the background color, e.g. #FF0000 for Red.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backgroundColor")]
		public string BackgroundColor { get; set; }
		
		/// <summary>
		/// The materials' diffuse/albedo color. This does not apply to vertex colors or texture maps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="colorSpace")]
		public System.Nullable<PresentationParamsColorSpace> ColorSpace { get; set; }
		
		/// <summary>
		/// A [Quaternion](//en.wikipedia.org/wiki/Quaternion). Please note: if in the response you see "w: 1" and nothing else this is the default value of [0, 0, 0, 1] where x,y, and z are 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orientingRotation")]
		public Quaternion OrientingRotation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PresentationParamsColorSpace
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNKNOWN")]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LINEAR")]
		LINEAR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GAMMA")]
		GAMMA = 2,
	}
	
	/// <summary>
	/// A [Quaternion](//en.wikipedia.org/wiki/Quaternion). Please note: if in the response you see "w: 1" and nothing else this is the default value of [0, 0, 0, 1] where x,y, and z are 0.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Quaternion
	{
		
		/// <summary>
		/// The scalar component.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="w")]
		public System.Nullable<System.Double> W { get; set; }
		
		/// <summary>
		/// The x component.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x")]
		public System.Nullable<System.Double> X { get; set; }
		
		/// <summary>
		/// The y component.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="y")]
		public System.Nullable<System.Double> Y { get; set; }
		
		/// <summary>
		/// The z component.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="z")]
		public System.Nullable<System.Double> Z { get; set; }
	}
	
	/// <summary>
	/// Info about the sources of this asset (i.e. assets that were remixed to create this asset).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemixInfo
	{
		
		/// <summary>
		/// Resource ids for the sources of this remix, of the form: `assets/{ASSET_ID}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceAsset")]
		public string[] SourceAsset { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VISIBILITY_UNSPECIFIED")]
		VISIBILITY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PRIVATE")]
		PRIVATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNLISTED")]
		UNLISTED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PUBLIC")]
		PUBLIC = 3,
	}
	
	/// <summary>
	/// A message generated by the asset import process.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssetImportMessage
	{
		
		/// <summary>
		/// The code associated with this message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<AssetImportMessageCode> Code { get; set; }
		
		/// <summary>
		/// An optional file path. Only present for those error codes that specify it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filePath")]
		public string FilePath { get; set; }
		
		/// <summary>
		/// A message resulting from reading an image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageError")]
		public ImageError ImageError { get; set; }
		
		/// <summary>
		/// Details of an error resulting from parsing an OBJ file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objParseError")]
		public ObjParseError ObjParseError { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetImportMessageCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CODE_UNSPECIFIED")]
		CODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NO_IMPORTABLE_FILE")]
		NO_IMPORTABLE_FILE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EMPTY_MODEL")]
		EMPTY_MODEL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OBJ_PARSE_ERROR")]
		OBJ_PARSE_ERROR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EXPIRED")]
		EXPIRED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMAGE_ERROR")]
		IMAGE_ERROR = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EXTRA_FILES_WITH_ARCHIVE")]
		EXTRA_FILES_WITH_ARCHIVE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DEFAULT_MATERIALS")]
		DEFAULT_MATERIALS = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FATAL_ERROR")]
		FATAL_ERROR = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_ELEMENT_TYPE")]
		INVALID_ELEMENT_TYPE = 9,
	}
	
	/// <summary>
	/// A message resulting from reading an image file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageError
	{
		
		/// <summary>
		/// The type of image error encountered. Optional for older image errors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<ImageErrorCode> Code { get; set; }
		
		/// <summary>
		/// The file path in the import of the image that was rejected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filePath")]
		public string FilePath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImageErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CODE_UNSPECIFIED")]
		CODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_IMAGE")]
		INVALID_IMAGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMAGE_TOO_BIG")]
		IMAGE_TOO_BIG = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WRONG_IMAGE_TYPE")]
		WRONG_IMAGE_TYPE = 3,
	}
	
	/// <summary>
	/// Details of an error resulting from parsing an OBJ file
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ObjParseError
	{
		
		/// <summary>
		/// The type of problem found (required).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<ObjParseErrorCode> Code { get; set; }
		
		/// <summary>
		/// The ending character index at which the problem was found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endIndex")]
		public System.Nullable<System.Int32> EndIndex { get; set; }
		
		/// <summary>
		/// The file path in which the problem was found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filePath")]
		public string FilePath { get; set; }
		
		/// <summary>
		/// The text of the line. Note that this may be truncated if the line was very long. This may not include the error if it occurs after line truncation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="line")]
		public string Line { get; set; }
		
		/// <summary>
		/// Line number at which the problem was found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lineNumber")]
		public System.Nullable<System.Int32> LineNumber { get; set; }
		
		/// <summary>
		/// The starting character index at which the problem was found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startIndex")]
		public System.Nullable<System.Int32> StartIndex { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ObjParseErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CODE_UNSPECIFIED")]
		CODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INCONSISTENT_VERTEX_REFS")]
		INCONSISTENT_VERTEX_REFS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_COMMAND")]
		INVALID_COMMAND = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_NUMBER")]
		INVALID_NUMBER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_VERTEX_REF")]
		INVALID_VERTEX_REF = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MISSING_GEOMETRIC_VERTEX")]
		MISSING_GEOMETRIC_VERTEX = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MISSING_TOKEN")]
		MISSING_TOKEN = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TOO_FEW_DIMENSIONS")]
		TOO_FEW_DIMENSIONS = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TOO_FEW_VERTICES")]
		TOO_FEW_VERTICES = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TOO_MANY_DIMENSIONS")]
		TOO_MANY_DIMENSIONS = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNSUPPORTED_COMMAND")]
		UNSUPPORTED_COMMAND = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNUSED_TOKENS")]
		UNUSED_TOKENS = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VERTEX_NOT_FOUND")]
		VERTEX_NOT_FOUND = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NUMBER_OUT_OF_RANGE")]
		NUMBER_OUT_OF_RANGE = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_VALUE")]
		INVALID_VALUE = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_TEXTURE_OPTION")]
		INVALID_TEXTURE_OPTION = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TOO_MANY_PROBLEMS")]
		TOO_MANY_PROBLEMS = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MISSING_FILE_NAME")]
		MISSING_FILE_NAME = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FILE_NOT_FOUND")]
		FILE_NOT_FOUND = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNKNOWN_MATERIAL")]
		UNKNOWN_MATERIAL = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NO_MATERIAL_DEFINED")]
		NO_MATERIAL_DEFINED = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_SMOOTHING_GROUP")]
		INVALID_SMOOTHING_GROUP = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MISSING_VERTEX_COLORS")]
		MISSING_VERTEX_COLORS = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FILE_SUBSTITUTION")]
		FILE_SUBSTITUTION = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LINE_TOO_LONG")]
		LINE_TOO_LONG = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_FILE_PATH")]
		INVALID_FILE_PATH = 25,
	}
	
	/// <summary>
	/// A response message from a request to list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAssetsResponse
	{
		
		/// <summary>
		/// A list of assets that match the criteria specified in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public Asset[] Assets { get; set; }
		
		/// <summary>
		/// The continuation token for retrieving the next page. If empty, indicates that there are no more pages. To get the next page, submit the same request specifying this value as the page_token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The total number of assets in the list, without pagination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalSize")]
		public System.Nullable<System.Int32> TotalSize { get; set; }
	}
	
	/// <summary>
	/// A response message from a request to list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListLikedAssetsResponse
	{
		
		/// <summary>
		/// A list of assets that match the criteria specified in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public Asset[] Assets { get; set; }
		
		/// <summary>
		/// The continuation token for retrieving the next page. If empty, indicates that there are no more pages. To get the next page, submit the same request specifying this value as the page_token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The total number of assets in the list, without pagination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalSize")]
		public System.Nullable<System.Int32> TotalSize { get; set; }
	}
	
	/// <summary>
	/// A response message from a request to list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListUserAssetsResponse
	{
		
		/// <summary>
		/// The continuation token for retrieving the next page. If empty, indicates that there are no more pages. To get the next page, submit the same request specifying this value as the page_token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The total number of assets in the list, without pagination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalSize")]
		public System.Nullable<System.Int32> TotalSize { get; set; }
		
		/// <summary>
		/// A list of UserAssets matching the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userAssets")]
		public UserAsset[] UserAssets { get; set; }
	}
	
	/// <summary>
	/// Data about the user's asset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserAsset
	{
		
		/// <summary>
		/// Represents and describes an asset in the Poly library. An asset is a 3D model or scene created using [Tilt Brush](//www.tiltbrush.com), [Blocks](//vr.google.com/blocks/), or any 3D program that produces a file that can be upload to Poly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asset")]
		public Asset Asset { get; set; }
	}
	
	/// <summary>
	/// A response message from a request to startImport. This is returned in the response field of the Operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartAssetImportResponse
	{
		
		/// <summary>
		/// The id of newly created asset. If this is empty when the operation is complete it means the import failed. Please refer to the assetImportMessages field to understand what went wrong.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetId")]
		public string AssetId { get; set; }
		
		/// <summary>
		/// The id of the asset import.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetImportId")]
		public string AssetImportId { get; set; }
		
		/// <summary>
		/// The message from the asset import. This will contain any warnings (or - in the case of failure - errors) that occurred during import.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetImportMessages")]
		public AssetImportMessage[] AssetImportMessages { get; set; }
		
		/// <summary>
		/// The publish URL for the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publishUrl")]
		public string PublishUrl { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists all public, remixable assets. These are assets with an access level of PUBLIC and published under the CC-By license.
		/// Poly_assets_list v1/assets
		/// </summary>
		/// <param name="category">Filter assets based on the specified category. Supported values are: `animals`, `architecture`, `art`, `food`, `nature`, `objects`, `people`, `scenes`, `technology`, and `transport`.</param>
		/// <param name="curated">Return only assets that have been curated by the Poly team.</param>
		/// <param name="format">Return only assets with the matching format. Acceptable values are: `BLOCKS`, `FBX`, `GLTF`, `GLTF2`, `OBJ`, `TILT`.</param>
		/// <param name="keywords">One or more search terms to be matched against all text that Poly has indexed for assets, which includes display_name, description, and tags. Multiple keywords should be separated by spaces.</param>
		/// <param name="maxComplexity">Returns assets that are of the specified complexity or less. Defaults to COMPLEX. For example, a request for MEDIUM assets also includes SIMPLE assets.</param>
		/// <param name="orderBy">Specifies an ordering for assets. Acceptable values are: `BEST`, `NEWEST`, `OLDEST`. Defaults to `BEST`, which ranks assets based on a combination of popularity and other features.</param>
		/// <param name="pageSize">The maximum number of assets to be returned. This value must be between `1` and `100`. Defaults to `20`.</param>
		/// <param name="pageToken">Specifies a continuation token from a previous search whose results were split into multiple pages. To get the next page, submit the same request specifying the value from next_page_token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListAssetsResponse> Poly_assets_listAsync(string category, bool curated, string format, string keywords, Poly_assets_listMaxComplexity maxComplexity, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/assets?category=" + (category==null? "" : System.Uri.EscapeDataString(category))+"&curated="+curated+"&format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&keywords=" + (keywords==null? "" : System.Uri.EscapeDataString(keywords))+"&maxComplexity=" + maxComplexity+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListAssetsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns detailed information about an asset given its name. PRIVATE assets are returned only if the currently authenticated user (via OAuth token) is the author of the asset.
		/// Poly_assets_get v1/{name}
		/// </summary>
		/// <param name="name">Required. An asset's name in the form `assets/{ASSET_ID}`.</param>
		/// <returns>Successful response</returns>
		public async Task<Asset> Poly_assets_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Asset>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists assets authored by the given user. Only the value 'me', representing the currently-authenticated user, is supported. May include assets with an access level of PRIVATE or UNLISTED and assets which are All Rights Reserved for the currently-authenticated user.
		/// Poly_users_assets_list v1/{name}/assets
		/// </summary>
		/// <param name="name">A valid user id. Currently, only the special value 'me', representing the currently-authenticated user is supported. To use 'me', you must pass an OAuth token with the request.</param>
		/// <param name="format">Return only assets with the matching format. Acceptable values are: `BLOCKS`, `FBX`, `GLTF`, `GLTF2`, `OBJ`, and `TILT`.</param>
		/// <param name="orderBy">Specifies an ordering for assets. Acceptable values are: `BEST`, `NEWEST`, `OLDEST`. Defaults to `BEST`, which ranks assets based on a combination of popularity and other features.</param>
		/// <param name="pageSize">The maximum number of assets to be returned. This value must be between `1` and `100`. Defaults to `20`.</param>
		/// <param name="pageToken">Specifies a continuation token from a previous search whose results were split into multiple pages. To get the next page, submit the same request specifying the value from next_page_token.</param>
		/// <param name="visibility">The visibility of the assets to be returned. Defaults to VISIBILITY_UNSPECIFIED which returns all assets.</param>
		/// <returns>Successful response</returns>
		public async Task<ListUserAssetsResponse> Poly_users_assets_listAsync(string name, string format, string orderBy, int pageSize, string pageToken, Poly_users_assets_listVisibility visibility, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/assets&format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&visibility=" + visibility;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListUserAssetsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists assets that the user has liked. Only the value 'me', representing the currently-authenticated user, is supported. May include assets with an access level of UNLISTED.
		/// Poly_users_likedassets_list v1/{name}/likedassets
		/// </summary>
		/// <param name="name">A valid user id. Currently, only the special value 'me', representing the currently-authenticated user is supported. To use 'me', you must pass an OAuth token with the request.</param>
		/// <param name="format">Return only assets with the matching format. Acceptable values are: `BLOCKS`, `FBX`, `GLTF`, `GLTF2`, `OBJ`, `TILT`.</param>
		/// <param name="orderBy">Specifies an ordering for assets. Acceptable values are: `BEST`, `NEWEST`, `OLDEST`, 'LIKED_TIME'. Defaults to `LIKED_TIME`, which ranks assets based on how recently they were liked.</param>
		/// <param name="pageSize">The maximum number of assets to be returned. This value must be between `1` and `100`. Defaults to `20`.</param>
		/// <param name="pageToken">Specifies a continuation token from a previous search whose results were split into multiple pages. To get the next page, submit the same request specifying the value from next_page_token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListLikedAssetsResponse> Poly_users_likedassets_listAsync(string name, string format, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/likedassets&format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListLikedAssetsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Poly_assets_listMaxComplexity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPLEXITY_UNSPECIFIED")]
		COMPLEXITY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPLEX")]
		COMPLEX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MEDIUM")]
		MEDIUM = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SIMPLE")]
		SIMPLE = 3,
	}
	
	public enum Poly_users_assets_listVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VISIBILITY_UNSPECIFIED")]
		VISIBILITY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PUBLISHED")]
		PUBLISHED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PRIVATE")]
		PRIVATE = 2,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
