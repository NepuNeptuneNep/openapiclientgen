//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Activity
	{
		
		/// <summary>
		/// If cost prices are utilized on employees, this can be used to determine a markup percentage for the given activity.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costPriceMarkupPercentage")]
		public System.Nullable<System.Double> CostPriceMarkupPercentage { get; set; }
		
		/// <summary>
		/// Date where price should change from before to after.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cutoffDate")]
		public System.Nullable<System.DateTimeOffset> CutoffDate { get; set; }
		
		/// <summary>
		/// The number of the activity group that this activity belongs.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groupNumber")]
		public int GroupNumber { get; set; }
		
		/// <summary>
		/// Hides an activity from employees when registering in e-conomic UI.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hideInSearch")]
		public System.Nullable<System.Boolean> HideInSearch { get; set; }
		
		/// <summary>
		/// If time in lieu is used, this defines which code the activity should utilize when registered upon.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inLieuCode")]
		public System.Nullable<System.Int32> InLieuCode { get; set; }
		
		/// <summary>
		/// Defines whether the activity can be registered upon.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAccessible")]
		public System.Nullable<System.Boolean> IsAccessible { get; set; }
		
		/// <summary>
		/// Name of the activity.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the activity.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Minimum: 1
		/// Maximum: 999999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(1, 999999999)]
		public int Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// Price to be used after defined cut off date if defined.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesPriceAfter")]
		public System.Nullable<System.Double> SalesPriceAfter { get; set; }
		
		/// <summary>
		/// Price for a given activity. This will be utilized if no special price is defined.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesPriceBefore")]
		public System.Nullable<System.Double> SalesPriceBefore { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Activity[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityGroup
	{
		
		/// <summary>
		/// The account number to register costs for closed activities. 
		///
		///If includeCostPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costAccountClosed")]
		public System.Nullable<System.Int32> CostAccountClosed { get; set; }
		
		/// <summary>
		/// The account number to register costs for ongoing activities. 
		///
		///If includeCostPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costAccountOngoing")]
		public System.Nullable<System.Int32> CostAccountOngoing { get; set; }
		
		/// <summary>
		/// The type of account for costs for ongoing activities: 
		///- 0: Debit 
		///- 1: Credit 
		///
		///If includeCostPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costAccountOngoingType")]
		public OngoingAccountType CostAccountOngoingType { get; set; }
		
		/// <summary>
		/// The contra account number to register costs for ongoing activities. 
		///
		///If includeCostPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costContraAccountOngoing")]
		public System.Nullable<System.Int32> CostContraAccountOngoing { get; set; }
		
		/// <summary>
		/// If set to true, activity costs will be included in accounting.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeCostPriceInFinance")]
		public System.Nullable<System.Boolean> IncludeCostPriceInFinance { get; set; }
		
		/// <summary>
		/// If set to true, activity revenue will be included in accounting.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeSalesPriceInFinance")]
		public System.Nullable<System.Boolean> IncludeSalesPriceInFinance { get; set; }
		
		/// <summary>
		/// Name of the activity group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the activity group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// The account number to register revenue for closed activities. 
		///
		///If includeSalesPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesAccountClosed")]
		public System.Nullable<System.Int32> SalesAccountClosed { get; set; }
		
		/// <summary>
		/// The account number to register revenue for ongoing activities. 
		///
		///If includeSalesPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesAccountOngoing")]
		public System.Nullable<System.Int32> SalesAccountOngoing { get; set; }
		
		/// <summary>
		/// The type of account for revenue from ongoing activities: 
		///- 0: Debit 
		///- 1: Credit 
		///
		///If includeSalesPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesAccountOngoingType")]
		public OngoingAccountType SalesAccountOngoingType { get; set; }
		
		/// <summary>
		/// The contra account number to register revenue for ongoing activities. 
		///
		///If includeSalesPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesContraAccountOngoing")]
		public System.Nullable<System.Int32> SalesContraAccountOngoing { get; set; }
		
		/// <summary>
		/// Activity group types: 
		///- 1: Productive, Invoiceable 
		///- 2: Productive, Non-Invoiceable 
		///- 3: Unproductive<p class='filter'>Filterable: eq, ne</p><p class='sort'>Sortable: true</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ActivityGroupType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum OngoingAccountType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ActivityGroupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityGroupCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ActivityGroup[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CostGroupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CostType
	{
		
		/// <summary>
		/// The number of the cost type group that the cost type belongs to.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: true</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="costGroupNumber")]
		public int CostGroupNumber { get; set; }
		
		/// <summary>
		/// It shows whether the cost type can be used to create expenses or not.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBarred")]
		public System.Nullable<System.Boolean> IsBarred { get; set; }
		
		/// <summary>
		/// The date when the cost type was last updated.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdated")]
		public System.Nullable<System.DateTimeOffset> LastUpdated { get; set; }
		
		/// <summary>
		/// Name of the cost type.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the cost type.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Minimum: 1
		/// Maximum: 999999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(1, 999999999)]
		public int Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// The code for the Vat that's going to be applied.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vatCode")]
		public string VatCode { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CostTypeCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public CostType[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CostTypeGroup
	{
		
		/// <summary>
		/// The account number to register costs for closed projects.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: true</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accountClosed")]
		public int AccountClosed { get; set; }
		
		/// <summary>
		/// The account number to register ongoing costs.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: true</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accountOnGoing")]
		public int AccountOnGoing { get; set; }
		
		/// <summary>
		/// The difference in percentage between the sales price and the cost price.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="markup")]
		public System.Nullable<System.Double> Markup { get; set; }
		
		/// <summary>
		/// Name of the cost type group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the cost type group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Minimum: 1
		/// Maximum: 999999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(1, 999999999)]
		public int Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// Cost type group types: 
		///- 1: Invoiceable 
		///- 2: NonInvoiceable<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CostGroupType Type { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CostTypeGroupCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public CostTypeGroup[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreatedResult
	{
		
		/// <summary>
		/// The identifier of the newly created entity<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Employee
	{
		
		/// <summary>
		/// Shows if the employee can be registered on or is barred.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public bool Access { get; set; }
		
		/// <summary>
		/// Employee's email address.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Max length: 50
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string Email { get; set; }
		
		/// <summary>
		/// The number of the employee group that this employee belongs.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groupNumber")]
		public int GroupNumber { get; set; }
		
		/// <summary>
		/// Name of the employee.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the employee.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Minimum: 0
		/// Maximum: 999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(0, 999999)]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// Employee's telephone number.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Max length: 20
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phone")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public string Phone { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EmployeeCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Employee[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EmployeeGroup
	{
		
		/// <summary>
		/// Name of the employee group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the employee group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Minimum: 1
		/// Maximum: 999999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(1, 999999999)]
		public int Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EmployeeGroupCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public EmployeeGroup[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EmployeeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		/// <summary>
		/// Some hints for the developer that might help avoid the error.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="developerHint")]
		public string DeveloperHint { get; set; }
		
		/// <summary>
		/// The error code.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorCode")]
		public string ErrorCode { get; set; }
		
		/// <summary>
		/// The unique log identifier of the error.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logId")]
		public string LogId { get; set; }
		
		/// <summary>
		/// The UTC time of the error being logged.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logTimeUtc")]
		public string LogTimeUtc { get; set; }
		
		/// <summary>
		/// Short description about the error.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The property name in case of validation logic issue.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="property")]
		public string Property { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Mileage
	{
		
		/// <summary>
		/// The date of the project mileage entry<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// The distance amount that the mileage registration should contain<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// The employee number of the project mileage entry<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="employeeNumber")]
		public int EmployeeNumber { get; set; }
		
		/// <summary>
		/// The starting place of the travel which the mileage registration reflects<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// By default it is true, so a user with rights will be able to approve. 
		///					Once it is approved, field becomes false and it will be impossible to approve ever again.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeApprove")]
		public System.Nullable<System.Boolean> IncludeApprove { get; set; }
		
		/// <summary>
		/// Value specifying if the mileage was approved. If it was approved, it can not be updated anymore.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isApproved")]
		public System.Nullable<System.Boolean> IsApproved { get; set; }
		
		/// <summary>
		/// The unique number of the project mileage entry<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// The project number of the project mileage entry<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="projectNumber")]
		public int ProjectNumber { get; set; }
		
		/// <summary>
		/// The destination of the travel which the mileage registration reflects<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MileageCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Mileage[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MileageNumbersCollection
	{
		
		/// <summary>
		/// The mileage numbers.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numbers")]
		public int[] Numbers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MileagePrices
	{
		
		/// <summary>
		/// The total cost of the trip, calculated based on the mileage cost rates.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costPrice")]
		public System.Nullable<System.Double> CostPrice { get; set; }
		
		/// <summary>
		/// The cost of the trip per mile, provided by the mileage setup.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costRate")]
		public System.Nullable<System.Double> CostRate { get; set; }
		
		/// <summary>
		/// The mileage entry identifier.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The total sales price of the trip, calculated based on the mileage sales rates.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesPrice")]
		public System.Nullable<System.Double> SalesPrice { get; set; }
		
		/// <summary>
		/// The sales price of the trip per mile, provided by the mileage setup.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesRate")]
		public System.Nullable<System.Double> SalesRate { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MileagePricesCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public MileagePrices[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project
	{
		
		/// <summary>
		/// The date when the project was closed and booked.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closedDate")]
		public System.Nullable<System.DateTimeOffset> ClosedDate { get; set; }
		
		/// <summary>
		/// The number of the contact person. Has to be from the same customer as the one defined in the project.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contactPersonId")]
		public System.Nullable<System.Int32> ContactPersonId { get; set; }
		
		/// <summary>
		/// Sum of registrations based on cost price for the project<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costPrice")]
		public System.Nullable<System.Double> CostPrice { get; set; }
		
		/// <summary>
		/// Number of customer this project is for. Required if project type is not Internal.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Minimum: 1
		/// Maximum: 999999999
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerNumber")]
		[System.ComponentModel.DataAnnotations.Range(1, 999999999)]
		public System.Nullable<System.Int32> CustomerNumber { get; set; }
		
		/// <summary>
		/// The project delivery date.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryDate")]
		public System.Nullable<System.DateTimeOffset> DeliveryDate { get; set; }
		
		/// <summary>
		/// The location number used to deliver the project.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryLocationNumber")]
		public System.Nullable<System.Int32> DeliveryLocationNumber { get; set; }
		
		/// <summary>
		/// Only relevant if the user uses addon dimensions<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="departmentNumber")]
		public System.Nullable<System.Int32> DepartmentNumber { get; set; }
		
		/// <summary>
		/// Text describing the project.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// Max length: 2500
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(2500)]
		public string Description { get; set; }
		
		/// <summary>
		/// If a fixed price is agreed upon with a customer, this can be utilized. It is not retrieved when invoicing, however, so it is only used for reporting.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedPrice")]
		public System.Nullable<System.Double> FixedPrice { get; set; }
		
		/// <summary>
		/// Sum of invoiced amount for the project<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invoicedTotal")]
		public System.Nullable<System.Double> InvoicedTotal { get; set; }
		
		/// <summary>
		/// Barred projects cannot retrieve registrations<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBarred")]
		public System.Nullable<System.Boolean> IsBarred { get; set; }
		
		/// <summary>
		/// Shows if the project is closed. Closed project can't accept more entries.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isClosed")]
		public System.Nullable<System.Boolean> IsClosed { get; set; }
		
		/// <summary>
		/// Decides whether the project is a main-project or sub-project. If false, it is a sub-project. If true, it is a main-project. Main-projects are grouping of projects. Main-project can't have entries, only sub-projects can.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isMainProject")]
		public System.Nullable<System.Boolean> IsMainProject { get; set; }
		
		/// <summary>
		/// Determines whether mileage should be included on sales invoices of the project<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isMileageInvoiced")]
		public System.Nullable<System.Boolean> IsMileageInvoiced { get; set; }
		
		/// <summary>
		/// The date and time when this project was last updated. Use it in the filter to retrieve only updated projects.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdated")]
		public System.Nullable<System.DateTimeOffset> LastUpdated { get; set; }
		
		/// <summary>
		/// The number of the main project, if this is a sub project linked to a main project. It can be null for both main and sub projects (sub project can exist not linked to any main project, like standalone project).<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mainProjectNumber")]
		public System.Nullable<System.Int32> MainProjectNumber { get; set; }
		
		/// <summary>
		/// Default amount of mileage for the project<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mileage")]
		public System.Nullable<System.Double> Mileage { get; set; }
		
		/// <summary>
		/// Name of the project.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the project. If it's not provided in the POST requests, it's auto-generated.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Minimum: 0
		/// Maximum: 999999999
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(0, 999999999)]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// Second employee number that is responsible for the project.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="otherResponsibleEmployeeNumber")]
		public System.Nullable<System.Int32> OtherResponsibleEmployeeNumber { get; set; }
		
		/// <summary>
		/// The number of the project group that this project belongs.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="projectGroupNumber")]
		public int ProjectGroupNumber { get; set; }
		
		/// <summary>
		/// The employee number that is responsible for the project.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responsibleEmployeeNumber")]
		public System.Nullable<System.Int32> ResponsibleEmployeeNumber { get; set; }
		
		/// <summary>
		/// Sum of registrations based on sales price for the project<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesPrice")]
		public System.Nullable<System.Double> SalesPrice { get; set; }
		
		/// <summary>
		/// The number of the project status. Project status is a separate manageable resource.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectActivity
	{
		
		/// <summary>
		/// The number of the activity that is linked to the project.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activityNumber")]
		public int ActivityNumber { get; set; }
		
		/// <summary>
		/// If set to true, registration on the project is no longer allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completed")]
		public System.Nullable<System.Boolean> Completed { get; set; }
		
		/// <summary>
		/// The date when registration on the project activity stops being allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endDate")]
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// The system unique number of the project activity entry. This property is not visible in the UI.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// The number of the project that the activity is linked to.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="projectNumber")]
		public int ProjectNumber { get; set; }
		
		/// <summary>
		/// The number of the employee that is responsible for the project activity.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responsibleEmployeeNumber")]
		public System.Nullable<System.Int32> ResponsibleEmployeeNumber { get; set; }
		
		/// <summary>
		/// The date when registration on the project activity starts being allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectActivityCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ProjectActivity[] Items { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Project[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectCustomer
	{
		
		/// <summary>
		/// Name of the customer.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Max length: 255
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the customer.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Minimum: 1
		/// Maximum: 999999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(1, 999999999)]
		public int Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectCustomerCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ProjectCustomer[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectEmployee
	{
		
		/// <summary>
		/// Employee's home address.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Address { get; set; }
		
		/// <summary>
		/// Shows if the employee can approve for example time entries.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="canApprove")]
		public bool CanApprove { get; set; }
		
		/// <summary>
		/// Shows if the employee can take for example a time entry to the invoice process.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="canInvoice")]
		public bool CanInvoice { get; set; }
		
		/// <summary>
		/// Employee's city of residence.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Max length: 50
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string City { get; set; }
		
		/// <summary>
		/// The cost after the cut off date.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costPriceAfter")]
		public System.Nullable<System.Double> CostPriceAfter { get; set; }
		
		/// <summary>
		/// The cost before the cut off date.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costPriceBefore")]
		public System.Nullable<System.Double> CostPriceBefore { get; set; }
		
		/// <summary>
		/// By default, salesPriceBefore is used, unless a cutoffDate and salesPriceAfter is determined. The cutoffDate serves the purpose of choosing which date the salesPriceAfter shall apply from. It can be null if only salesPriceBefore should apply.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cutOffDate")]
		public System.Nullable<System.DateOnly> CutOffDate { get; set; }
		
		/// <summary>
		/// Employee types: 
		///- 0: No user in e-conomic 
		///- 1: Time Logger 
		///- 2: Project Manager 
		///- 3: Mobile Time Logger<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="employeeType")]
		public EmployeeType EmployeeType { get; set; }
		
		/// <summary>
		/// The number of the employee group that this employee belongs.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groupNumber")]
		public int GroupNumber { get; set; }
		
		/// <summary>
		/// Shows if the employee can be registered on or is barred.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isBarred")]
		public bool IsBarred { get; set; }
		
		/// <summary>
		/// Shows if the employee is also a user.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isUser")]
		public System.Nullable<System.Boolean> IsUser { get; set; }
		
		/// <summary>
		/// Name of the employee.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the project employee.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Minimum: 1
		/// Maximum: 999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(1, 999999)]
		public int Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// The sale price after the cut off date.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesPriceAfter")]
		public System.Nullable<System.Double> SalesPriceAfter { get; set; }
		
		/// <summary>
		/// The sale price before the cut off date.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesPriceBefore")]
		public System.Nullable<System.Double> SalesPriceBefore { get; set; }
		
		/// <summary>
		/// User id of the employee if it's a user.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
		
		/// <summary>
		/// Employee's zip code.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Max length: 50
		/// Min length: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zipCode")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string ZipCode { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectEmployeeCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ProjectEmployee[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectEmployeeGroup
	{
		
		/// <summary>
		/// Name of the employee group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the employee group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// Required
		/// Minimum: 1
		/// Maximum: 999999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		[System.ComponentModel.DataAnnotations.Range(1, 999999999)]
		public int Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectEmployeeGroupCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ProjectEmployeeGroup[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectGroup
	{
		
		/// <summary>
		/// The account number to register costs for closed projects. 
		///
		///If includeCostPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costAccountClosed")]
		public System.Nullable<System.Int32> CostAccountClosed { get; set; }
		
		/// <summary>
		/// The account number to register costs for ongoing projects. 
		///
		///If includeCostPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costAccountOngoing")]
		public System.Nullable<System.Int32> CostAccountOngoing { get; set; }
		
		/// <summary>
		/// The type of account for costs for ongoing projects: 
		///- 0: Debit 
		///- 1: Credit 
		///
		///If includeCostPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costAccountOngoingType")]
		public OngoingAccountType CostAccountOngoingType { get; set; }
		
		/// <summary>
		/// The contra account number to register costs for ongoing projects. 
		///
		///If includeCostPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costContraAccountOngoing")]
		public System.Nullable<System.Int32> CostContraAccountOngoing { get; set; }
		
		/// <summary>
		/// If set to true, project costs will be included in accounting.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeCostPriceInFinance")]
		public System.Nullable<System.Boolean> IncludeCostPriceInFinance { get; set; }
		
		/// <summary>
		/// If set to true, project revenue will be included in accounting.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeSalesPriceInFinance")]
		public System.Nullable<System.Boolean> IncludeSalesPriceInFinance { get; set; }
		
		/// <summary>
		/// The project group name.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// Required
		/// Max length: 100
		/// Min length: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the project group.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// The account number to register revenue for closed projects. 
		///
		///If includeSalesPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesAccountClosed")]
		public System.Nullable<System.Int32> SalesAccountClosed { get; set; }
		
		/// <summary>
		/// The account number to register revenue for ongoing projects. 
		///
		///If includeSalesPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesAccountOngoing")]
		public System.Nullable<System.Int32> SalesAccountOngoing { get; set; }
		
		/// <summary>
		/// The type of account for revenue from ongoing projects: 
		///- 0: Debit 
		///- 1: Credit 
		///
		///If includeSalesPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesAccountOngoingType")]
		public OngoingAccountType SalesAccountOngoingType { get; set; }
		
		/// <summary>
		/// The contra account number to register revenue for ongoing projects. 
		///
		///If includeSalesPriceInFinance is set to true, this property is required. 
		///
		///Otherwise, it cannot be provided. 
		///
		///Only accessible accounts (not barred) with accountType=="status" or "profitAndLoss" are allowed.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesContraAccountOngoing")]
		public System.Nullable<System.Int32> SalesContraAccountOngoing { get; set; }
		
		/// <summary>
		/// Project group types: 
		///- 1: Internal 
		///- 2: External Invoiceable 
		///- 3: External Non Invoicable<p class='filter'>Filterable: eq, ne</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ProjectGroupType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ProjectGroupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectGroupCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ProjectGroup[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectStatus
	{
		
		/// <summary>
		/// Name of the project status.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique number of the project status.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// Defines the priority of the project status<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// Project status types: 
		///- 1: Quote sent 
		///- 2: Realised<p class='filter'>Filterable: eq, ne</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ProjectStatusType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ProjectStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectStatusCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ProjectStatus[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeEntry
	{
		
		/// <summary>
		/// The activity identifier of time entry.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activityNumber")]
		public int ActivityNumber { get; set; }
		
		/// <summary>
		/// The date of time entry.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// The employee identifier of time entry.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="employeeNumber")]
		public int EmployeeNumber { get; set; }
		
		/// <summary>
		/// Bool value specifying if the time entry was approved. If time entry was approved, it can not be updated anymore.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isApproved")]
		public System.Nullable<System.Boolean> IsApproved { get; set; }
		
		/// <summary>
		/// Bool value specifying if the time entry was reconciled.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isReconciled")]
		public System.Nullable<System.Boolean> IsReconciled { get; set; }
		
		/// <summary>
		/// The time entry last updated date.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: eq, ne, lt, lte, gt, gte</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdated")]
		public System.Nullable<System.DateTimeOffset> LastUpdated { get; set; }
		
		/// <summary>
		/// The time entry identifier.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// Number of hours of time entry.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numberOfHours")]
		public System.Nullable<System.Double> NumberOfHours { get; set; }
		
		/// <summary>
		/// The object version, required for PUT requests.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectVersion")]
		public string ObjectVersion { get; set; }
		
		/// <summary>
		/// The project identifier of time entry.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="projectNumber")]
		public int ProjectNumber { get; set; }
		
		/// <summary>
		/// Text description of time entry.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin, like</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeEntryCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TimeEntry[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeEntryNumbersCollection
	{
		
		/// <summary>
		/// The time entries numbers.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numbers")]
		public int[] Numbers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeEntryPrices
	{
		
		/// <summary>
		/// The time entry cost price, calculated based on the activity cost price or on the employee cost price when no activity price is provided.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costPrice")]
		public System.Nullable<System.Double> CostPrice { get; set; }
		
		/// <summary>
		/// The time entry identifier.<p class='filter'>Filterable: eq, ne, lt, lte, gt, gte, in, nin</p><p class='sort'>Sortable: true</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The time entry sales price, calculated based on the activity sales price or on the employee sales price when no activity price is provided.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salesPrice")]
		public System.Nullable<System.Double> SalesPrice { get; set; }
	}
	
	/// <summary>
	/// Array of objects along with a cursor. Max number in the array returned is 1000
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeEntryPricesCursorResults
	{
		
		/// <summary>
		/// Use this continuation cursor in a request back to continue the list. In case there are no more items to retrieve, the cursor is not returned at all.<p class='filter'>Read-only: true</p><p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursor")]
		public string Cursor { get; set; }
		
		/// <summary>
		/// Max number of items returned is 1000.<p class='filter'>Filterable: not filterable</p><p class='sort'>Sortable: false</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TimeEntryPrices[] Items { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Retrieve all Activities
		/// Use this endpoint to retrieve all Activities in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllActivities activities
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ActivityCursorResults> GetAllActivitiesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activities?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActivityCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Activity
		/// Use this endpoint to create a single Activity.
		/// CreateActivity activities
		/// </summary>
		public async Task CreateActivityAsync(Activity requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activities";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Activity
		/// Use this endpoint to update a single Activity.
		/// UpdateActivity activities
		/// </summary>
		public async Task UpdateActivityAsync(Activity requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activities";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve allowed activities
		/// Use this endpoint to get all the activities that the employee is allowed to register an entry on for a given project. Potential restrictions of registration are based on recording rules in the UI, which cannot be modified through the API. Add the employee number and project to your query parameter to obtain the allowed activities for registrations.
		/// GetAllowedActivities activities/allowed
		/// </summary>
		/// <param name="employeeNumber">The employee number.</param>
		/// <param name="projectNumber">The project number.</param>
		/// <returns>List of allowed activities.</returns>
		public async Task<Activity[]> GetAllowedActivitiesAsync(int employeeNumber, int projectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activities/allowed?employeeNumber="+employeeNumber+"&projectNumber="+projectNumber;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Activity[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Activities
		/// Call this endpoint to get the number of Activities. You can use a filtering as well.
		/// GetNumberOfActivities activities/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfActivitiesAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activities/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Activities
		/// Use this endpoint to load a page of Activities.
		/// GetPageOfActivities activities/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Activity[]> GetPageOfActivitiesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activities/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Activity[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Activity
		/// Use this endpoint to load a single Activity by id/number.
		/// GetActivityById activities/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Activity> GetActivityByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activities/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Activity>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Activity Groups
		/// Use this endpoint to retrieve all Activity Groups in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllActivityGroups activitygroups
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ActivityGroupCursorResults> GetAllActivityGroupsAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activitygroups?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActivityGroupCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Activity Group
		/// Use this endpoint to create a single Activity Group.
		/// CreateActivityGroup activitygroups
		/// </summary>
		public async Task CreateActivityGroupAsync(ActivityGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activitygroups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Activity Groups
		/// Call this endpoint to get the number of Activity Groups. You can use a filtering as well.
		/// GetNumberOfActivityGroups activitygroups/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfActivityGroupsAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activitygroups/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Activity Groups
		/// Use this endpoint to load a page of Activity Groups.
		/// GetPageOfActivityGroups activitygroups/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ActivityGroup[]> GetPageOfActivityGroupsAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activitygroups/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActivityGroup[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Activity Group
		/// Use this endpoint to load a single Activity Group by id/number.
		/// GetActivityGroupById activitygroups/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ActivityGroup> GetActivityGroupByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "activitygroups/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActivityGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Cost Type Groups
		/// Use this endpoint to retrieve all Cost Type Groups in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllCostTypeGroups costtypegroups
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CostTypeGroupCursorResults> GetAllCostTypeGroupsAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "costtypegroups?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CostTypeGroupCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Cost Type Groups
		/// Call this endpoint to get the number of Cost Type Groups. You can use a filtering as well.
		/// GetNumberOfCostTypeGroups costtypegroups/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfCostTypeGroupsAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "costtypegroups/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Cost Type Groups
		/// Use this endpoint to load a page of Cost Type Groups.
		/// GetPageOfCostTypeGroups costtypegroups/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CostTypeGroup[]> GetPageOfCostTypeGroupsAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "costtypegroups/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CostTypeGroup[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Cost Type Group
		/// Use this endpoint to load a single Cost Type Group by id/number.
		/// GetCostTypeGroupById costtypegroups/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CostTypeGroup> GetCostTypeGroupByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "costtypegroups/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CostTypeGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Cost Types
		/// Use this endpoint to retrieve all Cost Types in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllCostTypes costtypes
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CostTypeCursorResults> GetAllCostTypesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "costtypes?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CostTypeCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Cost Types
		/// Call this endpoint to get the number of Cost Types. You can use a filtering as well.
		/// GetNumberOfCostTypes costtypes/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfCostTypesAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "costtypes/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Cost Types
		/// Use this endpoint to load a page of Cost Types.
		/// GetPageOfCostTypes costtypes/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CostType[]> GetPageOfCostTypesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "costtypes/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CostType[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Cost Type
		/// Use this endpoint to load a single Cost Type by id/number.
		/// GetCostTypeById costtypes/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CostType> GetCostTypeByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "costtypes/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CostType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Employee groups
		/// Use this endpoint to retrieve all Employee groups in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllEmployeeGroups employeegroups
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EmployeeGroupCursorResults> GetAllEmployeeGroupsAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employeegroups?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EmployeeGroupCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Employee group
		/// Use this endpoint to create a single Employee group.
		/// CreateEmployeeGroup employeegroups
		/// </summary>
		public async Task CreateEmployeeGroupAsync(EmployeeGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employeegroups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Employee group
		/// Use this endpoint to update a single Employee group.
		/// UpdateEmployeeGroup employeegroups
		/// </summary>
		public async Task UpdateEmployeeGroupAsync(EmployeeGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employeegroups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Employee groups
		/// Call this endpoint to get the number of Employee groups. You can use a filtering as well.
		/// GetNumberOfEmployeeGroups employeegroups/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfEmployeeGroupsAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employeegroups/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Employee groups
		/// Use this endpoint to load a page of Employee groups.
		/// GetPageOfEmployeeGroups employeegroups/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EmployeeGroup[]> GetPageOfEmployeeGroupsAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employeegroups/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EmployeeGroup[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete single Employee group
		/// Use this endpoint to delete a single Employee group by id/number.
		/// DeleteEmployeeGroupById employeegroups/{number}
		/// </summary>
		public async Task DeleteEmployeeGroupByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employeegroups/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Employee group
		/// Use this endpoint to load a single Employee group by id/number.
		/// GetEmployeeGroupById employeegroups/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EmployeeGroup> GetEmployeeGroupByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employeegroups/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EmployeeGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Employees
		/// Use this endpoint to retrieve all Employees in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllEmployees employees
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EmployeeCursorResults> GetAllEmployeesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employees?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EmployeeCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Employee
		/// Use this endpoint to create a single Employee.
		/// CreateEmployee employees
		/// </summary>
		public async Task CreateEmployeeAsync(Employee requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employees";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Employee
		/// Use this endpoint to update a single Employee.
		/// UpdateEmployee employees
		/// </summary>
		public async Task UpdateEmployeeAsync(Employee requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employees";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Employees
		/// Call this endpoint to get the number of Employees. You can use a filtering as well.
		/// GetNumberOfEmployees employees/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfEmployeesAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employees/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Employees
		/// Use this endpoint to load a page of Employees.
		/// GetPageOfEmployees employees/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Employee[]> GetPageOfEmployeesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employees/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Employee[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete single Employee
		/// Use this endpoint to delete a single Employee by id/number.
		/// DeleteEmployeeById employees/{number}
		/// </summary>
		public async Task DeleteEmployeeByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employees/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Employee
		/// Use this endpoint to load a single Employee by id/number.
		/// GetEmployeeById employees/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Employee> GetEmployeeByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "employees/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Employee>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Mileage entry prices
		/// Use this endpoint to retrieve all Mileage entry prices in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllMileageEntryPrices mileageprices
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MileagePricesCursorResults> GetAllMileageEntryPricesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileageprices?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MileagePricesCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Mileage entry prices
		/// Use this endpoint to load a page of Mileage entry prices.
		/// GetPageOfMileageEntryPrices mileageprices/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MileagePrices[]> GetPageOfMileageEntryPricesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileageprices/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MileagePrices[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Mileage entry prices
		/// Use this endpoint to load a single Mileage entry prices by id/number.
		/// GetMileagePricesById mileageprices/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MileagePrices> GetMileagePricesByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileageprices/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MileagePrices>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Mileage entries
		/// Use this endpoint to retrieve all Mileage entries in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllMileageEntries mileages
		/// </summary>
		/// <returns>Success</returns>
		public async Task<MileageCursorResults> GetAllMileageEntriesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileages?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MileageCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Mileage entry
		/// Use this endpoint to create a single Mileage entry.
		/// CreateMileage mileages
		/// </summary>
		public async Task CreateMileageAsync(Mileage requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Mileage entry
		/// Use this endpoint to update a single Mileage entry.
		/// UpdateMileage mileages
		/// </summary>
		public async Task UpdateMileageAsync(Mileage requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Approve a list of Mileage entries
		/// Use this endpoint to approve a list of Mileage entries.
		/// ApproveMileageEntries mileages/approve
		/// </summary>
		public async Task ApproveMileageEntriesAsync(MileageNumbersCollection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileages/approve";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Mileage entries
		/// Call this endpoint to get the number of Mileage entries. You can use a filtering as well.
		/// GetNumberOfMileageEntries mileages/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfMileageEntriesAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileages/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Mileage entries
		/// Use this endpoint to load a page of Mileage entries.
		/// GetPageOfMileageEntries mileages/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Mileage[]> GetPageOfMileageEntriesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileages/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Mileage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete single Mileage entry
		/// Use this endpoint to delete a single Mileage entry by id/number.
		/// DeleteMileageById mileages/{number}
		/// </summary>
		public async Task DeleteMileageByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileages/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Mileage entry
		/// Use this endpoint to load a single Mileage entry by id/number.
		/// GetMileageById mileages/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Mileage> GetMileageByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mileages/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Mileage>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Project Activities
		/// Use this endpoint to retrieve all Project Activities in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllProjectActivities project-activities
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectActivityCursorResults> GetAllProjectActivitiesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-activities?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectActivityCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Project Activity
		/// Use this endpoint to create a single Project Activity.
		/// CreateProjectActivity project-activities
		/// </summary>
		public async Task CreateProjectActivityAsync(ProjectActivity requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-activities";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Project Activity
		/// Use this endpoint to update a single Project Activity.
		/// UpdateProjectActivity project-activities
		/// </summary>
		public async Task UpdateProjectActivityAsync(ProjectActivity requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-activities";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Project Activities
		/// Call this endpoint to get the number of Project Activities. You can use a filtering as well.
		/// GetNumberOfProjectActivities project-activities/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfProjectActivitiesAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-activities/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Project Activities
		/// Use this endpoint to load a page of Project Activities.
		/// GetPageOfProjectActivities project-activities/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectActivity[]> GetPageOfProjectActivitiesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-activities/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectActivity[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete single Project Activity
		/// Use this endpoint to delete a single Project Activity by id/number.
		/// DeleteProjectActivityById project-activities/{number}
		/// </summary>
		public async Task DeleteProjectActivityByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-activities/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Project Activity
		/// Use this endpoint to load a single Project Activity by id/number.
		/// GetProjectActivityById project-activities/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectActivity> GetProjectActivityByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-activities/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectActivity>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Project Customers
		/// Use this endpoint to retrieve all Project Customers in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllProjectCustomers project-customers
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectCustomerCursorResults> GetAllProjectCustomersAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-customers?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectCustomerCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Project Customers
		/// Call this endpoint to get the number of Project Customers. You can use a filtering as well.
		/// GetNumberOfProjectCustomers project-customers/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfProjectCustomersAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-customers/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Project Customers
		/// Use this endpoint to load a page of Project Customers.
		/// GetPageOfProjectCustomers project-customers/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectCustomer[]> GetPageOfProjectCustomersAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-customers/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectCustomer[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Project Customer
		/// Use this endpoint to load a single Project Customer by id/number.
		/// GetProjectCustomerById project-customers/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectCustomer> GetProjectCustomerByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-customers/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectCustomer>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Project employee groups
		/// Use this endpoint to retrieve all Project employee groups in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllProjectEmployeeGroups project-employeegroups
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectEmployeeGroupCursorResults> GetAllProjectEmployeeGroupsAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employeegroups?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectEmployeeGroupCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Project employee group
		/// Use this endpoint to create a single Project employee group.
		/// CreateProjectEmployeeGroup project-employeegroups
		/// </summary>
		public async Task CreateProjectEmployeeGroupAsync(ProjectEmployeeGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employeegroups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Project employee group
		/// Use this endpoint to update a single Project employee group.
		/// UpdateProjectEmployeeGroup project-employeegroups
		/// </summary>
		public async Task UpdateProjectEmployeeGroupAsync(ProjectEmployeeGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employeegroups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Project employee groups
		/// Call this endpoint to get the number of Project employee groups. You can use a filtering as well.
		/// GetNumberOfProjectEmployeeGroups project-employeegroups/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfProjectEmployeeGroupsAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employeegroups/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Project employee groups
		/// Use this endpoint to load a page of Project employee groups.
		/// GetPageOfProjectEmployeeGroups project-employeegroups/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectEmployeeGroup[]> GetPageOfProjectEmployeeGroupsAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employeegroups/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectEmployeeGroup[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete single Project employee group
		/// Use this endpoint to delete a single Project employee group by id/number.
		/// DeleteProjectEmployeeGroupById project-employeegroups/{number}
		/// </summary>
		public async Task DeleteProjectEmployeeGroupByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employeegroups/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Project employee group
		/// Use this endpoint to load a single Project employee group by id/number.
		/// GetProjectEmployeeGroupById project-employeegroups/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectEmployeeGroup> GetProjectEmployeeGroupByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employeegroups/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectEmployeeGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Project employees
		/// Use this endpoint to retrieve all Project employees in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllProjectEmployees project-employees
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectEmployeeCursorResults> GetAllProjectEmployeesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employees?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectEmployeeCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Project employee
		/// Use this endpoint to create a single Project employee.
		/// CreateProjectEmployee project-employees
		/// </summary>
		public async Task CreateProjectEmployeeAsync(ProjectEmployee requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employees";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Project employee
		/// Use this endpoint to update a single Project employee.
		/// UpdateProjectEmployee project-employees
		/// </summary>
		public async Task UpdateProjectEmployeeAsync(ProjectEmployee requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employees";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Project employees
		/// Call this endpoint to get the number of Project employees. You can use a filtering as well.
		/// GetNumberOfProjectEmployees project-employees/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfProjectEmployeesAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employees/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Project employees
		/// Use this endpoint to load a page of Project employees.
		/// GetPageOfProjectEmployees project-employees/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectEmployee[]> GetPageOfProjectEmployeesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employees/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectEmployee[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete single Project employee
		/// Use this endpoint to delete a single Project employee by id/number.
		/// DeleteProjectEmployeeById project-employees/{number}
		/// </summary>
		public async Task DeleteProjectEmployeeByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employees/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Project employee
		/// Use this endpoint to load a single Project employee by id/number.
		/// GetProjectEmployeeById project-employees/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectEmployee> GetProjectEmployeeByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "project-employees/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectEmployee>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Project Groups
		/// Use this endpoint to retrieve all Project Groups in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllProjectGroups projectgroups
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectGroupCursorResults> GetAllProjectGroupsAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectgroups?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectGroupCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Project Group
		/// Use this endpoint to create a single Project Group.
		/// CreateProjectGroup projectgroups
		/// </summary>
		public async Task CreateProjectGroupAsync(ProjectGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectgroups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Project Groups
		/// Call this endpoint to get the number of Project Groups. You can use a filtering as well.
		/// GetNumberOfProjectGroups projectgroups/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfProjectGroupsAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectgroups/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Project Groups
		/// Use this endpoint to load a page of Project Groups.
		/// GetPageOfProjectGroups projectgroups/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectGroup[]> GetPageOfProjectGroupsAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectgroups/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectGroup[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Project Group
		/// Use this endpoint to load a single Project Group by id/number.
		/// GetProjectGroupById projectgroups/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectGroup> GetProjectGroupByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectgroups/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Projects
		/// Use this endpoint to retrieve all Projects in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllProjects projects
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectCursorResults> GetAllProjectsAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Project
		/// Use this endpoint to create a single Project.
		/// CreateProject projects
		/// </summary>
		public async Task CreateProjectAsync(Project requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Project
		/// Use this endpoint to update a single Project.
		/// UpdateProject projects
		/// </summary>
		public async Task UpdateProjectAsync(Project requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the allowed projects that employee can register an entry on.
		/// Use this endpoint to get all the projects that the employee is allowed to register an entry on. Potential restrictions of registration are based on recording rules in the UI, which cannot be modified through the API. Add the employee number to your query parameter to obtain the allowed projects for registrations.
		/// GetPagedListOfProjectUnderEmployee projects/allowed
		/// </summary>
		/// <param name="employeeNumber">The employee number.</param>
		/// <returns>Success</returns>
		public async Task<Project[]> GetPagedListOfProjectUnderEmployeeAsync(int employeeNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/allowed?employeeNumber="+employeeNumber;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Projects
		/// Call this endpoint to get the number of Projects. You can use a filtering as well.
		/// GetNumberOfProjects projects/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfProjectsAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Projects
		/// Use this endpoint to load a page of Projects.
		/// GetPageOfProjects projects/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Project[]> GetPageOfProjectsAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete single Project
		/// Use this endpoint to delete a single Project by id/number.
		/// DeleteProjectById projects/{number}
		/// </summary>
		public async Task DeleteProjectByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Project
		/// Use this endpoint to load a single Project by id/number.
		/// GetProjectById projects/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Project> GetProjectByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Project Statuses
		/// Use this endpoint to retrieve all Project Statuses in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllProjectStatuses projectstatuses
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectStatusCursorResults> GetAllProjectStatusesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectstatuses?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectStatusCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Project Statuses
		/// Call this endpoint to get the number of Project Statuses. You can use a filtering as well.
		/// GetNumberOfProjectStatuses projectstatuses/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfProjectStatusesAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectstatuses/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Project Statuses
		/// Use this endpoint to load a page of Project Statuses.
		/// GetPageOfProjectStatuses projectstatuses/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectStatus[]> GetPageOfProjectStatusesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectstatuses/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectStatus[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Project Status
		/// Use this endpoint to load a single Project Status by id/number.
		/// GetProjectStatusById projectstatuses/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ProjectStatus> GetProjectStatusByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projectstatuses/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Time entries
		/// Use this endpoint to retrieve all Time entries in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllTimeEntries timeentries
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TimeEntryCursorResults> GetAllTimeEntriesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentries?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TimeEntryCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a single Time entry
		/// Use this endpoint to create a single Time entry.
		/// CreateTimeEntry timeentries
		/// </summary>
		public async Task CreateTimeEntryAsync(TimeEntry requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentries";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a single Time entry
		/// Use this endpoint to update a single Time entry.
		/// UpdateTimeEntry timeentries
		/// </summary>
		public async Task UpdateTimeEntryAsync(TimeEntry requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentries";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Approve a list of Time entries
		/// Use this endpoint to approve a list of Time entries.
		/// ApproveTimeEntries timeentries/approve
		/// </summary>
		public async Task ApproveTimeEntriesAsync(TimeEntryNumbersCollection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentries/approve";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the number of Time entries
		/// Call this endpoint to get the number of Time entries. You can use a filtering as well.
		/// GetNumberOfTimeEntries timeentries/count
		/// </summary>
		/// <returns>Success</returns>
		public async Task<int> GetNumberOfTimeEntriesAsync(string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentries/count?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<int>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Time entries
		/// Use this endpoint to load a page of Time entries.
		/// GetPageOfTimeEntries timeentries/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TimeEntry[]> GetPageOfTimeEntriesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentries/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TimeEntry[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete single Time entry
		/// Use this endpoint to delete a single Time entry by id/number.
		/// DeleteTimeEntryById timeentries/{number}
		/// </summary>
		public async Task DeleteTimeEntryByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentries/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Time entry
		/// Use this endpoint to load a single Time entry by id/number.
		/// GetTimeEntryById timeentries/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TimeEntry> GetTimeEntryByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentries/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TimeEntry>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Time entry prices
		/// Use this endpoint to retrieve all Time entry prices in bulk.  Max number of items returned in a single call is 1000. Use the continuation cursor parameter to set the continuation cursor for retrieval of next set of data. [pagination instructions](#section/Retrieving-data/Pagination)
		/// GetAllTimeEntryPrices timeentryprices
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TimeEntryPricesCursorResults> GetAllTimeEntryPricesAsync(string Cursor, string Filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentryprices?Cursor=" + (Cursor==null? "" : System.Uri.EscapeDataString(Cursor))+"&Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TimeEntryPricesCursorResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a page of Time entry prices
		/// Use this endpoint to load a page of Time entry prices.
		/// GetPageOfTimeEntryPrices timeentryprices/paged
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TimeEntryPrices[]> GetPageOfTimeEntryPricesAsync(string Filter, string Sort, int PageSize, int SkipPages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentryprices/paged?Filter=" + (Filter==null? "" : System.Uri.EscapeDataString(Filter))+"&Sort=" + (Sort==null? "" : System.Uri.EscapeDataString(Sort))+"&PageSize="+PageSize+"&SkipPages="+SkipPages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TimeEntryPrices[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve single Time entry prices
		/// Use this endpoint to load a single Time entry prices by id/number.
		/// GetTimeEntryPricesById timeentryprices/{number}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TimeEntryPrices> GetTimeEntryPricesByIdAsync(int number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "timeentryprices/"+number;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TimeEntryPrices>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
