//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Analysis
	{
		
		/// <summary>
		/// The commit identifier.
		///The commit identifier is included only if the same commit was successfully analyzed for all languages. A detailed breakdown of which commit was analyzed for each language is provided in the `languages` property.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commit-id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// The analysis identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Per-language information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="languages")]
		public Language_stats[] Languages { get; set; }
		
		/// <summary>
		/// A page on LGTM to view the logs for this analysis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="log-url")]
		public string Log_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="project")]
		public Project Project { get; set; }
		
		/// <summary>
		/// A page on LGTM to view the results of this analysis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results-url")]
		public string Results_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Language_stats
	{
		
		/// <summary>
		/// The number of alerts for this language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alerts")]
		public System.Nullable<System.Int32> Alerts { get; set; }
		
		/// <summary>
		/// The time the commit was analyzed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="analysis-date")]
		public System.Nullable<System.DateTimeOffset> Analysis_date { get; set; }
		
		/// <summary>
		/// The time of the commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commit-date")]
		public System.Nullable<System.DateTimeOffset> Commit_date { get; set; }
		
		/// <summary>
		/// The latest successfully analyzed commit for the language. All statistics refer to this commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commit-id")]
		public string Commit_id { get; set; }
		
		/// <summary>
		/// The short name for the language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// The number of lines of code for this language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lines")]
		public System.Nullable<System.Int32> Lines { get; set; }
		
		/// <summary>
		/// The status of the analysis of this language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<Language_statsStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Language_statsStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="success")]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="failure")]
		failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pending")]
		pending = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project
	{
		
		/// <summary>
		/// The numeric identifier of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// The display name of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The full URL of the project on LGTM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The URL identifier of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url-identifier")]
		public string Url_identifier { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Code_review
	{
		
		/// <summary>
		/// The identifier for the review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Detailed information for each language analyzed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="languages")]
		public Codereview_languages[] Languages { get; set; }
		
		/// <summary>
		/// A page on LGTM to view the status and results of this code review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results-url")]
		public string Results_url { get; set; }
		
		/// <summary>
		/// The status of the code review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Codereview_languagesStatus Status { get; set; }
		
		/// <summary>
		/// A summary of the current status of the code review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status-message")]
		public string Status_message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Codereview_languages
	{
		
		/// <summary>
		/// The list of added and fixed alerts per query for this language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alerts")]
		public Codereview_alerts[] Alerts { get; set; }
		
		/// <summary>
		/// The total number of alerts fixed by the patch for this language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixed")]
		public System.Nullable<System.Int32> Fixed { get; set; }
		
		/// <summary>
		/// The language analyzed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// The total number of alerts introduced by the patch for this language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="new")]
		public System.Nullable<System.Int32> New { get; set; }
		
		/// <summary>
		/// The status for analysis of this language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<Codereview_languagesStatus> Status { get; set; }
		
		/// <summary>
		/// The current state of analysis of this langauge. When available, a summary of analysis results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status-message")]
		public string Status_message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Codereview_alerts
	{
		
		/// <summary>
		/// The number of alerts fixed by the patch for this query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixed")]
		public System.Nullable<System.Int32> Fixed { get; set; }
		
		/// <summary>
		/// The number of alerts introduced by the patch for this query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="new")]
		public System.Nullable<System.Int32> New { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="query")]
		public Query Query { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Query
	{
		
		/// <summary>
		/// The numeric identifier of the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// The [language code](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) of the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// The `@name` of the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The name of the query pack that contains the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pack")]
		public string Pack { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Query_properties Properties { get; set; }
		
		/// <summary>
		/// A page on LGTM to view the details of the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Query_properties
	{
		
		/// <summary>
		/// The `@id` of the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The `@name` of the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The severity of the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
		
		/// <summary>
		/// The `@tags` associated with the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Codereview_languagesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pending")]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="failure")]
		failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="success")]
		success = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Health
	{
		
		/// <summary>
		/// A description of the status of the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Details of the health of the service. This contains information about the status of the components on which the service depends.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public System.Collections.Generic.Dictionary<string, Health> Details { get; set; }
		
		/// <summary>
		/// The status of the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<HealthStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum HealthStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNKNOWN")]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UP")]
		UP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DOWN")]
		DOWN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Measurement
	{
		
		/// <summary>
		/// The date and time when this metric was computed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
		
		/// <summary>
		/// The value of this metric at the timestamp reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Metric
	{
		
		/// <summary>
		/// A time series of values taken by the metric at different timestamps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="measurements")]
		public Measurement[] Measurements { get; set; }
		
		/// <summary>
		/// The identifier by which this metric is referenced in the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metric-id")]
		public string Metric_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Metric_name
	{
		
		/// <summary>
		/// The name by which the metric is listed in the user interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The identifier by which this metric is referenced in the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metric-id")]
		public string Metric_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Metrics_list
	{
		
		/// <summary>
		/// The list of names and identifiers by which the metrics are referenced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Metric_name[] Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Operation
	{
		
		/// <summary>
		/// The identifier for the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int64> Id { get; set; }
		
		/// <summary>
		/// Status of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<OperationStatus> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="task-result")]
		public Analysis Task_result { get; set; }
		
		/// <summary>
		/// The URL for the result of the task. For some operations, included only on completion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="task-result-url")]
		public string Task_result_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="task-type")]
		public OperationTask_type Task_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uploads")]
		public System.Collections.Generic.Dictionary<string, Upload_session> Uploads { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum OperationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pending")]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="done")]
		done = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum OperationTask_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="analysis")]
		analysis = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="codereview")]
		codereview = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="queryjob")]
		queryjob = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Upload_session
	{
		
		/// <summary>
		/// The identifier of the upload session
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The URL for uploading file content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project_details : Project
	{
		
		/// <summary>
		/// Per-language information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="languages")]
		public Project_language_stats[] Languages { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project_language_stats : Language_stats
	{
		
		/// <summary>
		/// The grade of the code for this language.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grade")]
		public System.Nullable<Project_language_statsGrade> Grade { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Project_language_statsGrade
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="A+")]
		APlus = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="A")]
		A = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="B")]
		B = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="C")]
		C = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="D")]
		D = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="E")]
		E = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project_list
	{
		
		/// <summary>
		/// A single page of projects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Project[] Data { get; set; }
		
		/// <summary>
		/// The URL to retrieve the next page of projects. Omitted if there is no next page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageUrl")]
		public string NextPageUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Query_result_entry
	{
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public string File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="line")]
		public System.Nullable<System.Int32> Line { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Queryjob
	{
		
		/// <summary>
		/// The identifier for the QueryJob.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// URL to view the result of the query job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result-url")]
		public string Result_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stats")]
		public Queryjob_stats Stats { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Queryjob_stats
	{
		
		/// <summary>
		/// The number of projects for which the query failed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failed")]
		public System.Nullable<System.Int32> Failed { get; set; }
		
		/// <summary>
		/// The number of projects scheduled for execution but pending. For very large jobs, not all projects are scheduled at the same time. Therefore, this number might increase as more projects are scheduled. This means that `successful + failed + pending` might be smaller than the total number of project that will be analyzed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pending")]
		public System.Nullable<System.Int32> Pending { get; set; }
		
		/// <summary>
		/// The number of projects for which the query returned results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="success-with-result")]
		public System.Nullable<System.Int32> Success_with_result { get; set; }
		
		/// <summary>
		/// The number of projects for which the query was successful but returned no results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="success-without-result")]
		public System.Nullable<System.Int32> Success_without_result { get; set; }
		
		/// <summary>
		/// The number of projects for which the query completed succesfully. These are broken down further between the ones that have results (`success-with-result`) and the ones that do not (`success-without-result`): `successful = success-with-result + success-without-result`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="successful")]
		public System.Nullable<System.Int32> Successful { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Queryjob_project_results
	{
		
		/// <summary>
		/// Columns returned by the query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columns")]
		public string[] Columns { get; set; }
		
		/// <summary>
		/// Results of the query divided by row.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string[] Data { get; set; }
		
		/// <summary>
		/// URL for retrieving the next part of the results (if applicable).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next")]
		public string Next { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="project")]
		public Project Project { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Queryjob_results_overview
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Queryjob_results_overview_entry[] Data { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next")]
		public string Next { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Queryjob_results_overview_entry
	{
		
		/// <summary>
		/// Error message. Only applies if `status` is `error`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		/// <summary>
		/// Number of results that refer to elements outside the source tree (e.g., libraries). Only applies if `status` is `success`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="external")]
		public System.Nullable<System.Int32> External { get; set; }
		
		/// <summary>
		/// Number of results that refer to elements within the source tree. Only applies if `status` is `success`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internal")]
		public System.Nullable<System.Int32> Internal { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="project")]
		public Project Project { get; set; }
		
		/// <summary>
		/// Describes whether the query was sucessfully executed against the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<Queryjob_results_overview_entryStatus> Status { get; set; }
		
		/// <summary>
		/// Number of results returned by the query. This is broken down further into `internal` and `external` results. Only applies if `status` is `success`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Queryjob_results_overview_entryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="success")]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="error")]
		error = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Version
	{
		
		/// <summary>
		/// The version number of the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Version information
		/// Get the version information of this API.
		/// GetVersion 
		/// </summary>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Version> GetVersionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Version>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get analysis summary
		/// Get a summary of the analysis results for a specific analysis identifier.
		/// 
		/// To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}` endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).
		/// 
		/// This endpoint reports the commit analyzed and a summary of the results for each language. Alternatively, you can use this identifier to download full details  of all the alerts found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
		/// 
		/// GetAnalysis analyses/{analysis_id}
		/// </summary>
		/// <param name="analysis_id">The analysis identifier.
		/// Min length: 40
		/// Max length: 40
		// </param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Analysis> GetAnalysisAsync(string analysis_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyses/{analysis_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Analysis>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detailed alert information
		/// Download all the alerts found by an analysis.
		/// Use the `Accept:` request header to specify the output media type as either CSV or [SARIF](https://lgtm.com/help/lgtm/sarif-results-file):
		/// 
		/// - `application/sarif+json`: Alerts in SARIF format. If no version is specified the latest supported SARIF version is used.
		/// - `application/json`: Alerts in SARIF format (*deprecated*).
		/// If no version is specified, [SARIF 2.0.0](http://docs.oasis-open.org/sarif/sarif/v2.0/sarif-v2.0.html)
		/// is used for backwards compatibility.
		/// 
		/// - `text/csv`: Alerts in CSV format. The `text/csv` media type has two optional parameters:
		/// - `charset`: determines the character encoding of the text, by default UTF-8.
		/// - `header`: determines whether a header row with column names is `present` or `absent`.
		/// The default value for this parameter is `present`.
		/// For example, an Accept header with value `text/csv; header=absent`
		/// would result in CSV output without a header row.
		/// 
		/// 
		/// 
		/// 
		/// To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}`  endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).
		/// 
		/// GetAlerts analyses/{analysis_id}/alerts
		/// </summary>
		/// <param name="analysis_id">The analysis identifier.</param>
		/// <param name="sarif_version">The desired version of the SARIF format. Currently supported versions are `1.0.0`, `2.0.0`, and `2.1.0`.</param>
		/// <param name="excluded_files">Set `true` to include results in files that are excluded from the output by default. This includes results in test code and generated files. For more information, see [File classification](https://lgtm.com/help/lgtm/file-classification).</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<string> GetAlertsAsync(string analysis_id, string sarif_version, bool excluded_files, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyses/{analysis_id}/alerts?sarif-version=" + (sarif_version==null? "" : System.Uri.EscapeDataString(sarif_version))+"&excluded-files="+excluded_files;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Run analysis of a specific commit
		/// Trigger the analysis of a specific commit to a project. If a previous attempt to analyze that commit failed, this triggers a fresh analysis.  This is supported for all LGTM projects, regardless of repository type or host. The commit must be available in the main repository, but can be on a branch that isn't tracked by LGTM. For both LGTM.com and LGTM Enterprise, you must include an access token with the `analyses:write` scope.
		/// 
		/// When you request the analysis of a commit, the API returns:
		/// - `operation-id`: used to track the status of the task using the `/operations` endpoint. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation).
		/// - `status`: initially pending.
		/// - `task-result`: containing information about the progress and results of the analysis.
		/// 
		/// RequestAnalysis analyses/{project_id}
		/// </summary>
		/// <param name="project_id">The numeric project identifier.</param>
		/// <param name="commit">The identifier of the commit to analyze.</param>
		/// <param name="language">The language codes of the languages to analyze.
		///For a list of available languages, see [Supported languages](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported). To specify more than one language, this parameter can be repeated. If no language is specified, all the project's languages will be analyzed.
		///
		/// Maximum items: 10
		// </param>
		public async Task RequestAnalysisAsync(long project_id, string commit, string[] language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyses/{project_id}?commit=" + (commit==null? "" : System.Uri.EscapeDataString(commit))+"&"+string.Join("&", language.Select(z => $"language={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get analysis summary for a specific commit
		/// Get a summary of the analysis results for a specific commit, or the latest commit, to a project. (For projects configured for sparse or upload analysis, only `latest` is supported.)
		/// 
		/// This endpoint reports a summary of results for each language, and also the analysis identifier. You can use the analysis identifier to download full details of all the alerts  found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
		/// 
		/// GetAnalysisForCommit analyses/{project_id}/commits/{commit_id}
		/// </summary>
		/// <param name="project_id">The numeric project identifier.</param>
		/// <param name="commit_id">The identifier of a specific commit. Alternatively, use `latest` for the most recent analyzed commit.</param>
		/// <returns>Success. Data returned.</returns>
		public async Task<Analysis> GetAnalysisForCommitAsync(long project_id, string commit_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "analyses/{project_id}/commits/{commit_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Analysis>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get results of code review
		/// Get the results of a code review using the review identifier for the task.
		/// 
		/// When you request a code review, the response includes a task result URL of the form: `/codereviews/{review-id}`.
		/// 
		/// This endpoint reports the results of a complete code review, or the status of a review  that's still in progress.
		/// 
		/// GetCodeReview codereviews/{review_id}
		/// </summary>
		/// <param name="review_id">The identifier for the review (from the `task-result-url`).</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Code_review[]> GetCodeReviewAsync(string review_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "codereviews/{review_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Code_review[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detailed alert information for an issue
		/// Fetch the alert information for an issue in [SARIF](https://lgtm.com/help/lgtm/sarif-results-file) format.
		/// 
		/// GetIssue issues/{project_id}/{alert_key}
		/// </summary>
		/// <param name="project_id">The numeric project identifier.</param>
		/// <param name="alert_key">The alert key is generated by LGTM when it posts an issue `create` webhook request 
		/// to an external system using the [issue tracker Webhook API](https://lgtm.com/admin/help/issuetracker-webhook-api).
		/// This key is an opaque identifier that tracks the alert's location over time. For example, if a file containing the alert
		/// is modified, the SARIF data will reflect the updated location of the alert.
		/// Note that the key needs to be URL encoded as it may contain characters that are not web-safe.  
		///</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task GetIssueAsync(long project_id, string alert_key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "issues/{project_id}/{alert_key}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// API specification
		/// Get the specification of this API in [OpenAPI](https://github.com/OAI/OpenAPI-Specification) format. This endpoint does not require an access token. This makes it easier for you to use the specification with third-party tools.
		/// GetSpec openapi
		/// </summary>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<string> GetSpecAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "openapi";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get operation status
		/// Track progress of a long-running operation using the operations identifier returned when you  created the operation. For example, by triggering the analysis of a commit, or the code review of a patch. For both LGTM.com and LGTM Enterprise, you must include an access token with the `operations:read` scope.
		/// 
		/// GetOperation operations/{operation_id}
		/// </summary>
		/// <param name="operation_id">The operation identifier returned on creating the task.</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Operation> GetOperationAsync(long operation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "operations/{operation_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List projects
		/// List all the projects the current user has authorization to view.
		/// 
		/// A maximum of 100 projects are returned in each response. When further results are available, the response includes the URL you need to request the next page of results.
		/// 
		/// Use the optional parameter, `limit`, to change the number of results reported in each response (range of 1&mdash;100). If you supply an invalid value for this  parameter, the default value of 100 is used.
		/// 
		/// When more than one page of results is available, each response includes a `nextPageUrl` response parameter. You can use this URL to request the next page of results. The `nextPageUrl` includes an automatically generated `start` parameter, which specifies the projects to return in the next page of results.
		/// 
		/// GetProjects projects
		/// </summary>
		/// <param name="limit">The maximum number of projects to return in each response (1-100).
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="start">An opaque identifier generated by the API.</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Project_list> GetProjectsAsync(int limit, string start, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects?limit="+limit+"&start=" + (start==null? "" : System.Uri.EscapeDataString(start));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_list>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete project by numeric identifier
		/// Delete a project with a particular numeric project identifier.
		/// In addition to access to the project, administrative access to LGTM or the LGTM Enterprise instance is required to delete projects.
		/// 
		/// DeleteProject projects/{project_id}
		/// </summary>
		/// <param name="project_id">The numeric project identifier
		/// Minimum: 1
		// </param>
		/// <returns>Success. Details of the deleted project returned.</returns>
		public async Task<Project_details> DeleteProjectAsync(long project_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/{project_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_details>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get project by numeric identifier
		/// Get the latest summary for a specific project using the numeric project identifier.
		/// 
		/// To find the LGTM identifier for a project, list all projects using the `/projects`  endpoint and look up the project by name. Alternatively, use the `/projects/{provider}/{org}/{name}` endpoint. If you have administration access, the project identifier is also displayed in  the administration page for the project.
		/// 
		/// GetProject projects/{project_id}
		/// </summary>
		/// <param name="project_id">The numeric project identifier
		/// Minimum: 1
		// </param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Project_details> GetProjectAsync(long project_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/{project_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_details>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get configuration for a project identified by numeric identifier
		/// Get the latest configuration for a specific project using the numeric project identifier.
		/// GetProjectConfig projects/{project_id}/settings/analysis-configuration
		/// </summary>
		/// <param name="project_id">The numeric project identifier</param>
		/// <param name="source">The type of project configuration to retrieve.
		///If this parameter isn't specified, the request retrieves the effective configuration. That is, the configuration that is actually applied to the project, which may be from:
		///* the repository
		///* the administrator-set, project configuration
		///* the global configuration.
		///
		///If you do specify this value, it must be one of:
		///
		/// * `repository` to retrieve the configuration specified by a YAML file in the repository. A 404 status is returned if there is no repository configuration. 
		///
		/// * `administrator` to retrieve the administrator-set, project configuration. A 404 status is returned if there is no administrator configuration.
		///</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task GetProjectConfigAsync(long project_id, GetProjectConfigSource source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/{project_id}/settings/analysis-configuration?source=" + source;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get project by URL identifier
		/// Get the latest summary for a specific project using the project's URL identifier `{provider}/{org}/{name}`.
		/// 
		/// To find the URL identifier for a project, view the project overview page in LGTM. The URL identifier follows after `/projects`. For example, for a project with the URL `https://lgtm.example.com/projects/g/apache/commons-io` the URL identifier is `g/apache/commons-io`. In the example, `g` represents the `provider` (repository host), `apache` is the `organization` and `commons-io` is the `name` of the repository.
		/// 
		/// GetProjectByUrlIdentifier projects/{provider}/{org}/{name}
		/// </summary>
		/// <param name="provider">The first part of the URL identifier of a project, which represents the repository host.</param>
		/// <param name="org">The second part of the URL identifier of a project, the organization.</param>
		/// <param name="name">The third part of the URL identifier of a project, the repository name.</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Project_details> GetProjectByUrlIdentifierAsync(string provider, string org, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (provider==null? "" : System.Uri.EscapeDataString(provider))+"/"+ (org==null? "" : System.Uri.EscapeDataString(org))+"/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project_details>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the status of a query job
		/// Get the status of a query job using the query job identifier for the task.
		/// 
		/// When you create a query job, the response includes a task result URL of the form: `/queryjobs/{queryjob-id}`.
		/// 
		/// GetQueryJob queryjobs/{queryjob_id}
		/// </summary>
		/// <param name="queryjob_id">The identifier of the query job, from the `task-result` given in the response to the initial `POST /queryjobs` request.</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Queryjob> GetQueryJobAsync(string queryjob_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queryjobs/{queryjob_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Queryjob>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Provide a summary of results for the projects in the query job
		/// This endpoint provides a summary of the results generated by completed query runs for each  project specified in the the POST /queryjobs endpoint.  For completed query jobs, the summary includes:
		/// 
		/// * The number of results for successful query runs.
		/// * Error information for failed query runs.
		/// 
		/// No information is included in the response for any project for which the query  run is still in progress.
		/// 
		/// GetQueryJobResultsOverview queryjobs/{queryjob_id}/results
		/// </summary>
		/// <param name="queryjob_id">The identifier of the query job, from the `task-result` given in the response to the initial `POST /queryjobs` request.</param>
		/// <param name="start">An opaque identifier generated by the API used for pagination. 
		///This identifier will be included as part of the response for this endpoint whenever more than one page of results is available. 
		///</param>
		/// <param name="limit">The number of results to return. Useful for pagination.</param>
		/// <param name="filter">Only return a subset of results. Legal values are `w-results`, `wo-results`, `error`.</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Queryjob_results_overview> GetQueryJobResultsOverviewAsync(string queryjob_id, string start, int limit, string filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queryjobs/{queryjob_id}/results?start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&limit="+limit+"&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Queryjob_results_overview>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the results of a query job for a specific project
		/// Fetch the results for a specific project. The endpoint succeeds only if the query was successful,  and returns a `404` error otherwise.  By default, the endpoint provides only results that are within the source tree. To obtain all results, specify the `nofilter` parameter.
		/// 
		/// GetQueryJobResultsForProject queryjobs/{queryjob_id}/results/{project_id}
		/// </summary>
		/// <param name="queryjob_id">The identifier of the query job, from the `task-result` given in the response to the initial `POST /queryjobs` request.</param>
		/// <param name="project_id">The identifier for the project.</param>
		/// <param name="start">Start point for the page of results.</param>
		/// <param name="limit">The maximum number of results to display (less than 100).</param>
		/// <param name="nofilter">Include results that are not part of the source tree. These results are filtered out by default.</param>
		/// <returns>Success. The result contains three items: column headers, data, and pagination information.</returns>
		public async Task<Queryjob_project_results> GetQueryJobResultsForProjectAsync(string queryjob_id, string project_id, int start, int limit, bool nofilter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queryjobs/{queryjob_id}/results/{project_id}?start="+start+"&limit="+limit+"&nofilter="+nofilter;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Queryjob_project_results>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Abort database upload process
		/// Aborts the specified upload session and deletes any uploaded parts. After the session is aborted it cannot be restarted.
		/// If any part uploads are in progress when the session is aborted, their data may not be deleted. To ensure that uploaded parts are deleted correctly, you should only abort an upload session after all part uploads have completed.
		/// 
		/// AbortUpload snapshots/uploads/{session_id}
		/// </summary>
		/// <param name="session_id">The id of the upload session.</param>
		public async Task AbortUploadAsync(string session_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "snapshots/uploads/{session_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Complete snapshot upload session
		/// Completes the database upload by closing the upload session, upgrading the database if appropriate, and scheduling analysis of that snapshot of the codebase.
		/// 
		/// You can view the analysis progress and access the results using the `task-result-url`.
		/// 
		/// CompleteUpload snapshots/uploads/{session_id}
		/// </summary>
		/// <param name="session_id">The id of the upload session.</param>
		public async Task CompleteUploadAsync(string session_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "snapshots/uploads/{session_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download a snapshot
		/// Download a CodeQL database from LGTM, representing a snapshot of the codebase, to run queries in your IDE.
		/// 
		/// This endpoint works for projects that have been successfully analyzed for the language specified in the request.  A successful request redirects you to a URL for downloading a database that represents the code snapshot, as specified in the `Location:` header in the response. Therefore, your HTTP client should be configured to follow redirects. For example, if you are using `curl`, you can add the`-L` flag to the command.
		/// 
		/// The database is downloaded as a zip file that can be imported into an IDE equipped with a  CodeQL extension. The extension must be up to date to analyze databases downloaded from LGTM. For more information on running queries locally in your IDE, see [Runnning queries in your IDE](https://lgtm.com/help/lgtm/running-queries-ide).
		/// 
		/// GetSnapshot snapshots/{project_id}/{language}
		/// </summary>
		/// <param name="project_id">The numeric project identifier.</param>
		/// <param name="language">The language of the database to download.</param>
		public async Task GetSnapshotAsync(long project_id, string language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "snapshots/{project_id}/"+ (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start snapshot upload session
		/// Start a session to upload an externally-built database (which represents a snapshot of a codebase) to a project on LGTM.
		/// 
		/// This endpoint works for projects that are already on LGTM, and the selected language of  the database must already be configured. The project must be configured with 'upload' analysis mode. You can upload a "bundled" CodeQL database or a database exported by  the QL command-line tools (`odasa`).
		/// 
		/// If your database was generated using a version of the  command line that is older than LGTM,  LGTM will try to upgrade and analyze it when the upload is complete. You can include cached predicates in the upload, but they are ignored as the cache is  repopulated after the database has been upgraded and analyzed. However, if you want to include results with your database, make sure the database is  compatible before you start the upload session.  Incompatible databases with results won't be upgraded and therefore cannot be uploaded.  For further information on externally-built databases,  see [Preparing snapshots to upload to LGTM using the QL command-line tools](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).
		/// 
		/// 
		/// When the upload session has been successfully started, upload the database to the  upload URL returned in the response. The database can be uploaded to the upload URL in parts using  the [`PUT /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIduploadPart) endpoint. After uploading all the parts you must call  the [`POST /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIdcompleteUpload) endpoint to complete the upload session.
		/// 
		/// InitSnapshotUpload snapshots/{project_id}/{language}
		/// </summary>
		/// <param name="project_id">The numeric project identifier.</param>
		/// <param name="language">The language of the database to upload.</param>
		/// <param name="commit">The identifier of the analyzed commit.</param>
		/// <param name="date">The date and time of the analyzed commit (default the current time).</param>
		/// <returns>Success.</returns>
		public async Task<Upload_session> InitSnapshotUploadAsync(long project_id, string language, string commit, System.DateTimeOffset date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "snapshots/{project_id}/"+ (language==null? "" : System.Uri.EscapeDataString(language))+"&commit=" + (commit==null? "" : System.Uri.EscapeDataString(commit))+"&date=" + date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Upload_session>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a summary of the application's health
		/// Return an indication of whether the application is working as expected (up) or needs  attention (down).
		/// \> The `description` and `details` fields are reported only if the request includes an access token for a user account that has administration rights for this LGTM server.
		/// 
		/// GetHealth system/health
		/// </summary>
		/// <returns>The application is up.</returns>
		public async Task<Health> GetHealthAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/health";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Health>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the identifiers and descriptions of the usage metrics
		/// LGTM administrators can use this endpoint to list the usage metrics that are available to download.
		/// 
		/// GetMetrics system/metrics
		/// </summary>
		/// <returns>The metric identifiers and descriptions are returned.</returns>
		public async Task<Metrics_list> GetMetricsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/metrics";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Metrics_list>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the computed values of the specified metric
		/// LGTM administrators can download usage data using this endpoint. The response includes up to 1000 values for the specified metric and reports the date-time that each value was calculated. There is normally one value per day.
		/// 
		/// GetMetric system/metrics/{metric_id}
		/// </summary>
		/// <param name="metric_id">The identifier of the metric.</param>
		/// <returns>Success. Requested data returned.</returns>
		public async Task<Metric> GetMetricAsync(string metric_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/metrics/{metric_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Metric>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum AddProjectMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="full")]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sparse")]
		sparse = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="upload")]
		upload = 2,
	}
	
	public enum GetProjectConfigSource
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="repository")]
		repository = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="administrator")]
		administrator = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
