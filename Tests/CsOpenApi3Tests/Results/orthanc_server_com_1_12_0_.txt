//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Clear changes
		/// Clear the full history stored in the changes log
		/// ChangesDelete changes
		/// </summary>
		public async Task ChangesDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "changes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List changes
		/// Whenever Orthanc receives a new DICOM instance, this event is recorded in the so-called _Changes Log_. This enables remote scripts to react to the arrival of new DICOM resources. A typical application is auto-routing, where an external script waits for a new DICOM instance to arrive into Orthanc, then forward this instance to another modality.
		/// ChangesGetByLimitAndSince changes
		/// </summary>
		/// <param name="limit">Limit the number of results</param>
		/// <param name="since">Show only the resources since the provided index</param>
		public async Task<object> ChangesGetByLimitAndSinceAsync(double limit, double since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "changes?limit="+limit+"&since="+since;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Clear exports
		/// Clear the full history stored in the exports log
		/// ExportsDelete exports
		/// </summary>
		public async Task ExportsDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exports";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List exports
		/// For medical traceability, Orthanc can be configured to store a log of all the resources that have been exported to remote modalities. In auto-routing scenarios, it is important to prevent this log to grow indefinitely as incoming instances are routed. You can either disable this logging by setting the option `LogExportedResources` to `false` in the configuration file, or periodically clear this log by `DELETE`-ing this URI. This route might be removed in future versions of Orthanc.
		/// ExportsGetByLimitAndSince exports
		/// </summary>
		/// <param name="limit">Limit the number of results</param>
		/// <param name="since">Show only the resources since the provided index</param>
		public async Task<object> ExportsGetByLimitAndSinceAsync(double limit, double since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exports?limit="+limit+"&since="+since;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the available instances
		/// List the Orthanc identifiers of all the available DICOM instances
		/// InstancesGetByExpandAndFullAndLimitAndRequestedTagsAnd_shortAndSince instances
		/// </summary>
		/// <param name="expand">If present, retrieve detailed information about the individual instances</param>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="limit">Limit the number of results</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="since">Show only the resources since the provided index</param>
		public async Task<object> InstancesGetByExpandAndFullAndLimitAndRequestedTagsAnd_shortAndSinceAsync(string expand, bool full, double limit, string requestedTags, bool _short, double since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&full="+full+"&limit="+limit+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short+"&since="+since;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete some instance
		/// Delete the DICOM instance whose Orthanc identifier is provided in the URL
		/// Instances_idDelete instances/{id}
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task Instances_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get information about some instance
		/// Get detailed information about the DICOM instance whose Orthanc identifier is provided in the URL
		/// Instances_idGetByFullAndRequestedTagsAnd_short instances/{id}
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Anonymize instance
		/// Download an anonymized version of the DICOM instance whose Orthanc identifier is provided in the URL: https://book.orthanc-server.com/users/anonymization.html#anonymization-of-a-single-instance
		/// Instances_idAnonymizePost instances/{id}/anonymize
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task Instances_idAnonymizePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/anonymize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List attachments
		/// Get the list of attachments that are associated with the given instance
		/// Instances_idAttachmentsGetByFull instances/{id}/attachments
		/// </summary>
		/// <param name="full">If present, retrieve the attachments list and their numerical ids</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idAttachmentsGetByFullAsync(string full, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments?full=" + (full==null? "" : System.Uri.EscapeDataString(full));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete attachment
		/// Delete an attachment associated with the given DICOM instance. This call will fail if trying to delete a system attachment (i.e. whose index is < 1024).
		/// Instances_idAttachments_nameDelete instances/{id}/attachments/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameDeleteAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations on attachments
		/// Get the list of the operations that are available for attachments associated with the given instance
		/// Instances_idAttachments_nameGet instances/{id}/attachments/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Instances_idAttachments_nameGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Compress attachment
		/// Change the compression scheme that is used to store an attachment.
		/// Instances_idAttachments_nameCompressPost instances/{id}/attachments/{name}/compress
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameCompressPostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compress";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get attachment (no decompression)
		/// Get the (binary) content of one attachment associated with the given instance. The attachment will not be decompressed if `StorageCompression` is `true`.
		/// Instances_idAttachments_nameCompressed_dataGet instances/{id}/attachments/{name}/compressed-data
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameCompressed_dataGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-data";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get MD5 of attachment on disk
		/// Get the MD5 hash of one attachment associated with the given instance, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.
		/// Instances_idAttachments_nameCompressed_md5Get instances/{id}/attachments/{name}/compressed-md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameCompressed_md5GetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get size of attachment on disk
		/// Get the size of one attachment associated with the given instance, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.
		/// Instances_idAttachments_nameCompressed_sizeGet instances/{id}/attachments/{name}/compressed-size
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameCompressed_sizeGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-size";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get attachment
		/// Get the (binary) content of one attachment associated with the given instance
		/// Instances_idAttachments_nameDataGet instances/{id}/attachments/{name}/data
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameDataGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/data";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get info about the attachment
		/// Get all the information about the attachment associated with the given instance
		/// Instances_idAttachments_nameInfoGet instances/{id}/attachments/{name}/info
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Instances_idAttachments_nameInfoGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/info";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Is attachment compressed?
		/// Test whether the attachment has been stored as a compressed file on the disk.
		/// Instances_idAttachments_nameIs_compressedGet instances/{id}/attachments/{name}/is-compressed
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameIs_compressedGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/is-compressed";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get MD5 of attachment
		/// Get the MD5 hash of one attachment associated with the given instance
		/// Instances_idAttachments_nameMd5Get instances/{id}/attachments/{name}/md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameMd5GetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get size of attachment
		/// Get the size of one attachment associated with the given instance
		/// Instances_idAttachments_nameSizeGet instances/{id}/attachments/{name}/size
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameSizeGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/size";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Uncompress attachment
		/// Change the compression scheme that is used to store an attachment.
		/// Instances_idAttachments_nameUncompressPost instances/{id}/attachments/{name}/uncompress
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Instances_idAttachments_nameUncompressPostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/uncompress";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Verify attachment
		/// Verify that the attachment is not corrupted, by validating its MD5 hash
		/// Instances_idAttachments_nameVerify_md5Post instances/{id}/attachments/{name}/verify-md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Instances_idAttachments_nameVerify_md5PostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/verify-md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get raw tag
		/// Get the raw content of one DICOM tag in the hierarchy of DICOM dataset
		/// Instances_idContentGetBy___ instances/{id}/content
		/// </summary>
		/// <param name="___">Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, `/0008-1140/1/0008-1150`</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idContentGetBy___Async(string ___, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/content?...=" + (___==null? "" : System.Uri.EscapeDataString(___));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Download DICOM
		/// Download one DICOM instance
		/// Instances_idFileGet instances/{id}/file
		/// </summary>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idFileGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/file";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List available frames
		/// List the frames that are available in the DICOM instance of interest
		/// Instances_idFramesGet instances/{id}/frames
		/// </summary>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task<object> Instances_idFramesGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations
		/// List the available operations under URI `/instances/{id}/frames/{frame}/`
		/// Instances_idFrames_frameGet instances/{id}/frames/{frame}
		/// </summary>
		public async Task<object> Instances_idFrames_frameGetAsync(string frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+ (frame==null? "" : System.Uri.EscapeDataString(frame));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode a frame (int16)
		/// Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.
		/// Instances_idFrames_frameImage_int16GetByQualityAndReturnUnsupportedImage instances/{id}/frames/{frame}/image-int16
		/// </summary>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idFrames_frameImage_int16GetByQualityAndReturnUnsupportedImageAsync(double quality, bool returnUnsupportedImage, double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/image-int16?quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode a frame (uint16)
		/// Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.
		/// Instances_idFrames_frameImage_uint16GetByQualityAndReturnUnsupportedImage instances/{id}/frames/{frame}/image-uint16
		/// </summary>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idFrames_frameImage_uint16GetByQualityAndReturnUnsupportedImageAsync(double quality, bool returnUnsupportedImage, double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/image-uint16?quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode a frame (uint8)
		/// Decode one frame of interest from the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.
		/// Instances_idFrames_frameImage_uint8GetByQualityAndReturnUnsupportedImage instances/{id}/frames/{frame}/image-uint8
		/// </summary>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idFrames_frameImage_uint8GetByQualityAndReturnUnsupportedImageAsync(double quality, bool returnUnsupportedImage, double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/image-uint8?quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode frame for Matlab
		/// Decode one frame of interest from the given DICOM instance, and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://book.orthanc-server.com/faq/matlab.html
		/// Instances_idFrames_frameMatlabGet instances/{id}/frames/{frame}/matlab
		/// </summary>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idFrames_frameMatlabGetAsync(double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/matlab";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode frame for numpy
		/// Decode one frame of interest from the given DICOM instance, for use with numpy in Python. The numpy array has 3 dimensions: (height, width, color channel).
		/// Instances_idFrames_frameNumpyGetByCompressAndRescale instances/{id}/frames/{frame}/numpy
		/// </summary>
		/// <param name="compress">Compress the file as `.npz`</param>
		/// <param name="rescale">On grayscale images, apply the rescaling and return floating-point values</param>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the DICOM resource of interest</param>
		public async Task Instances_idFrames_frameNumpyGetByCompressAndRescaleAsync(bool compress, bool rescale, double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/numpy?compress="+compress+"&rescale="+rescale;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode a frame (preview)
		/// Decode one frame of interest from the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.
		/// Instances_idFrames_framePreviewGetByQualityAndReturnUnsupportedImage instances/{id}/frames/{frame}/preview
		/// </summary>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idFrames_framePreviewGetByQualityAndReturnUnsupportedImageAsync(double quality, bool returnUnsupportedImage, double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/preview?quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Access raw frame
		/// Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes.
		/// Instances_idFrames_frameRawGet instances/{id}/frames/{frame}/raw
		/// </summary>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task Instances_idFrames_frameRawGetAsync(double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/raw";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Access raw frame (compressed)
		/// Access the raw content of one individual frame of the DICOM instance of interest, bypassing image decoding. This is notably useful to access the source files in compressed transfer syntaxes. The image is compressed using gzip
		/// Instances_idFrames_frameRaw_gzGet instances/{id}/frames/{frame}/raw.gz
		/// </summary>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task Instances_idFrames_frameRaw_gzGetAsync(double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/raw.gz";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Render a frame
		/// Render one frame of interest from the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.
		/// Instances_idFrames_frameRenderedGetByHeightAndQualityAndReturnUnsupportedImageAndSmoothAndWidthAndWindow_centerAndWindow_width instances/{id}/frames/{frame}/rendered
		/// </summary>
		/// <param name="height">Height of the resized image</param>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="smooth">Whether to smooth image on resize</param>
		/// <param name="width">Width of the resized image</param>
		/// <param name="window_center">Windowing center</param>
		/// <param name="window_width">Windowing width</param>
		/// <param name="frame">Index of the frame (starts at `0`)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idFrames_frameRenderedGetByHeightAndQualityAndReturnUnsupportedImageAndSmoothAndWidthAndWindow_centerAndWindow_widthAsync(double height, double quality, bool returnUnsupportedImage, bool smooth, double width, double window_center, double window_width, double frame, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/frames/"+frame+"/rendered?height="+height+"&quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage+"&smooth="+smooth+"&width="+width+"&window-center="+window_center+"&window-width="+window_width;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get DICOM meta-header
		/// Get the DICOM tags in the meta-header of the DICOM instance. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.
		/// Instances_idHeaderGetBy_shortAndSimplify instances/{id}/header
		/// </summary>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task<object> Instances_idHeaderGetBy_shortAndSimplifyAsync(bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/header?short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode an image (int16)
		/// Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [-32768,32767] range. Negative values must be interpreted according to two's complement.
		/// Instances_idImage_int16GetByQualityAndReturnUnsupportedImage instances/{id}/image-int16
		/// </summary>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idImage_int16GetByQualityAndReturnUnsupportedImageAsync(double quality, bool returnUnsupportedImage, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/image-int16?quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode an image (uint16)
		/// Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,65535] range.
		/// Instances_idImage_uint16GetByQualityAndReturnUnsupportedImage instances/{id}/image-uint16
		/// </summary>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idImage_uint16GetByQualityAndReturnUnsupportedImageAsync(double quality, bool returnUnsupportedImage, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/image-uint16?quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode an image (uint8)
		/// Decode the first frame of the given DICOM instance. Pixels of grayscale images are truncated to the [0,255] range.
		/// Instances_idImage_uint8GetByQualityAndReturnUnsupportedImage instances/{id}/image-uint8
		/// </summary>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idImage_uint8GetByQualityAndReturnUnsupportedImageAsync(double quality, bool returnUnsupportedImage, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/image-uint8?quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List labels
		/// Get the labels that are associated with the given instance (new in Orthanc 1.12.0)
		/// Instances_idLabelsGet instances/{id}/labels
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idLabelsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove label
		/// Remove a label associated with a instance
		/// Instances_idLabels_labelDelete instances/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="label">The label to be removed</param>
		public async Task Instances_idLabels_labelDeleteAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Test label
		/// Test whether the instance is associated with the given label
		/// Instances_idLabels_labelGet instances/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="label">The label of interest</param>
		public async Task Instances_idLabels_labelGetAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add label
		/// Associate a label with a instance
		/// Instances_idLabels_labelPut instances/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="label">The label to be added</param>
		public async Task Instances_idLabels_labelPutAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode frame for Matlab
		/// Decode the first frame of the given DICOM instance., and export this frame as a Octave/Matlab matrix to be imported with `eval()`: https://book.orthanc-server.com/faq/matlab.html
		/// Instances_idMatlabGet instances/{id}/matlab
		/// </summary>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idMatlabGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/matlab";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List metadata
		/// Get the list of metadata that are associated with the given instance
		/// Instances_idMetadataGetByExpandAndNumeric instances/{id}/metadata
		/// </summary>
		/// <param name="expand">If present, also retrieve the value of the individual metadata</param>
		/// <param name="numeric">If present, use the numeric identifier of the metadata instead of its symbolic name</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idMetadataGetByExpandAndNumericAsync(string expand, string numeric, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&numeric=" + (numeric==null? "" : System.Uri.EscapeDataString(numeric));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete metadata
		/// Delete some metadata associated with the given DICOM instance. This call will fail if trying to delete a system metadata (i.e. whose index is < 1024).
		/// Instances_idMetadata_nameDelete instances/{id}/metadata/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the metadata, or its index (cf. `UserMetadata` configuration option)</param>
		public async Task Instances_idMetadata_nameDeleteAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get metadata
		/// Get the value of a metadata that is associated with the given instance
		/// Instances_idMetadata_nameGet instances/{id}/metadata/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		/// <param name="name">The name of the metadata, or its index (cf. `UserMetadata` configuration option)</param>
		public async Task Instances_idMetadata_nameGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Modify instance
		/// Download a modified version of the DICOM instance whose Orthanc identifier is provided in the URL: https://book.orthanc-server.com/users/anonymization.html#modification-of-a-single-instance
		/// Instances_idModifyPost instances/{id}/modify
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task Instances_idModifyPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/modify";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get instance module
		/// Get the instance module of the DICOM instance whose Orthanc identifier is provided in the URL
		/// Instances_idModuleGetByIgnore_lengthAnd_shortAndSimplify instances/{id}/module
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idModuleGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/module?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode instance for numpy
		/// Decode the given DICOM instance, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).
		/// Instances_idNumpyGetByCompressAndRescale instances/{id}/numpy
		/// </summary>
		/// <param name="compress">Compress the file as `.npz`</param>
		/// <param name="rescale">On grayscale images, apply the rescaling and return floating-point values</param>
		/// <param name="id">Orthanc identifier of the DICOM resource of interest</param>
		public async Task Instances_idNumpyGetByCompressAndRescaleAsync(bool compress, bool rescale, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/numpy?compress="+compress+"&rescale="+rescale;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get parent patient
		/// Get detailed information about the parent patient of the DICOM instance whose Orthanc identifier is provided in the URL
		/// Instances_idPatientGetByFullAndRequestedTagsAnd_short instances/{id}/patient
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idPatientGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/patient?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get embedded PDF
		/// Get the PDF file that is embedded in one DICOM instance. If the DICOM instance doesn't contain the `EncapsulatedDocument` tag or if the `MIMETypeOfEncapsulatedDocument` tag doesn't correspond to the PDF type, a `404` HTTP error is raised.
		/// Instances_idPdfGet instances/{id}/pdf
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance interest</param>
		public async Task Instances_idPdfGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/pdf";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode an image (preview)
		/// Decode the first frame of the given DICOM instance. The full dynamic range of grayscale images is rescaled to the [0,255] range.
		/// Instances_idPreviewGetByQualityAndReturnUnsupportedImage instances/{id}/preview
		/// </summary>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idPreviewGetByQualityAndReturnUnsupportedImageAsync(double quality, bool returnUnsupportedImage, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/preview?quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reconstruct tags & optionally files of instance
		/// Reconstruct the main DICOM tags in DB of the instance whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.
		/// Instances_idReconstructPost instances/{id}/reconstruct
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task Instances_idReconstructPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/reconstruct";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Render an image
		/// Render the first frame of the given DICOM instance. This function takes scaling into account (`RescaleSlope` and `RescaleIntercept` tags), as well as the default windowing stored in the DICOM file (`WindowCenter` and `WindowWidth`tags), and can be used to resize the resulting image. Color images are not affected by windowing.
		/// Instances_idRenderedGetByHeightAndQualityAndReturnUnsupportedImageAndSmoothAndWidthAndWindow_centerAndWindow_width instances/{id}/rendered
		/// </summary>
		/// <param name="height">Height of the resized image</param>
		/// <param name="quality">Quality for JPEG images (between 1 and 100, defaults to 90)</param>
		/// <param name="returnUnsupportedImage">Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false)</param>
		/// <param name="smooth">Whether to smooth image on resize</param>
		/// <param name="width">Width of the resized image</param>
		/// <param name="window_center">Windowing center</param>
		/// <param name="window_width">Windowing width</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task Instances_idRenderedGetByHeightAndQualityAndReturnUnsupportedImageAndSmoothAndWidthAndWindow_centerAndWindow_widthAsync(double height, double quality, bool returnUnsupportedImage, bool smooth, double width, double window_center, double window_width, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/rendered?height="+height+"&quality="+quality+"&returnUnsupportedImage="+returnUnsupportedImage+"&smooth="+smooth+"&width="+width+"&window-center="+window_center+"&window-width="+window_width;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get parent series
		/// Get detailed information about the parent series of the DICOM instance whose Orthanc identifier is provided in the URL
		/// Instances_idSeriesGetByFullAndRequestedTagsAnd_short instances/{id}/series
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idSeriesGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/series?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get human-readable tags
		/// Get the DICOM tags in human-readable format (same as the `/instances/{id}/tags?simplify` route)
		/// Instances_idSimplified_tagsGetByIgnore_length instances/{id}/simplified-tags
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task<object> Instances_idSimplified_tagsGetByIgnore_lengthAsync(string[] ignore_length, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/simplified-tags?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get instance statistics
		/// Get statistics about the given instance
		/// Instances_idStatisticsGet instances/{id}/statistics
		/// </summary>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idStatisticsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/statistics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get parent study
		/// Get detailed information about the parent study of the DICOM instance whose Orthanc identifier is provided in the URL
		/// Instances_idStudyGetByFullAndRequestedTagsAnd_short instances/{id}/study
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the instance of interest</param>
		public async Task<object> Instances_idStudyGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/study?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get DICOM tags
		/// Get the DICOM tags in the specified format. By default, the `full` format is used, which combines hexadecimal tags with human-readable description.
		/// Instances_idTagsGetByIgnore_lengthAnd_shortAndSimplify instances/{id}/tags
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the DICOM instance of interest</param>
		public async Task<object> Instances_idTagsGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "instances/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/tags?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List jobs
		/// List all the available jobs
		/// JobsGetByExpand jobs
		/// </summary>
		/// <param name="expand">If present, retrieve detailed information about the individual jobs</param>
		public async Task<object> JobsGetByExpandAsync(string expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get job
		/// Retrieve detailed information about the job whose identifier is provided in the URL: https://book.orthanc-server.com/users/advanced-rest.html#jobs
		/// Jobs_idGet jobs/{id}
		/// </summary>
		/// <param name="id">Identifier of the job of interest</param>
		public async Task<object> Jobs_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Cancel job
		/// Cancel the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://book.orthanc-server.com/users/advanced-rest.html#jobs
		/// Jobs_idCancelPost jobs/{id}/cancel
		/// </summary>
		/// <param name="id">Identifier of the job of interest</param>
		public async Task<object> Jobs_idCancelPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/cancel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Pause job
		/// Pause the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://book.orthanc-server.com/users/advanced-rest.html#jobs
		/// Jobs_idPausePost jobs/{id}/pause
		/// </summary>
		/// <param name="id">Identifier of the job of interest</param>
		public async Task<object> Jobs_idPausePostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/pause";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Resubmit job
		/// Resubmit the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://book.orthanc-server.com/users/advanced-rest.html#jobs
		/// Jobs_idResubmitPost jobs/{id}/resubmit
		/// </summary>
		/// <param name="id">Identifier of the job of interest</param>
		public async Task<object> Jobs_idResubmitPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/resubmit";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Resume job
		/// Resume the job whose identifier is provided in the URL. Check out the Orthanc Book for more information about the state machine applicable to jobs: https://book.orthanc-server.com/users/advanced-rest.html#jobs
		/// Jobs_idResumePost jobs/{id}/resume
		/// </summary>
		/// <param name="id">Identifier of the job of interest</param>
		public async Task<object> Jobs_idResumePostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/resume";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get job output
		/// Retrieve some output produced by a job. As of Orthanc 1.8.2, only the jobs that generate a DICOMDIR media or a ZIP archive provide such an output (with `key` equals to `archive`).
		/// Jobs_id_keyGet jobs/{id}/{key}
		/// </summary>
		/// <param name="id">Identifier of the job of interest</param>
		/// <param name="key">Name of the output of interest</param>
		public async Task Jobs_id_keyGetAsync(string id, string key, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/"+ (key==null? "" : System.Uri.EscapeDataString(key));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List DICOM modalities
		/// List all the DICOM modalities that are known to Orthanc. This corresponds either to the content of the `DicomModalities` configuration option, or to the information stored in the database if `DicomModalitiesInDatabase` is `true`.
		/// ModalitiesGetByExpand modalities
		/// </summary>
		/// <param name="expand">If present, retrieve detailed information about the individual DICOM modalities</param>
		public async Task<object> ModalitiesGetByExpandAsync(string expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete DICOM modality
		/// Delete one DICOM modality. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.
		/// Modalities_idDelete modalities/{id}
		/// </summary>
		/// <param name="id">Identifier of the DICOM modality of interest</param>
		public async Task Modalities_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations on modality
		/// List the operations that are available for a DICOM modality.
		/// Modalities_idGet modalities/{id}
		/// </summary>
		/// <param name="id">Identifier of the DICOM modality of interest</param>
		public async Task<object> Modalities_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update DICOM modality
		/// Define a new DICOM modality, or update an existing one. This change is permanent iff. `DicomModalitiesInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.
		/// Modalities_idPut modalities/{id}
		/// </summary>
		/// <param name="id">Identifier of the new/updated DICOM modality</param>
		public async Task Modalities_idPutAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get modality configuration
		/// Get detailed information about the configuration of some DICOM modality
		/// Modalities_idConfigurationGet modalities/{id}/configuration
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idConfigurationGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/configuration";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trigger C-ECHO SCU
		/// Trigger C-ECHO SCU command against the DICOM modality whose identifier is provided in URL: https://book.orthanc-server.com/users/rest.html#performing-c-echo
		/// Modalities_idEchoPost modalities/{id}/echo
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task Modalities_idEchoPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/echo";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Hierarchical C-FIND SCU
		/// Trigger a sequence of C-FIND SCU commands against the DICOM modality whose identifier is provided in URL, in order to discover a hierarchy of matching patients/studies/series. Deprecated in favor of `/modalities/{id}/query`.
		/// Modalities_idFindPost modalities/{id}/find
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idFindPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/find";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// C-FIND SCU for instances
		/// Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find an instance. Deprecated in favor of `/modalities/{id}/query`.
		/// Modalities_idFind_instancePost modalities/{id}/find-instance
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idFind_instancePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/find-instance";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// C-FIND SCU for patients
		/// Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a patient. Deprecated in favor of `/modalities/{id}/query`.
		/// Modalities_idFind_patientPost modalities/{id}/find-patient
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idFind_patientPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/find-patient";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// C-FIND SCU for series
		/// Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a series. Deprecated in favor of `/modalities/{id}/query`.
		/// Modalities_idFind_seriesPost modalities/{id}/find-series
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idFind_seriesPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/find-series";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// C-FIND SCU for studies
		/// Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL, in order to find a study. Deprecated in favor of `/modalities/{id}/query`.
		/// Modalities_idFind_studyPost modalities/{id}/find-study
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idFind_studyPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/find-study";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// C-FIND SCU for worklist
		/// Trigger C-FIND SCU command against the remote worklists of the DICOM modality whose identifier is provided in URL
		/// Modalities_idFind_worklistPost modalities/{id}/find-worklist
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idFind_worklistPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/find-worklist";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trigger C-MOVE SCU
		/// Start a C-MOVE SCU command as a job, in order to drive the execution of a sequence of C-STORE commands by some remote DICOM modality whose identifier is provided in the URL: https://book.orthanc-server.com/users/rest.html#performing-c-move
		/// Modalities_idMovePost modalities/{id}/move
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idMovePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/move";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trigger C-FIND SCU
		/// Trigger C-FIND SCU command against the DICOM modality whose identifier is provided in URL: https://book.orthanc-server.com/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest
		/// Modalities_idQueryPost modalities/{id}/query
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idQueryPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trigger storage commitment request
		/// Trigger a storage commitment request to some remote DICOM modality whose identifier is provided in the URL: https://book.orthanc-server.com/users/storage-commitment.html#storage-commitment-scu
		/// Modalities_idStorage_commitmentPost modalities/{id}/storage-commitment
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idStorage_commitmentPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/storage-commitment";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trigger C-STORE SCU
		/// Start a C-STORE SCU command as a job, in order to send DICOM resources stored locally to some remote DICOM modality whose identifier is provided in the URL: https://book.orthanc-server.com/users/rest.html#rest-store-scu
		/// Modalities_idStorePost modalities/{id}/store
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Modalities_idStorePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "modalities/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/store";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the available patients
		/// List the Orthanc identifiers of all the available DICOM patients
		/// PatientsGetByExpandAndFullAndLimitAndRequestedTagsAnd_shortAndSince patients
		/// </summary>
		/// <param name="expand">If present, retrieve detailed information about the individual patients</param>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="limit">Limit the number of results</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="since">Show only the resources since the provided index</param>
		public async Task<object> PatientsGetByExpandAndFullAndLimitAndRequestedTagsAnd_shortAndSinceAsync(string expand, bool full, double limit, string requestedTags, bool _short, double since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&full="+full+"&limit="+limit+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short+"&since="+since;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete some patient
		/// Delete the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idDelete patients/{id}
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task Patients_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get information about some patient
		/// Get detailed information about the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idGetByFullAndRequestedTagsAnd_short patients/{id}
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Anonymize patient
		/// Start a job that will anonymize all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://book.orthanc-server.com/users/anonymization.html#anonymization-of-patients-studies-or-series
		/// Patients_idAnonymizePost patients/{id}/anonymize
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idAnonymizePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/anonymize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create ZIP archive
		/// Synchronously create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.
		/// Patients_idArchiveGetByFilenameAndTranscode patients/{id}/archive
		/// </summary>
		/// <param name="filename">Filename to set in the "Content-Disposition" HTTP header (including file extension)</param>
		/// <param name="transcode">If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task Patients_idArchiveGetByFilenameAndTranscodeAsync(string filename, string transcode, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/archive?filename=" + (filename==null? "" : System.Uri.EscapeDataString(filename))+"&transcode=" + (transcode==null? "" : System.Uri.EscapeDataString(transcode));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create ZIP archive
		/// Create a ZIP archive containing the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idArchivePost patients/{id}/archive
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idArchivePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/archive";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List attachments
		/// Get the list of attachments that are associated with the given patient
		/// Patients_idAttachmentsGetByFull patients/{id}/attachments
		/// </summary>
		/// <param name="full">If present, retrieve the attachments list and their numerical ids</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idAttachmentsGetByFullAsync(string full, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments?full=" + (full==null? "" : System.Uri.EscapeDataString(full));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete attachment
		/// Delete an attachment associated with the given DICOM patient. This call will fail if trying to delete a system attachment (i.e. whose index is < 1024).
		/// Patients_idAttachments_nameDelete patients/{id}/attachments/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameDeleteAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations on attachments
		/// Get the list of the operations that are available for attachments associated with the given patient
		/// Patients_idAttachments_nameGet patients/{id}/attachments/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Patients_idAttachments_nameGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Compress attachment
		/// Change the compression scheme that is used to store an attachment.
		/// Patients_idAttachments_nameCompressPost patients/{id}/attachments/{name}/compress
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameCompressPostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compress";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get attachment (no decompression)
		/// Get the (binary) content of one attachment associated with the given patient. The attachment will not be decompressed if `StorageCompression` is `true`.
		/// Patients_idAttachments_nameCompressed_dataGet patients/{id}/attachments/{name}/compressed-data
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameCompressed_dataGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-data";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get MD5 of attachment on disk
		/// Get the MD5 hash of one attachment associated with the given patient, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.
		/// Patients_idAttachments_nameCompressed_md5Get patients/{id}/attachments/{name}/compressed-md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameCompressed_md5GetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get size of attachment on disk
		/// Get the size of one attachment associated with the given patient, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.
		/// Patients_idAttachments_nameCompressed_sizeGet patients/{id}/attachments/{name}/compressed-size
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameCompressed_sizeGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-size";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get attachment
		/// Get the (binary) content of one attachment associated with the given patient
		/// Patients_idAttachments_nameDataGet patients/{id}/attachments/{name}/data
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameDataGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/data";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get info about the attachment
		/// Get all the information about the attachment associated with the given patient
		/// Patients_idAttachments_nameInfoGet patients/{id}/attachments/{name}/info
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Patients_idAttachments_nameInfoGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/info";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Is attachment compressed?
		/// Test whether the attachment has been stored as a compressed file on the disk.
		/// Patients_idAttachments_nameIs_compressedGet patients/{id}/attachments/{name}/is-compressed
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameIs_compressedGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/is-compressed";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get MD5 of attachment
		/// Get the MD5 hash of one attachment associated with the given patient
		/// Patients_idAttachments_nameMd5Get patients/{id}/attachments/{name}/md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameMd5GetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get size of attachment
		/// Get the size of one attachment associated with the given patient
		/// Patients_idAttachments_nameSizeGet patients/{id}/attachments/{name}/size
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameSizeGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/size";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Uncompress attachment
		/// Change the compression scheme that is used to store an attachment.
		/// Patients_idAttachments_nameUncompressPost patients/{id}/attachments/{name}/uncompress
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Patients_idAttachments_nameUncompressPostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/uncompress";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Verify attachment
		/// Verify that the attachment is not corrupted, by validating its MD5 hash
		/// Patients_idAttachments_nameVerify_md5Post patients/{id}/attachments/{name}/verify-md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Patients_idAttachments_nameVerify_md5PostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/verify-md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get child instances
		/// Get detailed information about the child instances of the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idInstancesGetByFullAndRequestedTagsAnd_short patients/{id}/instances
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idInstancesGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instances?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get tags of instances
		/// Get the tags of all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idInstances_tagsGetByIgnore_lengthAnd_shortAndSimplify patients/{id}/instances-tags
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idInstances_tagsGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instances-tags?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List labels
		/// Get the labels that are associated with the given patient (new in Orthanc 1.12.0)
		/// Patients_idLabelsGet patients/{id}/labels
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idLabelsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove label
		/// Remove a label associated with a patient
		/// Patients_idLabels_labelDelete patients/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="label">The label to be removed</param>
		public async Task Patients_idLabels_labelDeleteAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Test label
		/// Test whether the patient is associated with the given label
		/// Patients_idLabels_labelGet patients/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="label">The label of interest</param>
		public async Task Patients_idLabels_labelGetAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add label
		/// Associate a label with a patient
		/// Patients_idLabels_labelPut patients/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="label">The label to be added</param>
		public async Task Patients_idLabels_labelPutAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create DICOMDIR media
		/// Synchronously create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.
		/// Patients_idMediaGetByExtendedAndFilenameAndTranscode patients/{id}/media
		/// </summary>
		/// <param name="extended">If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*</param>
		/// <param name="filename">Filename to set in the "Content-Disposition" HTTP header (including file extension)</param>
		/// <param name="transcode">If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task Patients_idMediaGetByExtendedAndFilenameAndTranscodeAsync(string extended, string filename, string transcode, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/media?extended=" + (extended==null? "" : System.Uri.EscapeDataString(extended))+"&filename=" + (filename==null? "" : System.Uri.EscapeDataString(filename))+"&transcode=" + (transcode==null? "" : System.Uri.EscapeDataString(transcode));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create DICOMDIR media
		/// Create a DICOMDIR media containing the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idMediaPost patients/{id}/media
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idMediaPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/media";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List metadata
		/// Get the list of metadata that are associated with the given patient
		/// Patients_idMetadataGetByExpandAndNumeric patients/{id}/metadata
		/// </summary>
		/// <param name="expand">If present, also retrieve the value of the individual metadata</param>
		/// <param name="numeric">If present, use the numeric identifier of the metadata instead of its symbolic name</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idMetadataGetByExpandAndNumericAsync(string expand, string numeric, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&numeric=" + (numeric==null? "" : System.Uri.EscapeDataString(numeric));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete metadata
		/// Delete some metadata associated with the given DICOM patient. This call will fail if trying to delete a system metadata (i.e. whose index is < 1024).
		/// Patients_idMetadata_nameDelete patients/{id}/metadata/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the metadata, or its index (cf. `UserMetadata` configuration option)</param>
		public async Task Patients_idMetadata_nameDeleteAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get metadata
		/// Get the value of a metadata that is associated with the given patient
		/// Patients_idMetadata_nameGet patients/{id}/metadata/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		/// <param name="name">The name of the metadata, or its index (cf. `UserMetadata` configuration option)</param>
		public async Task Patients_idMetadata_nameGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Modify patient
		/// Start a job that will modify all the DICOM instances within the patient whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new patient, whose Orthanc identifiers will be returned by the job. https://book.orthanc-server.com/users/anonymization.html#modification-of-studies-or-series
		/// Patients_idModifyPost patients/{id}/modify
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idModifyPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/modify";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get patient module
		/// Get the patient module of the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idModuleGetByIgnore_lengthAnd_shortAndSimplify patients/{id}/module
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idModuleGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/module?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Is the patient protected against recycling?
		/// Is the patient protected against recycling?
		/// Patients_idProtectedGet patients/{id}/protected
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task Patients_idProtectedGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/protected";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Protect one patient against recycling
		/// Check out configuration options `MaximumStorageSize` and `MaximumPatientCount`
		/// Patients_idProtectedPut patients/{id}/protected
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task Patients_idProtectedPutAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/protected";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reconstruct tags & optionally files of patient
		/// Reconstruct the main DICOM tags in DB of the patient whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.
		/// Patients_idReconstructPost patients/{id}/reconstruct
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task Patients_idReconstructPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/reconstruct";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get child series
		/// Get detailed information about the child series of the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idSeriesGetByFullAndRequestedTagsAnd_short patients/{id}/series
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idSeriesGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/series?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get shared tags
		/// Extract the DICOM tags whose value is constant across all the child instances of the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idShared_tagsGetBy_shortAndSimplify patients/{id}/shared-tags
		/// </summary>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idShared_tagsGetBy_shortAndSimplifyAsync(bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/shared-tags?short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get patient statistics
		/// Get statistics about the given patient
		/// Patients_idStatisticsGet patients/{id}/statistics
		/// </summary>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idStatisticsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/statistics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get child studies
		/// Get detailed information about the child studies of the DICOM patient whose Orthanc identifier is provided in the URL
		/// Patients_idStudiesGetByFullAndRequestedTagsAnd_short patients/{id}/studies
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the patient of interest</param>
		public async Task<object> Patients_idStudiesGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "patients/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/studies?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List Orthanc peers
		/// List all the Orthanc peers that are known to Orthanc. This corresponds either to the content of the `OrthancPeers` configuration option, or to the information stored in the database if `OrthancPeersInDatabase` is `true`.
		/// PeersGetByExpand peers
		/// </summary>
		/// <param name="expand">If present, retrieve detailed information about the individual Orthanc peers</param>
		public async Task<object> PeersGetByExpandAsync(string expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "peers?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete Orthanc peer
		/// Delete one Orthanc peer. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.
		/// Peers_idDelete peers/{id}
		/// </summary>
		/// <param name="id">Identifier of the Orthanc peer of interest</param>
		public async Task Peers_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "peers/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations on peer
		/// List the operations that are available for an Orthanc peer.
		/// Peers_idGet peers/{id}
		/// </summary>
		/// <param name="id">Identifier of the peer of interest</param>
		public async Task<object> Peers_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "peers/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update Orthanc peer
		/// Define a new Orthanc peer, or update an existing one. This change is permanent iff. `OrthancPeersInDatabase` is `true`, otherwise it is lost at the next restart of Orthanc.
		/// Peers_idPut peers/{id}
		/// </summary>
		/// <param name="id">Identifier of the new/updated Orthanc peer</param>
		public async Task Peers_idPutAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "peers/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get peer configuration
		/// Get detailed information about the configuration of some Orthanc peer
		/// Peers_idConfigurationGet peers/{id}/configuration
		/// </summary>
		/// <param name="id">Identifier of the peer of interest</param>
		public async Task<object> Peers_idConfigurationGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "peers/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/configuration";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Send to Orthanc peer
		/// Send DICOM resources stored locally to some remote Orthanc peer whose identifier is provided in the URL: https://book.orthanc-server.com/users/rest.html#sending-one-resource
		/// Peers_idStorePost peers/{id}/store
		/// </summary>
		/// <param name="id">Identifier of the modality of interest</param>
		public async Task<object> Peers_idStorePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "peers/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/store";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get peer system information
		/// Get system information about some Orthanc peer. This corresponds to doing a `GET` request against the `/system` URI of the remote peer. This route can be used to test connectivity.
		/// Peers_idSystemGet peers/{id}/system
		/// </summary>
		/// <param name="id">Identifier of the peer of interest</param>
		public async Task<object> Peers_idSystemGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "peers/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/system";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List plugins
		/// List all the installed plugins
		/// PluginsGet plugins
		/// </summary>
		public async Task<object> PluginsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "plugins";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// JavaScript extensions to Orthanc Explorer
		/// Get the JavaScript extensions that are installed by all the plugins using the `OrthancPluginExtendOrthancExplorer()` function of the plugin SDK. This route is for internal use of Orthanc Explorer.
		/// PluginsExplorer_jsGet plugins/explorer.js
		/// </summary>
		public async Task PluginsExplorer_jsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "plugins/explorer.js";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get plugin
		/// Get system information about the plugin whose identifier is provided in the URL
		/// Plugins_idGet plugins/{id}
		/// </summary>
		/// <param name="id">Identifier of the job of interest</param>
		public async Task<object> Plugins_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "plugins/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List query/retrieve operations
		/// List the identifiers of all the query/retrieve operations on DICOM modalities, as initiated by calls to `/modalities/{id}/query`. The length of this list is bounded by the `QueryRetrieveSize` configuration option of Orthanc. https://book.orthanc-server.com/users/rest.html#performing-query-retrieve-c-find-and-find-with-rest
		/// QueriesGet queries
		/// </summary>
		public async Task<object> QueriesGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a query
		/// Delete the query/retrieve operation whose identifier is provided in the URL
		/// Queries_idDelete queries/{id}
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		public async Task Queries_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations on a query
		/// List the available operations for the query/retrieve operation whose identifier is provided in the URL
		/// Queries_idGet queries/{id}
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		public async Task<object> Queries_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List answers to a query
		/// List the indices of all the available answers resulting from a query/retrieve operation on some DICOM modality, whose identifier is provided in the URL
		/// Queries_idAnswersGetByExpandAnd_shortAndSimplify queries/{id}/answers
		/// </summary>
		/// <param name="expand">If present, retrieve detailed information about the individual answers</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Identifier of the query of interest</param>
		public async Task<object> Queries_idAnswersGetByExpandAnd_shortAndSimplifyAsync(string expand, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/answers?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations on an answer
		/// List the available operations on an answer associated with the query/retrieve operation whose identifier is provided in the URL
		/// Queries_idAnswers_indexGet queries/{id}/answers/{index}
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		/// <param name="index">Index of the answer</param>
		public async Task<object> Queries_idAnswers_indexGetAsync(string id, string index, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/answers/"+ (index==null? "" : System.Uri.EscapeDataString(index));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get one answer
		/// Get the content (DICOM tags) of one answer associated with the query/retrieve operation whose identifier is provided in the URL
		/// Queries_idAnswers_indexContentGetBy_shortAndSimplify queries/{id}/answers/{index}/content
		/// </summary>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Identifier of the query of interest</param>
		/// <param name="index">Index of the answer</param>
		public async Task<object> Queries_idAnswers_indexContentGetBy_shortAndSimplifyAsync(bool _short, bool simplify, string id, string index, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/answers/"+ (index==null? "" : System.Uri.EscapeDataString(index))+"/content?short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Query the child instances of an answer
		/// Issue a second DICOM C-FIND operation, in order to query the child instances associated with one answer to some query/retrieve operation whose identifiers are provided in the URL
		/// Queries_idAnswers_indexQuery_instancesPost queries/{id}/answers/{index}/query-instances
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		/// <param name="index">Index of the answer</param>
		public async Task<object> Queries_idAnswers_indexQuery_instancesPostAsync(string id, string index, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/answers/"+ (index==null? "" : System.Uri.EscapeDataString(index))+"/query-instances";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Query the child series of an answer
		/// Issue a second DICOM C-FIND operation, in order to query the child series associated with one answer to some query/retrieve operation whose identifiers are provided in the URL
		/// Queries_idAnswers_indexQuery_seriesPost queries/{id}/answers/{index}/query-series
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		/// <param name="index">Index of the answer</param>
		public async Task<object> Queries_idAnswers_indexQuery_seriesPostAsync(string id, string index, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/answers/"+ (index==null? "" : System.Uri.EscapeDataString(index))+"/query-series";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Query the child studies of an answer
		/// Issue a second DICOM C-FIND operation, in order to query the child studies associated with one answer to some query/retrieve operation whose identifiers are provided in the URL
		/// Queries_idAnswers_indexQuery_studiesPost queries/{id}/answers/{index}/query-studies
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		/// <param name="index">Index of the answer</param>
		public async Task<object> Queries_idAnswers_indexQuery_studiesPostAsync(string id, string index, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/answers/"+ (index==null? "" : System.Uri.EscapeDataString(index))+"/query-studies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve one answer
		/// Start a C-MOVE SCU command as a job, in order to retrieve one answer associated with the query/retrieve operation whose identifiers are provided in the URL: https://book.orthanc-server.com/users/rest.html#performing-retrieve-c-move
		/// Queries_idAnswers_indexRetrievePost queries/{id}/answers/{index}/retrieve
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		/// <param name="index">Index of the answer</param>
		public async Task<object> Queries_idAnswers_indexRetrievePostAsync(string id, string index, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/answers/"+ (index==null? "" : System.Uri.EscapeDataString(index))+"/retrieve";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get level of original query
		/// Get the query level (value of the `QueryRetrieveLevel` tag) of the query/retrieve operation whose identifier is provided in the URL
		/// Queries_idLevelGet queries/{id}/level
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		public async Task Queries_idLevelGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/level";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get modality of original query
		/// Get the identifier of the DICOM modality that was targeted by the query/retrieve operation whose identifier is provided in the URL
		/// Queries_idModalityGet queries/{id}/modality
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		public async Task Queries_idModalityGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/modality";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get original query arguments
		/// Get the original DICOM filter associated with the query/retrieve operation whose identifier is provided in the URL
		/// Queries_idQueryGetBy_shortAndSimplify queries/{id}/query
		/// </summary>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Identifier of the query of interest</param>
		public async Task<object> Queries_idQueryGetBy_shortAndSimplifyAsync(bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/query?short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all answers
		/// Start a C-MOVE SCU command as a job, in order to retrieve all the answers associated with the query/retrieve operation whose identifier is provided in the URL: https://book.orthanc-server.com/users/rest.html#performing-retrieve-c-move
		/// Queries_idRetrievePost queries/{id}/retrieve
		/// </summary>
		/// <param name="id">Identifier of the query of interest</param>
		public async Task<object> Queries_idRetrievePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "queries/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/retrieve";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the available series
		/// List the Orthanc identifiers of all the available DICOM series
		/// SeriesGetByExpandAndFullAndLimitAndRequestedTagsAnd_shortAndSince series
		/// </summary>
		/// <param name="expand">If present, retrieve detailed information about the individual series</param>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="limit">Limit the number of results</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="since">Show only the resources since the provided index</param>
		public async Task<object> SeriesGetByExpandAndFullAndLimitAndRequestedTagsAnd_shortAndSinceAsync(string expand, bool full, double limit, string requestedTags, bool _short, double since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&full="+full+"&limit="+limit+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short+"&since="+since;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete some series
		/// Delete the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idDelete series/{id}
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task Series_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get information about some series
		/// Get detailed information about the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idGetByFullAndRequestedTagsAnd_short series/{id}
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Anonymize series
		/// Start a job that will anonymize all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://book.orthanc-server.com/users/anonymization.html#anonymization-of-patients-studies-or-series
		/// Series_idAnonymizePost series/{id}/anonymize
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idAnonymizePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/anonymize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create ZIP archive
		/// Synchronously create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.
		/// Series_idArchiveGetByFilenameAndTranscode series/{id}/archive
		/// </summary>
		/// <param name="filename">Filename to set in the "Content-Disposition" HTTP header (including file extension)</param>
		/// <param name="transcode">If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task Series_idArchiveGetByFilenameAndTranscodeAsync(string filename, string transcode, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/archive?filename=" + (filename==null? "" : System.Uri.EscapeDataString(filename))+"&transcode=" + (transcode==null? "" : System.Uri.EscapeDataString(transcode));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create ZIP archive
		/// Create a ZIP archive containing the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idArchivePost series/{id}/archive
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idArchivePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/archive";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List attachments
		/// Get the list of attachments that are associated with the given series
		/// Series_idAttachmentsGetByFull series/{id}/attachments
		/// </summary>
		/// <param name="full">If present, retrieve the attachments list and their numerical ids</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idAttachmentsGetByFullAsync(string full, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments?full=" + (full==null? "" : System.Uri.EscapeDataString(full));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete attachment
		/// Delete an attachment associated with the given DICOM series. This call will fail if trying to delete a system attachment (i.e. whose index is < 1024).
		/// Series_idAttachments_nameDelete series/{id}/attachments/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameDeleteAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations on attachments
		/// Get the list of the operations that are available for attachments associated with the given series
		/// Series_idAttachments_nameGet series/{id}/attachments/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Series_idAttachments_nameGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Compress attachment
		/// Change the compression scheme that is used to store an attachment.
		/// Series_idAttachments_nameCompressPost series/{id}/attachments/{name}/compress
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameCompressPostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compress";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get attachment (no decompression)
		/// Get the (binary) content of one attachment associated with the given series. The attachment will not be decompressed if `StorageCompression` is `true`.
		/// Series_idAttachments_nameCompressed_dataGet series/{id}/attachments/{name}/compressed-data
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameCompressed_dataGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-data";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get MD5 of attachment on disk
		/// Get the MD5 hash of one attachment associated with the given series, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.
		/// Series_idAttachments_nameCompressed_md5Get series/{id}/attachments/{name}/compressed-md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameCompressed_md5GetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get size of attachment on disk
		/// Get the size of one attachment associated with the given series, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.
		/// Series_idAttachments_nameCompressed_sizeGet series/{id}/attachments/{name}/compressed-size
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameCompressed_sizeGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-size";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get attachment
		/// Get the (binary) content of one attachment associated with the given series
		/// Series_idAttachments_nameDataGet series/{id}/attachments/{name}/data
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameDataGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/data";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get info about the attachment
		/// Get all the information about the attachment associated with the given series
		/// Series_idAttachments_nameInfoGet series/{id}/attachments/{name}/info
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Series_idAttachments_nameInfoGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/info";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Is attachment compressed?
		/// Test whether the attachment has been stored as a compressed file on the disk.
		/// Series_idAttachments_nameIs_compressedGet series/{id}/attachments/{name}/is-compressed
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameIs_compressedGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/is-compressed";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get MD5 of attachment
		/// Get the MD5 hash of one attachment associated with the given series
		/// Series_idAttachments_nameMd5Get series/{id}/attachments/{name}/md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameMd5GetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get size of attachment
		/// Get the size of one attachment associated with the given series
		/// Series_idAttachments_nameSizeGet series/{id}/attachments/{name}/size
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameSizeGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/size";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Uncompress attachment
		/// Change the compression scheme that is used to store an attachment.
		/// Series_idAttachments_nameUncompressPost series/{id}/attachments/{name}/uncompress
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Series_idAttachments_nameUncompressPostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/uncompress";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Verify attachment
		/// Verify that the attachment is not corrupted, by validating its MD5 hash
		/// Series_idAttachments_nameVerify_md5Post series/{id}/attachments/{name}/verify-md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Series_idAttachments_nameVerify_md5PostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/verify-md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get child instances
		/// Get detailed information about the child instances of the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idInstancesGetByFullAndRequestedTagsAnd_short series/{id}/instances
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idInstancesGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instances?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get tags of instances
		/// Get the tags of all the child instances of the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idInstances_tagsGetByIgnore_lengthAnd_shortAndSimplify series/{id}/instances-tags
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idInstances_tagsGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instances-tags?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List labels
		/// Get the labels that are associated with the given series (new in Orthanc 1.12.0)
		/// Series_idLabelsGet series/{id}/labels
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idLabelsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove label
		/// Remove a label associated with a series
		/// Series_idLabels_labelDelete series/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="label">The label to be removed</param>
		public async Task Series_idLabels_labelDeleteAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Test label
		/// Test whether the series is associated with the given label
		/// Series_idLabels_labelGet series/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="label">The label of interest</param>
		public async Task Series_idLabels_labelGetAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add label
		/// Associate a label with a series
		/// Series_idLabels_labelPut series/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="label">The label to be added</param>
		public async Task Series_idLabels_labelPutAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create DICOMDIR media
		/// Synchronously create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.
		/// Series_idMediaGetByExtendedAndFilenameAndTranscode series/{id}/media
		/// </summary>
		/// <param name="extended">If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*</param>
		/// <param name="filename">Filename to set in the "Content-Disposition" HTTP header (including file extension)</param>
		/// <param name="transcode">If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task Series_idMediaGetByExtendedAndFilenameAndTranscodeAsync(string extended, string filename, string transcode, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/media?extended=" + (extended==null? "" : System.Uri.EscapeDataString(extended))+"&filename=" + (filename==null? "" : System.Uri.EscapeDataString(filename))+"&transcode=" + (transcode==null? "" : System.Uri.EscapeDataString(transcode));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create DICOMDIR media
		/// Create a DICOMDIR media containing the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idMediaPost series/{id}/media
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idMediaPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/media";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List metadata
		/// Get the list of metadata that are associated with the given series
		/// Series_idMetadataGetByExpandAndNumeric series/{id}/metadata
		/// </summary>
		/// <param name="expand">If present, also retrieve the value of the individual metadata</param>
		/// <param name="numeric">If present, use the numeric identifier of the metadata instead of its symbolic name</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idMetadataGetByExpandAndNumericAsync(string expand, string numeric, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&numeric=" + (numeric==null? "" : System.Uri.EscapeDataString(numeric));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete metadata
		/// Delete some metadata associated with the given DICOM series. This call will fail if trying to delete a system metadata (i.e. whose index is < 1024).
		/// Series_idMetadata_nameDelete series/{id}/metadata/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the metadata, or its index (cf. `UserMetadata` configuration option)</param>
		public async Task Series_idMetadata_nameDeleteAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get metadata
		/// Get the value of a metadata that is associated with the given series
		/// Series_idMetadata_nameGet series/{id}/metadata/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		/// <param name="name">The name of the metadata, or its index (cf. `UserMetadata` configuration option)</param>
		public async Task Series_idMetadata_nameGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Modify series
		/// Start a job that will modify all the DICOM instances within the series whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new series, whose Orthanc identifiers will be returned by the job. https://book.orthanc-server.com/users/anonymization.html#modification-of-studies-or-series
		/// Series_idModifyPost series/{id}/modify
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idModifyPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/modify";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get series module
		/// Get the series module of the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idModuleGetByIgnore_lengthAnd_shortAndSimplify series/{id}/module
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idModuleGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/module?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Decode series for numpy
		/// Decode the given DICOM series, for use with numpy in Python. The numpy array has 4 dimensions: (frame, height, width, color channel).
		/// Series_idNumpyGetByCompressAndRescale series/{id}/numpy
		/// </summary>
		/// <param name="compress">Compress the file as `.npz`</param>
		/// <param name="rescale">On grayscale images, apply the rescaling and return floating-point values</param>
		/// <param name="id">Orthanc identifier of the DICOM resource of interest</param>
		public async Task Series_idNumpyGetByCompressAndRescaleAsync(bool compress, bool rescale, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/numpy?compress="+compress+"&rescale="+rescale;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Order the slices
		/// Sort the instances and frames (slices) of the DICOM series whose Orthanc identifier is provided in the URL. This URI is essentially used by the Orthanc Web viewer and by the Osimis Web viewer.
		/// Series_idOrdered_slicesGet series/{id}/ordered-slices
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idOrdered_slicesGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/ordered-slices";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get parent patient
		/// Get detailed information about the parent patient of the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idPatientGetByFullAndRequestedTagsAnd_short series/{id}/patient
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idPatientGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/patient?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reconstruct tags & optionally files of series
		/// Reconstruct the main DICOM tags in DB of the series whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.
		/// Series_idReconstructPost series/{id}/reconstruct
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task Series_idReconstructPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/reconstruct";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get shared tags
		/// Extract the DICOM tags whose value is constant across all the child instances of the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idShared_tagsGetBy_shortAndSimplify series/{id}/shared-tags
		/// </summary>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idShared_tagsGetBy_shortAndSimplifyAsync(bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/shared-tags?short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get series statistics
		/// Get statistics about the given series
		/// Series_idStatisticsGet series/{id}/statistics
		/// </summary>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idStatisticsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/statistics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get parent study
		/// Get detailed information about the parent study of the DICOM series whose Orthanc identifier is provided in the URL
		/// Series_idStudyGetByFullAndRequestedTagsAnd_short series/{id}/study
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the series of interest</param>
		public async Task<object> Series_idStudyGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/study?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get database statistics
		/// Get statistics related to the database of Orthanc
		/// StatisticsGet statistics
		/// </summary>
		public async Task<object> StatisticsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "statistics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get storage commitment report
		/// Get the storage commitment report whose identifier is provided in the URL: https://book.orthanc-server.com/users/storage-commitment.html#storage-commitment-scu
		/// Storage_commitment_idGet storage-commitment/{id}
		/// </summary>
		/// <param name="id">Identifier of the storage commitment report</param>
		public async Task<object> Storage_commitment_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "storage-commitment/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove after storage commitment
		/// Remove out of Orthanc, the DICOM instances that have been reported to have been properly received the storage commitment report whose identifier is provided in the URL. This is only possible if the `Status` of the storage commitment report is `Success`. https://book.orthanc-server.com/users/storage-commitment.html#removing-the-instances
		/// Storage_commitment_idRemovePost storage-commitment/{id}/remove
		/// </summary>
		/// <param name="id">Identifier of the storage commitment report</param>
		public async Task Storage_commitment_idRemovePostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "storage-commitment/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/remove";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the available studies
		/// List the Orthanc identifiers of all the available DICOM studies
		/// StudiesGetByExpandAndFullAndLimitAndRequestedTagsAnd_shortAndSince studies
		/// </summary>
		/// <param name="expand">If present, retrieve detailed information about the individual studies</param>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="limit">Limit the number of results</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="since">Show only the resources since the provided index</param>
		public async Task<object> StudiesGetByExpandAndFullAndLimitAndRequestedTagsAnd_shortAndSinceAsync(string expand, bool full, double limit, string requestedTags, bool _short, double since, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&full="+full+"&limit="+limit+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short+"&since="+since;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete some study
		/// Delete the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idDelete studies/{id}
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task Studies_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get information about some study
		/// Get detailed information about the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idGetByFullAndRequestedTagsAnd_short studies/{id}
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Anonymize study
		/// Start a job that will anonymize all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://book.orthanc-server.com/users/anonymization.html#anonymization-of-patients-studies-or-series
		/// Studies_idAnonymizePost studies/{id}/anonymize
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idAnonymizePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/anonymize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create ZIP archive
		/// Synchronously create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.
		/// Studies_idArchiveGetByFilenameAndTranscode studies/{id}/archive
		/// </summary>
		/// <param name="filename">Filename to set in the "Content-Disposition" HTTP header (including file extension)</param>
		/// <param name="transcode">If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task Studies_idArchiveGetByFilenameAndTranscodeAsync(string filename, string transcode, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/archive?filename=" + (filename==null? "" : System.Uri.EscapeDataString(filename))+"&transcode=" + (transcode==null? "" : System.Uri.EscapeDataString(transcode));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create ZIP archive
		/// Create a ZIP archive containing the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idArchivePost studies/{id}/archive
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idArchivePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/archive";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List attachments
		/// Get the list of attachments that are associated with the given study
		/// Studies_idAttachmentsGetByFull studies/{id}/attachments
		/// </summary>
		/// <param name="full">If present, retrieve the attachments list and their numerical ids</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idAttachmentsGetByFullAsync(string full, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments?full=" + (full==null? "" : System.Uri.EscapeDataString(full));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete attachment
		/// Delete an attachment associated with the given DICOM study. This call will fail if trying to delete a system attachment (i.e. whose index is < 1024).
		/// Studies_idAttachments_nameDelete studies/{id}/attachments/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameDeleteAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations on attachments
		/// Get the list of the operations that are available for attachments associated with the given study
		/// Studies_idAttachments_nameGet studies/{id}/attachments/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Studies_idAttachments_nameGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Compress attachment
		/// Change the compression scheme that is used to store an attachment.
		/// Studies_idAttachments_nameCompressPost studies/{id}/attachments/{name}/compress
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameCompressPostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compress";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get attachment (no decompression)
		/// Get the (binary) content of one attachment associated with the given study. The attachment will not be decompressed if `StorageCompression` is `true`.
		/// Studies_idAttachments_nameCompressed_dataGet studies/{id}/attachments/{name}/compressed-data
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameCompressed_dataGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-data";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get MD5 of attachment on disk
		/// Get the MD5 hash of one attachment associated with the given study, as stored on the disk. This is different from `.../md5` iff `EnableStorage` is `true`.
		/// Studies_idAttachments_nameCompressed_md5Get studies/{id}/attachments/{name}/compressed-md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameCompressed_md5GetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get size of attachment on disk
		/// Get the size of one attachment associated with the given study, as stored on the disk. This is different from `.../size` iff `EnableStorage` is `true`.
		/// Studies_idAttachments_nameCompressed_sizeGet studies/{id}/attachments/{name}/compressed-size
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameCompressed_sizeGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/compressed-size";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get attachment
		/// Get the (binary) content of one attachment associated with the given study
		/// Studies_idAttachments_nameDataGet studies/{id}/attachments/{name}/data
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameDataGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/data";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get info about the attachment
		/// Get all the information about the attachment associated with the given study
		/// Studies_idAttachments_nameInfoGet studies/{id}/attachments/{name}/info
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Studies_idAttachments_nameInfoGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/info";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Is attachment compressed?
		/// Test whether the attachment has been stored as a compressed file on the disk.
		/// Studies_idAttachments_nameIs_compressedGet studies/{id}/attachments/{name}/is-compressed
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameIs_compressedGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/is-compressed";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get MD5 of attachment
		/// Get the MD5 hash of one attachment associated with the given study
		/// Studies_idAttachments_nameMd5Get studies/{id}/attachments/{name}/md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameMd5GetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get size of attachment
		/// Get the size of one attachment associated with the given study
		/// Studies_idAttachments_nameSizeGet studies/{id}/attachments/{name}/size
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameSizeGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/size";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Uncompress attachment
		/// Change the compression scheme that is used to store an attachment.
		/// Studies_idAttachments_nameUncompressPost studies/{id}/attachments/{name}/uncompress
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task Studies_idAttachments_nameUncompressPostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/uncompress";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Verify attachment
		/// Verify that the attachment is not corrupted, by validating its MD5 hash
		/// Studies_idAttachments_nameVerify_md5Post studies/{id}/attachments/{name}/verify-md5
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the attachment, or its index (cf. `UserContentType` configuration option)</param>
		public async Task<object> Studies_idAttachments_nameVerify_md5PostAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/attachments/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/verify-md5";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get child instances
		/// Get detailed information about the child instances of the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idInstancesGetByFullAndRequestedTagsAnd_short studies/{id}/instances
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idInstancesGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instances?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get tags of instances
		/// Get the tags of all the child instances of the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idInstances_tagsGetByIgnore_lengthAnd_shortAndSimplify studies/{id}/instances-tags
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idInstances_tagsGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instances-tags?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List labels
		/// Get the labels that are associated with the given study (new in Orthanc 1.12.0)
		/// Studies_idLabelsGet studies/{id}/labels
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idLabelsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove label
		/// Remove a label associated with a study
		/// Studies_idLabels_labelDelete studies/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="label">The label to be removed</param>
		public async Task Studies_idLabels_labelDeleteAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Test label
		/// Test whether the study is associated with the given label
		/// Studies_idLabels_labelGet studies/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="label">The label of interest</param>
		public async Task Studies_idLabels_labelGetAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add label
		/// Associate a label with a study
		/// Studies_idLabels_labelPut studies/{id}/labels/{label}
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="label">The label to be added</param>
		public async Task Studies_idLabels_labelPutAsync(string id, string label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/labels/"+ (label==null? "" : System.Uri.EscapeDataString(label));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create DICOMDIR media
		/// Synchronously create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL. This flavor is synchronous, which might *not* be desirable to archive large amount of data, as it might lead to network timeouts. Prefer the asynchronous version using `POST` method.
		/// Studies_idMediaGetByExtendedAndFilenameAndTranscode studies/{id}/media
		/// </summary>
		/// <param name="extended">If present, will include additional tags such as `SeriesDescription`, leading to a so-called *extended DICOMDIR*</param>
		/// <param name="filename">Filename to set in the "Content-Disposition" HTTP header (including file extension)</param>
		/// <param name="transcode">If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task Studies_idMediaGetByExtendedAndFilenameAndTranscodeAsync(string extended, string filename, string transcode, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/media?extended=" + (extended==null? "" : System.Uri.EscapeDataString(extended))+"&filename=" + (filename==null? "" : System.Uri.EscapeDataString(filename))+"&transcode=" + (transcode==null? "" : System.Uri.EscapeDataString(transcode));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create DICOMDIR media
		/// Create a DICOMDIR media containing the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idMediaPost studies/{id}/media
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idMediaPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/media";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Merge study
		/// Start a new job so as to move some DICOM resources into the DICOM study whose Orthanc identifier is provided in the URL: https://book.orthanc-server.com/users/anonymization.html#merging
		/// Studies_idMergePost studies/{id}/merge
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idMergePostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/merge";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List metadata
		/// Get the list of metadata that are associated with the given study
		/// Studies_idMetadataGetByExpandAndNumeric studies/{id}/metadata
		/// </summary>
		/// <param name="expand">If present, also retrieve the value of the individual metadata</param>
		/// <param name="numeric">If present, use the numeric identifier of the metadata instead of its symbolic name</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idMetadataGetByExpandAndNumericAsync(string expand, string numeric, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata?expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&numeric=" + (numeric==null? "" : System.Uri.EscapeDataString(numeric));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete metadata
		/// Delete some metadata associated with the given DICOM study. This call will fail if trying to delete a system metadata (i.e. whose index is < 1024).
		/// Studies_idMetadata_nameDelete studies/{id}/metadata/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the metadata, or its index (cf. `UserMetadata` configuration option)</param>
		public async Task Studies_idMetadata_nameDeleteAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get metadata
		/// Get the value of a metadata that is associated with the given study
		/// Studies_idMetadata_nameGet studies/{id}/metadata/{name}
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		/// <param name="name">The name of the metadata, or its index (cf. `UserMetadata` configuration option)</param>
		public async Task Studies_idMetadata_nameGetAsync(string id, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metadata/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Modify study
		/// Start a job that will modify all the DICOM instances within the study whose identifier is provided in the URL. The modified DICOM instances will be stored into a brand new study, whose Orthanc identifiers will be returned by the job. https://book.orthanc-server.com/users/anonymization.html#modification-of-studies-or-series
		/// Studies_idModifyPost studies/{id}/modify
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idModifyPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/modify";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get study module
		/// Get the study module of the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idModuleGetByIgnore_lengthAnd_shortAndSimplify studies/{id}/module
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idModuleGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/module?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get patient module of study
		/// Get the patient module of the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idModule_patientGetByIgnore_lengthAnd_shortAndSimplify studies/{id}/module-patient
		/// </summary>
		/// <param name="ignore_length">Also include the DICOM tags that are provided in this list, even if their associated value is long</param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idModule_patientGetByIgnore_lengthAnd_shortAndSimplifyAsync(string[] ignore_length, bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/module-patient?"+string.Join("&", ignore_length.Select(z => $"ignore-length={System.Uri.EscapeDataString(z.ToString())}"))+"&short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get parent patient
		/// Get detailed information about the parent patient of the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idPatientGetByFullAndRequestedTagsAnd_short studies/{id}/patient
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idPatientGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/patient?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reconstruct tags & optionally files of study
		/// Reconstruct the main DICOM tags in DB of the study whose Orthanc identifier is provided in the URL. This is useful if child studies/series/instances have inconsistent values for higher-level tags, in order to force Orthanc to use the value from the resource of interest. Beware that this is a time-consuming operation, as all the children DICOM instances will be parsed again, and the Orthanc index will be updated accordingly.
		/// Studies_idReconstructPost studies/{id}/reconstruct
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task Studies_idReconstructPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/reconstruct";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get child series
		/// Get detailed information about the child series of the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idSeriesGetByFullAndRequestedTagsAnd_short studies/{id}/series
		/// </summary>
		/// <param name="full">If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value)</param>
		/// <param name="requestedTags">If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: 'requestedTags=0010,0010;PatientBirthDate'.  The tags requested tags are returned in the 'RequestedTags' field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return </param>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idSeriesGetByFullAndRequestedTagsAnd_shortAsync(bool full, string requestedTags, bool _short, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/series?full="+full+"&requestedTags=" + (requestedTags==null? "" : System.Uri.EscapeDataString(requestedTags))+"&short="+_short;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get shared tags
		/// Extract the DICOM tags whose value is constant across all the child instances of the DICOM study whose Orthanc identifier is provided in the URL
		/// Studies_idShared_tagsGetBy_shortAndSimplify studies/{id}/shared-tags
		/// </summary>
		/// <param name="_short">If present, report the DICOM tags in hexadecimal format</param>
		/// <param name="simplify">If present, report the DICOM tags in human-readable format (using the symbolic name of the tags)</param>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idShared_tagsGetBy_shortAndSimplifyAsync(bool _short, bool simplify, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/shared-tags?short="+_short+"&simplify="+simplify;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Split study
		/// Start a new job so as to split the DICOM study whose Orthanc identifier is provided in the URL, by taking some of its children series or instances out of it and putting them into a brand new study (this new study is created by setting the `StudyInstanceUID` tag to a random identifier): https://book.orthanc-server.com/users/anonymization.html#splitting
		/// Studies_idSplitPost studies/{id}/split
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idSplitPostAsync(string id, object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/split";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get study statistics
		/// Get statistics about the given study
		/// Studies_idStatisticsGet studies/{id}/statistics
		/// </summary>
		/// <param name="id">Orthanc identifier of the study of interest</param>
		public async Task<object> Studies_idStatisticsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "studies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/statistics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get system information
		/// Get system information about Orthanc
		/// SystemGet system
		/// </summary>
		public async Task<object> SystemGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List operations
		/// List the available operations under URI `/tools/`
		/// ToolsGet tools
		/// </summary>
		public async Task<object> ToolsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get accepted transfer syntaxes
		/// Get the list of UIDs of the DICOM transfer syntaxes that are accepted by Orthanc C-STORE SCP. This corresponds to the configuration options `AcceptedTransferSyntaxes` and `XXXTransferSyntaxAccepted`.
		/// ToolsAccepted_transfer_syntaxesGet tools/accepted-transfer-syntaxes
		/// </summary>
		public async Task<object> ToolsAccepted_transfer_syntaxesGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/accepted-transfer-syntaxes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Set accepted transfer syntaxes
		/// Set the DICOM transfer syntaxes that accepted by Orthanc C-STORE SCP
		/// ToolsAccepted_transfer_syntaxesPut tools/accepted-transfer-syntaxes
		/// </summary>
		public async Task<object> ToolsAccepted_transfer_syntaxesPutAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/accepted-transfer-syntaxes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Anonymize a set of resources
		/// Start a job that will anonymize all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.
		/// ToolsBulk_anonymizePost tools/bulk-anonymize
		/// </summary>
		public async Task<object> ToolsBulk_anonymizePostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/bulk-anonymize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Describe a set of resources
		/// Get the content all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field, in one single call.
		/// ToolsBulk_contentPost tools/bulk-content
		/// </summary>
		public async Task ToolsBulk_contentPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/bulk-content";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a set of resources
		/// Delete all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.
		/// ToolsBulk_deletePost tools/bulk-delete
		/// </summary>
		public async Task ToolsBulk_deletePostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/bulk-delete";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Modify a set of resources
		/// Start a job that will modify all the DICOM patients, studies, series or instances whose identifiers are provided in the `Resources` field.
		/// ToolsBulk_modifyPost tools/bulk-modify
		/// </summary>
		public async Task<object> ToolsBulk_modifyPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/bulk-modify";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create ZIP archive
		/// Create a ZIP archive containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body
		/// ToolsCreate_archivePost tools/create-archive
		/// </summary>
		public async Task<object> ToolsCreate_archivePostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/create-archive";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create one DICOM instance
		/// Create one DICOM instance, and store it into Orthanc
		/// ToolsCreate_dicomPost tools/create-dicom
		/// </summary>
		public async Task<object> ToolsCreate_dicomPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/create-dicom";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create DICOMDIR media
		/// Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body
		/// ToolsCreate_mediaPost tools/create-media
		/// </summary>
		public async Task<object> ToolsCreate_mediaPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/create-media";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create DICOMDIR media
		/// Create a DICOMDIR media containing the DICOM resources (patients, studies, series, or instances) whose Orthanc identifiers are provided in the body
		/// ToolsCreate_media_extendedPost tools/create-media-extended
		/// </summary>
		public async Task<object> ToolsCreate_media_extendedPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/create-media-extended";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get default encoding
		/// Get the default encoding that is used by Orthanc if parsing a DICOM instance without the `SpecificCharacterEncoding` tag, or during C-FIND. This corresponds to the configuration option `DefaultEncoding`.
		/// ToolsDefault_encodingGet tools/default-encoding
		/// </summary>
		public async Task ToolsDefault_encodingGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/default-encoding";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get DICOM conformance
		/// Get the DICOM conformance statement of Orthanc
		/// ToolsDicom_conformanceGet tools/dicom-conformance
		/// </summary>
		public async Task ToolsDicom_conformanceGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/dicom-conformance";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trigger C-ECHO SCU
		/// Trigger C-ECHO SCU command against a DICOM modality described in the POST body, without having to register the modality in some `/modalities/{id}` (new in Orthanc 1.8.1)
		/// ToolsDicom_echoPost tools/dicom-echo
		/// </summary>
		public async Task ToolsDicom_echoPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/dicom-echo";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Look for local resources
		/// This URI can be used to perform a search on the content of the local Orthanc server, in a way that is similar to querying remote DICOM modalities using C-FIND SCU: https://book.orthanc-server.com/users/rest.html#performing-finds-within-orthanc
		/// ToolsFindPost tools/find
		/// </summary>
		public async Task<object> ToolsFindPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/find";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Generate an identifier
		/// Generate a random DICOM identifier
		/// ToolsGenerate_uidGetByLevel tools/generate-uid
		/// </summary>
		/// <param name="level">Type of DICOM resource among: `patient`, `study`, `series` or `instance`</param>
		public async Task ToolsGenerate_uidGetByLevelAsync(string level, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/generate-uid?level=" + (level==null? "" : System.Uri.EscapeDataString(level));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Invalidate DICOM-as-JSON summaries
		/// Remove all the attachments of the type "DICOM-as-JSON" that are associated will all the DICOM instances stored in Orthanc. These summaries will be automatically re-created on the next access. This is notably useful after changes to the `Dictionary` configuration option. https://book.orthanc-server.com/faq/orthanc-storage.html#storage-area
		/// ToolsInvalidate_tagsPost tools/invalidate-tags
		/// </summary>
		public async Task ToolsInvalidate_tagsPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/invalidate-tags";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get all the used labels
		/// List all the labels that are associated with any resource of the Orthanc database
		/// ToolsLabelsGet tools/labels
		/// </summary>
		public async Task<object> ToolsLabelsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/labels";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get main log level
		/// Get the main log level of Orthanc
		/// ToolsLog_levelGet tools/log-level
		/// </summary>
		public async Task ToolsLog_levelGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/log-level";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get log level for `dicom`
		/// Get the log level of the log category `dicom`
		/// ToolsLog_level_dicomGet tools/log-level-dicom
		/// </summary>
		public async Task ToolsLog_level_dicomGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/log-level-dicom";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get log level for `generic`
		/// Get the log level of the log category `generic`
		/// ToolsLog_level_genericGet tools/log-level-generic
		/// </summary>
		public async Task ToolsLog_level_genericGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/log-level-generic";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get log level for `http`
		/// Get the log level of the log category `http`
		/// ToolsLog_level_httpGet tools/log-level-http
		/// </summary>
		public async Task ToolsLog_level_httpGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/log-level-http";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get log level for `jobs`
		/// Get the log level of the log category `jobs`
		/// ToolsLog_level_jobsGet tools/log-level-jobs
		/// </summary>
		public async Task ToolsLog_level_jobsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/log-level-jobs";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get log level for `lua`
		/// Get the log level of the log category `lua`
		/// ToolsLog_level_luaGet tools/log-level-lua
		/// </summary>
		public async Task ToolsLog_level_luaGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/log-level-lua";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get log level for `plugins`
		/// Get the log level of the log category `plugins`
		/// ToolsLog_level_pluginsGet tools/log-level-plugins
		/// </summary>
		public async Task ToolsLog_level_pluginsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/log-level-plugins";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get log level for `sqlite`
		/// Get the log level of the log category `sqlite`
		/// ToolsLog_level_sqliteGet tools/log-level-sqlite
		/// </summary>
		public async Task ToolsLog_level_sqliteGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/log-level-sqlite";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Are metrics collected?
		/// Returns a Boolean specifying whether Prometheus metrics are collected and exposed at `/tools/metrics-prometheus`
		/// ToolsMetricsGet tools/metrics
		/// </summary>
		public async Task ToolsMetricsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/metrics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get usage metrics
		/// Get usage metrics of Orthanc in the Prometheus file format (OpenMetrics): https://book.orthanc-server.com/users/advanced-rest.html#instrumentation-with-prometheus
		/// ToolsMetrics_prometheusGet tools/metrics-prometheus
		/// </summary>
		public async Task ToolsMetrics_prometheusGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/metrics-prometheus";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get UTC time
		/// Get UTC time
		/// ToolsNowGet tools/now
		/// </summary>
		public async Task ToolsNowGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/now";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get local time
		/// Get local time
		/// ToolsNow_localGet tools/now-local
		/// </summary>
		public async Task ToolsNow_localGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/now-local";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reconstruct all the index
		/// Reconstruct the index of all the tags of all the DICOM instances that are stored in Orthanc. This is notably useful after the deletion of resources whose children resources have inconsistent values with their sibling resources. Beware that this is a highly time-consuming operation, as all the DICOM instances will be parsed again, and as all the Orthanc index will be regenerated. If you have a large database to process, it is advised to use the Housekeeper plugin to perform this action resource by resource
		/// ToolsReconstructPost tools/reconstruct
		/// </summary>
		public async Task ToolsReconstructPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/reconstruct";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Restart Orthanc
		/// Restart Orthanc
		/// ToolsResetPost tools/reset
		/// </summary>
		public async Task ToolsResetPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/reset";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Shutdown Orthanc
		/// Shutdown Orthanc
		/// ToolsShutdownPost tools/shutdown
		/// </summary>
		public async Task ToolsShutdownPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/shutdown";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Is unknown SOP class accepted?
		/// Shall Orthanc C-STORE SCP accept DICOM instances with an unknown SOP class UID?
		/// ToolsUnknown_sop_class_acceptedGet tools/unknown-sop-class-accepted
		/// </summary>
		public async Task ToolsUnknown_sop_class_acceptedGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tools/unknown-sop-class-accepted";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
