//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// An action Item.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Action
	{
		
		/// <summary>
		/// The name of the permission "action"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A collection of actions.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActionCollection
	{
	}
	
	/// <summary>
	/// The Action-Resource item.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActionResource
	{
		
		/// <summary>
		/// An action Item.
		///
		///*New in version 2.1.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Action Action { get; set; }
		
		/// <summary>
		/// A resource on which permissions are granted.
		///
		///*New in version 2.1.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public Resource Resource { get; set; }
	}
	
	/// <summary>
	/// A resource on which permissions are granted.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Resource
	{
		
		/// <summary>
		/// The name of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BasicDAGRun
	{
		
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="data_interval_end")]
		public System.Nullable<System.DateTimeOffset> Data_interval_end { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="data_interval_start")]
		public System.Nullable<System.DateTimeOffset> Data_interval_start { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="end_date")]
		public System.Nullable<System.DateTimeOffset> End_date { get; set; }
		
		/// <summary>
		/// The logical date (previously called execution date). This is the time or interval covered by
		///this DAG run, according to the DAG definition.
		///
		///The value of this field can be set only when creating the object. If you try to modify the
		///field of an existing object, the request fails with an BAD_REQUEST error.
		///
		///This together with DAG_ID are a unique key.
		///
		///*New in version 2.2.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logical_date")]
		public System.Nullable<System.DateTimeOffset> Logical_date { get; set; }
		
		/// <summary>
		/// Run ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="run_id")]
		public string Run_id { get; set; }
		
		/// <summary>
		/// The start time. The time when DAG run was actually created.
		///
		///*Changed in version 2.1.3*&#58; Field becomes nullable.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_date")]
		public System.Nullable<System.DateTimeOffset> Start_date { get; set; }
		
		/// <summary>
		/// DAG State.
		///
		///*Changed in version 2.1.3*&#58; 'queued' is added as a possible value.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<BasicDAGRunState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BasicDAGRunState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
	}
	
	/// <summary>
	/// Class reference
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClassReference
	{
		
		[System.Runtime.Serialization.DataMember(Name="class_name")]
		public string Class_name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="module_path")]
		public string Module_path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClearDagRun
	{
		
		/// <summary>
		/// If set, don't actually run this operation. The response will contain a list of task instances
		///planned to be cleaned, but not modified in any way.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dry_run")]
		public System.Nullable<System.Boolean> Dry_run { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClearTaskInstances
	{
		
		/// <summary>
		/// The DagRun ID for this task instance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_run_id")]
		public string Dag_run_id { get; set; }
		
		/// <summary>
		/// If set, don't actually run this operation. The response will contain a list of task instances
		///planned to be cleaned, but not modified in any way.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dry_run")]
		public System.Nullable<System.Boolean> Dry_run { get; set; }
		
		/// <summary>
		/// The maximum execution date to clear.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_date")]
		public string End_date { get; set; }
		
		/// <summary>
		/// If set to true, downstream tasks are also affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_downstream")]
		public System.Nullable<System.Boolean> Include_downstream { get; set; }
		
		/// <summary>
		/// If set to True, also tasks from future DAG Runs are affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_future")]
		public System.Nullable<System.Boolean> Include_future { get; set; }
		
		/// <summary>
		/// Clear tasks in the parent dag of the subdag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_parentdag")]
		public System.Nullable<System.Boolean> Include_parentdag { get; set; }
		
		/// <summary>
		/// If set to True, also tasks from past DAG Runs are affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_past")]
		public System.Nullable<System.Boolean> Include_past { get; set; }
		
		/// <summary>
		/// Clear tasks in subdags and clear external tasks indicated by ExternalTaskMarker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_subdags")]
		public System.Nullable<System.Boolean> Include_subdags { get; set; }
		
		/// <summary>
		/// If set to true, upstream tasks are also affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_upstream")]
		public System.Nullable<System.Boolean> Include_upstream { get; set; }
		
		/// <summary>
		/// Only clear failed tasks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="only_failed")]
		public System.Nullable<System.Boolean> Only_failed { get; set; }
		
		/// <summary>
		/// Only clear running tasks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="only_running")]
		public System.Nullable<System.Boolean> Only_running { get; set; }
		
		/// <summary>
		/// Set state of DAG runs to RUNNING.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reset_dag_runs")]
		public System.Nullable<System.Boolean> Reset_dag_runs { get; set; }
		
		/// <summary>
		/// The minimum execution date to clear.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_date")]
		public string Start_date { get; set; }
		
		/// <summary>
		/// A list of task ids to clear.
		///
		///*New in version 2.1.0*
		///
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="task_ids")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Task_ids { get; set; }
	}
	
	/// <summary>
	/// Metadata about collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CollectionInfo
	{
		
		/// <summary>
		/// Count of total objects in the current result set before pagination parameters
		///(limit, offset) are applied.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Int32> Total_entries { get; set; }
	}
	
	/// <summary>
	/// The configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Config
	{
		
		[System.Runtime.Serialization.DataMember(Name="sections")]
		public ConfigSection[] Sections { get; set; }
	}
	
	/// <summary>
	/// The section of configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigSection
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="options")]
		public ConfigOption[] Options { get; set; }
	}
	
	/// <summary>
	/// The option of configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigOption
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Full representation of the connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Connection : ConnectionCollectionItem
	{
		
		/// <summary>
		/// Other values that cannot be put into another field, e.g. RSA keys.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extra")]
		public string Extra { get; set; }
		
		/// <summary>
		/// Password of the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
	}
	
	/// <summary>
	/// Collection of connections.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectionCollection
	{
	}
	
	/// <summary>
	/// Connection collection item.
	///The password and extra fields are only available when retrieving a single object due to the sensitivity of this data.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectionCollectionItem
	{
		
		/// <summary>
		/// The connection type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conn_type")]
		public string Conn_type { get; set; }
		
		/// <summary>
		/// The connection ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_id")]
		public string Connection_id { get; set; }
		
		/// <summary>
		/// The description of the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Host of the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Login of the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="login")]
		public string Login { get; set; }
		
		/// <summary>
		/// Port of the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Schema of the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
	}
	
	/// <summary>
	/// Connection test results.
	///
	///*New in version 2.2.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectionTest
	{
		
		/// <summary>
		/// The success or failure message of the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The status of the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Boolean> Status { get; set; }
	}
	
	/// <summary>
	/// Cron expression
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CronExpression
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string @__type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// DAG
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DAG
	{
		
		/// <summary>
		/// The ID of the DAG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		/// <summary>
		/// Default view of the DAG inside the webserver
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="default_view")]
		public string Default_view { get; set; }
		
		/// <summary>
		/// User-provided DAG description, which can consist of several sentences or paragraphs that describe DAG contents.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The key containing the encrypted path to the file. Encryption and decryption take place only on the server. This prevents the client from reading an non-DAG file. This also ensures API extensibility, because the format of encrypted data may change.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file_token")]
		public string File_token { get; set; }
		
		/// <summary>
		/// The absolute path to the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileloc")]
		public string Fileloc { get; set; }
		
		/// <summary>
		/// Whether the DAG has import errors
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_import_errors")]
		public System.Nullable<System.Boolean> Has_import_errors { get; set; }
		
		/// <summary>
		/// Whether the DAG has task concurrency limits
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_task_concurrency_limits")]
		public System.Nullable<System.Boolean> Has_task_concurrency_limits { get; set; }
		
		/// <summary>
		/// Whether the DAG is currently seen by the scheduler(s).
		///
		///*New in version 2.1.1*
		///
		///*Changed in version 2.2.0*&#58; Field is read-only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_active")]
		public System.Nullable<System.Boolean> Is_active { get; set; }
		
		/// <summary>
		/// Whether the DAG is paused.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_paused")]
		public System.Nullable<System.Boolean> Is_paused { get; set; }
		
		/// <summary>
		/// Whether the DAG is SubDAG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_subdag")]
		public System.Nullable<System.Boolean> Is_subdag { get; set; }
		
		/// <summary>
		/// Time when the DAG last received a refresh signal
		///(e.g. the DAG's "refresh" button was clicked in the web UI)
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_expired")]
		public System.Nullable<System.DateTimeOffset> Last_expired { get; set; }
		
		/// <summary>
		/// The last time the DAG was parsed.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_parsed_time")]
		public System.Nullable<System.DateTimeOffset> Last_parsed_time { get; set; }
		
		/// <summary>
		/// The last time the DAG was pickled.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_pickled")]
		public System.Nullable<System.DateTimeOffset> Last_pickled { get; set; }
		
		/// <summary>
		/// Maximum number of active DAG runs for the DAG
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_active_runs")]
		public System.Nullable<System.Int32> Max_active_runs { get; set; }
		
		/// <summary>
		/// Maximum number of active tasks that can be run on the DAG
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_active_tasks")]
		public System.Nullable<System.Int32> Max_active_tasks { get; set; }
		
		/// <summary>
		/// The logical date of the next dag run.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next_dagrun")]
		public System.Nullable<System.DateTimeOffset> Next_dagrun { get; set; }
		
		/// <summary>
		/// Earliest time at which this ``next_dagrun`` can be created.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next_dagrun_create_after")]
		public System.Nullable<System.DateTimeOffset> Next_dagrun_create_after { get; set; }
		
		/// <summary>
		/// The end of the interval of the next dag run.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next_dagrun_data_interval_end")]
		public System.Nullable<System.DateTimeOffset> Next_dagrun_data_interval_end { get; set; }
		
		/// <summary>
		/// The start of the interval of the next dag run.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next_dagrun_data_interval_start")]
		public System.Nullable<System.DateTimeOffset> Next_dagrun_data_interval_start { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owners")]
		public string[] Owners { get; set; }
		
		/// <summary>
		/// Foreign key to the latest pickle_id
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pickle_id")]
		public string Pickle_id { get; set; }
		
		/// <summary>
		/// If the DAG is SubDAG then it is the top level DAG identifier. Otherwise, null.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="root_dag_id")]
		public string Root_dag_id { get; set; }
		
		/// <summary>
		/// Schedule interval. Defines how often DAG runs, this object gets added to your latest task instance's
		///execution_date to figure out the next schedule.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule_interval")]
		public ScheduleInterval Schedule_interval { get; set; }
		
		/// <summary>
		/// Whether (one of) the scheduler is scheduling this DAG at the moment
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduler_lock")]
		public System.Nullable<System.Boolean> Scheduler_lock { get; set; }
		
		/// <summary>
		/// List of tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// Timetable/Schedule Interval description.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timetable_description")]
		public string Timetable_description { get; set; }
	}
	
	/// <summary>
	/// Tag
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Collection of DAGs.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DAGCollection
	{
	}
	
	/// <summary>
	/// DAG details.
	///
	///For details see:
	///[airflow.models.DAG](https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/models/index.html#airflow.models.DAG)
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DAGDetail : DAG
	{
		
		[System.Runtime.Serialization.DataMember(Name="catchup")]
		public System.Nullable<System.Boolean> Catchup { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="concurrency")]
		public System.Nullable<System.Double> Concurrency { get; set; }
		
		/// <summary>
		/// Time delta
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_run_timeout")]
		public TimeDelta Dag_run_timeout { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_view")]
		public string Default_view { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="doc_md")]
		public string Doc_md { get; set; }
		
		/// <summary>
		/// The DAG's end date.
		///
		///*New in version 2.3.0*.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_date")]
		public System.Nullable<System.DateTimeOffset> End_date { get; set; }
		
		/// <summary>
		/// Whether the DAG is paused upon creation.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_paused_upon_creation")]
		public System.Nullable<System.Boolean> Is_paused_upon_creation { get; set; }
		
		/// <summary>
		/// The last time the DAG was parsed.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_parsed")]
		public System.Nullable<System.DateTimeOffset> Last_parsed { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="orientation")]
		public string Orientation { get; set; }
		
		/// <summary>
		/// User-specified DAG params.
		///
		///*New in version 2.0.1*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="params")]
		public string Params { get; set; }
		
		/// <summary>
		/// Whether to render templates as native Python objects.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="render_template_as_native_obj")]
		public System.Nullable<System.Boolean> Render_template_as_native_obj { get; set; }
		
		/// <summary>
		/// The DAG's start date.
		///
		///*Changed in version 2.0.1*&#58; Field becomes nullable.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_date")]
		public System.Nullable<System.DateTimeOffset> Start_date { get; set; }
		
		/// <summary>
		/// The template search path.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template_search_path")]
		public string[] Template_search_path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
	}
	
	/// <summary>
	/// Time delta
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeDelta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string @__type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="days")]
		public int Days { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="microseconds")]
		public int Microseconds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seconds")]
		public int Seconds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DAGRun
	{
		
		/// <summary>
		/// JSON object describing additional configuration parameters.
		///
		///The value of this field can be set only when creating the object. If you try to modify the
		///field of an existing object, the request fails with an BAD_REQUEST error.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conf")]
		public string Conf { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		/// <summary>
		/// Run ID.
		///
		///The value of this field can be set only when creating the object. If you try to modify the
		///field of an existing object, the request fails with an BAD_REQUEST error.
		///
		///If not provided, a value will be generated based on execution_date.
		///
		///If the specified dag_run_id is in use, the creation request fails with an ALREADY_EXISTS error.
		///
		///This together with DAG_ID are a unique key.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_run_id")]
		public string Dag_run_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="data_interval_end")]
		public System.Nullable<System.DateTimeOffset> Data_interval_end { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="data_interval_start")]
		public System.Nullable<System.DateTimeOffset> Data_interval_start { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="end_date")]
		public System.Nullable<System.DateTimeOffset> End_date { get; set; }
		
		/// <summary>
		/// The execution date. This is the same as logical_date, kept for backwards compatibility.
		///If both this field and logical_date are provided but with different values, the request
		///will fail with an BAD_REQUEST error.
		///
		///*Changed in version 2.2.0*&#58; Field becomes nullable.
		///
		///*Deprecated since version 2.2.0*&#58; Use 'logical_date' instead.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution_date")]
		public System.Nullable<System.DateTimeOffset> Execution_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="external_trigger")]
		public System.Nullable<System.Boolean> External_trigger { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_scheduling_decision")]
		public System.Nullable<System.DateTimeOffset> Last_scheduling_decision { get; set; }
		
		/// <summary>
		/// The logical date (previously called execution date). This is the time or interval covered by
		///this DAG run, according to the DAG definition.
		///
		///The value of this field can be set only when creating the object. If you try to modify the
		///field of an existing object, the request fails with an BAD_REQUEST error.
		///
		///This together with DAG_ID are a unique key.
		///
		///*New in version 2.2.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logical_date")]
		public System.Nullable<System.DateTimeOffset> Logical_date { get; set; }
		
		/// <summary>
		/// Contains manually entered notes by the user about the DagRun.
		///
		///*New in version 2.5.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="run_type")]
		public System.Nullable<DAGRunRun_type> Run_type { get; set; }
		
		/// <summary>
		/// The start time. The time when DAG run was actually created.
		///
		///*Changed in version 2.1.3*&#58; Field becomes nullable.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_date")]
		public System.Nullable<System.DateTimeOffset> Start_date { get; set; }
		
		/// <summary>
		/// DAG State.
		///
		///*Changed in version 2.1.3*&#58; 'queued' is added as a possible value.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public BasicDAGRunState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DAGRunRun_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backfill = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		manual = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		scheduled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dataset_triggered = 3,
	}
	
	/// <summary>
	/// Collection of DAG runs.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DAGRunCollection
	{
	}
	
	/// <summary>
	/// A datasets reference to a downstream DAG.
	///
	///*New in version 2.4.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DagScheduleDatasetReference
	{
		
		/// <summary>
		/// The dataset reference creation time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// The DAG ID that depends on the dataset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		/// <summary>
		/// The dataset reference update time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	/// <summary>
	/// DAG State.
	///
	///*Changed in version 2.1.3*&#58; 'queued' is added as a possible value.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DagState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DagWarning
	{
		
		/// <summary>
		/// The dag_id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		/// <summary>
		/// The message for the dag warning.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The time when this warning was logged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public string Timestamp { get; set; }
		
		/// <summary>
		/// The warning type for the dag warning.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning_type")]
		public string Warning_type { get; set; }
	}
	
	/// <summary>
	/// Collection of DAG warnings.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DagWarningCollection
	{
	}
	
	/// <summary>
	/// A dataset item.
	///
	///*New in version 2.4.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Dataset
	{
		
		[System.Runtime.Serialization.DataMember(Name="consuming_dags")]
		public DagScheduleDatasetReference[] Consuming_dags { get; set; }
		
		/// <summary>
		/// The dataset creation time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// The dataset extra
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extra")]
		public string Extra { get; set; }
		
		/// <summary>
		/// The dataset id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="producing_tasks")]
		public TaskOutletDatasetReference[] Producing_tasks { get; set; }
		
		/// <summary>
		/// The dataset update time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
		
		/// <summary>
		/// The dataset uri
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// A datasets reference to an upstream task.
	///
	///*New in version 2.4.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskOutletDatasetReference
	{
		
		/// <summary>
		/// The dataset creation time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// The DAG ID that updates the dataset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		/// <summary>
		/// The task ID that updates the dataset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="task_id")]
		public string Task_id { get; set; }
		
		/// <summary>
		/// The dataset update time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	/// <summary>
	/// A collection of datasets.
	///
	///*New in version 2.4.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DatasetCollection
	{
	}
	
	/// <summary>
	/// A dataset event.
	///
	///*New in version 2.4.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DatasetEvent
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_dagruns")]
		public BasicDAGRun[] Created_dagruns { get; set; }
		
		/// <summary>
		/// The dataset id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataset_id")]
		public System.Nullable<System.Int32> Dataset_id { get; set; }
		
		/// <summary>
		/// The URI of the dataset
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataset_uri")]
		public string Dataset_uri { get; set; }
		
		/// <summary>
		/// The dataset event extra
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extra")]
		public string Extra { get; set; }
		
		/// <summary>
		/// The DAG ID that updated the dataset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_dag_id")]
		public string Source_dag_id { get; set; }
		
		/// <summary>
		/// The task map index that updated the dataset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_map_index")]
		public System.Nullable<System.Int32> Source_map_index { get; set; }
		
		/// <summary>
		/// The DAG run ID that updated the dataset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_run_id")]
		public string Source_run_id { get; set; }
		
		/// <summary>
		/// The task ID that updated the dataset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_task_id")]
		public string Source_task_id { get; set; }
		
		/// <summary>
		/// The dataset event creation time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public string Timestamp { get; set; }
	}
	
	/// <summary>
	/// A collection of dataset events.
	///
	///*New in version 2.4.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DatasetEventCollection
	{
	}
	
	/// <summary>
	/// [RFC7807](https://tools.ietf.org/html/rfc7807) compliant response.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		/// <summary>
		/// A human-readable explanation specific to this occurrence of the problem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// A URI reference that identifies the specific occurrence of the problem. It may or may
		///not yield further information if dereferenced.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		/// <summary>
		/// The HTTP status code generated by the API server for this occurrence of the problem.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public double Status { get; set; }
		
		/// <summary>
		/// A short, human-readable summary of the problem type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// A URI reference [RFC3986] that identifies the problem type. This specification
		///encourages that, when dereferenced, it provide human-readable documentation for
		///the problem type.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Log of user operations via CLI or Web UI.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventLog
	{
		
		/// <summary>
		/// The DAG ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		/// <summary>
		/// A key describing the type of event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="event")]
		public string Event { get; set; }
		
		/// <summary>
		/// The event log ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="event_log_id")]
		public System.Nullable<System.Int32> Event_log_id { get; set; }
		
		/// <summary>
		/// When the event was dispatched for an object having execution_date, the value of this field.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution_date")]
		public System.Nullable<System.DateTimeOffset> Execution_date { get; set; }
		
		/// <summary>
		/// Other information that was not included in the other fields, e.g. the complete CLI command.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extra")]
		public string Extra { get; set; }
		
		/// <summary>
		/// Name of the user who triggered these events a.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public string Owner { get; set; }
		
		/// <summary>
		/// The DAG ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="task_id")]
		public string Task_id { get; set; }
		
		/// <summary>
		/// The time when these events happened.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="when")]
		public System.Nullable<System.DateTimeOffset> When { get; set; }
	}
	
	/// <summary>
	/// Collection of event logs.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventLogCollection
	{
	}
	
	/// <summary>
	/// Additional links containing additional information about the task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExtraLink
	{
		
		/// <summary>
		/// Class reference
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="class_ref")]
		public ClassReference Class_ref { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The collection of extra links.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExtraLinkCollection
	{
		
		[System.Runtime.Serialization.DataMember(Name="extra_links")]
		public ExtraLink[] Extra_links { get; set; }
	}
	
	/// <summary>
	/// Instance status information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthInfo
	{
		
		/// <summary>
		/// The status of the metadatabase.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadatabase")]
		public MetadatabaseStatus Metadatabase { get; set; }
		
		/// <summary>
		/// The status and the latest scheduler heartbeat.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduler")]
		public SchedulerStatus Scheduler { get; set; }
	}
	
	/// <summary>
	/// The status of the metadatabase.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetadatabaseStatus
	{
		
		/// <summary>
		/// Health status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<MetadatabaseStatusStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MetadatabaseStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		healthy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unhealthy = 1,
	}
	
	/// <summary>
	/// The status and the latest scheduler heartbeat.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SchedulerStatus
	{
		
		/// <summary>
		/// The time the scheduler last do a heartbeat.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latest_scheduler_heartbeat")]
		public string Latest_scheduler_heartbeat { get; set; }
		
		/// <summary>
		/// Health status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MetadatabaseStatusStatus Status { get; set; }
	}
	
	/// <summary>
	/// Health status
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HealthStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		healthy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unhealthy = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportError
	{
		
		/// <summary>
		/// The filename
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		/// <summary>
		/// The import error ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="import_error_id")]
		public System.Nullable<System.Int32> Import_error_id { get; set; }
		
		/// <summary>
		/// The full stackstrace..
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stack_trace")]
		public string Stack_trace { get; set; }
		
		/// <summary>
		/// The time when this error was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public string Timestamp { get; set; }
	}
	
	/// <summary>
	/// Collection of import errors.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportErrorCollection
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Job
	{
		
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="end_date")]
		public string End_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="executor_class")]
		public string Executor_class { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="job_type")]
		public string Job_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latest_heartbeat")]
		public string Latest_heartbeat { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start_date")]
		public string Start_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unixname")]
		public string Unixname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListDagRunsForm
	{
		
		/// <summary>
		/// Return objects with specific DAG IDs.
		///The value can be repeated to retrieve multiple matching values (OR condition).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_ids")]
		public string[] Dag_ids { get; set; }
		
		/// <summary>
		/// Returns objects greater or equal the specified date.
		///
		///This can be combined with end_date_lte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_date_gte")]
		public System.Nullable<System.DateTimeOffset> End_date_gte { get; set; }
		
		/// <summary>
		/// Returns objects less than or equal to the specified date.
		///
		///This can be combined with end_date_gte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_date_lte")]
		public System.Nullable<System.DateTimeOffset> End_date_lte { get; set; }
		
		/// <summary>
		/// Returns objects greater or equal to the specified date.
		///
		///This can be combined with execution_date_lte key to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution_date_gte")]
		public System.Nullable<System.DateTimeOffset> Execution_date_gte { get; set; }
		
		/// <summary>
		/// Returns objects less than or equal to the specified date.
		///
		///This can be combined with execution_date_gte key to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution_date_lte")]
		public System.Nullable<System.DateTimeOffset> Execution_date_lte { get; set; }
		
		/// <summary>
		/// The name of the field to order the results by. Prefix a field name
		///with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="order_by")]
		public string Order_by { get; set; }
		
		/// <summary>
		/// The numbers of items to return.
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page_limit")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Page_limit { get; set; }
		
		/// <summary>
		/// The number of items to skip before starting to collect the result set.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page_offset")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Page_offset { get; set; }
		
		/// <summary>
		/// Returns objects greater or equal the specified date.
		///
		///This can be combined with start_date_lte key to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_date_gte")]
		public System.Nullable<System.DateTimeOffset> Start_date_gte { get; set; }
		
		/// <summary>
		/// Returns objects less or equal the specified date.
		///
		///This can be combined with start_date_gte parameter to receive only the selected period
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_date_lte")]
		public System.Nullable<System.DateTimeOffset> Start_date_lte { get; set; }
		
		/// <summary>
		/// Return objects with specific states.
		///The value can be repeated to retrieve multiple matching values (OR condition).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="states")]
		public string[] States { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTaskInstanceForm
	{
		
		/// <summary>
		/// Return objects with specific DAG IDs.
		///The value can be repeated to retrieve multiple matching values (OR condition).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_ids")]
		public string[] Dag_ids { get; set; }
		
		/// <summary>
		/// Returns objects greater than or equal to the specified values.
		///
		///This can be combined with duration_lte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration_gte")]
		public System.Nullable<System.Double> Duration_gte { get; set; }
		
		/// <summary>
		/// Returns objects less than or equal to the specified values.
		///
		///This can be combined with duration_gte parameter to receive only the selected range.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration_lte")]
		public System.Nullable<System.Double> Duration_lte { get; set; }
		
		/// <summary>
		/// Returns objects greater or equal the specified date.
		///
		///This can be combined with start_date_lte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_date_gte")]
		public System.Nullable<System.DateTimeOffset> End_date_gte { get; set; }
		
		/// <summary>
		/// Returns objects less than or equal to the specified date.
		///
		///This can be combined with start_date_gte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_date_lte")]
		public System.Nullable<System.DateTimeOffset> End_date_lte { get; set; }
		
		/// <summary>
		/// Returns objects greater or equal to the specified date.
		///
		///This can be combined with execution_date_lte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution_date_gte")]
		public System.Nullable<System.DateTimeOffset> Execution_date_gte { get; set; }
		
		/// <summary>
		/// Returns objects less than or equal to the specified date.
		///
		///This can be combined with execution_date_gte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution_date_lte")]
		public System.Nullable<System.DateTimeOffset> Execution_date_lte { get; set; }
		
		/// <summary>
		/// The value can be repeated to retrieve multiple matching values (OR condition).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pool")]
		public string[] Pool { get; set; }
		
		/// <summary>
		/// The value can be repeated to retrieve multiple matching values (OR condition).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queue")]
		public string[] Queue { get; set; }
		
		/// <summary>
		/// Returns objects greater or equal the specified date.
		///
		///This can be combined with start_date_lte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_date_gte")]
		public System.Nullable<System.DateTimeOffset> Start_date_gte { get; set; }
		
		/// <summary>
		/// Returns objects less or equal the specified date.
		///
		///This can be combined with start_date_gte parameter to receive only the selected period.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_date_lte")]
		public System.Nullable<System.DateTimeOffset> Start_date_lte { get; set; }
		
		/// <summary>
		/// The value can be repeated to retrieve multiple matching values (OR condition).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public TaskState[] State { get; set; }
	}
	
	/// <summary>
	/// Task state.
	///
	///*Changed in version 2.0.2*&#58; 'removed' is added as a possible value.
	///
	///*Changed in version 2.2.0*&#58; 'deferred' is added as a possible value.
	///
	///*Changed in version 2.4.0*&#58; 'sensing' state has been removed.
	///*Changed in version 2.4.2*&#58; 'restarting' is added as a possible value
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TaskState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		upstream_failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		skipped = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		up_for_retry = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		up_for_reschedule = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		scheduled = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deferred = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		removed = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restarting = 12,
	}
	
	/// <summary>
	/// A collection of plugin.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PluginCollection
	{
	}
	
	/// <summary>
	/// A plugin Item.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PluginCollectionItem
	{
		
		/// <summary>
		/// The Flask Appbuilder menu items
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appbuilder_menu_items")]
		public string[] Appbuilder_menu_items { get; set; }
		
		/// <summary>
		/// The appuilder views
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appbuilder_views")]
		public string[] Appbuilder_views { get; set; }
		
		/// <summary>
		/// The plugin executors
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executors")]
		public string[] Executors { get; set; }
		
		/// <summary>
		/// The flask blueprints
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flask_blueprints")]
		public string[] Flask_blueprints { get; set; }
		
		/// <summary>
		/// The global operator extra links
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="global_operator_extra_links")]
		public string[] Global_operator_extra_links { get; set; }
		
		/// <summary>
		/// The plugin hooks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hooks")]
		public string[] Hooks { get; set; }
		
		/// <summary>
		/// The plugin macros
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macros")]
		public string[] Macros { get; set; }
		
		/// <summary>
		/// The name of the plugin
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Operator extra links
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operator_extra_links")]
		public string[] Operator_extra_links { get; set; }
		
		/// <summary>
		/// The plugin source
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	/// <summary>
	/// The pool
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pool
	{
		
		/// <summary>
		/// The description of the pool.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The number of slots used by running/queued tasks at the moment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="occupied_slots")]
		public System.Nullable<System.Int32> Occupied_slots { get; set; }
		
		/// <summary>
		/// The number of free slots at the moment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="open_slots")]
		public System.Nullable<System.Int32> Open_slots { get; set; }
		
		/// <summary>
		/// The number of slots used by queued tasks at the moment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queued_slots")]
		public System.Nullable<System.Int32> Queued_slots { get; set; }
		
		/// <summary>
		/// The maximum number of slots that can be assigned to tasks. One job may occupy one or more slots.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slots")]
		public System.Nullable<System.Int32> Slots { get; set; }
		
		/// <summary>
		/// The number of slots used by running tasks at the moment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="used_slots")]
		public System.Nullable<System.Int32> Used_slots { get; set; }
	}
	
	/// <summary>
	/// Collection of pools.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PoolCollection
	{
	}
	
	/// <summary>
	/// The provider
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Provider
	{
		
		/// <summary>
		/// The description of the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The package name of the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="package_name")]
		public string Package_name { get; set; }
		
		/// <summary>
		/// The version of the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Collection of providers.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProviderCollection
	{
		
		[System.Runtime.Serialization.DataMember(Name="providers")]
		public Provider[] Providers { get; set; }
	}
	
	/// <summary>
	/// Relative delta
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RelativeDelta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string @__type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="day")]
		public int Day { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="days")]
		public int Days { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hour")]
		public int Hour { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hours")]
		public int Hours { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="leapdays")]
		public int Leapdays { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="microsecond")]
		public int Microsecond { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="microseconds")]
		public int Microseconds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minute")]
		public int Minute { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minutes")]
		public int Minutes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="month")]
		public int Month { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="months")]
		public int Months { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="second")]
		public int Second { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seconds")]
		public int Seconds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public int Year { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="years")]
		public int Years { get; set; }
	}
	
	/// <summary>
	/// a role item.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Role
	{
		
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public ActionResource[] Actions { get; set; }
		
		/// <summary>
		/// The name of the role
		///
		///*Changed in version 2.3.0*&#58; A minimum character length requirement ('minLength') is added.
		///
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A collection of roles.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoleCollection
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SLAMiss
	{
		
		/// <summary>
		/// The DAG ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email_sent")]
		public System.Nullable<System.Boolean> Email_sent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="execution_date")]
		public string Execution_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notification_sent")]
		public System.Nullable<System.Boolean> Notification_sent { get; set; }
		
		/// <summary>
		/// The task ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="task_id")]
		public string Task_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public string Timestamp { get; set; }
	}
	
	/// <summary>
	/// Schedule interval. Defines how often DAG runs, this object gets added to your latest task instance's
	///execution_date to figure out the next schedule.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScheduleInterval
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetDagRunNote
	{
		
		/// <summary>
		/// Custom notes left by users for this Dag Run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetTaskInstanceNote
	{
		
		/// <summary>
		/// The custom note to set for this Task Instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
	}
	
	/// <summary>
	/// For details see:
	///[airflow.models.BaseOperator](https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/models/index.html#airflow.models.BaseOperator)
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Task_
	{
		
		/// <summary>
		/// Class reference
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="class_ref")]
		public ClassReference Class_ref { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="depends_on_past")]
		public System.Nullable<System.Boolean> Depends_on_past { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="downstream_task_ids")]
		public string[] Downstream_task_ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="end_date")]
		public System.Nullable<System.DateTimeOffset> End_date { get; set; }
		
		/// <summary>
		/// Time delta
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution_timeout")]
		public TimeDelta Execution_timeout { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="extra_links")]
		public Task_Extra_links[] Task_Extra_links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_mapped")]
		public System.Nullable<System.Boolean> Is_mapped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public string Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pool")]
		public string Pool { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pool_slots")]
		public System.Nullable<System.Double> Pool_slots { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priority_weight")]
		public System.Nullable<System.Double> Priority_weight { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="queue")]
		public string Queue { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public System.Nullable<System.Double> Retries { get; set; }
		
		/// <summary>
		/// Time delta
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retry_delay")]
		public TimeDelta Retry_delay { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="retry_exponential_backoff")]
		public System.Nullable<System.Boolean> Retry_exponential_backoff { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start_date")]
		public System.Nullable<System.DateTimeOffset> Start_date { get; set; }
		
		/// <summary>
		/// DAG
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sub_dag")]
		public DAG Sub_dag { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="task_id")]
		public string Task_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="template_fields")]
		public string[] Template_fields { get; set; }
		
		/// <summary>
		/// Trigger rule.
		///
		///*Changed in version 2.2.0*&#58; 'none_failed_min_one_success' is added as a possible value.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trigger_rule")]
		public System.Nullable<Task_Trigger_rule> Trigger_rule { get; set; }
		
		/// <summary>
		/// Color in hexadecimal notation.
		/// Pattern: ^#[a-fA-F0-9]{3,6}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ui_color")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^#[a-fA-F0-9]{3,6}$")]
		public string Ui_color { get; set; }
		
		/// <summary>
		/// Color in hexadecimal notation.
		/// Pattern: ^#[a-fA-F0-9]{3,6}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ui_fgcolor")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^#[a-fA-F0-9]{3,6}$")]
		public string Ui_fgcolor { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="wait_for_downstream")]
		public System.Nullable<System.Boolean> Wait_for_downstream { get; set; }
		
		/// <summary>
		/// Weight rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight_rule")]
		public System.Nullable<Task_Weight_rule> Weight_rule { get; set; }
	}
	
	public class Task_Extra_links
	{
		
		/// <summary>
		/// Class reference
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="class_ref")]
		public ClassReference Class_ref { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Task_Trigger_rule
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all_success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all_failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all_done = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		one_success = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		one_failed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none_failed = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none_skipped = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none_failed_or_skipped = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none_failed_min_one_success = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dummy = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum Task_Weight_rule
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		downstream = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		upstream = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		absolute = 2,
	}
	
	/// <summary>
	/// Collection of tasks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskCollection
	{
		
		[System.Runtime.Serialization.DataMember(Name="tasks")]
		public Task_[] Tasks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskInstance
	{
		
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		/// <summary>
		/// The DagRun ID for this task instance
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_run_id")]
		public string Dag_run_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Double> Duration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="end_date")]
		public string End_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="execution_date")]
		public string Execution_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="executor_config")]
		public string Executor_config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="map_index")]
		public System.Nullable<System.Int32> Map_index { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="max_tries")]
		public System.Nullable<System.Int32> Max_tries { get; set; }
		
		/// <summary>
		/// Contains manually entered notes by the user about the TaskInstance.
		///
		///*New in version 2.5.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// *Changed in version 2.1.1*&#58; Field becomes nullable.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operator")]
		public string Operator { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pid")]
		public System.Nullable<System.Int32> Pid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pool")]
		public string Pool { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pool_slots")]
		public System.Nullable<System.Int32> Pool_slots { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priority_weight")]
		public System.Nullable<System.Int32> Priority_weight { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="queue")]
		public string Queue { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="queued_when")]
		public string Queued_when { get; set; }
		
		/// <summary>
		/// JSON object describing rendered fields.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rendered_fields")]
		public string Rendered_fields { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sla_miss")]
		public SLAMiss Sla_miss { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start_date")]
		public string Start_date { get; set; }
		
		/// <summary>
		/// Task state.
		///
		///*Changed in version 2.0.2*&#58; 'removed' is added as a possible value.
		///
		///*Changed in version 2.2.0*&#58; 'deferred' is added as a possible value.
		///
		///*Changed in version 2.4.0*&#58; 'sensing' state has been removed.
		///*Changed in version 2.4.2*&#58; 'restarting' is added as a possible value
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public TaskState State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="task_id")]
		public string Task_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trigger")]
		public Trigger Trigger { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triggerer_job")]
		public Job Triggerer_job { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="try_number")]
		public System.Nullable<System.Int32> Try_number { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unixname")]
		public string Unixname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trigger
	{
		
		[System.Runtime.Serialization.DataMember(Name="classpath")]
		public string Classpath { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_date")]
		public string Created_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kwargs")]
		public string Kwargs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="triggerer_id")]
		public System.Nullable<System.Int32> Triggerer_id { get; set; }
	}
	
	/// <summary>
	/// Collection of task instances.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskInstanceCollection
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskInstanceReference
	{
		
		/// <summary>
		/// The DAG ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		/// <summary>
		/// The DAG run ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_run_id")]
		public string Dag_run_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="execution_date")]
		public string Execution_date { get; set; }
		
		/// <summary>
		/// The task ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="task_id")]
		public string Task_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskInstanceReferenceCollection
	{
		
		[System.Runtime.Serialization.DataMember(Name="task_instances")]
		public TaskInstanceReference[] Task_instances { get; set; }
	}
	
	/// <summary>
	/// Trigger rule.
	///
	///*Changed in version 2.2.0*&#58; 'none_failed_min_one_success' is added as a possible value.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TriggerRule
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all_success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all_failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all_done = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		one_success = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		one_failed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none_failed = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none_skipped = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none_failed_or_skipped = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none_failed_min_one_success = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dummy = 9,
	}
	
	/// <summary>
	/// Modify the state of a DAG run.
	///
	///*New in version 2.2.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateDagRunState
	{
		
		/// <summary>
		/// The state to set this DagRun
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<UpdateDagRunStateState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UpdateDagRunStateState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTaskInstance
	{
		
		/// <summary>
		/// If set, don't actually run this operation. The response will contain the task instance
		///planned to be affected, but won't be modified in any way.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dry_run")]
		public System.Nullable<System.Boolean> Dry_run { get; set; }
		
		/// <summary>
		/// Expected new state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="new_state")]
		public System.Nullable<UpdateTaskInstanceNew_state> New_state { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UpdateTaskInstanceNew_state
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTaskInstancesState
	{
		
		/// <summary>
		/// The task instance's DAG run ID. Either set this or execution_date but not both.
		///
		///*New in version 2.3.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dag_run_id")]
		public string Dag_run_id { get; set; }
		
		/// <summary>
		/// If set, don't actually run this operation. The response will contain a list of task instances
		///planned to be affected, but won't be modified in any way.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dry_run")]
		public System.Nullable<System.Boolean> Dry_run { get; set; }
		
		/// <summary>
		/// The execution date. Either set this or dag_run_id but not both.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution_date")]
		public string Execution_date { get; set; }
		
		/// <summary>
		/// If set to true, downstream tasks are also affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_downstream")]
		public System.Nullable<System.Boolean> Include_downstream { get; set; }
		
		/// <summary>
		/// If set to True, also tasks from future DAG Runs are affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_future")]
		public System.Nullable<System.Boolean> Include_future { get; set; }
		
		/// <summary>
		/// If set to True, also tasks from past DAG Runs are affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_past")]
		public System.Nullable<System.Boolean> Include_past { get; set; }
		
		/// <summary>
		/// If set to true, upstream tasks are also affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include_upstream")]
		public System.Nullable<System.Boolean> Include_upstream { get; set; }
		
		/// <summary>
		/// Expected new state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="new_state")]
		public UpdateTaskInstanceNew_state New_state { get; set; }
		
		/// <summary>
		/// The task ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="task_id")]
		public string Task_id { get; set; }
	}
	
	/// <summary>
	/// A user object with sensitive data.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User
	{
	}
	
	/// <summary>
	/// Collection of users.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserCollection
	{
	}
	
	/// <summary>
	/// A user object.
	///
	///*New in version 2.1.0*
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserCollectionItem
	{
		
		/// <summary>
		/// Whether the user is active
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The date user was changed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="changed_on")]
		public string Changed_on { get; set; }
		
		/// <summary>
		/// The date user was created
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_on")]
		public string Created_on { get; set; }
		
		/// <summary>
		/// The user's email.
		///
		///*Changed in version 2.2.0*&#58; A minimum character length requirement ('minLength') is added.
		///
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Email { get; set; }
		
		/// <summary>
		/// The number of times the login failed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failed_login_count")]
		public System.Nullable<System.Int32> Failed_login_count { get; set; }
		
		/// <summary>
		/// The user's first name.
		///
		///*Changed in version 2.4.0*&#58; The requirement for this to be non-empty was removed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first_name")]
		public string First_name { get; set; }
		
		/// <summary>
		/// The last user login
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_login")]
		public string Last_login { get; set; }
		
		/// <summary>
		/// The user's last name.
		///
		///*Changed in version 2.4.0*&#58; The requirement for this to be non-empty was removed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_name")]
		public string Last_name { get; set; }
		
		/// <summary>
		/// The login count
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="login_count")]
		public System.Nullable<System.Int32> Login_count { get; set; }
		
		/// <summary>
		/// User roles.
		///
		///*Changed in version 2.2.0*&#58; Field is no longer read-only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public UserCollectionItemRoles[] UserCollectionItemRoles { get; set; }
		
		/// <summary>
		/// The username.
		///
		///*Changed in version 2.2.0*&#58; A minimum character length requirement ('minLength') is added.
		///
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Username { get; set; }
	}
	
	public class UserCollectionItemRoles
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Full representation of Variable
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Variable : VariableCollectionItem
	{
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Collection of variables.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VariableCollection
	{
	}
	
	/// <summary>
	/// XCom entry collection item.
	///The value field are only available when retrieving a single object due to the sensitivity of this data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VariableCollectionItem
	{
		
		/// <summary>
		/// The description of the variable.
		///
		///*New in version 2.4.0*
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
	}
	
	/// <summary>
	/// Version information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VersionInfo
	{
		
		/// <summary>
		/// The git version (including git commit hash)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="git_version")]
		public string Git_version { get; set; }
		
		/// <summary>
		/// The version of Airflow
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Weight rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum WeightRule
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		downstream = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		upstream = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		absolute = 2,
	}
	
	/// <summary>
	/// Full representations of XCom entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class XCom : XComCollectionItem
	{
		
		/// <summary>
		/// The value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Collection of XCom entries.
	///
	///*Changed in version 2.1.0*&#58; 'total_entries' field is added.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class XComCollection
	{
	}
	
	/// <summary>
	/// XCom entry collection item.
	///
	///The value field is only available when reading a single object due to the size of the value.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class XComCollectionItem
	{
		
		[System.Runtime.Serialization.DataMember(Name="dag_id")]
		public string Dag_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="execution_date")]
		public string Execution_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="task_id")]
		public string Task_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public string Timestamp { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get current configuration
		/// Get_config config
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Config> Get_configAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Config>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List connections
		/// Get_connections connections
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<ConnectionCollection> Get_connectionsAsync(int limit, int offset, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "connections?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ConnectionCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a connection
		/// Post_connection connections
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Connection> Post_connectionAsync(Connection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "connections";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Connection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Test a connection
		/// Test a connection.
		/// 
		/// *New in version 2.2.0*
		/// 
		/// Test_connection connections/test
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<ConnectionTest> Test_connectionAsync(Connection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "connections/test";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ConnectionTest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a connection
		/// Delete_connection connections/{connection_id}
		/// </summary>
		public async Task Delete_connectionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "connections/{connection_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a connection
		/// Get_connection connections/{connection_id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Connection> Get_connectionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "connections/{connection_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Connection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a connection
		/// Patch_connection connections/{connection_id}
		/// </summary>
		/// <param name="update_mask">The fields to update on the resource. If absent or empty, all modifiable fields are updated.
		///A comma-separated list of fully qualified names of fields.
		///</param>
		/// <returns>Success.</returns>
		public async Task<Connection> Patch_connectionAsync(string[] update_mask, Connection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "connections/{connection_id}?"+string.Join("&", update_mask.Select(z => $"update_mask={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Connection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a source code
		/// Get a source code using file token.
		/// 
		/// Get_dag_source dagSources/{file_token}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Get_dag_sourceReturn> Get_dag_sourceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dagSources/{file_token}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Get_dag_sourceReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List dag warnings
		/// Get_dag_warnings dagWarnings
		/// </summary>
		/// <param name="dag_id">If set, only return DAG warnings with this dag_id.</param>
		/// <param name="warning_type">If set, only return DAG warnings with this type.</param>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<DagWarningCollection> Get_dag_warningsAsync(string dag_id, string warning_type, int limit, int offset, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dagWarnings?dag_id=" + (dag_id==null? "" : System.Uri.EscapeDataString(dag_id))+"&warning_type=" + (warning_type==null? "" : System.Uri.EscapeDataString(warning_type))+"&limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DagWarningCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List DAGs
		/// List DAGs in the database.
		/// `dag_id_pattern` can be set to match dags of a specific pattern
		/// 
		/// Get_dags dags
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <param name="tags">List of tags to filter results.
		///
		///*New in version 2.2.0*
		///</param>
		/// <param name="only_active">Only filter active DAGs.
		///
		///*New in version 2.1.1*
		///</param>
		/// <param name="dag_id_pattern">If set, only return DAGs with dag_ids matching this pattern.
		///</param>
		/// <returns>Success.</returns>
		public async Task<DAGCollection> Get_dagsAsync(int limit, int offset, string order_by, string[] tags, bool only_active, string dag_id_pattern, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&only_active="+only_active+"&dag_id_pattern=" + (dag_id_pattern==null? "" : System.Uri.EscapeDataString(dag_id_pattern));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update DAGs
		/// Update DAGs of a given dag_id_pattern using UpdateMask.
		/// This endpoint allows specifying `~` as the dag_id_pattern to update all DAGs.
		/// *New in version 2.3.0*
		/// 
		/// Patch_dags dags
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="tags">List of tags to filter results.
		///
		///*New in version 2.2.0*
		///</param>
		/// <param name="update_mask">The fields to update on the resource. If absent or empty, all modifiable fields are updated.
		///A comma-separated list of fully qualified names of fields.
		///</param>
		/// <param name="only_active">Only filter active DAGs.
		///
		///*New in version 2.1.1*
		///</param>
		/// <param name="dag_id_pattern">If set, only update DAGs with dag_ids matching this pattern.
		///</param>
		/// <returns>Success.</returns>
		public async Task<DAGCollection> Patch_dagsAsync(int limit, int offset, string[] tags, string[] update_mask, bool only_active, string dag_id_pattern, DAG requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags?limit="+limit+"&offset="+offset+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", update_mask.Select(z => $"update_mask={System.Uri.EscapeDataString(z.ToString())}"))+"&only_active="+only_active+"&dag_id_pattern=" + (dag_id_pattern==null? "" : System.Uri.EscapeDataString(dag_id_pattern));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a DAG
		/// Deletes all metadata related to the DAG, including finished DAG Runs and Tasks.
		/// Logs are not deleted. This action cannot be undone.
		/// 
		/// *New in version 2.2.0*
		/// 
		/// Delete_dag dags/{dag_id}
		/// </summary>
		public async Task Delete_dagAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get basic information about a DAG
		/// Presents only information available in database (DAGModel).
		/// If you need detailed information, consider using GET /dags/{dag_id}/details.
		/// 
		/// Get_dag dags/{dag_id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DAG> Get_dagAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAG>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a DAG
		/// Patch_dag dags/{dag_id}
		/// </summary>
		/// <param name="update_mask">The fields to update on the resource. If absent or empty, all modifiable fields are updated.
		///A comma-separated list of fully qualified names of fields.
		///</param>
		/// <returns>Success.</returns>
		public async Task<DAG> Patch_dagAsync(string[] update_mask, DAG requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}?"+string.Join("&", update_mask.Select(z => $"update_mask={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAG>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Clear a set of task instances
		/// Clears a set of task instances associated with the DAG for a specified date range.
		/// 
		/// Post_clear_task_instances dags/{dag_id}/clearTaskInstances
		/// </summary>
		/// <param name="requestBody">Parameters of action</param>
		/// <returns>Success.</returns>
		public async Task<TaskInstanceReferenceCollection> Post_clear_task_instancesAsync(ClearTaskInstances requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/clearTaskInstances";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstanceReferenceCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List DAG runs
		/// This endpoint allows specifying `~` as the dag_id to retrieve DAG runs for all DAGs.
		/// 
		/// Get_dag_runs dags/{dag_id}/dagRuns
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="execution_date_gte">Returns objects greater or equal to the specified date.
		///
		///This can be combined with execution_date_lte parameter to receive only the selected period.
		///</param>
		/// <param name="execution_date_lte">Returns objects less than or equal to the specified date.
		///
		///This can be combined with execution_date_gte parameter to receive only the selected period.
		///</param>
		/// <param name="start_date_gte">Returns objects greater or equal the specified date.
		///
		///This can be combined with start_date_lte parameter to receive only the selected period.
		///</param>
		/// <param name="start_date_lte">Returns objects less or equal the specified date.
		///
		///This can be combined with start_date_gte parameter to receive only the selected period.
		///</param>
		/// <param name="end_date_gte">Returns objects greater or equal the specified date.
		///
		///This can be combined with start_date_lte parameter to receive only the selected period.
		///</param>
		/// <param name="end_date_lte">Returns objects less than or equal to the specified date.
		///
		///This can be combined with start_date_gte parameter to receive only the selected period.
		///</param>
		/// <param name="state">The value can be repeated to retrieve multiple matching values (OR condition).</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>List of DAG runs.</returns>
		public async Task<DAGRunCollection> Get_dag_runsAsync(int limit, int offset, System.DateTimeOffset execution_date_gte, System.DateTimeOffset execution_date_lte, System.DateTimeOffset start_date_gte, System.DateTimeOffset start_date_lte, System.DateTimeOffset end_date_gte, System.DateTimeOffset end_date_lte, string[] state, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns?limit="+limit+"&offset="+offset+"&execution_date_gte=" + execution_date_gte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&execution_date_lte=" + execution_date_lte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&start_date_gte=" + start_date_gte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&start_date_lte=" + start_date_lte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&end_date_gte=" + end_date_gte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&end_date_lte=" + end_date_lte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&"+string.Join("&", state.Select(z => $"state={System.Uri.EscapeDataString(z.ToString())}"))+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGRunCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Trigger a new DAG run
		/// Post_dag_run dags/{dag_id}/dagRuns
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DAGRun> Post_dag_runAsync(DAGRun requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGRun>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a DAG run
		/// Delete_dag_run dags/{dag_id}/dagRuns/{dag_run_id}
		/// </summary>
		public async Task Delete_dag_runAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a DAG run
		/// Get_dag_run dags/{dag_id}/dagRuns/{dag_run_id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DAGRun> Get_dag_runAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGRun>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify a DAG run
		/// Modify a DAG run.
		/// 
		/// *New in version 2.2.0*
		/// 
		/// Update_dag_run_state dags/{dag_id}/dagRuns/{dag_run_id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DAGRun> Update_dag_run_stateAsync(UpdateDagRunState requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGRun>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Clear a DAG run
		/// Clear a DAG run.
		/// 
		/// *New in version 2.4.0*
		/// 
		/// Clear_dag_run dags/{dag_id}/dagRuns/{dag_run_id}/clear
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DAGRun> Clear_dag_runAsync(ClearDagRun requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/clear";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGRun>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update the DagRun note.
		/// Update the manual user note of a DagRun.
		/// 
		/// *New in version 2.5.0*
		/// 
		/// Set_dag_run_note dags/{dag_id}/dagRuns/{dag_run_id}/setNote
		/// </summary>
		/// <param name="requestBody">Parameters of set DagRun note.</param>
		/// <returns>Success.</returns>
		public async Task<DAGRun> Set_dag_run_noteAsync(SetDagRunNote requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/setNote";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGRun>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List task instances
		/// This endpoint allows specifying `~` as the dag_id, dag_run_id to retrieve DAG runs for all DAGs and DAG runs.
		/// 
		/// Get_task_instances dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <returns>Success.</returns>
		public async Task<TaskInstanceCollection> Get_task_instancesAsync(int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstanceCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a task instance
		/// Get_task_instance dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<TaskInstance> Get_task_instanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstance>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the state of a task instance
		/// Updates the state for single task instance.
		/// *New in version 2.5.0*
		/// 
		/// Patch_task_instance dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}
		/// </summary>
		/// <param name="requestBody">Parameters of action</param>
		/// <returns>Success.</returns>
		public async Task<TaskInstanceReference> Patch_task_instanceAsync(UpdateTaskInstance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstanceReference>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List extra links
		/// List extra links for task instance.
		/// 
		/// Get_extra_links dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/links
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<ExtraLinkCollection> Get_extra_linksAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/links";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExtraLinkCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List mapped task instances
		/// Get details of all mapped task instances.
		/// 
		/// *New in version 2.3.0*
		/// 
		/// Get_mapped_task_instances dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/listMapped
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="execution_date_gte">Returns objects greater or equal to the specified date.
		///
		///This can be combined with execution_date_lte parameter to receive only the selected period.
		///</param>
		/// <param name="execution_date_lte">Returns objects less than or equal to the specified date.
		///
		///This can be combined with execution_date_gte parameter to receive only the selected period.
		///</param>
		/// <param name="start_date_gte">Returns objects greater or equal the specified date.
		///
		///This can be combined with start_date_lte parameter to receive only the selected period.
		///</param>
		/// <param name="start_date_lte">Returns objects less or equal the specified date.
		///
		///This can be combined with start_date_gte parameter to receive only the selected period.
		///</param>
		/// <param name="end_date_gte">Returns objects greater or equal the specified date.
		///
		///This can be combined with start_date_lte parameter to receive only the selected period.
		///</param>
		/// <param name="end_date_lte">Returns objects less than or equal to the specified date.
		///
		///This can be combined with start_date_gte parameter to receive only the selected period.
		///</param>
		/// <param name="duration_gte">Returns objects greater than or equal to the specified values.
		///
		///This can be combined with duration_lte parameter to receive only the selected period.
		///</param>
		/// <param name="duration_lte">Returns objects less than or equal to the specified values.
		///
		///This can be combined with duration_gte parameter to receive only the selected range.
		///</param>
		/// <param name="state">The value can be repeated to retrieve multiple matching values (OR condition).</param>
		/// <param name="pool">The value can be repeated to retrieve multiple matching values (OR condition).</param>
		/// <param name="queue">The value can be repeated to retrieve multiple matching values (OR condition).</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<TaskInstanceCollection> Get_mapped_task_instancesAsync(int limit, int offset, System.DateTimeOffset execution_date_gte, System.DateTimeOffset execution_date_lte, System.DateTimeOffset start_date_gte, System.DateTimeOffset start_date_lte, System.DateTimeOffset end_date_gte, System.DateTimeOffset end_date_lte, double duration_gte, double duration_lte, string[] state, string[] pool, string[] queue, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/listMapped?limit="+limit+"&offset="+offset+"&execution_date_gte=" + execution_date_gte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&execution_date_lte=" + execution_date_lte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&start_date_gte=" + start_date_gte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&start_date_lte=" + start_date_lte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&end_date_gte=" + end_date_gte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&end_date_lte=" + end_date_lte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&duration_gte="+duration_gte+"&duration_lte="+duration_lte+"&"+string.Join("&", state.Select(z => $"state={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", pool.Select(z => $"pool={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", queue.Select(z => $"queue={System.Uri.EscapeDataString(z.ToString())}"))+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstanceCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get logs
		/// Get logs for a specific task instance and its try number.
		/// Get_log dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/logs/{task_try_number}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Get_logReturn> Get_logAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/logs/{task_try_number}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Get_logReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the TaskInstance note.
		/// Update the manual user note of a non-mapped Task Instance.
		/// 
		/// *New in version 2.5.0*
		/// 
		/// Set_task_instance_note dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/setNote
		/// </summary>
		/// <param name="requestBody">Parameters of set Task Instance note.</param>
		/// <returns>Success.</returns>
		public async Task<TaskInstance> Set_task_instance_noteAsync(SetTaskInstanceNote requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/setNote";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstance>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List XCom entries
		/// This endpoint allows specifying `~` as the dag_id, dag_run_id, task_id to retrieve XCOM entries for for all DAGs, DAG runs and task instances. XCom values won't be returned as they can be large. Use this endpoint to get a list of XCom entries and then fetch individual entry to get value.
		/// Get_xcom_entries dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <returns>Success.</returns>
		public async Task<XComCollection> Get_xcom_entriesAsync(int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<XComCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an XCom entry
		/// Get_xcom_entry dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{xcom_key}
		/// </summary>
		/// <param name="deserialize">Whether to deserialize an XCom value when using a custom XCom backend.
		///
		///The XCom API endpoint calls `orm_deserialize_value` by default since an XCom may contain value
		///that is potentially expensive to deserialize in the web server. Setting this to true overrides
		///the consideration, and calls `deserialize_value` instead.
		///
		///This parameter is not meaningful when using the default XCom backend.
		///
		///*New in version 2.4.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<XCom> Get_xcom_entryAsync(bool deserialize, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{xcom_key}?deserialize="+deserialize;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<XCom>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a mapped task instance
		/// Get details of a mapped task instance.
		/// 
		/// *New in version 2.3.0*
		/// 
		/// Get_mapped_task_instance dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<TaskInstance> Get_mapped_task_instanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstance>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the state of a mapped task instance
		/// Updates the state for single mapped task instance.
		/// *New in version 2.5.0*
		/// 
		/// Patch_mapped_task_instance dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}
		/// </summary>
		/// <param name="requestBody">Parameters of action</param>
		/// <returns>Success.</returns>
		public async Task<TaskInstanceReference> Patch_mapped_task_instanceAsync(UpdateTaskInstance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstanceReference>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update the TaskInstance note.
		/// Update the manual user note of a mapped Task Instance.
		/// 
		/// *New in version 2.5.0*
		/// 
		/// Set_mapped_task_instance_note dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}/setNote
		/// </summary>
		/// <param name="requestBody">Parameters of set Task Instance note.</param>
		/// <returns>Success.</returns>
		public async Task<TaskInstance> Set_mapped_task_instance_noteAsync(SetTaskInstanceNote requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}/setNote";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstance>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get dataset events for a DAG run
		/// Get datasets for a dag run.
		/// 
		/// *New in version 2.4.0*
		/// 
		/// Get_upstream_dataset_events dags/{dag_id}/dagRuns/{dag_run_id}/upstreamDatasetEvents
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DatasetEventCollection> Get_upstream_dataset_eventsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/dagRuns/{dag_run_id}/upstreamDatasetEvents";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DatasetEventCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a simplified representation of DAG
		/// The response contains many DAG attributes, so the response can be large. If possible, consider using GET /dags/{dag_id}.
		/// 
		/// Get_dag_details dags/{dag_id}/details
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DAGDetail> Get_dag_detailsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/details";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get tasks for DAG
		/// Get_tasks dags/{dag_id}/tasks
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<TaskCollection> Get_tasksAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/tasks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get simplified representation of a task
		/// Get_task dags/{dag_id}/tasks/{task_id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Task_> Get_taskAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/tasks/{task_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Task_>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set a state of task instances
		/// Updates the state for multiple task instances simultaneously.
		/// 
		/// Post_set_task_instances_state dags/{dag_id}/updateTaskInstancesState
		/// </summary>
		/// <param name="requestBody">Parameters of action</param>
		/// <returns>Success.</returns>
		public async Task<TaskInstanceReferenceCollection> Post_set_task_instances_stateAsync(UpdateTaskInstancesState requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/{dag_id}/updateTaskInstancesState";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstanceReferenceCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List DAG runs (batch)
		/// This endpoint is a POST to allow filtering across a large number of DAG IDs, where as a GET it would run in to maximum HTTP request URL length limit.
		/// 
		/// Get_dag_runs_batch dags/~/dagRuns/list
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DAGRunCollection> Get_dag_runs_batchAsync(ListDagRunsForm requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/~/dagRuns/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DAGRunCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List task instances (batch)
		/// List task instances from all DAGs and DAG runs.
		/// This endpoint is a POST to allow filtering across a large number of DAG IDs, where as a GET it would run in to maximum HTTP request URL length limits.
		/// 
		/// Get_task_instances_batch dags/~/dagRuns/~/taskInstances/list
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<TaskInstanceCollection> Get_task_instances_batchAsync(ListTaskInstanceForm requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "dags/~/dagRuns/~/taskInstances/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskInstanceCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List datasets
		/// Get_datasets datasets
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <param name="uri_pattern">If set, only return datasets with uris matching this pattern.
		///</param>
		/// <returns>Success.</returns>
		public async Task<DatasetCollection> Get_datasetsAsync(int limit, int offset, string order_by, string uri_pattern, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "datasets?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by))+"&uri_pattern=" + (uri_pattern==null? "" : System.Uri.EscapeDataString(uri_pattern));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DatasetCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get dataset events
		/// Get dataset events
		/// Get_dataset_events datasets/events
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<DatasetEventCollection> Get_dataset_eventsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "datasets/events";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DatasetEventCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a dataset
		/// Get a dataset by uri.
		/// Get_dataset datasets/{uri}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Dataset> Get_datasetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "datasets/{uri}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Dataset>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List log entries
		/// List log entries from event log.
		/// Get_event_logs eventLogs
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<EventLogCollection> Get_event_logsAsync(int limit, int offset, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "eventLogs?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventLogCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a log entry
		/// Get_event_log eventLogs/{event_log_id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<EventLog> Get_event_logAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "eventLogs/{event_log_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventLog>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get instance status
		/// Get the status of Airflow's metadatabase and scheduler. It includes info about
		/// metadatabase and last heartbeat of scheduler.
		/// 
		/// Get_health health
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<HealthInfo> Get_healthAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List import errors
		/// Get_import_errors importErrors
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<ImportErrorCollection> Get_import_errorsAsync(int limit, int offset, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "importErrors?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImportErrorCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an import error
		/// Get_import_error importErrors/{import_error_id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<ImportError> Get_import_errorAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "importErrors/{import_error_id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImportError>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List permissions
		/// Get a list of permissions.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Get_permissions permissions
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <returns>Success.</returns>
		public async Task<ActionCollection> Get_permissionsAsync(int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "permissions?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of loaded plugins
		/// Get a list of loaded plugins.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Get_plugins plugins
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <returns>Success</returns>
		public async Task<PluginCollection> Get_pluginsAsync(int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "plugins?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PluginCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List pools
		/// Get_pools pools
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>List of pools.</returns>
		public async Task<PoolCollection> Get_poolsAsync(int limit, int offset, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pools?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PoolCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a pool
		/// Post_pool pools
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Pool> Post_poolAsync(Pool requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pools";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pool>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a pool
		/// Delete_pool pools/{pool_name}
		/// </summary>
		public async Task Delete_poolAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pools/{pool_name}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a pool
		/// Get_pool pools/{pool_name}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Pool> Get_poolAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pools/{pool_name}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pool>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a pool
		/// Patch_pool pools/{pool_name}
		/// </summary>
		/// <param name="update_mask">The fields to update on the resource. If absent or empty, all modifiable fields are updated.
		///A comma-separated list of fully qualified names of fields.
		///</param>
		/// <returns>Success.</returns>
		public async Task<Pool> Patch_poolAsync(string[] update_mask, Pool requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pools/{pool_name}?"+string.Join("&", update_mask.Select(z => $"update_mask={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Pool>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List providers
		/// Get a list of providers.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Get_providers providers
		/// </summary>
		/// <returns>List of providers.</returns>
		public async Task<ProviderCollection> Get_providersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "providers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProviderCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List roles
		/// Get a list of roles.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Get_roles roles
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<RoleCollection> Get_rolesAsync(int limit, int offset, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "roles?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RoleCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a role
		/// Create a new role.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Post_role roles
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Role> Post_roleAsync(Role requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "roles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Role>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a role
		/// Delete a role.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Delete_role roles/{role_name}
		/// </summary>
		public async Task Delete_roleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "roles/{role_name}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a role
		/// Get a role.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Get_role roles/{role_name}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Role> Get_roleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "roles/{role_name}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Role>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a role
		/// Update a role.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Patch_role roles/{role_name}
		/// </summary>
		/// <param name="update_mask">The fields to update on the resource. If absent or empty, all modifiable fields are updated.
		///A comma-separated list of fully qualified names of fields.
		///</param>
		/// <returns>Success.</returns>
		public async Task<Role> Patch_roleAsync(string[] update_mask, Role requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "roles/{role_name}?"+string.Join("&", update_mask.Select(z => $"update_mask={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Role>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List users
		/// Get a list of users.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Get_users users
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<UserCollection> Get_usersAsync(int limit, int offset, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a user
		/// Create a new user with unique username and email.
		/// 
		/// *New in version 2.2.0*
		/// 
		/// Post_user users
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<User> Post_userAsync(User requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a user
		/// Delete a user with a specific username.
		/// 
		/// *New in version 2.2.0*
		/// 
		/// Delete_user users/{username}
		/// </summary>
		public async Task Delete_userAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/{username}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a user
		/// Get a user with a specific username.
		/// 
		/// *New in version 2.1.0*
		/// 
		/// Get_user users/{username}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<UserCollectionItem> Get_userAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/{username}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserCollectionItem>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a user
		/// Update fields for a user.
		/// 
		/// *New in version 2.2.0*
		/// 
		/// Patch_user users/{username}
		/// </summary>
		/// <param name="update_mask">The fields to update on the resource. If absent or empty, all modifiable fields are updated.
		///A comma-separated list of fully qualified names of fields.
		///</param>
		/// <returns>Success.</returns>
		public async Task<UserCollectionItem> Patch_userAsync(string[] update_mask, User requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/{username}?"+string.Join("&", update_mask.Select(z => $"update_mask={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UserCollectionItem>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List variables
		/// The collection does not contain data. To get data, you must get a single entity.
		/// Get_variables variables
		/// </summary>
		/// <param name="limit">The numbers of items to return.</param>
		/// <param name="offset">The number of items to skip before starting to collect the result set.</param>
		/// <param name="order_by">The name of the field to order the results by.
		///Prefix a field name with `-` to reverse the sort order.
		///
		///*New in version 2.1.0*
		///</param>
		/// <returns>Success.</returns>
		public async Task<VariableCollection> Get_variablesAsync(int limit, int offset, string order_by, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variables?limit="+limit+"&offset="+offset+"&order_by=" + (order_by==null? "" : System.Uri.EscapeDataString(order_by));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VariableCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a variable
		/// Post_variables variables
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Variable> Post_variablesAsync(Variable requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variables";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Variable>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a variable
		/// Delete_variable variables/{variable_key}
		/// </summary>
		public async Task Delete_variableAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variables/{variable_key}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a variable
		/// Get a variable by key.
		/// Get_variable variables/{variable_key}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Variable> Get_variableAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variables/{variable_key}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Variable>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a variable
		/// Update a variable by key.
		/// Patch_variable variables/{variable_key}
		/// </summary>
		/// <param name="update_mask">The fields to update on the resource. If absent or empty, all modifiable fields are updated.
		///A comma-separated list of fully qualified names of fields.
		///</param>
		/// <returns>Success.</returns>
		public async Task<Variable> Patch_variableAsync(string[] update_mask, Variable requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variables/{variable_key}?"+string.Join("&", update_mask.Select(z => $"update_mask={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Variable>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get version information
		/// Get_version version
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<VersionInfo> Get_versionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VersionInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class Get_dag_sourceReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
	}
	
	public class Get_logReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="continuation_token")]
		public string Continuation_token { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
