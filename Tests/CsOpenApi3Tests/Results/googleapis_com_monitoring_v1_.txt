//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aggregation
	{
		
		/// <summary>
		/// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alignmentPeriod")]
		public string AlignmentPeriod { get; set; }
		
		/// <summary>
		/// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="crossSeriesReducer")]
		public System.Nullable<AggregationCrossSeriesReducer> CrossSeriesReducer { get; set; }
		
		/// <summary>
		/// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupByFields")]
		public string[] GroupByFields { get; set; }
		
		/// <summary>
		/// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perSeriesAligner")]
		public System.Nullable<AggregationPerSeriesAligner> PerSeriesAligner { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AggregationCrossSeriesReducer
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_MEAN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_MIN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_MAX = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_SUM = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_STDDEV = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_COUNT = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_COUNT_TRUE = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_COUNT_FALSE = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_FRACTION_TRUE = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_PERCENTILE_99 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_PERCENTILE_95 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_PERCENTILE_50 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REDUCE_PERCENTILE_05 = 13,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AggregationPerSeriesAligner
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_DELTA = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_RATE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_INTERPOLATE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_NEXT_OLDER = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_MIN = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_MAX = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_MEAN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_COUNT = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_SUM = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_STDDEV = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_COUNT_TRUE = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_COUNT_FALSE = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_FRACTION_TRUE = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_PERCENTILE_99 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_PERCENTILE_95 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_PERCENTILE_50 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_PERCENTILE_05 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALIGN_PERCENT_CHANGE = 18,
	}
	
	/// <summary>
	/// Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AggregationFunction
	{
		
		/// <summary>
		/// Optional. Parameters applied to the aggregation function. Only used for functions that require them.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public Parameter[] Parameters { get; set; }
		
		/// <summary>
		/// Required. The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM()
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Parameter
	{
		
		/// <summary>
		/// A floating-point parameter value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="doubleValue")]
		public System.Nullable<System.Double> DoubleValue { get; set; }
		
		/// <summary>
		/// An integer parameter value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="intValue")]
		public string IntValue { get; set; }
	}
	
	/// <summary>
	/// A chart that displays alert policy data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AlertChart
	{
		
		/// <summary>
		/// Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A chart axis.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Axis
	{
		
		/// <summary>
		/// The label of the axis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The axis scale. By default, a linear scale is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scale")]
		public System.Nullable<AxisScale> Scale { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AxisScale
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCALE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINEAR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOG10 = 2,
	}
	
	/// <summary>
	/// Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Breakdown
	{
		
		/// <summary>
		/// Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationFunction")]
		public AggregationFunction AggregationFunction { get; set; }
		
		/// <summary>
		/// Required. The name of the column in the dataset containing the breakdown values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="column")]
		public string Column { get; set; }
		
		/// <summary>
		/// Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limit")]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		/// <summary>
		/// Required. The sort order is applied to the values of the breakdown column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sortOrder")]
		public System.Nullable<BreakdownSortOrder> SortOrder { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum BreakdownSortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SORT_ORDER_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SORT_ORDER_NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SORT_ORDER_ASCENDING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SORT_ORDER_DESCENDING = 3,
	}
	
	/// <summary>
	/// Options to control visual rendering of a chart.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ChartOptions
	{
		
		/// <summary>
		/// Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayHorizontal")]
		public System.Nullable<System.Boolean> DisplayHorizontal { get; set; }
		
		/// <summary>
		/// The chart mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<ChartOptionsMode> Mode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ChartOptionsMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		X_RAY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATS = 3,
	}
	
	/// <summary>
	/// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CollapsibleGroup
	{
		
		/// <summary>
		/// The collapsed state of the widget on first page load.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="collapsed")]
		public System.Nullable<System.Boolean> Collapsed { get; set; }
	}
	
	/// <summary>
	/// Defines the layout properties and content for a column.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Column
	{
		
		/// <summary>
		/// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public string Weight { get; set; }
		
		/// <summary>
		/// The display widgets arranged vertically in this column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="widgets")]
		public Widget[] Widgets { get; set; }
	}
	
	/// <summary>
	/// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Widget
	{
		
		/// <summary>
		/// A chart that displays alert policy data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alertChart")]
		public AlertChart AlertChart { get; set; }
		
		/// <summary>
		/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blank")]
		public Empty Blank { get; set; }
		
		/// <summary>
		/// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="collapsibleGroup")]
		public CollapsibleGroup CollapsibleGroup { get; set; }
		
		/// <summary>
		/// A widget that displays a list of error groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorReportingPanel")]
		public ErrorReportingPanel ErrorReportingPanel { get; set; }
		
		/// <summary>
		/// Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A widget that displays a list of incidents
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="incidentList")]
		public IncidentList IncidentList { get; set; }
		
		/// <summary>
		/// A widget that displays a stream of log.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logsPanel")]
		public LogsPanel LogsPanel { get; set; }
		
		/// <summary>
		/// A widget that displays timeseries data as a pie or a donut.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pieChart")]
		public PieChart PieChart { get; set; }
		
		/// <summary>
		/// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scorecard")]
		public Scorecard Scorecard { get; set; }
		
		/// <summary>
		/// A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sectionHeader")]
		public SectionHeader SectionHeader { get; set; }
		
		/// <summary>
		/// A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="singleViewGroup")]
		public SingleViewGroup SingleViewGroup { get; set; }
		
		/// <summary>
		/// A widget that displays textual content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public Text Text { get; set; }
		
		/// <summary>
		/// A table that displays time series data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeriesTable")]
		public TimeSeriesTable TimeSeriesTable { get; set; }
		
		/// <summary>
		/// Optional. The title of the widget.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// A chart that displays data on a 2D (X and Y axes) plane.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xyChart")]
		public XyChart XyChart { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// A widget that displays a list of error groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ErrorReportingPanel
	{
		
		/// <summary>
		/// The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectNames")]
		public string[] ProjectNames { get; set; }
		
		/// <summary>
		/// An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="services")]
		public string[] Services { get; set; }
		
		/// <summary>
		/// Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="versions")]
		public string[] Versions { get; set; }
	}
	
	/// <summary>
	/// A widget that displays a list of incidents
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IncidentList
	{
		
		/// <summary>
		/// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monitoredResources")]
		public MonitoredResource[] MonitoredResources { get; set; }
		
		/// <summary>
		/// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policyNames")]
		public string[] PolicyNames { get; set; }
	}
	
	/// <summary>
	/// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }} 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MonitoredResource
	{
		
		/// <summary>
		/// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A widget that displays a stream of log.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LogsPanel
	{
		
		/// <summary>
		/// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public string Filter { get; set; }
		
		/// <summary>
		/// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceNames")]
		public string[] ResourceNames { get; set; }
	}
	
	/// <summary>
	/// A widget that displays timeseries data as a pie or a donut.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PieChart
	{
		
		/// <summary>
		/// Required. Indicates the visualization type for the PieChart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chartType")]
		public System.Nullable<PieChartChartType> ChartType { get; set; }
		
		/// <summary>
		/// Required. The queries for the chart's data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataSets")]
		public PieChartDataSet[] DataSets { get; set; }
		
		/// <summary>
		/// Optional. Indicates whether or not the pie chart should show slices' labels
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="showLabels")]
		public System.Nullable<System.Boolean> ShowLabels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PieChartChartType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PIE_CHART_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PIE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DONUT = 2,
	}
	
	/// <summary>
	/// Groups a time series query definition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PieChartDataSet
	{
		
		/// <summary>
		/// A dimension is a structured label, class, or category for a set of measurements in your data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dimensions")]
		public Dimension[] Dimensions { get; set; }
		
		/// <summary>
		/// A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="measures")]
		public Measure[] Measures { get; set; }
		
		/// <summary>
		/// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minAlignmentPeriod")]
		public string MinAlignmentPeriod { get; set; }
		
		/// <summary>
		/// Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sliceNameTemplate")]
		public string SliceNameTemplate { get; set; }
		
		/// <summary>
		/// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeriesQuery")]
		public TimeSeriesQuery TimeSeriesQuery { get; set; }
	}
	
	/// <summary>
	/// A chart dimension. Dimensions are a structured labewl, class, or category for a set of measurements in your data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Dimension
	{
		
		/// <summary>
		/// The name of the column in the source SQL query that is used to chart the dimension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="column")]
		public string Column { get; set; }
		
		/// <summary>
		/// The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columnType")]
		public string ColumnType { get; set; }
		
		/// <summary>
		/// float_bin_size is used when the column type used for a dimension is a floating point numeric column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="floatBinSize")]
		public System.Nullable<System.Double> FloatBinSize { get; set; }
		
		/// <summary>
		/// A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxBinCount")]
		public System.Nullable<System.Int32> MaxBinCount { get; set; }
		
		/// <summary>
		/// numeric_bin_size is used when the column type used for a dimension is numeric or string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numericBinSize")]
		public System.Nullable<System.Int32> NumericBinSize { get; set; }
		
		/// <summary>
		/// The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sortColumn")]
		public string SortColumn { get; set; }
		
		/// <summary>
		/// The sort order applied to the sort column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sortOrder")]
		public BreakdownSortOrder SortOrder { get; set; }
		
		/// <summary>
		/// time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeBinSize")]
		public string TimeBinSize { get; set; }
	}
	
	/// <summary>
	/// A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Measure
	{
		
		/// <summary>
		/// Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationFunction")]
		public AggregationFunction AggregationFunction { get; set; }
		
		/// <summary>
		/// The column name within the dataset used for the measure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="column")]
		public string Column { get; set; }
	}
	
	/// <summary>
	/// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeSeriesQuery
	{
		
		/// <summary>
		/// Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="opsAnalyticsQuery")]
		public OpsAnalyticsQuery OpsAnalyticsQuery { get; set; }
		
		/// <summary>
		/// Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputFullDuration")]
		public System.Nullable<System.Boolean> OutputFullDuration { get; set; }
		
		/// <summary>
		/// A query used to fetch time series with PromQL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prometheusQuery")]
		public string PrometheusQuery { get; set; }
		
		/// <summary>
		/// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeriesFilter")]
		public TimeSeriesFilter TimeSeriesFilter { get; set; }
		
		/// <summary>
		/// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeriesFilterRatio")]
		public TimeSeriesFilterRatio TimeSeriesFilterRatio { get; set; }
		
		/// <summary>
		/// A query used to fetch time series with MQL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeriesQueryLanguage")]
		public string TimeSeriesQueryLanguage { get; set; }
		
		/// <summary>
		/// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unitOverride")]
		public string UnitOverride { get; set; }
	}
	
	/// <summary>
	/// Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OpsAnalyticsQuery
	{
		
		/// <summary>
		/// A SQL query to fetch time series, category series, or numeric series data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sql")]
		public string Sql { get; set; }
	}
	
	/// <summary>
	/// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeSeriesFilter
	{
		
		/// <summary>
		/// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregation")]
		public Aggregation Aggregation { get; set; }
		
		/// <summary>
		/// Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public string Filter { get; set; }
		
		/// <summary>
		/// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pickTimeSeriesFilter")]
		public PickTimeSeriesFilter PickTimeSeriesFilter { get; set; }
		
		/// <summary>
		/// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryAggregation")]
		public Aggregation SecondaryAggregation { get; set; }
		
		/// <summary>
		/// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statisticalTimeSeriesFilter")]
		public StatisticalTimeSeriesFilter StatisticalTimeSeriesFilter { get; set; }
	}
	
	/// <summary>
	/// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PickTimeSeriesFilter
	{
		
		/// <summary>
		/// How to use the ranking to select time series that pass through the filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public System.Nullable<PickTimeSeriesFilterDirection> Direction { get; set; }
		
		/// <summary>
		/// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public Interval Interval { get; set; }
		
		/// <summary>
		/// How many time series to allow to pass through the filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numTimeSeries")]
		public System.Nullable<System.Int32> NumTimeSeries { get; set; }
		
		/// <summary>
		/// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rankingMethod")]
		public System.Nullable<PickTimeSeriesFilterRankingMethod> RankingMethod { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PickTimeSeriesFilterDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECTION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOTTOM = 2,
	}
	
	/// <summary>
	/// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Interval
	{
		
		/// <summary>
		/// Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PickTimeSeriesFilterRankingMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD_MEAN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD_MAX = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD_MIN = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD_SUM = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD_LATEST = 5,
	}
	
	/// <summary>
	/// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StatisticalTimeSeriesFilter
	{
		
		/// <summary>
		/// How many time series to output.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numTimeSeries")]
		public System.Nullable<System.Int32> NumTimeSeries { get; set; }
		
		/// <summary>
		/// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rankingMethod")]
		public System.Nullable<StatisticalTimeSeriesFilterRankingMethod> RankingMethod { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum StatisticalTimeSeriesFilterRankingMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METHOD_CLUSTER_OUTLIER = 1,
	}
	
	/// <summary>
	/// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeSeriesFilterRatio
	{
		
		/// <summary>
		/// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="denominator")]
		public RatioPart Denominator { get; set; }
		
		/// <summary>
		/// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numerator")]
		public RatioPart Numerator { get; set; }
		
		/// <summary>
		/// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pickTimeSeriesFilter")]
		public PickTimeSeriesFilter PickTimeSeriesFilter { get; set; }
		
		/// <summary>
		/// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryAggregation")]
		public Aggregation SecondaryAggregation { get; set; }
		
		/// <summary>
		/// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statisticalTimeSeriesFilter")]
		public StatisticalTimeSeriesFilter StatisticalTimeSeriesFilter { get; set; }
	}
	
	/// <summary>
	/// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RatioPart
	{
		
		/// <summary>
		/// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregation")]
		public Aggregation Aggregation { get; set; }
		
		/// <summary>
		/// Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public string Filter { get; set; }
	}
	
	/// <summary>
	/// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Scorecard
	{
		
		/// <summary>
		/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blankView")]
		public Empty BlankView { get; set; }
		
		/// <summary>
		/// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gaugeView")]
		public GaugeView GaugeView { get; set; }
		
		/// <summary>
		/// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sparkChartView")]
		public SparkChartView SparkChartView { get; set; }
		
		/// <summary>
		/// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thresholds")]
		public Threshold[] Thresholds { get; set; }
		
		/// <summary>
		/// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeriesQuery")]
		public TimeSeriesQuery TimeSeriesQuery { get; set; }
	}
	
	/// <summary>
	/// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GaugeView
	{
		
		/// <summary>
		/// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lowerBound")]
		public System.Nullable<System.Double> LowerBound { get; set; }
		
		/// <summary>
		/// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upperBound")]
		public System.Nullable<System.Double> UpperBound { get; set; }
	}
	
	/// <summary>
	/// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SparkChartView
	{
		
		/// <summary>
		/// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minAlignmentPeriod")]
		public string MinAlignmentPeriod { get; set; }
		
		/// <summary>
		/// Required. The type of sparkchart to show in this chartView.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sparkChartType")]
		public System.Nullable<SparkChartViewSparkChartType> SparkChartType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SparkChartViewSparkChartType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPARK_CHART_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPARK_LINE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPARK_BAR = 2,
	}
	
	/// <summary>
	/// Defines a threshold for categorizing time series values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Threshold
	{
		
		/// <summary>
		/// The state color for this threshold. Color is not allowed in a XyChart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="color")]
		public System.Nullable<ThresholdColor> Color { get; set; }
		
		/// <summary>
		/// The direction for the current threshold. Direction is not allowed in a XyChart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public System.Nullable<ThresholdDirection> Direction { get; set; }
		
		/// <summary>
		/// A label for the threshold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetAxis")]
		public System.Nullable<ThresholdTargetAxis> TargetAxis { get; set; }
		
		/// <summary>
		/// The value of the threshold. The value should be defined in the native scale of the metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ThresholdColor
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLOR_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YELLOW = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ThresholdDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECTION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABOVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BELOW = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ThresholdTargetAxis
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_AXIS_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Y1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Y2 = 2,
	}
	
	/// <summary>
	/// A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SectionHeader
	{
		
		/// <summary>
		/// Whether to insert a divider below the section in the table of contents
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dividerBelow")]
		public System.Nullable<System.Boolean> DividerBelow { get; set; }
		
		/// <summary>
		/// The subtitle of the section
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subtitle")]
		public string Subtitle { get; set; }
	}
	
	/// <summary>
	/// A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SingleViewGroup
	{
	}
	
	/// <summary>
	/// A widget that displays textual content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Text
	{
		
		/// <summary>
		/// The text content to be displayed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// How the text content is formatted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public System.Nullable<TextFormat> Format { get; set; }
		
		/// <summary>
		/// Properties that determine how the title and content are styled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="style")]
		public TextStyle Style { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TextFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORMAT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MARKDOWN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RAW = 2,
	}
	
	/// <summary>
	/// Properties that determine how the title and content are styled
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TextStyle
	{
		
		/// <summary>
		/// The background color as a hex string. "#RRGGBB" or "#RGB"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backgroundColor")]
		public string BackgroundColor { get; set; }
		
		/// <summary>
		/// Font sizes for both the title and content. The title will still be larger relative to the content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fontSize")]
		public System.Nullable<TextStyleFontSize> FontSize { get; set; }
		
		/// <summary>
		/// The horizontal alignment of both the title and content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="horizontalAlignment")]
		public System.Nullable<TextStyleHorizontalAlignment> HorizontalAlignment { get; set; }
		
		/// <summary>
		/// The amount of padding around the widget
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="padding")]
		public System.Nullable<TextStylePadding> Padding { get; set; }
		
		/// <summary>
		/// The pointer location for this widget (also sometimes called a "tail")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pointerLocation")]
		public System.Nullable<TextStylePointerLocation> PointerLocation { get; set; }
		
		/// <summary>
		/// The text color as a hex string. "#RRGGBB" or "#RGB"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="textColor")]
		public string TextColor { get; set; }
		
		/// <summary>
		/// The vertical alignment of both the title and content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verticalAlignment")]
		public System.Nullable<TextStyleVerticalAlignment> VerticalAlignment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TextStyleFontSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FONT_SIZE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FS_EXTRA_SMALL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FS_SMALL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FS_MEDIUM = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FS_LARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FS_EXTRA_LARGE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TextStyleHorizontalAlignment
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HORIZONTAL_ALIGNMENT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		H_LEFT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		H_CENTER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		H_RIGHT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TextStylePadding
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PADDING_SIZE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		P_EXTRA_SMALL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		P_SMALL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		P_MEDIUM = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		P_LARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		P_EXTRA_LARGE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TextStylePointerLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POINTER_LOCATION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_TOP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_RIGHT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_BOTTOM = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_LEFT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_TOP_LEFT = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_TOP_RIGHT = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_RIGHT_TOP = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_RIGHT_BOTTOM = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_BOTTOM_RIGHT = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_BOTTOM_LEFT = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_LEFT_BOTTOM = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL_LEFT_TOP = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TextStyleVerticalAlignment
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VERTICAL_ALIGNMENT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		V_TOP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		V_CENTER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		V_BOTTOM = 3,
	}
	
	/// <summary>
	/// A table that displays time series data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeSeriesTable
	{
		
		/// <summary>
		/// Optional. The list of the persistent column settings for the table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columnSettings")]
		public ColumnSettings[] ColumnSettings { get; set; }
		
		/// <summary>
		/// Required. The data displayed in this table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataSets")]
		public TableDataSet[] DataSets { get; set; }
		
		/// <summary>
		/// Optional. Store rendering strategy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metricVisualization")]
		public System.Nullable<TimeSeriesTableMetricVisualization> MetricVisualization { get; set; }
	}
	
	/// <summary>
	/// The persistent settings for a table's columns.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ColumnSettings
	{
		
		/// <summary>
		/// Required. The id of the column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="column")]
		public string Column { get; set; }
		
		/// <summary>
		/// Required. Whether the column should be visible on page load.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visible")]
		public System.Nullable<System.Boolean> Visible { get; set; }
	}
	
	/// <summary>
	/// Groups a time series query definition with table options.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TableDataSet
	{
		
		/// <summary>
		/// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minAlignmentPeriod")]
		public string MinAlignmentPeriod { get; set; }
		
		/// <summary>
		/// Table display options that can be reused.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tableDisplayOptions")]
		public TableDisplayOptions TableDisplayOptions { get; set; }
		
		/// <summary>
		/// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tableTemplate")]
		public string TableTemplate { get; set; }
		
		/// <summary>
		/// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeriesQuery")]
		public TimeSeriesQuery TimeSeriesQuery { get; set; }
	}
	
	/// <summary>
	/// Table display options that can be reused.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TableDisplayOptions
	{
		
		/// <summary>
		/// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shownColumns")]
		public string[] ShownColumns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TimeSeriesTableMetricVisualization
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METRIC_VISUALIZATION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NUMBER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BAR = 2,
	}
	
	/// <summary>
	/// A chart that displays data on a 2D (X and Y axes) plane.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class XyChart
	{
		
		/// <summary>
		/// Options to control visual rendering of a chart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chartOptions")]
		public ChartOptions ChartOptions { get; set; }
		
		/// <summary>
		/// Required. The data displayed in this chart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataSets")]
		public DataSet[] DataSets { get; set; }
		
		/// <summary>
		/// Threshold lines drawn horizontally across the chart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thresholds")]
		public Threshold[] Thresholds { get; set; }
		
		/// <summary>
		/// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeshiftDuration")]
		public string TimeshiftDuration { get; set; }
		
		/// <summary>
		/// A chart axis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xAxis")]
		public Axis XAxis { get; set; }
		
		/// <summary>
		/// A chart axis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="y2Axis")]
		public Axis Y2Axis { get; set; }
		
		/// <summary>
		/// A chart axis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yAxis")]
		public Axis YAxis { get; set; }
	}
	
	/// <summary>
	/// Groups a time series query definition with charting options.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DataSet
	{
		
		/// <summary>
		/// Optional. The collection of breakdowns to be applied to the dataset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="breakdowns")]
		public Breakdown[] Breakdowns { get; set; }
		
		/// <summary>
		/// Optional. A collection of dimension columns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dimensions")]
		public Dimension[] Dimensions { get; set; }
		
		/// <summary>
		/// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="legendTemplate")]
		public string LegendTemplate { get; set; }
		
		/// <summary>
		/// Optional. A collection of measures.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="measures")]
		public Measure[] Measures { get; set; }
		
		/// <summary>
		/// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minAlignmentPeriod")]
		public string MinAlignmentPeriod { get; set; }
		
		/// <summary>
		/// How this data should be plotted on the chart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plotType")]
		public System.Nullable<DataSetPlotType> PlotType { get; set; }
		
		/// <summary>
		/// Optional. The target axis to use for plotting the metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetAxis")]
		public ThresholdTargetAxis TargetAxis { get; set; }
		
		/// <summary>
		/// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeriesQuery")]
		public TimeSeriesQuery TimeSeriesQuery { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DataSetPlotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLOT_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STACKED_AREA = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STACKED_BAR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEATMAP = 4,
	}
	
	/// <summary>
	/// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ColumnLayout
	{
		
		/// <summary>
		/// The columns of content to display.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columns")]
		public Column[] Columns { get; set; }
	}
	
	/// <summary>
	/// A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Dashboard
	{
		
		/// <summary>
		/// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columnLayout")]
		public ColumnLayout ColumnLayout { get; set; }
		
		/// <summary>
		/// Filters to reduce the amount of data charted based on the filter criteria.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dashboardFilters")]
		public DashboardFilter[] DashboardFilters { get; set; }
		
		/// <summary>
		/// Required. The mutable, human-readable name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gridLayout")]
		public GridLayout GridLayout { get; set; }
		
		/// <summary>
		/// Labels applied to the dashboard
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mosaicLayout")]
		public MosaicLayout MosaicLayout { get; set; }
		
		/// <summary>
		/// Identifier. The resource name of the dashboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rowLayout")]
		public RowLayout RowLayout { get; set; }
	}
	
	/// <summary>
	/// A filter to reduce the amount of data charted in relevant widgets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DashboardFilter
	{
		
		/// <summary>
		/// The specified filter type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filterType")]
		public System.Nullable<DashboardFilterFilterType> FilterType { get; set; }
		
		/// <summary>
		/// Required. The key for the label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelKey")]
		public string LabelKey { get; set; }
		
		/// <summary>
		/// A variable-length string value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stringValue")]
		public string StringValue { get; set; }
		
		/// <summary>
		/// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="templateVariable")]
		public string TemplateVariable { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DashboardFilterFilterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILTER_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOURCE_LABEL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		METRIC_LABEL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_METADATA_LABEL = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYSTEM_METADATA_LABEL = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GROUP = 5,
	}
	
	/// <summary>
	/// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GridLayout
	{
		
		/// <summary>
		/// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columns")]
		public string Columns { get; set; }
		
		/// <summary>
		/// The informational elements that are arranged into the columns row-first.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="widgets")]
		public Widget[] Widgets { get; set; }
	}
	
	/// <summary>
	/// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MosaicLayout
	{
		
		/// <summary>
		/// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columns")]
		public System.Nullable<System.Int32> Columns { get; set; }
		
		/// <summary>
		/// The tiles to display.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tiles")]
		public Tile[] Tiles { get; set; }
	}
	
	/// <summary>
	/// A single tile in the mosaic. The placement and size of the tile are configurable.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Tile
	{
		
		/// <summary>
		/// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="widget")]
		public Widget Widget { get; set; }
		
		/// <summary>
		/// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
		
		/// <summary>
		/// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xPos")]
		public System.Nullable<System.Int32> XPos { get; set; }
		
		/// <summary>
		/// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yPos")]
		public System.Nullable<System.Int32> YPos { get; set; }
	}
	
	/// <summary>
	/// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RowLayout
	{
		
		/// <summary>
		/// The rows of content to display.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rows")]
		public Row[] Rows { get; set; }
	}
	
	/// <summary>
	/// Defines the layout properties and content for a row.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Row
	{
		
		/// <summary>
		/// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public string Weight { get; set; }
		
		/// <summary>
		/// The display widgets arranged horizontally in this row.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="widgets")]
		public Widget[] Widgets { get; set; }
	}
	
	/// <summary>
	/// A set of (label, value) pairs that were removed from a Distribution time series during aggregation and then added as an attachment to a Distribution.Exemplar.The full label set for the exemplars is constructed by using the dropped pairs in combination with the label values that remain on the aggregated Distribution time series. The constructed full label set can be used to identify the specific entity, such as the instance or job, which might be contributing to a long-tail. However, with dropped labels, the storage requirements are reduced because only the aggregated distribution values for a large group of time series are stored.Note that there are no guarantees on ordering of the labels from exemplar-to-exemplar and from distribution-to-distribution in the same stream, and there may be duplicates. It is up to clients to resolve any ambiguities.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DroppedLabels
	{
		
		/// <summary>
		/// Map from label to its value, for all labels dropped in any aggregation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public System.Collections.Generic.Dictionary<string, string> Label { get; set; }
	}
	
	/// <summary>
	/// A single field of a message type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Field
	{
		
		/// <summary>
		/// The field cardinality.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cardinality")]
		public System.Nullable<FieldCardinality> Cardinality { get; set; }
		
		/// <summary>
		/// The string value of the default value of this field. Proto2 syntax only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultValue")]
		public string DefaultValue { get; set; }
		
		/// <summary>
		/// The field JSON name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jsonName")]
		public string JsonName { get; set; }
		
		/// <summary>
		/// The field type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public System.Nullable<FieldKind> Kind { get; set; }
		
		/// <summary>
		/// The field name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The field number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The index of the field type in Type.oneofs, for message or enumeration types. The first type has index 1; zero means the type is not in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oneofIndex")]
		public System.Nullable<System.Int32> OneofIndex { get; set; }
		
		/// <summary>
		/// The protocol buffer options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="options")]
		public Option[] Options { get; set; }
		
		/// <summary>
		/// Whether to use alternative packed wire representation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packed")]
		public System.Nullable<System.Boolean> Packed { get; set; }
		
		/// <summary>
		/// The field type URL, without the scheme, for message or enumeration types. Example: "type.googleapis.com/google.protobuf.Timestamp".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typeUrl")]
		public string TypeUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FieldCardinality
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CARDINALITY_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CARDINALITY_OPTIONAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CARDINALITY_REQUIRED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CARDINALITY_REPEATED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FieldKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_DOUBLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_FLOAT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_INT64 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UINT64 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_INT32 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_FIXED64 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_FIXED32 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_BOOL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_STRING = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_GROUP = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_MESSAGE = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_BYTES = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UINT32 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_ENUM = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_SFIXED32 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_SFIXED64 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_SINT32 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_SINT64 = 18,
	}
	
	/// <summary>
	/// A protocol buffer option, which can be attached to a message, field, enumeration, etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Option
	{
		
		/// <summary>
		/// The option's name. For protobuf built-in options (options defined in descriptor.proto), this is the short name. For example, "map_entry". For custom options, it should be the fully-qualified name. For example, "google.api.http".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The option's value packed in an Any message. If the value is a primitive, the corresponding wrapper type defined in google/protobuf/wrappers.proto should be used. If the value is an enum, it should be stored as an int32 value using the google.protobuf.Int32Value type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Collections.Generic.Dictionary<string, object> Value { get; set; }
	}
	
	/// <summary>
	/// Message that represents an arbitrary HTTP body. It should only be used for payload formats that can't be represented as JSON, such as raw binary or an HTML page.This message can be used both in streaming and non-streaming API methods in the request as well as the response.It can be used as a top-level request field, which is convenient if one wants to extract parameters from either the URL or HTTP template into the request fields and also want access to the raw HTTP body.Example: message GetResourceRequest { // A unique request id. string request_id = 1; // The raw HTTP body is bound to this field. google.api.HttpBody http_body = 2; } service ResourceService { rpc GetResource(GetResourceRequest) returns (google.api.HttpBody); rpc UpdateResource(google.api.HttpBody) returns (google.protobuf.Empty); } Example with streaming methods: service CaldavService { rpc GetCalendar(stream google.api.HttpBody) returns (stream google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns (stream google.api.HttpBody); } Use of this type only changes how the request and response bodies are handled, all other features will continue to work unchanged.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HttpBody
	{
		
		/// <summary>
		/// The HTTP Content-Type header value specifying the content type of the body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
		
		/// <summary>
		/// The HTTP request/response body as raw binary.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
		
		/// <summary>
		/// Application specific response metadata. Must be set in the first response for streaming APIs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extensions")]
		public string[] Extensions { get; set; }
	}
	
	/// <summary>
	/// The ListDashboards request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListDashboardsResponse
	{
		
		/// <summary>
		/// The list of requested dashboards.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dashboards")]
		public Dashboard[] Dashboards { get; set; }
		
		/// <summary>
		/// If there are more results than have been returned, then this field is set to a non-empty value. To see the additional results, use that value as page_token in the next call to this method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Response for the ListMetricsScopesByMonitoredProject method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListMetricsScopesByMonitoredProjectResponse
	{
		
		/// <summary>
		/// A set of all metrics scopes that the specified monitored project has been added to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metricsScopes")]
		public MetricsScope[] MetricsScopes { get; set; }
	}
	
	/// <summary>
	/// Represents a Metrics Scope (https://cloud.google.com/monitoring/settings#concept-scope) in Cloud Monitoring, which specifies one or more Google projects and zero or more AWS accounts to monitor together.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MetricsScope
	{
		
		/// <summary>
		/// Output only. The time when this Metrics Scope was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The list of projects monitored by this Metrics Scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monitoredProjects")]
		public MonitoredProject[] MonitoredProjects { get; set; }
		
		/// <summary>
		/// Immutable. The resource name of the Monitoring Metrics Scope. On input, the resource name can be specified with the scoping project ID or number. On output, the resource name is specified with the scoping project number. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The time when this Metrics Scope record was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// A project being monitored (https://cloud.google.com/monitoring/settings/multiple-projects#create-multi) by a Metrics Scope.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MonitoredProject
	{
		
		/// <summary>
		/// Output only. The time when this MonitoredProject was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Immutable. The resource name of the MonitoredProject. On input, the resource name includes the scoping project ID and monitored project ID. On output, it contains the equivalent project numbers. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}/projects/{MONITORED_PROJECT_ID_OR_NUMBER}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Operation
	{
		
		/// <summary>
		/// If the value is false, it means the operation is still in progress. If true, the operation is completed, and either error or response is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the name should be a resource name ending with operations/{unique_id}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as Delete, the response is google.protobuf.Empty. If the original method is standard Get/Create/Update, the response should be the resource. For other methods, the response should have the type XxxResponse, where Xxx is the original method name. For example, if the original method name is TakeSnapshot(), the inferred response type is TakeSnapshotResponse.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Contains metadata for longrunning operation for the edit Metrics Scope endpoints.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationMetadata
	{
		
		/// <summary>
		/// The time when the batch request was received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Current state of the batch operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<OperationMetadataState> State { get; set; }
		
		/// <summary>
		/// The time when the operation result was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OperationMetadataState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 4,
	}
	
	/// <summary>
	/// QueryExemplarsRequest holds all parameters of the Prometheus upstream API for querying exemplars.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryExemplarsRequest
	{
		
		/// <summary>
		/// The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// A PromQL query string. Query lanauge documentation: https://prometheus.io/docs/prometheus/latest/querying/basics/.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public string Query { get; set; }
		
		/// <summary>
		/// The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	/// <summary>
	/// QueryInstantRequest holds all parameters of the Prometheus upstream instant query API plus GCM specific parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryInstantRequest
	{
		
		/// <summary>
		/// A PromQL query string. Query lanauge documentation: https://prometheus.io/docs/prometheus/latest/querying/basics/.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public string Query { get; set; }
		
		/// <summary>
		/// The single point in time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public string Time { get; set; }
		
		/// <summary>
		/// An upper bound timeout for the query. Either a Prometheus duration string (https://prometheus.io/docs/prometheus/latest/querying/basics/#time-durations) or floating point seconds. This non-standard encoding must be used for compatibility with the open source API. Clients may still implement timeouts at the connection level while ignoring this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public string Timeout { get; set; }
	}
	
	/// <summary>
	/// QueryLabelsRequest holds all parameters of the Prometheus upstream API for returning a list of label names.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryLabelsRequest
	{
		
		/// <summary>
		/// The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// A list of matchers encoded in the Prometheus label matcher format to constrain the values to series that satisfy them.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="match")]
		public string Match { get; set; }
		
		/// <summary>
		/// The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	/// <summary>
	/// QueryRangeRequest holds all parameters of the Prometheus upstream range query API plus GCM specific parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryRangeRequest
	{
		
		/// <summary>
		/// The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// A PromQL query string. Query lanauge documentation: https://prometheus.io/docs/prometheus/latest/querying/basics/.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public string Query { get; set; }
		
		/// <summary>
		/// The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
		
		/// <summary>
		/// The resolution of query result. Either a Prometheus duration string (https://prometheus.io/docs/prometheus/latest/querying/basics/#time-durations) or floating point seconds. This non-standard encoding must be used for compatibility with the open source API. Clients may still implement timeouts at the connection level while ignoring this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="step")]
		public string Step { get; set; }
		
		/// <summary>
		/// An upper bound timeout for the query. Either a Prometheus duration string (https://prometheus.io/docs/prometheus/latest/querying/basics/#time-durations) or floating point seconds. This non-standard encoding must be used for compatibility with the open source API. Clients may still implement timeouts at the connection level while ignoring this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public string Timeout { get; set; }
	}
	
	/// <summary>
	/// QuerySeries holds all parameters of the Prometheus upstream API for querying series.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QuerySeriesRequest
	{
		
		/// <summary>
		/// The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	/// <summary>
	/// SourceContext represents information about the source of a protobuf element, like the file in which it is defined.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceContext
	{
		
		/// <summary>
		/// The path-qualified name of the .proto file that contained the associated protobuf element. For example: "google/protobuf/source_context.proto".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileName")]
		public string FileName { get; set; }
	}
	
	/// <summary>
	/// The context of a span. This is attached to an Exemplar in Distribution values during aggregation.It contains the name of a span with format: projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID] 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SpanContext
	{
		
		/// <summary>
		/// The resource name of the span. The format is: projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID] [TRACE_ID] is a unique identifier for a trace within a project; it is a 32-character hexadecimal encoding of a 16-byte array.[SPAN_ID] is a unique identifier for a span within a trace; it is a 16-character hexadecimal encoding of an 8-byte array.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spanName")]
		public string SpanName { get; set; }
	}
	
	/// <summary>
	/// A protocol buffer message type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Type
	{
		
		/// <summary>
		/// The source edition string, only valid when syntax is SYNTAX_EDITIONS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="edition")]
		public string Edition { get; set; }
		
		/// <summary>
		/// The list of fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public Field[] Fields { get; set; }
		
		/// <summary>
		/// The fully qualified message name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of types appearing in oneof definitions in this type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oneofs")]
		public string[] Oneofs { get; set; }
		
		/// <summary>
		/// The protocol buffer options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="options")]
		public Option[] Options { get; set; }
		
		/// <summary>
		/// SourceContext represents information about the source of a protobuf element, like the file in which it is defined.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceContext")]
		public SourceContext SourceContext { get; set; }
		
		/// <summary>
		/// The source syntax.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syntax")]
		public System.Nullable<TypeSyntax> Syntax { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TypeSyntax
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYNTAX_PROTO2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYNTAX_PROTO3 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYNTAX_EDITIONS = 2,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Returns a list of every Metrics Scope that a specific MonitoredProject has been added to. The metrics scope representing the specified monitored project will always be the first entry in the response.
		/// Monitoring_locations_global_metricsScopes_listMetricsScopesByMonitoredProject v1/locations/global/metricsScopes:listMetricsScopesByMonitoredProject
		/// </summary>
		/// <param name="monitoredResourceContainer">Required. The resource name of the Monitored Project being requested. Example: projects/{MONITORED_PROJECT_ID_OR_NUMBER}</param>
		/// <returns>Successful response</returns>
		public async Task<ListMetricsScopesByMonitoredProjectResponse> Monitoring_locations_global_metricsScopes_listMetricsScopesByMonitoredProjectAsync(string monitoredResourceContainer, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/locations/global/metricsScopes:listMetricsScopesByMonitoredProject?monitoredResourceContainer=" + (monitoredResourceContainer==null? "" : System.Uri.EscapeDataString(monitoredResourceContainer));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListMetricsScopesByMonitoredProjectResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes an existing custom dashboard.This method requires the monitoring.dashboards.delete permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).
		/// Monitoring_projects_dashboards_delete v1/{name}
		/// </summary>
		/// <param name="name">Required. The resource name of the Dashboard. The format is: projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID] </param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Monitoring_projects_dashboards_deleteAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Fetches a specific dashboard.This method requires the monitoring.dashboards.get permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).
		/// Monitoring_projects_dashboards_get v1/{name}
		/// </summary>
		/// <param name="name">Required. The resource name of the Dashboard. The format is one of: dashboards/[DASHBOARD_ID] (for system dashboards) projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID] (for custom dashboards).</param>
		/// <returns>Successful response</returns>
		public async Task<Dashboard> Monitoring_projects_dashboards_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Dashboard>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Replaces an existing custom dashboard with a new definition.This method requires the monitoring.dashboards.update permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).
		/// Monitoring_projects_dashboards_patch v1/{name}
		/// </summary>
		/// <param name="name">Identifier. The resource name of the dashboard.</param>
		/// <param name="validateOnly">If set, validate the request and preview the review, but do not actually save it.</param>
		/// <returns>Successful response</returns>
		public async Task<Dashboard> Monitoring_projects_dashboards_patchAsync(string name, bool validateOnly, Dashboard requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&validateOnly="+validateOnly;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Dashboard>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists possible values for a given label name.
		/// Monitoring_projects_location_prometheus_api_v1_label_values v1/{name}/location/{location}/prometheus/api/v1/label/{label}/values
		/// </summary>
		/// <param name="name">The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER.</param>
		/// <param name="location">Location of the resource information. Has to be "global" now.</param>
		/// <param name="label">The label name for which values are queried.</param>
		/// <param name="end">The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.</param>
		/// <param name="match">A list of matchers encoded in the Prometheus label matcher format to constrain the values to series that satisfy them.</param>
		/// <param name="start">The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpBody> Monitoring_projects_location_prometheus_api_v1_label_valuesAsync(string name, string location, string label, string end, string match, string start, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/location/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/prometheus/api/v1/label/"+ (label==null? "" : System.Uri.EscapeDataString(label))+"/values&end=" + (end==null? "" : System.Uri.EscapeDataString(end))+"&match=" + (match==null? "" : System.Uri.EscapeDataString(match))+"&start=" + (start==null? "" : System.Uri.EscapeDataString(start));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<HttpBody>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists labels for metrics.
		/// Monitoring_projects_location_prometheus_api_v1_labels v1/{name}/location/{location}/prometheus/api/v1/labels
		/// </summary>
		/// <param name="name">The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER.</param>
		/// <param name="location">Location of the resource information. Has to be "global" now.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpBody> Monitoring_projects_location_prometheus_api_v1_labelsAsync(string name, string location, QueryLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/location/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/prometheus/api/v1/labels";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<HttpBody>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists metadata for metrics.
		/// Monitoring_projects_location_prometheus_api_v1_metadata_list v1/{name}/location/{location}/prometheus/api/v1/metadata
		/// </summary>
		/// <param name="name">Required. The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER.</param>
		/// <param name="location">Location of the resource information. Has to be "global" for now.</param>
		/// <param name="limit">Maximum number of metrics to return.</param>
		/// <param name="metric">The metric name for which to query metadata. If unset, all metric metadata is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpBody> Monitoring_projects_location_prometheus_api_v1_metadata_listAsync(string name, string location, string limit, string metric, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/location/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/prometheus/api/v1/metadata&limit=" + (limit==null? "" : System.Uri.EscapeDataString(limit))+"&metric=" + (metric==null? "" : System.Uri.EscapeDataString(metric));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<HttpBody>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Evaluate a PromQL query at a single point in time.
		/// Monitoring_projects_location_prometheus_api_v1_query v1/{name}/location/{location}/prometheus/api/v1/query
		/// </summary>
		/// <param name="name">The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine.</param>
		/// <param name="location">Location of the resource information. Has to be "global" now.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpBody> Monitoring_projects_location_prometheus_api_v1_queryAsync(string name, string location, QueryInstantRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/location/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/prometheus/api/v1/query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<HttpBody>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists exemplars relevant to a given PromQL query,
		/// Monitoring_projects_location_prometheus_api_v1_query_exemplars v1/{name}/location/{location}/prometheus/api/v1/query_exemplars
		/// </summary>
		/// <param name="name">The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine.</param>
		/// <param name="location">Location of the resource information. Has to be "global" now.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpBody> Monitoring_projects_location_prometheus_api_v1_query_exemplarsAsync(string name, string location, QueryExemplarsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/location/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/prometheus/api/v1/query_exemplars";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<HttpBody>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Evaluate a PromQL query with start, end time range.
		/// Monitoring_projects_location_prometheus_api_v1_query_range v1/{name}/location/{location}/prometheus/api/v1/query_range
		/// </summary>
		/// <param name="name">The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine.</param>
		/// <param name="location">Location of the resource information. Has to be "global" now.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpBody> Monitoring_projects_location_prometheus_api_v1_query_rangeAsync(string name, string location, QueryRangeRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/location/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/prometheus/api/v1/query_range";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<HttpBody>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists metadata for metrics.
		/// Monitoring_projects_location_prometheus_api_v1_series v1/{name}/location/{location}/prometheus/api/v1/series
		/// </summary>
		/// <param name="name">Required. The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER.</param>
		/// <param name="location">Location of the resource information. Has to be "global" for now.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpBody> Monitoring_projects_location_prometheus_api_v1_seriesAsync(string name, string location, QuerySeriesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/location/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/prometheus/api/v1/series";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<HttpBody>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists the existing dashboards.This method requires the monitoring.dashboards.list permission on the specified project. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).
		/// Monitoring_projects_dashboards_list v1/{parent}/dashboards
		/// </summary>
		/// <param name="parent">Required. The scope of the dashboards to list. The format is: projects/[PROJECT_ID_OR_NUMBER] </param>
		/// <param name="pageSize">A positive number that is the maximum number of results to return. If unspecified, a default of 1000 is used.</param>
		/// <param name="pageToken">Optional. If this field is not empty then it must contain the nextPageToken value returned by a previous call to this method. Using this field causes the method to return additional results from the previous method call.</param>
		/// <returns>Successful response</returns>
		public async Task<ListDashboardsResponse> Monitoring_projects_dashboards_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/dashboards&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListDashboardsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a new custom dashboard. For examples on how you can use this API to create dashboards, see Managing dashboards by API (https://cloud.google.com/monitoring/dashboards/api-dashboard). This method requires the monitoring.dashboards.create permission on the specified project. For more information about permissions, see Cloud Identity and Access Management (https://cloud.google.com/iam).
		/// Monitoring_projects_dashboards_create v1/{parent}/dashboards
		/// </summary>
		/// <param name="parent">Required. The project on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER] The [PROJECT_ID_OR_NUMBER] must match the dashboard resource name.</param>
		/// <param name="validateOnly">If set, validate the request and preview the review, but do not actually save it.</param>
		/// <returns>Successful response</returns>
		public async Task<Dashboard> Monitoring_projects_dashboards_createAsync(string parent, bool validateOnly, Dashboard requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/dashboards&validateOnly="+validateOnly;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Dashboard>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Adds a MonitoredProject with the given project ID to the specified Metrics Scope.
		/// Monitoring_locations_global_metricsScopes_projects_create v1/{parent}/projects
		/// </summary>
		/// <param name="parent">Required. The resource name of the existing Metrics Scope that will monitor this project. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Monitoring_locations_global_metricsScopes_projects_createAsync(string parent, MonitoredProject requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/projects";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Operation>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
