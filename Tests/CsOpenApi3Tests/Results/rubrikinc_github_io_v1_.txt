//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActionDetails
	{
		
		/// <summary>
		/// Action script to run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actionString")]
		public string ActionString { get; set; }
		
		/// <summary>
		/// Flag to determine whether action script needs to be run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEnabled")]
		public bool IsEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityLogSummaryV1
	{
		
		/// <summary>
		/// The serialized AfterId of the response, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="afterId")]
		public string AfterId { get; set; }
		
		/// <summary>
		/// List of the events in the event series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventDetailList")]
		public EventSummaryV1[] EventDetailList { get; set; }
		
		/// <summary>
		/// Status of an event series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventSeriesStatus")]
		public System.Nullable<ActivityLogSummaryV1EventSeriesStatus> EventSeriesStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latestEvent")]
		public EventSummaryV1 LatestEvent { get; set; }
		
		/// <summary>
		/// The number of events in the same series as the specified event that have the warning status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="warningCount")]
		public int WarningCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventSummaryV1
	{
		
		/// <summary>
		/// The serialized AfterId of the response, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="afterId")]
		public string AfterId { get; set; }
		
		/// <summary>
		/// A string that contains all the information for this event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventInfo")]
		public string EventInfo { get; set; }
		
		/// <summary>
		/// The event name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventName")]
		public string EventName { get; set; }
		
		/// <summary>
		/// The ID of the event series that this event belongs to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventSeriesId")]
		public string EventSeriesId { get; set; }
		
		/// <summary>
		/// Level of event's severity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventSeverity")]
		public System.Nullable<EventSummaryV1EventSeverity> EventSeverity { get; set; }
		
		/// <summary>
		/// Status of an event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventStatus")]
		public EventSummaryV1EventStatus EventStatus { get; set; }
		
		/// <summary>
		/// Type of an event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventType")]
		public EventSummaryV1EventType EventType { get; set; }
		
		/// <summary>
		/// The event ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The ID of the associated job instance, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jobInstanceId")]
		public string JobInstanceId { get; set; }
		
		/// <summary>
		/// The ID of the object associated with the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		public string ObjectId { get; set; }
		
		/// <summary>
		/// The name of the object associated with the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectName")]
		public string ObjectName { get; set; }
		
		/// <summary>
		/// Type of the object associated with the event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public EventSummaryV1ObjectType ObjectType { get; set; }
		
		/// <summary>
		/// The time at which this event occurred.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.DateTimeOffset Time { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventSummaryV1EventSeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Critical = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Warning = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Informational = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventSummaryV1EventStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failure = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Warning = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Info = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Queued = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Success = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceling = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskSuccess = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventSummaryV1EventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Archive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Audit = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthDomain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsEvent = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Backup = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Classification = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeSource = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeVm = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Configuration = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connection = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Conversion = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Diagnostic = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Discovery = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failover = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fileset = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hardware = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HostEvent = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervScvmm = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervServer = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Index = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Instantiate = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LegalHold = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Maintenance = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixCluster = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Recovery = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replication = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResourceOperations = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Storage = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArray = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StormResource = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Support = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TestFailover = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrade = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VCenter = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcd = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnknownEventType = 37,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventSummaryV1ObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateAhvVm = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateAwsAzure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateHypervVm = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateLinuxUnixHosts = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateNasShares = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateOracleDb = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateSapHanaDb = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateStorageArrays = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateVcdVapps = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateVsphereVm = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateWindowsHosts = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppBlueprint = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppFlows = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthDomain = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsAccount = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsEventType = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Certificate = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cluster = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ComputeInstance = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DataLocation = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ec2Instance = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Envoy = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Host = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervScvmm = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervServer = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervVm = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JobInstance = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ldap = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxHost = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxFileset = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ManagedVolume = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Mssql = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NasHost = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixCluster = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixVm = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleDb = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleHost = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleRac = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PublicCloudMachineInstance = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SamlSso = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SapHanaDb = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SapHanaSystem = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFileset = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SlaDomain = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SmbDomain = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArray = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArrayVolumeGroup = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Storm = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SupportBundle = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnknownObjectType = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrade = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UserActionAudit = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcd = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VcdVapp = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcenter = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VmwareVm = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsHost = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsFileset = 58,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ActivityLogSummaryV1EventSeriesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceling = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SuccessWithWarnings = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityLogSummaryV1ListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ActivityLogSummaryV1[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdaptiveThrottlingSettingsVmwareFields
	{
		
		[System.Runtime.Serialization.DataMember(Name="vmwareThrottlingSettings")]
		public VmwareAdaptiveThrottlingSettings VmwareThrottlingSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareAdaptiveThrottlingSettings
	{
		
		/// <summary>
		/// Threshold virtual machine CPU utilization value that determines whether to postpone a scheduled snapshot of a vSphere virtual machine. Specify the threshold value as a percentage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuUtilizationThreshold")]
		public System.Nullable<System.Int32> CpuUtilizationThreshold { get; set; }
		
		/// <summary>
		/// Threshold datastore latency value, measured across all datastores, that determines whether to postpone a scheduled snapshot of a vSphere virtual machine. Specify the threshold value in milliseconds (ms).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datastoreIoLatencyThreshold")]
		public System.Nullable<System.Int32> DatastoreIoLatencyThreshold { get; set; }
		
		/// <summary>
		/// Threshold virtual machine latency value that determines whether to postpone a scheduled snapshot of the vSphere virtual machine. Specify the threshold value in milliseconds (ms).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ioLatencyThreshold")]
		public System.Nullable<System.Int32> IoLatencyThreshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdvancedLdapConfiguration
	{
		
		/// <summary>
		/// Maximum level of groups to query. Set to 1 to query the immediate groups to which a user belongs. Leave blank to query all the groups to which a user belongs. Valid values are between 1 and 50 inclusive. When ldapSearchAcrossIntegrations is set to be true, this value is ignored. When this value is set, then for this ldap service, ldapActiveDirectoryDisableMatchingRuleInChain is ignored and assumed to be true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupMaxLevel")]
		public System.Nullable<System.Int32> GroupMaxLevel { get; set; }
		
		/// <summary>
		/// LDAP field that contains the group members. For example, Active Directory uses the field "member".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupMemberAttribute")]
		public string GroupMemberAttribute { get; set; }
		
		/// <summary>
		/// Points to the group that this entry belongs to. For example, Active Directory uses the field "memberOf".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupMembershipAttribute")]
		public string GroupMembershipAttribute { get; set; }
		
		/// <summary>
		/// A string representation of the LDAP group search filter in RFC4515 format. For example, a group search filter for Active Directory has the string representation (objectCategory=group).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupSearchFilter")]
		public string GroupSearchFilter { get; set; }
		
		/// <summary>
		/// Specifies the user name. Active Directory searches can use the attributes sAMAccountName and userPrincipalName.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userNameSearchAttribute")]
		public string UserNameSearchAttribute { get; set; }
		
		/// <summary>
		/// A string representation of the LDAP user search filter in RFC4515 format. For example, an Active Directory user search filter that selects all enabled user objects has the following string representation (&(objectCategory=person) (objectClass=user) (!(userAccountControl:1.2.840.113556.1.4.803:=2))).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userSearchFilter")]
		public string UserSearchFilter { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdvancedUiConfigAttributes
	{
		
		/// <summary>
		/// Units for frequency and retention. Accepted values are Minute, Hourly, Daily, Weekly, Monthly, Quarterly, and Yearly.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retentionType")]
		public AdvancedUiConfigAttributesRetentionType RetentionType { get; set; }
		
		/// <summary>
		/// Units for frequency and retention. Accepted values are Minute, Hourly, Daily, Weekly, Monthly, Quarterly, and Yearly.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeUnit")]
		public AdvancedUiConfigAttributesRetentionType TimeUnit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AdvancedUiConfigAttributesRetentionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Minute = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hourly = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Daily = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Weekly = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Monthly = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Quarterly = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Yearly = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AgentSecondaryCertificateInfo
	{
		
		/// <summary>
		/// ID of the certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certId")]
		public string CertId { get; set; }
		
		/// <summary>
		/// Parsed cluster ID from the certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clusterUuid")]
		public string ClusterUuid { get; set; }
		
		/// <summary>
		/// Whether this certificate has been marked for use by agents.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isAgentEnabled")]
		public bool IsAgentEnabled { get; set; }
		
		/// <summary>
		/// Display name for the certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AgentSecondaryCertificateInfoListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AgentSecondaryCertificateInfo[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AgentStatus
	{
		
		/// <summary>
		/// The agent connection status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agentStatus")]
		public string AgentStatus1 { get; set; }
		
		/// <summary>
		/// The reason the agent disconnected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disconnectReason")]
		public string DisconnectReason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AppSearchResponse : SearchResponse
	{
		
		/// <summary>
		/// ID assigned to the child virtual machine of the vApp where this file was found.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="childObjectId")]
		public string ChildObjectId { get; set; }
		
		/// <summary>
		/// Name of the child virtual machine of the vApp where this file was found.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="childObjectName")]
		public string ChildObjectName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AppSearchResponseListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AppSearchResponse[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApplyLegalHoldDefinition
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="holdConfig")]
		public HoldConfig HoldConfig { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotId")]
		public string SnapshotId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HoldConfig
	{
		
		/// <summary>
		/// A Boolean that specifies whether snapshots that are currently local will be kept local after archiving. When this value is 'true', a snapshot that is currently local is retained locally after being archived. The default value is 'false'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isHoldInPlace")]
		public System.Nullable<System.Boolean> IsHoldInPlace { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArchivalSpec
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archivalThreshold")]
		public long ArchivalThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archivalTieringSpec")]
		public ArchivalTieringSpec ArchivalTieringSpec { get; set; }
		
		/// <summary>
		/// A Boolean value that identifies whether the archival location type supports direct archive backups.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassthroughSupported")]
		public System.Nullable<System.Boolean> IsPassthroughSupported { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="locationName")]
		public string LocationName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArchivalTieringSpec
	{
		
		/// <summary>
		/// The set of storage classes that support Cold tiering during smart or instant tiering.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coldStorageClass")]
		public System.Nullable<ArchivalTieringSpecColdStorageClass> ColdStorageClass { get; set; }
		
		/// <summary>
		/// A Boolean value that determines whether to immediately tier uploaded snapshots to cold storage. When this value is 'true,' uploaded snapshots are immediately tiered to cold storage. When this value is 'false,' snapshots are marked as eligible for tiering to cold storage after their time on the archival location exceeds the configured minimum accessible duration.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isInstantTieringEnabled")]
		public bool IsInstantTieringEnabled { get; set; }
		
		/// <summary>
		/// Specifies an interval in seconds. Uploaded snapshots are accessible for instant recovery for the duration of the specified interval. This value is ignored when Instant Tiering is enabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minAccessibleDurationInSeconds")]
		public System.Nullable<System.Int64> MinAccessibleDurationInSeconds { get; set; }
		
		/// <summary>
		/// Indicates if existing snapshots for all objects protected by the SLA should be tiered. If not specified, this defaults to false. Only the snapshots that exist in the archival location associated with the SLA will be tiered.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldTierExistingSnapshots")]
		public System.Nullable<System.Boolean> ShouldTierExistingSnapshots { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ArchivalTieringSpecColdStorageClass
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AzureArchive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Glacier = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GlacierDeepArchive = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArchivalSpecV2
	{
		
		/// <summary>
		/// Amount of time, in seconds, after which the snapshot must be uploaded.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archivalThreshold")]
		public long ArchivalThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archivalTieringSpec")]
		public ArchivalTieringSpec ArchivalTieringSpec { get; set; }
		
		/// <summary>
		/// Boolean value that indicates if the archival location type supports direct archive backups.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassthroughSupported")]
		public System.Nullable<System.Boolean> IsPassthroughSupported { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="locationName")]
		public string LocationName { get; set; }
		
		/// <summary>
		/// The Polaris managed ID of an archival location. At least one of the parameters locationId and polarisManagedId must be defined to correctly refer to an archival location.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="polarisManagedId")]
		public string PolarisManagedId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AsyncRequestStatus
	{
		
		/// <summary>
		/// The end time of the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public RequestErrorInfo Error { get; set; }
		
		/// <summary>
		/// The ID of the request object used to poll the status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// References to any related objects.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="links")]
		public Link[] Links { get; set; }
		
		/// <summary>
		/// The ID of the node where the job ran.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
		
		/// <summary>
		/// The current percentage progress of the asynchronous request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public System.Nullable<System.Double> Progress { get; set; }
		
		/// <summary>
		/// The start time of the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		/// <summary>
		/// Status of the ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RequestErrorInfo
	{
		
		/// <summary>
		/// The error message for failed IDs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Link
	{
		
		/// <summary>
		/// The destination of the link.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
		
		/// <summary>
		/// The relation of the destination of this link to the current resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rel")]
		public string Rel { get; set; }
	}
	
	/// <summary>
	/// The type of authentication domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AuthDomainType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Local = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ldap = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Idp = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AvailableVersionInfo
	{
		
		/// <summary>
		/// Specifies the source from which the CDM software is available.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="availability")]
		public AvailableVersionInfoAvailability Availability { get; set; }
		
		/// <summary>
		/// Brief description of the Rubrik CDM version. An example response value is "Rubrik 5.0 (GA)".
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="downloadJobInfo")]
		public DownloadJobInfo DownloadJobInfo { get; set; }
		
		/// <summary>
		/// The date the Rubrik CDM family was released. This date is only available for software images stored remotely and not yet downloaded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="generalAvailabilityReleaseDateForReleaseFamily")]
		public string GeneralAvailabilityReleaseDateForReleaseFamily { get; set; }
		
		/// <summary>
		/// The MD5 checksum of the software image. This value is used to verify the integrity of the package download.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5sum")]
		public string Md5sum { get; set; }
		
		/// <summary>
		/// The date the Rubrik CDM version was released. This is only available for software images stored remotely and not yet downloaded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public string ReleaseDate { get; set; }
		
		/// <summary>
		/// The URL used to access the version Release Notes for the Rubrik CDM software image. The URL is available only for software images stored remotely and not yet downloaded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseNotes")]
		public string ReleaseNotes { get; set; }
		
		/// <summary>
		/// The remote download URL of the Rubrik CDM software image. This URL is used to download the software to the Rubrik cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteDownloadUrl")]
		public string RemoteDownloadUrl { get; set; }
		
		/// <summary>
		/// The size, in bytes, of the downloaded software image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// The version of Rubrik CDM available in the Rubrik cluster or in the Rubrik remote central repository.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AvailableVersionInfoAvailability
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LocalCluster = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LocalNode = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Remote = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Downloading = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DownloadJobInfo
	{
		
		/// <summary>
		/// Event identifier corresponding to the job instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventId")]
		public string EventId { get; set; }
		
		/// <summary>
		/// Identifier corresponding to the download job instance.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobInstanceId")]
		public string JobInstanceId { get; set; }
		
		/// <summary>
		/// Progress, as a percentage, of the job. Only populated if the job is currently running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public System.Nullable<System.Double> Progress { get; set; }
		
		/// <summary>
		/// Remaining time estimate for the job to complete. Only populated if the job is currently running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remainingTimeEstimateInSeconds")]
		public System.Nullable<System.Int64> RemainingTimeEstimateInSeconds { get; set; }
		
		/// <summary>
		/// Status of the download job instance.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AwsEc2InstanceSlaObjectCount
	{
		
		/// <summary>
		/// The number of EC2 instances protected under this SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numEc2Instances")]
		public System.Nullable<System.Int32> NumEc2Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackupTaskDiagnosticInfo
	{
		
		/// <summary>
		/// The expected completion time of the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedEndTime")]
		public System.Nullable<System.DateTimeOffset> ExpectedEndTime { get; set; }
		
		/// <summary>
		/// The scheduled start time of the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queueTime")]
		public System.Nullable<System.DateTimeOffset> QueueTime { get; set; }
		
		/// <summary>
		/// Status of the task.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="taskStatus")]
		public BackupTaskDiagnosticInfoTaskStatus TaskStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackupTaskDiagnosticInfoTaskStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Queued = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Started = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Retried = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Succeeded = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackupWindow
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="durationInHours")]
		public int DurationInHours { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTimeAttributes")]
		public SlaStartTimeAttributes StartTimeAttributes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaStartTimeAttributes
	{
		
		[System.Runtime.Serialization.DataMember(Name="dayOfWeek")]
		public System.Nullable<System.Int32> DayOfWeek { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hour")]
		public int Hour { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minutes")]
		public int Minutes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseGuestCredential
	{
		
		/// <summary>
		/// Password for the account used to login to the VM guest OS.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Username for the account used to login to the VM guest OS. To include a domain, use the format <domain>\<username>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseGuestCredentialDetail
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseOnDemandSnapshotConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="slaId")]
		public string SlaId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseSnapshotDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="config")]
		public string Config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isCorrupt")]
		public System.Nullable<System.Boolean> IsCorrupt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseSnapshotSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="archivalLocationIds")]
		public string[] ArchivalLocationIds { get; set; }
		
		/// <summary>
		/// Integer value that represents the archival state of a snapshot. 0 means the snapshot is not archived. 2 means the snapshot is archived. 3 means the snapshot is downloaded from the archival location. 4 means the snapshot is in the process of being downloaded from the archival location. 6 means the snapshot is stored locally and at the archival location.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudState")]
		public System.Nullable<System.Int64> CloudState { get; set; }
		
		/// <summary>
		/// The current cloud storage tier of a snapshot. A snapshot's cloud storage tier determines how the cloud provider will determine storage and retrieval costs, as well as retrieval latency. Accepted values are Hot, Cool, AzureArchive (with Azure locations), Glacier, and GlacierDeepArchive (for AWS S3 locations). The value Cold has been deprecated in favor of AzureArchive, which is the recommended replacement value.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudStorageTier")]
		public System.Nullable<BaseSnapshotSummaryCloudStorageTier> CloudStorageTier { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="consistencyLevel")]
		public string ConsistencyLevel { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expirationDate")]
		public System.Nullable<System.DateTimeOffset> ExpirationDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Integer value representing the state of the indexing job for a snapshot. 0 means that the indexing has not begun or is in progress. 1 means indexing completed successfully. 2 means that the indexer failed to process this snapshot.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indexState")]
		public System.Nullable<System.Int64> IndexState { get; set; }
		
		/// <summary>
		/// A Boolean that indicates whether or not custom retention is applied to the snapshot.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isCustomRetentionApplied")]
		public bool IsCustomRetentionApplied { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isOnDemandSnapshot")]
		public bool IsOnDemandSnapshot { get; set; }
		
		/// <summary>
		/// A Boolean that indicates whether the snapshot is placed on Legal Hold. When this value is 'true', the snapshot is placed on Legal Hold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPlacedOnLegalHold")]
		public System.Nullable<System.Boolean> IsPlacedOnLegalHold { get; set; }
		
		/// <summary>
		/// A Boolean that indicates whether the snapshot is being retained under a Retention Lock SLA Domain. When this value is 'true', the snapshot is being retained under a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRetainedByRetentionLockSla")]
		public System.Nullable<System.Boolean> IsRetainedByRetentionLockSla { get; set; }
		
		/// <summary>
		/// ID of the parent snapshot if the current snapshot is a child snapshot. Child snapshots are snapshots of objects that are part of an app, either a vCloud Director vApp or an AppBlueprint. Snapshots of the app are parent snapshots.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentSnapshotId")]
		public string ParentSnapshotId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="replicationLocationIds")]
		public string[] ReplicationLocationIds { get; set; }
		
		/// <summary>
		/// (Deprecated) For a policy based snapshot this parameter contains the ID of the SLA Domain currently assigned to the data source of that snapshot. For an on demand snapshot this field corresponds to the SLA Domain that was assigned when the snapshot was taken. A data source, and individual snapshots, can be reassigned to a different SLA Domain, or the SLA Domain can be modified. In any of these cases this parameter can contain a stale and incorrect value. To view retention information for this snapshot, use snapshotRetentionInfo instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slaId")]
		public string SlaId { get; set; }
		
		/// <summary>
		/// (Deprecated) For a policy based snapshot this parameter contains the name of the SLA Domain currently assigned to the data source of that snapshot. For an on demand snapshot this field corresponds to the SLA Domain that was assigned when the snapshot was taken. A data source, and individual snapshots, can be reassigned to a different SLA Domain, or the SLA Domain can be modified. In any of these cases this parameter can contain a stale and incorrect value. To view retention information for this snapshot, use snapshotRetentionInfo instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slaName")]
		public string SlaName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snapshotRetentionInfo")]
		public SnapshotRetentionInfo SnapshotRetentionInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceObjectType")]
		public string SourceObjectType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BaseSnapshotSummaryCloudStorageTier
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cool = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cold = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AzureArchive = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Glacier = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GlacierDeepArchive = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotRetentionInfo
	{
		
		/// <summary>
		/// List of snapshot retention information on the archival locations.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archivalInfos")]
		public SnapshotLocationRetentionInfo[] ArchivalInfos { get; set; }
		
		/// <summary>
		/// Snapshot retention information such as frequency tag and expected expiration time on the cloud native locations.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cloudNativeLocationInfo")]
		public SnapshotLocationRetentionInfo[] CloudNativeLocationInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="localInfo")]
		public SnapshotLocationRetentionInfo LocalInfo { get; set; }
		
		/// <summary>
		/// List of snapshot retention information on the replicated locations.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="replicationInfos")]
		public SnapshotLocationRetentionInfo[] ReplicationInfos { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotLocationRetentionInfo
	{
		
		/// <summary>
		/// Time when the snapshot expired or is expected to expire at this location. This field will only be set if the snapshot has ever existed at the location. If the snapshot is present at the location, but the expiration time calculation is pending, this field will be absent. If the expiration time calculation is complete and the field is still absent, the snapshot will be retained forever at this location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expirationTime")]
		public System.Nullable<System.DateTimeOffset> ExpirationTime { get; set; }
		
		/// <summary>
		/// ID of the location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A Boolean that indicates whether expiration date for snapshot has been calculated. This field will be absent if the snapshot has never existed at this location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isExpirationDateCalculated")]
		public System.Nullable<System.Boolean> IsExpirationDateCalculated { get; set; }
		
		/// <summary>
		/// Indicates whether expiration information of the snapshot is unavailable at this location. This field is always and only present for replication locations. Its value is true if and only if the replicated snapshots are from pre-5.2 cluster.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isExpirationInformationUnavailable")]
		public System.Nullable<System.Boolean> IsExpirationInformationUnavailable { get; set; }
		
		/// <summary>
		/// Boolean that specifies whether the snapshot is present at this location. When this value is 'false,' the snapshot is expired at this location. Because retention information is unreliable for locations where the snapshots are not present, confirming that this value is 'true' is the best practice.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isSnapshotPresent")]
		public bool IsSnapshotPresent { get; set; }
		
		/// <summary>
		/// Name of the location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The tag to determine what frequency the snapshot corresponds to at this location. The snapshot tag can be hourly, daily, weekly, monthly, quarterly, or yearly depending on the SLA frequency which is used to determine the retention of the snapshot. A value of "Ready for Deletion" means that the snapshot will be deleted soon. A value of "Forever" means that the snapshot will never be deleted. This field is absent when the tag computation is incomplete.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotFrequency")]
		public string SnapshotFrequency { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchAsyncRequest
	{
		
		/// <summary>
		/// Batch of the request object IDs used to poll the status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchAsyncRequestStatus
	{
		
		/// <summary>
		/// The asynchronous request status of a batch request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public AsyncRequestStatus[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchMountSnapshotJobConfig
	{
		
		/// <summary>
		/// Array of objects containing information about snapshots to mount.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshots")]
		public MountSnapshotJobConfigForBatchV1[] Snapshots { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MountSnapshotJobConfigForBatchV1
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public MountSnapshotJobConfigV1 Config { get; set; }
		
		/// <summary>
		/// Mounts the oldest snapshot taken after the specified date. This parameter is only evaluated when no values are set for snapshotId and snapshotBeforeDate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotAfterDate")]
		public System.Nullable<System.DateTimeOffset> SnapshotAfterDate { get; set; }
		
		/// <summary>
		/// Mounts the most recent snapshot taken prior to the specified date. This parameter is only evaluated when no value is set for snapshotId.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotBeforeDate")]
		public System.Nullable<System.DateTimeOffset> SnapshotBeforeDate { get; set; }
		
		/// <summary>
		/// The ID of the snapshot to export. This parameter is optional if either of the `snapshotBeforeDate` or `snapshotAfterDate` parameters is configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotId")]
		public string SnapshotId { get; set; }
		
		/// <summary>
		/// ID of the virtual machine whose snapshot needs to be mounted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchVmSnapshotSummaries
	{
		
		/// <summary>
		/// The snapshot summaries for a list of virtual machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public VmSnapshotSummaries[] Responses { get; set; }
	}
	
	/// <summary>
	/// Snapshot summaries for the virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmSnapshotSummaries
	{
		
		/// <summary>
		/// The ID of the virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
		
		/// <summary>
		/// A list of VmSnapshotSummary for the virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmSnapshotsSummaries")]
		public VmSnapshotSummary[] VmSnapshotsSummaries { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmSnapshotSummary : BaseSnapshotSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="vNicsInfo")]
		public VmwareVNicBindingInfo[] VNicsInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmName")]
		public string VmName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareVNicBindingInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backingNetworkInfo")]
		public VmwareNetworkInfo BackingNetworkInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkDeviceInfo")]
		public VmwareNetworkDeviceInfo NetworkDeviceInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareNetworkInfo
	{
		
		/// <summary>
		/// ID of the VMware network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="moid")]
		public string Moid { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// VMware network type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkType")]
		public System.Nullable<VmwareNetworkInfoNetworkType> NetworkType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VmwareNetworkInfoNetworkType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_NETWORK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISTRIBUTED_PORT_GROUP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPAQUE_NETWORK = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OTHER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareNetworkDeviceInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public int Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchVmwareCdpLiveInfo
	{
		
		/// <summary>
		/// The live CDP info for the virtual machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public VmwareCdpLiveInfo[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareCdpLiveInfo
	{
		
		/// <summary>
		/// The time on this node. Computed after computing the live CDP info for the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentTime")]
		public System.Nullable<System.DateTimeOffset> CurrentTime { get; set; }
		
		/// <summary>
		/// The latest time to which this virtual machine can be recovered locally.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localRecoveryPoint")]
		public System.Nullable<System.DateTimeOffset> LocalRecoveryPoint { get; set; }
		
		/// <summary>
		/// The latest time to which this virtual machine can be recovered on a remote cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteRecoveryPoint")]
		public System.Nullable<System.DateTimeOffset> RemoteRecoveryPoint { get; set; }
		
		/// <summary>
		/// The ID of the virtual machine that we are getting CDP live fields for.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchVmwareCdpStateInfo
	{
		
		/// <summary>
		/// The CDP state info for the virtual machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public VmwareCdpStateInfo[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareCdpStateInfo
	{
		
		/// <summary>
		/// The percentage of healthy time over all CDP-enabled time over the last 24 hours. Range from 0.0 to 100.0 .
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthPercentage")]
		public System.Nullable<System.Double> HealthPercentage { get; set; }
		
		/// <summary>
		/// Current Local CDP Status of virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localStatus")]
		public System.Nullable<VmwareCdpStateInfoLocalStatus> LocalStatus { get; set; }
		
		/// <summary>
		/// Current CDP Replication Status of virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicationStatus")]
		public System.Nullable<VmwareCdpStateInfoReplicationStatus> ReplicationStatus { get; set; }
		
		/// <summary>
		/// The ID of the virtual machine for which the cluster is retrieving CDP state information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VmwareCdpStateInfoLocalStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotEnabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Pending = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TakingSnapshot = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Resyncing = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VmwareCdpStateInfoReplicationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotEnabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Healthy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Initializing = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchVmwareVmMissedRecoverableRanges
	{
		
		/// <summary>
		/// Missed recoverable ranges for a set of virtual machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public VmwareVmMissedRecoverableRanges[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareVmMissedRecoverableRanges
	{
		
		/// <summary>
		/// Missed recoverable ranges for the virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="missedRecoverableRanges")]
		public VmwareRecoverableRange[] MissedRecoverableRanges { get; set; }
		
		/// <summary>
		/// ID of the virtual machine for which missed recoverable ranges are being retrieved.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareRecoverableRange
	{
		
		[System.Runtime.Serialization.DataMember(Name="beginTime")]
		public System.Nullable<System.DateTimeOffset> BeginTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchVmwareVmMissedRecoverableRangesRequest
	{
		
		/// <summary>
		/// Query filter - only ranges that occur after this time are included. The date-time string should be in ISO8601 format. For example, `2018-01-01T01:23:45.678Z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="after_time")]
		public System.Nullable<System.DateTimeOffset> After_time { get; set; }
		
		/// <summary>
		/// Query filter - only ranges that occur before this time are included. The date-time string should be in ISO8601 format. For example, `2018-01-01T01:23:45.678Z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="before_time")]
		public System.Nullable<System.DateTimeOffset> Before_time { get; set; }
		
		/// <summary>
		/// ID of each CDP-enabled virtual machine for which missed recoverable ranges are being retrieved.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmIds")]
		public string[] VmIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchVmwareVmRecoverableRanges
	{
		
		/// <summary>
		/// The recoverable ranges for a set of virtual machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public VmwareVmRecoverableRanges[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareVmRecoverableRanges
	{
		
		/// <summary>
		/// The recoverable ranges for the virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoverableRanges")]
		public VmwareRecoverableRange[] RecoverableRanges { get; set; }
		
		/// <summary>
		/// The ID of the virtual machine for which to retrieve recoverable ranges.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchVmwareVmRecoverableRangesRequest
	{
		
		/// <summary>
		/// Query filter - only ranges after this time will be included. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="after_time")]
		public System.Nullable<System.DateTimeOffset> After_time { get; set; }
		
		/// <summary>
		/// Query filter - only ranges before this time will be included. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="before_time")]
		public System.Nullable<System.DateTimeOffset> Before_time { get; set; }
		
		/// <summary>
		/// The ID of each CDP-enabled virtual machine for which recoverable ranges are being retrieved.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmIds")]
		public string[] VmIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BlackoutWindow
	{
		
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BlackoutWindowResponseInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blackoutWindowStatus")]
		public BlackoutWindowStatus BlackoutWindowStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blackoutWindows")]
		public BlackoutWindows BlackoutWindows { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BlackoutWindowStatus
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isGlobalBlackoutActive")]
		public bool IsGlobalBlackoutActive { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isSnappableBlackoutActive")]
		public System.Nullable<System.Boolean> IsSnappableBlackoutActive { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BlackoutWindows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalBlackoutWindows")]
		public BlackoutWindow[] GlobalBlackoutWindows { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snappableBlackoutWindows")]
		public BlackoutWindow[] SnappableBlackoutWindows { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BooleanResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public bool Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BootstrappableNodeInfoV1
	{
		
		/// <summary>
		/// Hostname of a Rubrik node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// IPv6 address of a Rubrik node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public string Ipv6 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BootstrappableNodeIpv4Info
	{
		
		/// <summary>
		/// Hostname of a Rubrik node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// IPv4 address of a Rubrik node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public string Ipv4 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BrowseResponse
	{
		
		/// <summary>
		/// The type of file, either a regular file or a directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileMode")]
		public string FileMode { get; set; }
		
		/// <summary>
		/// The name of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastModified")]
		public string LastModified { get; set; }
		
		/// <summary>
		/// The complete path of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// Description about the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// Reason the file is unreadable. Undefined if the file is readable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreadable")]
		public System.Nullable<System.Int32> Unreadable { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BrowseResponseListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public BrowseResponse[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkDeleteObjectSnapshotsConfig
	{
		
		/// <summary>
		/// The ID of the location that contains the snapshots to delete. When no location ID is present, this API endpoint deletes snapshots from all locations.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// A list of snapshot IDs for the snapshots to delete.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotIds")]
		public string[] SnapshotIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkDeleteSnapshotsConfig
	{
		
		/// <summary>
		/// List of object IDs. This endpoint deletes all snapshots from all locations for the objects with the specified IDs.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectIds")]
		public string[] ObjectIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkOnDemandSnapshotJobConfig
	{
		
		/// <summary>
		/// The ID of the SLA Domain to assign to the virtual machines.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slaId")]
		public string SlaId { get; set; }
		
		/// <summary>
		/// The IDs of the virtual machines for which to take on-demand snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vms")]
		public string[] Vms { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkOracleDbDetails
	{
		
		/// <summary>
		/// An array that contains all Oracle Database update details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public OracleDbDetail[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleDbDetail : OracleDbSummary
	{
		
		/// <summary>
		/// Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostLogRetentionHours")]
		public int HostLogRetentionHours { get; set; }
		
		/// <summary>
		/// Path where the NFS share is mounted on the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostMount")]
		public string HostMount { get; set; }
		
		/// <summary>
		/// Specifies an interval in minutes. This interval is the period between successive log backups.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInMinutes")]
		public int LogBackupFrequencyInMinutes { get; set; }
		
		/// <summary>
		/// Specifies an interval in hours. Log backups are retained for the duration of the interval.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logRetentionHours")]
		public int LogRetentionHours { get; set; }
		
		/// <summary>
		/// Number of channels used to backup the Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numChannels")]
		public int NumChannels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkOracleHostDetails
	{
		
		/// <summary>
		/// An array that contains all Oracle Host update details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public OracleHostDetail[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleHostDetail : OracleHostSummary
	{
		
		/// <summary>
		/// Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostLogRetentionHours")]
		public int HostLogRetentionHours { get; set; }
		
		/// <summary>
		/// Path where the NFS share is mounted on the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostMount")]
		public string HostMount { get; set; }
		
		/// <summary>
		/// Specifies an interval in minutes. This interval is the period between successive log backups.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInMinutes")]
		public int LogBackupFrequencyInMinutes { get; set; }
		
		/// <summary>
		/// Specifies an interval in hours. Log backups are retained for the duration of the interval.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logRetentionHours")]
		public int LogRetentionHours { get; set; }
		
		/// <summary>
		/// Number of channels used to backup the Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numChannels")]
		public int NumChannels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkOracleRacDetails
	{
		
		/// <summary>
		/// An array that contains all Oracle RAC update details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public OracleRacDetail[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleRacDetail : OracleRacSummary
	{
		
		/// <summary>
		/// Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostLogRetentionHours")]
		public int HostLogRetentionHours { get; set; }
		
		/// <summary>
		/// Path where the NFS share is mounted on the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostMount")]
		public string HostMount { get; set; }
		
		/// <summary>
		/// Specifies an interval in minutes. This interval is the period between successive log backups.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInMinutes")]
		public int LogBackupFrequencyInMinutes { get; set; }
		
		/// <summary>
		/// Specifies an interval in hours. Log backups are retained for the duration of the interval.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logRetentionHours")]
		public int LogRetentionHours { get; set; }
		
		/// <summary>
		/// Number of channels used to backup the Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numChannels")]
		public int NumChannels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkShareAddResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="refreshJobStatus")]
		public AsyncRequestStatus RefreshJobStatus { get; set; }
		
		/// <summary>
		/// Details of created shares.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sharesDetail")]
		public HostShareDetail[] SharesDetail { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostShareDetail
	{
		
		/// <summary>
		/// The domain of the SMB share.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// The NFS export point or SMB share name for the NAS share.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exportPoint")]
		public string ExportPoint { get; set; }
		
		/// <summary>
		/// The host ID of the NAS Share host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostShareParameters")]
		public HostShareParameters HostShareParameters { get; set; }
		
		/// <summary>
		/// The hostname of the NAS host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// The unique ID of the NAS Share.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The ID of the primary Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// The type of NAS share.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shareType")]
		public HostShareDetailShareType ShareType { get; set; }
		
		/// <summary>
		/// The status of connection between the Rubrik cluster and the NAS Share. Possible responses are Connected and Disconnected.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// The username to access the NAS share.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// NAS Vendor Type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vendorType")]
		public System.Nullable<HostShareDetailVendorType> VendorType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostShareParameters
	{
		
		/// <summary>
		/// Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isIsilonChangelistEnabled")]
		public System.Nullable<System.Boolean> IsIsilonChangelistEnabled { get; set; }
		
		/// <summary>
		/// Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isNetAppSnapDiffEnabled")]
		public System.Nullable<System.Boolean> IsNetAppSnapDiffEnabled { get; set; }
		
		/// <summary>
		/// Indicates whether the share is on a SnapMirror destination volume on a NetApp NAS share. When this value is 'true', fileset backup operations pick the latest Netapp snapshot on the volume, subject to the configured label matching. During share registration, Rubrik checks with NetApp NAS to find out whether the share is on SnapMirror destination and sets this parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isOnNetAppSnapMirrorDestVolume")]
		public System.Nullable<System.Boolean> IsOnNetAppSnapMirrorDestVolume { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostShareDetailShareType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NFS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SMB = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostShareDetailVendorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETAPP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ISILON = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FLASHBLADE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkSlaConflictsSummary
	{
		
		/// <summary>
		/// List of SLA domain conflict summaries for the specified managed IDs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public SlaConflictsSummary[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaConflictsSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conflicts")]
		public ManagedHierarchyObjectSummary[] Conflicts { get; set; }
		
		/// <summary>
		/// managedId.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Indicates if the results returned are inconsistent due to an ongoing SLA assignment operation within this object's hierarchy. This endpoint does not consider the results of in flight SLA operations since they have not yet completed. Because the results may change once the operation completes, Rubrik advises waiting until all SLA assignments have completed on this hierarchy before reassigning, unless changing the childrens' SLAs directly with this assignment is unacceptable.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isPossiblyInconsistent")]
		public bool IsPossiblyInconsistent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedHierarchyObjectSummary : Snappable
	{
		
		[System.Runtime.Serialization.DataMember(Name="infraPath")]
		public ManagedHierarchyObjectAncestor[] InfraPath { get; set; }
		
		/// <summary>
		/// Indicates whether the managed hierarchy object is deleted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isDeleted")]
		public bool IsDeleted { get; set; }
		
		/// <summary>
		/// Whether this managed object is a relic (an archived snappable with unexpired snapshots).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public bool IsRelic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slaPath")]
		public ManagedHierarchyObjectAncestor[] SlaPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedHierarchyObjectAncestor
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkTierSnapshotsConfig
	{
		
		/// <summary>
		/// Users can specify the archival location ID in order to tier snapshots in the specified archival location. When an archival location ID is not specified, snapshots in the archival location specified in the SLA Domain policy for protected objects will be tiered. Relic and unprotected object snapshots across all archival locations will be tiered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// A list of object IDs to tier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectIds")]
		public string[] ObjectIds { get; set; }
	}
	
	/// <summary>
	/// Current Local CDP Status of virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CdpLocalStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotEnabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Pending = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TakingSnapshot = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Resyncing = 5,
	}
	
	/// <summary>
	/// Current CDP Replication Status of virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CdpReplicationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotEnabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Healthy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Initializing = 3,
	}
	
	/// <summary>
	/// Current CDP State of virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CdpState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotEnabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Pending = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WaitingForInitialSnapshot = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Broken = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FailedToStart = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TryingToStart = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Resyncing = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CertificateImportRequest
	{
		
		/// <summary>
		/// ID of the certificate signing request (CSR) associated with the imported certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="csrId")]
		public string CsrId { get; set; }
		
		/// <summary>
		/// User-friendly description for the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display name for the certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The certificates, and optionally private key to be imported, in PEM format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pemFile")]
		public string PemFile { get; set; }
		
		/// <summary>
		/// The private key, in PEM format, to be imported. If a private key is provided using this field instead of the pemFile field, the import fails if the private key is not successfully parsed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for certificates.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CertificateListSortAttributes
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		description = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hasKey = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		expiration = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CertificatePatchRequest
	{
		
		/// <summary>
		/// User-friendly description for the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display name for the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The certificates to be imported, in PEM format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pemFile")]
		public string PemFile { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CertificateSummary
	{
		
		/// <summary>
		/// ID of the certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certId")]
		public string CertId { get; set; }
		
		/// <summary>
		/// User-friendly description for the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The expiration date for the certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expiration")]
		public System.DateTimeOffset Expiration { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether or not the certificate is associated with a stored private key. When this value is 'true,' the private key for the certificate is stored. When this value is 'false,' the private key for the certificate is not stored.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasKey")]
		public bool HasKey { get; set; }
		
		/// <summary>
		/// Display name for the certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The certificates, in PEM format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pemFile")]
		public string PemFile { get; set; }
		
		/// <summary>
		/// A list of components using the certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="usedBy")]
		public string UsedBy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CertificateSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public CertificateSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudInstantiationSpec
	{
		
		/// <summary>
		/// Specifies the number of seconds to retain an image file that is generated for a snappable. Setting this to -1 disables cloud instantiation for the snappable.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="imageRetentionInSeconds")]
		public long ImageRetentionInSeconds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudOutComputeForecastSummaries
	{
		
		[System.Runtime.Serialization.DataMember(Name="forecastWithConsolidation")]
		public CloudOutComputeForecastSummary ForecastWithConsolidation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forecastWithoutConsolidation")]
		public CloudOutComputeForecastSummary ForecastWithoutConsolidation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudOutComputeForecastSummary
	{
		
		/// <summary>
		/// The cost of running a compute instance. The list contains up to forecastPeriodInGranularityUnit values, one for each granularity. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values, the first value for the first year, the second value for the second year, and the third value for the third year.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="computeCostInUSD")]
		public int[] ComputeCostInUSD { get; set; }
		
		/// <summary>
		/// Number of hours for which a compute instance is used. The list contains up to forecastPeriodInGranularityUnit values, one for each granularity. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values, the first value for the first year, the second value for the second year, and the third value for the third year.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="computeDurationInHrs")]
		public int[] ComputeDurationInHrs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudOutForecastRequest
	{
		
		/// <summary>
		/// Filter to perform forecasts, with or without archival consolidation enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="consolidationFilter")]
		public CloudOutForecastRequestConsolidationFilter ConsolidationFilter { get; set; }
		
		/// <summary>
		/// Length of forecast period, in multiples of granularity. The maximum supported forecast period is 10 years.
		/// Required
		/// Minimum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forecastPeriodInGranularityUnit")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public int ForecastPeriodInGranularityUnit { get; set; }
		
		/// <summary>
		/// Granularity of the cloud utilization forecast.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="granularity")]
		public CloudOutForecastRequestGranularity Granularity { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slaParameters")]
		public CloudOutForecastSlaParameters SlaParameters { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CloudOutForecastRequestConsolidationFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForecastWithConsolidation = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForecastWithoutConsolidation = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForecastWithAndWithoutConsolidation = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CloudOutForecastRequestGranularity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Quarter = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Year = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudOutForecastSlaParameters
	{
		
		/// <summary>
		/// The advanced UI configuration according to the SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advancedUiConfig")]
		public AdvancedUiConfigAttributes[] AdvancedUiConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archivalSpecs")]
		public ArchivalSpecV2 ArchivalSpecs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequencies")]
		public SlaFrequencyV2 Frequencies { get; set; }
		
		/// <summary>
		/// Maximum local retention limit, in seconds, according to the SLA Domain. Required only for remote SLA Domains.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLocalRetentionLimit")]
		public System.Nullable<System.Int64> MaxLocalRetentionLimit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaFrequencyV2
	{
		
		[System.Runtime.Serialization.DataMember(Name="daily")]
		public FrequencyConfig Daily { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hourly")]
		public FrequencyConfig Hourly { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minute")]
		public FrequencyConfig Minute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="monthly")]
		public MonthlyConfig Monthly { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="quarterly")]
		public QuarterlyConfig Quarterly { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="weekly")]
		public WeeklyConfig Weekly { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="yearly")]
		public YearlyConfig Yearly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FrequencyConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public int Frequency { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retention")]
		public int Retention { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudOutForecastSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="assumptions")]
		public ForecastAssumptions Assumptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="locationForecast")]
		public PerLocationCloudOutForecastSummary LocationForecast { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForecastAssumptions
	{
		
		/// <summary>
		/// Annual growth rate of protected data.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="annualGrowthRateInPercent")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AnnualGrowthRateInPercent { get; set; }
		
		/// <summary>
		/// Data compression factor.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compressionFactor")]
		public double CompressionFactor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequencyChangeRates")]
		public FrequencyChangeRates FrequencyChangeRates { get; set; }
		
		/// <summary>
		/// Logical data size protected by the SLA Domain.
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logicalDataSizeInGB")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double LogicalDataSizeInGB { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FrequencyChangeRates
	{
		
		/// <summary>
		/// Daily change rate.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dailyChangeRateInPercent")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DailyChangeRateInPercent { get; set; }
		
		/// <summary>
		/// Monthly change rate.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyChangeRateInPercent")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> MonthlyChangeRateInPercent { get; set; }
		
		/// <summary>
		/// Quarterly change rate.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quarterlyChangeRateInPercent")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> QuarterlyChangeRateInPercent { get; set; }
		
		/// <summary>
		/// Weekly change rate.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weeklyChangeRateInPercent")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> WeeklyChangeRateInPercent { get; set; }
		
		/// <summary>
		/// Yearly change rate.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yearlyChangeRateInPercent")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> YearlyChangeRateInPercent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PerLocationCloudOutForecastSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="computeForecast")]
		public CloudOutComputeForecastSummaries ComputeForecast { get; set; }
		
		/// <summary>
		/// Type of compute instance used at the cloud archival location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceType")]
		public string InstanceType { get; set; }
		
		/// <summary>
		/// Name of the cloud archival location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locationName")]
		public string LocationName { get; set; }
		
		/// <summary>
		/// Region of the cloud archival location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationRegion")]
		public string LocationRegion { get; set; }
		
		/// <summary>
		/// Type of cloud archival location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locationType")]
		public string LocationType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storageForecast")]
		public CloudOutStorageForecastSummaries StorageForecast { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudOutStorageForecastSummaries
	{
		
		[System.Runtime.Serialization.DataMember(Name="forecastWithConsolidation")]
		public CloudOutStorageForecastSummary ForecastWithConsolidation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forecastWithoutConsolidation")]
		public CloudOutStorageForecastSummary ForecastWithoutConsolidation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudOutStorageForecastSummary
	{
		
		/// <summary>
		/// Data retrieval costs, in USD, for the cloud archival location. The list contains forecastPeriodInGranularityUnit values, one for each granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. The first value corresponds to the first year, the second value corresponds to the second year, and the third value corresponds to the third year.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataRetrievalCostInUSD")]
		public int[] DataRetrievalCostInUSD { get; set; }
		
		/// <summary>
		/// Early deletion costs, in USD, for the cloud archival location. The list contains forecastPeriodInGranularityUnit values, one for each granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. The first value corresponds to the first year, the second value corresponds to the second year, and the third value corresponds to the third year.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="earlyDeletionCostInUSD")]
		public int[] EarlyDeletionCostInUSD { get; set; }
		
		/// <summary>
		/// Storage utilization forecast for cloud archival location across various storage classes. The list contains one object per storage class that is used on the cloud archival location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perStorageClassForecast")]
		public PerStorageClassCloudOutStorageForecastSummary[] PerStorageClassForecast { get; set; }
		
		/// <summary>
		/// Storage costs, in USD, for the cloud archival location. The list contains forecastPeriodInGranularityUnit values, one for each granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. The first value corresponds to the first year, the second value corresponds to the second year, and the third value corresponds to the third year.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageCostInUSD")]
		public int[] StorageCostInUSD { get; set; }
		
		/// <summary>
		/// Storage values, in GBs, used on the cloud archival location. The number of values in the list is specified by the value of the forecastPeriodInGranularityUnit parameter. Each value in the list is for the last day of the granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. First value corresponds to the last day of the first year. Second value corresponds to the last day of the second year. Third value corresponds to the last day of the third year.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storageUsedInGB")]
		public int[] StorageUsedInGB { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PerStorageClassCloudOutStorageForecastSummary
	{
		
		/// <summary>
		/// Storage class of the cloud archival location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storageClass")]
		public string StorageClass { get; set; }
		
		/// <summary>
		/// Storage costs, in USD, for a particular storage class in the cloud archival location. The list contains forecastPeriodInGranularityUnit values, one for each granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. The first value corresponds to the first year, the second value corresponds to the second year, and the third value corresponds to the third year.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storageCostInUSD")]
		public int[] StorageCostInUSD { get; set; }
		
		/// <summary>
		/// Storage values, in GBs, used on a particular storage class in the cloud archival location. The number of values in the list is specified by the value of the forecastPeriodInGranularityUnit parameter. Each value in the list is for the last day of the granularity period. For example, for a 3-year forecast period with a granularity of 'year', the list contains 3 values. First value corresponds to the last day of the first year. Second value corresponds to the last day of the second year. Third value corresponds to the last day of the third year.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storageUsedInGB")]
		public int[] StorageUsedInGB { get; set; }
	}
	
	/// <summary>
	/// The set of storage classes that support Cold tiering during smart or instant tiering.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CloudStorageColdTier
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AzureArchive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Glacier = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GlacierDeepArchive = 2,
	}
	
	/// <summary>
	/// Specifies the retrieval speed option when retrieving data from the cold storage tier to the hot storage tier for restore purposes. Rubrik cannot directly restore data from the cold storage tier and the data must be first retrieved into the hot storage tier. This is applicable only for AWS S3 and Azure archival locations. For AWS, three speed options are supported -- AwsExpedited, AwsStandard, and AwsBulk. AwsBulk is the cheapest and slowest. AwsExpedited is the fastest and most expensive. AwsStandard is the recommended default value. For Azure the only option is AzureStandard.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CloudStorageRehydrationSpeed
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsBulk = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsStandard = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsExpedited = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AzureStandard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterApiVersion
	{
		
		/// <summary>
		/// REST API version.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterCertificate
	{
		
		/// <summary>
		/// Cluster certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterGeolocation
	{
		
		/// <summary>
		/// Address information for mapping the location of the Rubrik cluster. This
		/// value is used to provide a location for the Rubrik cluster on the
		/// dashboard map.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterHostGroupInfo
	{
		
		/// <summary>
		/// Name of data center the compute cluster is a member of.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenterName")]
		public string DatacenterName { get; set; }
		
		/// <summary>
		/// Host groups configured in the compute cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostGroups")]
		public HostGroupInfo[] HostGroups { get; set; }
		
		/// <summary>
		/// Moid of the compute cluster. This is not the Rubrik managed id.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the compute cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostGroupInfo
	{
		
		/// <summary>
		/// ID of the host group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the host group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterInfo
	{
		
		/// <summary>
		/// Version of the EULA accepted by admin.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="acceptedEulaVersion")]
		public string AcceptedEulaVersion { get; set; }
		
		/// <summary>
		/// REST API version.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geolocation")]
		public ClusterGeolocation Geolocation { get; set; }
		
		/// <summary>
		/// ID of the Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Latest version of the EULA that must be accepted by admin.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latestEulaVersion")]
		public string LatestEulaVersion { get; set; }
		
		/// <summary>
		/// Name of the cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public ClusterTimezone Timezone { get; set; }
		
		/// <summary>
		/// Rubrik cluster software version.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterTimezone
	{
		
		/// <summary>
		/// Cluster time zone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public ClusterTimezoneTimezone Timezone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ClusterTimezoneTimezone
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Africa/Johannesburg")]
		Africa_Johannesburg = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Africa/Lagos")]
		Africa_Lagos = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Africa/Nairobi")]
		Africa_Nairobi = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Anchorage")]
		America_Anchorage = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Araguaina")]
		America_Araguaina = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Barbados")]
		America_Barbados = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Chicago")]
		America_Chicago = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Costa_Rica")]
		America_Costa_Rica = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Bogota")]
		America_Bogota = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Panama")]
		America_Panama = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Atikokan")]
		America_Atikokan = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Denver")]
		America_Denver = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Los_Angeles")]
		America_Los_Angeles = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Mexico_City")]
		America_Mexico_City = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/New_York")]
		America_New_York = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Noronha")]
		America_Noronha = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Phoenix")]
		America_Phoenix = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Santiago")]
		America_Santiago = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/St_Johns")]
		America_St_Johns = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Toronto")]
		America_Toronto = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="America/Vancouver")]
		America_Vancouver = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Bangkok")]
		Asia_Bangkok = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Dhaka")]
		Asia_Dhaka = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Dubai")]
		Asia_Dubai = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Hong_Kong")]
		Asia_Hong_Kong = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Karachi")]
		Asia_Karachi = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Kathmandu")]
		Asia_Kathmandu = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Kolkata")]
		Asia_Kolkata = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Magadan")]
		Asia_Magadan = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Singapore")]
		Asia_Singapore = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Asia/Tokyo")]
		Asia_Tokyo = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Atlantic/Cape_Verde")]
		Atlantic_Cape_Verde = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Australia/Adelaide")]
		Australia_Adelaide = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Australia/Brisbane")]
		Australia_Brisbane = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Australia/Perth")]
		Australia_Perth = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Australia/Sydney")]
		Australia_Sydney = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Europe/Amsterdam")]
		Europe_Amsterdam = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Europe/Athens")]
		Europe_Athens = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Europe/London")]
		Europe_London = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Europe/Moscow")]
		Europe_Moscow = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Pacific/Auckland")]
		Pacific_Auckland = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Pacific/Honolulu")]
		Pacific_Honolulu = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Pacific/Midway")]
		Pacific_Midway = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UTC = 43,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterUpdate
	{
		
		/// <summary>
		/// Version of the EULA accepted by admin. By modifying this attribute you
		/// agree to the specific version of the EULA. You can view the EULA from
		/// UI.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceptedEulaVersion")]
		public string AcceptedEulaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geolocation")]
		public ClusterGeolocation Geolocation { get; set; }
		
		/// <summary>
		/// New name for a Rubrik cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public ClusterTimezone Timezone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterVersion
	{
		
		/// <summary>
		/// Rubrik cluster software version.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterVisibilityConfig
	{
		
		/// <summary>
		/// Names of the host groups being protected.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostGroupFilter")]
		public string[] HostGroupFilter { get; set; }
		
		/// <summary>
		/// VMware managed object ID of the compute cluster. This is not the ID managed by Rubrik.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterVisibilityInfo : ClusterVisibilityConfig
	{
		
		/// <summary>
		/// Name of the compute cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CommunityUserCredentials
	{
		
		/// <summary>
		/// Password for the account used to login to the Rubrik community / self-serve website.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Username for the account used to login to the Rubrik community / self-serve website.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Specifies a number of snapshots. Compliance for each object is calculated for the most recent snapshots, up to the specified number.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ComplianceRangeFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastSnapshot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Last2Snapshots = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Last3Snapshots = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AllSnapshots = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComplianceSummarySLAV1
	{
		
		/// <summary>
		/// Number of objects in compliance based on the snapshot range filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numberOfInComplianceSnapshots")]
		public System.Nullable<System.Int64> NumberOfInComplianceSnapshots { get; set; }
		
		/// <summary>
		/// Number of objects out of compliance based on the snapshot range filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numberOfOutOfComplianceSnapshots")]
		public System.Nullable<System.Int64> NumberOfOutOfComplianceSnapshots { get; set; }
		
		/// <summary>
		/// Percent of objects in compliance based on the snapshot range filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentOfInComplianceSnapshots")]
		public System.Nullable<System.Double> PercentOfInComplianceSnapshots { get; set; }
		
		/// <summary>
		/// Percent of objects out of compliance based on the snapshot range filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentOfOutOfComplianceSnapshots")]
		public System.Nullable<System.Double> PercentOfOutOfComplianceSnapshots { get; set; }
		
		/// <summary>
		/// Specifies a number of snapshots. Compliance for each object is calculated for the most recent snapshots, up to the specified number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotRange")]
		public ComplianceRangeFilter SnapshotRange { get; set; }
		
		/// <summary>
		/// Total number of protected objects based on the snapshot range filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalProtected")]
		public System.Nullable<System.Int64> TotalProtected { get; set; }
		
		/// <summary>
		/// Status of compliance summary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedStatus")]
		public ComplianceSummarySLAV1UpdatedStatus UpdatedStatus { get; set; }
		
		/// <summary>
		/// The timestamp of the most recent successful update to the compliance summary stats.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatedTime")]
		public System.Nullable<System.DateTimeOffset> UpdatedTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ComplianceSummarySLAV1UpdatedStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updated = 1,
	}
	
	/// <summary>
	/// Status of compliance summary.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ComplianceSummaryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updated = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComplianceSummaryV1
	{
		
		/// <summary>
		/// Number of objects awaiting first full backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numberOfAwaitingFirstFullSnapshot")]
		public long NumberOfAwaitingFirstFullSnapshot { get; set; }
		
		/// <summary>
		/// Number of objects in compliance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numberOfInComplianceSnapshots")]
		public long NumberOfInComplianceSnapshots { get; set; }
		
		/// <summary>
		/// Number of objects out of compliance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numberOfOutOfComplianceSnapshots")]
		public long NumberOfOutOfComplianceSnapshots { get; set; }
		
		/// <summary>
		/// Percent of objects in compliance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="percentOfInComplianceSnapshots")]
		public double PercentOfInComplianceSnapshots { get; set; }
		
		/// <summary>
		/// Percent of objects out of compliance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="percentOfOutOfComplianceSnapshots")]
		public double PercentOfOutOfComplianceSnapshots { get; set; }
		
		/// <summary>
		/// Total number of protected objects.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="totalProtected")]
		public long TotalProtected { get; set; }
		
		/// <summary>
		/// Last updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatedTime")]
		public System.Nullable<System.DateTimeOffset> UpdatedTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComputeClusterDetail : ComputeClusterSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public VmwareHostSummary[] Hosts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="moid")]
		public string Moid { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualMachines")]
		public VirtualMachineSummary[] VirtualMachines { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareHostSummary : SlaAssignable
	{
		
		/// <summary>
		/// The ID of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectId")]
		public string EffectiveSlaSourceObjectId { get; set; }
		
		/// <summary>
		/// The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectName")]
		public string EffectiveSlaSourceObjectName { get; set; }
		
		/// <summary>
		/// Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualMachineSummary : Snappable
	{
		
		[System.Runtime.Serialization.DataMember(Name="agentStatus")]
		public AgentStatus AgentStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cloudInstantiationSpec")]
		public CloudInstantiationSpec CloudInstantiationSpec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clusterName")]
		public string ClusterName { get; set; }
		
		/// <summary>
		/// Brief info of all the objects in the folder path to this VM.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="folderPath")]
		public VmPathPoint[] FolderPath { get; set; }
		
		/// <summary>
		/// Status of authentication with a specific virtual machine using guest credentials. Possible values are: SUCCESSFUL, PENDING, or FAILED.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="guestCredentialAuthorizationStatus")]
		public string GuestCredentialAuthorizationStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="guestOsName")]
		public string GuestOsName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostName")]
		public string HostName { get; set; }
		
		/// <summary>
		/// Brief info of all the objects in the infrastructure path to this VM.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="infraPath")]
		public VmPathPoint[] InfraPath { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public bool IsRelic { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isReplicationEnabled")]
		public bool IsReplicationEnabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="moid")]
		public string Moid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="parentAppInfo")]
		public ParentAppInfo ParentAppInfo { get; set; }
		
		/// <summary>
		/// The power status of VM(ON,OFF,SLEEP etc.).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerStatus")]
		public string PowerStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protectionDate")]
		public System.Nullable<System.DateTimeOffset> ProtectionDate { get; set; }
		
		/// <summary>
		/// Consistency level mandated for this VM or empty string for none.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotConsistencyMandate")]
		public VirtualMachineSummarySnapshotConsistencyMandate SnapshotConsistencyMandate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="toolsInstalled")]
		public System.Nullable<System.Boolean> ToolsInstalled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vcenterId")]
		public string VcenterId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmwareToolsInstalled")]
		public bool VmwareToolsInstalled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmPathPoint
	{
		
		/// <summary>
		/// ID of the object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// (Deprecated) - See **id**.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="managedId")]
		public string ManagedId { get; set; }
		
		/// <summary>
		/// Name of the object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ParentAppInfo
	{
		
		/// <summary>
		/// ID assigned to the vApp object that manages a specified virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether a virtual machine is protected through the SLA Domain assigned to the parent vApp. Set to 'true' when the virtual machine is protected through the parent vApp, otherwise set to 'false'. Direct assignment of a virtual machine to an SLA Domain is not possible when this value is 'true'. Also, setting this value to true is not possible when the virtual machine has an existing direct assignment to an SLA Domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isProtectedThruHierarchy")]
		public bool IsProtectedThruHierarchy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VirtualMachineSummarySnapshotConsistencyMandate
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCONSISTENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CRASH_CONSISTENT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILE_SYSTEM_CONSISTENT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VSS_CONSISTENT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APP_CONSISTENT = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComputeClusterSummary : SlaAssignable
	{
		
		/// <summary>
		/// The ID of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectId")]
		public string EffectiveSlaSourceObjectId { get; set; }
		
		/// <summary>
		/// The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectName")]
		public string EffectiveSlaSourceObjectName { get; set; }
		
		/// <summary>
		/// Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComputeClusterSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ComputeClusterSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComputeClusterUpdate
	{
		
		/// <summary>
		/// The ID of the SLA Domain that is configured for this Compute Cluster. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
	}
	
	/// <summary>
	/// Source of configuration change.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConfigChangeSource
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CustomerApi = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrade = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResetNode = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Software = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Init = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigParam
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyName")]
		public string KeyName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="valName")]
		public string ValName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationSummary
	{
		
		/// <summary>
		/// The current value of the configuration option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentValue")]
		public string CurrentValue { get; set; }
		
		/// <summary>
		/// The default value, if any, for this configuration value for this release version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultValue")]
		public string DefaultValue { get; set; }
		
		/// <summary>
		/// The name of the configuration value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The configuration namespace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
		
		/// <summary>
		/// For local configuration options, the ID of the node. 'cluster' for cluster-wide configuration options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
		
		/// <summary>
		/// The timestamp specified in the input query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="onDate")]
		public System.Nullable<System.DateTimeOffset> OnDate { get; set; }
		
		/// <summary>
		/// Value of the configuration option at the requested time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="valueOnDate")]
		public string ValueOnDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ConfigurationSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationUpdateSummary
	{
		
		/// <summary>
		/// The username of the account that changed the value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiUser")]
		public string ApiUser { get; set; }
		
		/// <summary>
		/// JSON-serialized blob of metadata used to fetch information about the configuration update. For example, the upgrade version, previous state, etc.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configChangeMetadata")]
		public string ConfigChangeMetadata { get; set; }
		
		/// <summary>
		/// The timestamp of the change.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modifiedDateTime")]
		public System.Nullable<System.DateTimeOffset> ModifiedDateTime { get; set; }
		
		/// <summary>
		/// The name of the updated configuration option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The namespace of the updated configuration. Changes that do not begin with the string `local_` are cluster-wide changes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
		
		/// <summary>
		/// The value of the configuration option after the update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newValue")]
		public string NewValue { get; set; }
		
		/// <summary>
		/// The updated node. For cluster-wide configuration changes, this value is `all`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
		
		/// <summary>
		/// The original value of the configuration option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oldValue")]
		public string OldValue { get; set; }
		
		/// <summary>
		/// The source of the change.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationUpdateSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ConfigurationUpdateSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Specifies whether the SLA Domain is used for protection or retention.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConfiguredSlaType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ProtectionSla = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RetentionSla = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CorsConfiguration
	{
		
		/// <summary>
		/// The allowed headers as a comma separated string of values. The following headers are allowed by default: 'Accept', 'Accept-Language', 'Content-Language', 'and Content-Type'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedHeaders")]
		public string AllowedHeaders { get; set; }
		
		/// <summary>
		/// The allowed origins as a comma separated string of values. Use the special string '*' to allow any origin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedOrigins")]
		public string AllowedOrigins { get; set; }
		
		/// <summary>
		/// A Boolean value that indicates if CORS support is enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEnabled")]
		public bool IsEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CorsConfigurationPatch
	{
		
		/// <summary>
		/// The allowed headers as a comma separated string of values. The following headers are allowed by default: 'Accept', 'Accept-Language', 'Content-Language', 'and Content-Type'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedHeaders")]
		public string AllowedHeaders { get; set; }
		
		/// <summary>
		/// The allowed origins as a comma separated string of values. Use the special string '*' to allow any origin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedOrigins")]
		public string AllowedOrigins { get; set; }
		
		/// <summary>
		/// A Boolean value that indicates if CORS support is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEnabled")]
		public System.Nullable<System.Boolean> IsEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CountResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="count")]
		public long Count { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateNewVappParams
	{
		
		/// <summary>
		/// Name of the specified vApp within vCloud.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID assigned to the Organization VDC object that will contain the newly created vApp object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="orgVdcId")]
		public string OrgVdcId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVappNetworkParams : VappNetworkSummary
	{
		
		/// <summary>
		/// Name to assign to the vApp network that is referenced by the specified new vApp network object. If a name is specified, the Rubrik REST API server uses the name to rename the vApp network within the vCloud. If the value is empty, the vApp network is not renamed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newName")]
		public string NewName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CsrRequest
	{
		
		/// <summary>
		/// The city where the provided organization is located, for example, New York or London.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// The two-letter ISO code for the country where the provided organization is located, for example US, GB, or FR.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// An email address associated with the organization, if applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emailAddress")]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// A comma-separated list of host names that are associated with the certificate. This list accepts wildcard hostnames, such as '*.rubrik.example.com', in addition to fully-qualified domain names.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostnames")]
		public string[] Hostnames { get; set; }
		
		/// <summary>
		/// The name of the organization associated with the certificate, for example 'Rubrik, Inc.'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public string Organization { get; set; }
		
		/// <summary>
		/// The name of the organizational unit associated with the certificate, for example, Engineering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationUnit")]
		public string OrganizationUnit { get; set; }
		
		/// <summary>
		/// If applicable, the name of the state where the provided organization is located, for example, California.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// The surname associated with the certificate, if applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="surname")]
		public string Surname { get; set; }
		
		/// <summary>
		/// The user ID associated with the certificate, if applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uid")]
		public string Uid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CsrSummary
	{
		
		/// <summary>
		/// Base64 encoded PKCS#10 certificate signing request. The request should start with -----BEGIN CERTIFICATE REQUEST-----.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="csr")]
		public string Csr { get; set; }
		
		/// <summary>
		/// ID of the generated CSR.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="csrId")]
		public string CsrId { get; set; }
		
		/// <summary>
		/// A comma-separated list of host names that are associated with the certificate. This list accepts wildcard hostnames, such as '*.rubrik.example.com', in addition to fully-qualified domain names.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostnames")]
		public string[] Hostnames { get; set; }
		
		/// <summary>
		/// Display name for the generated CSR.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Subject line of the CSR.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public string Subject { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CsrSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public CsrSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DataCenterSummary : SlaAssignable
	{
		
		/// <summary>
		/// The ID of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectId")]
		public string EffectiveSlaSourceObjectId { get; set; }
		
		/// <summary>
		/// The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectName")]
		public string EffectiveSlaSourceObjectName { get; set; }
		
		/// <summary>
		/// Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DataGuardGroupMember
	{
		
		/// <summary>
		/// Unique name of the member Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dbUniqueName")]
		public string DbUniqueName { get; set; }
		
		/// <summary>
		/// Rubrik ID of the RAC on which this database is hosted. This field is empty when the database is not hosted on a RAC environment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="racId")]
		public string RacId { get; set; }
		
		/// <summary>
		/// Cluster name assigned to the Oracle RAC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="racName")]
		public string RacName { get; set; }
		
		/// <summary>
		/// Current role of the member Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// Rubrik ID of the standalone Oracle host on which this database is hosted. This field is empty when the database is not hosted on a standalone system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="standaloneHostId")]
		public string StandaloneHostId { get; set; }
		
		/// <summary>
		/// Name of the standalone Oracle database host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="standaloneHostName")]
		public string StandaloneHostName { get; set; }
	}
	
	/// <summary>
	/// Specifies whether this database is a Data Guard member, Data Guard group, or a non-Data Guard database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DataGuardType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DataGuardGroup = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DataGuardMember = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NonDataGuard = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DataStoreSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="capacity")]
		public System.Nullable<System.Int64> Capacity { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dataCenterName")]
		public string DataCenterName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dataStoreType")]
		public string DataStoreType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isLocal")]
		public System.Nullable<System.Boolean> IsLocal { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Type of database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DatabaseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Oracle = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SQL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DbLogReportProperties
	{
		
		/// <summary>
		/// Indicates whether the database log backup delay notification is enabled. Set to 'true' to send an email notification when the log backup delay is more than the configured threshold, and 'false' to disable the behavior.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enableDelayNotification")]
		public bool EnableDelayNotification { get; set; }
		
		/// <summary>
		/// The frequency for sending an email notification to the customer when the log backup delay is more than the threshold.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logDelayNotificationFrequencyInMin")]
		public long LogDelayNotificationFrequencyInMin { get; set; }
		
		/// <summary>
		/// The threshold for the delay in log backup before an email notification should be created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logDelayThresholdInMin")]
		public long LogDelayThresholdInMin { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DbLogReportPropertiesUpdate
	{
		
		/// <summary>
		/// Indicates whether the database log backup delay notification is enabled. Set to 'true' to send an email notification when the log backup delay is more than the configured threshold, and 'false' to disable the behavior.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableDelayNotification")]
		public System.Nullable<System.Boolean> EnableDelayNotification { get; set; }
		
		/// <summary>
		/// An integer that specifies an interval in minutes. Email notifications about the log backup delay exceeding the specified threshold are sent at a maximum frequency specified by the interval.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logDelayNotificationFrequencyInMin")]
		public System.Nullable<System.Int64> LogDelayNotificationFrequencyInMin { get; set; }
		
		/// <summary>
		/// An integer that specifies an interval in minutes. The CDM cluster sends an email notification when a log backup is delayed for longer than the specified interval.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logDelayThresholdInMin")]
		public System.Nullable<System.Int64> LogDelayThresholdInMin { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DbLogReportSummary
	{
		
		/// <summary>
		/// Type of database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="databaseType")]
		public DatabaseType DatabaseType { get; set; }
		
		/// <summary>
		/// ID of the SLA Domain controlling the database protection.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// Name of the SLA Domain controlling the database protection.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Time, in UTC, of the last database backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSnapshotTime")]
		public System.Nullable<System.DateTimeOffset> LastSnapshotTime { get; set; }
		
		/// <summary>
		/// Latest point in time, in UTC, to which the database can be restored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestRecoveryTime")]
		public System.Nullable<System.DateTimeOffset> LatestRecoveryTime { get; set; }
		
		/// <summary>
		/// Location of the customer database. For a standalone SQL database, this includes the host and instance name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Amount of time, in seconds, that has elapsed since the next expected log backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBackupDelay")]
		public System.Nullable<System.Int64> LogBackupDelay { get; set; }
		
		/// <summary>
		/// Frequency, in seconds, of the database log backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequency")]
		public System.Nullable<System.Int32> LogBackupFrequency { get; set; }
		
		/// <summary>
		/// Name of the database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the primary Rubrik cluster on which the database is located.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DbLogReportSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public DbLogReportSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Field used to sort when enumerating log report summary information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DbLogReportSummaryListSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		location = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		databaseType = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		logBackupFrequency = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lastSnapshotTime = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		latestRecoveryTime = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		logBackupDelay = 7,
	}
	
	/// <summary>
	/// Status of the task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DiagnosticTaskStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Queued = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Started = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Retried = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Succeeded = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisablePerLocationPause
	{
		
		/// <summary>
		/// Specifies whether to replicate snapshots taken during and before replication pause. When this value is 'true,' snapshots taken during and before the replication pause are not replicated. In all other cases, snapshots taken before and during the replication pause are replicated.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shouldSkipOldSnapshots")]
		public bool ShouldSkipOldSnapshots { get; set; }
		
		/// <summary>
		/// Replication from specified Rubrik clusters are resumed. Specified Rubrik clusters must be paused replication sources of local Rubrik cluster.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceClusterUuids")]
		public string[] SourceClusterUuids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiscoveredNasShare
	{
		
		/// <summary>
		/// The NFS export point or SMB share name for the NAS share.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exportPoint")]
		public string ExportPoint { get; set; }
		
		/// <summary>
		/// The type of NAS Share.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shareType")]
		public HostShareDetailShareType ShareType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DissolveLegalHoldDefinition
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotIds")]
		public string[] SnapshotIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DissolveLegalHoldResponse
	{
		
		/// <summary>
		/// List of snapshots whose legal hold have been successfully dissolved.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dissolvedSnapshotIds")]
		public string[] DissolvedSnapshotIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DownloadFileJobConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="legalHoldDownloadConfig")]
		public LegalHoldDownloadConfig LegalHoldDownloadConfig { get; set; }
		
		/// <summary>
		/// Absolute file path.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LegalHoldDownloadConfig
	{
		
		/// <summary>
		/// Specifies if the download action is in response to a Legal Hold. This download generates a SHA1 checksum of downloaded data that external bodies can use for integrity verification.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isLegalHoldDownload")]
		public bool IsLegalHoldDownload { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DownloadMssqlBackupFilesByIdJobConfig
	{
		
		/// <summary>
		/// A list of snapshots and logs to download.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public string[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="legalHoldDownloadConfig")]
		public LegalHoldDownloadConfig LegalHoldDownloadConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DownloadedSnapshotSlaAssignmentInfo
	{
		
		/// <summary>
		/// The managed ID of the object that owns the downloaded snapshots in the provided list.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		public string ObjectId { get; set; }
		
		/// <summary>
		/// The ID of the SLA Domain to assign to the provided list of downloaded snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slaDomainId")]
		public string SlaDomainId { get; set; }
		
		/// <summary>
		/// A list of snapshot IDs. The SLA Domain manages retention for the downloaded copy of the snapshots assigned to the snapshot IDs. If a snapshot in the list has no downloaded copy, its retention period remains unchanged.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotIds")]
		public string[] SnapshotIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EffectiveSlaHolder
	{
		
		/// <summary>
		/// The ID of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectId")]
		public string EffectiveSlaSourceObjectId { get; set; }
		
		/// <summary>
		/// The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectName")]
		public string EffectiveSlaSourceObjectName { get; set; }
		
		/// <summary>
		/// Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnablePerLocationPause
	{
		
		/// <summary>
		/// Specifies whether replication jobs are canceled immediately. When this value is 'true,' replication jobs will be canceled immediately. In all other cases, current running replication jobs will be allowed to finish before pausing.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shouldCancelImmediately")]
		public bool ShouldCancelImmediately { get; set; }
		
		/// <summary>
		/// Replication from specified Rubrik clusters are paused. Specified Rubrik clusters must be active replication sources of local Rubrik cluster.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceClusterUuids")]
		public string[] SourceClusterUuids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EncryptionStatus
	{
		
		/// <summary>
		/// Cipher method for encryption at rest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cipher")]
		public string Cipher { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether data on the cluster is encrypted at rest. When this value is 'true,' data stored on the cluster is encrypted. When this value is 'false,' data stored on the cluster is not encrypted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEncrypted")]
		public bool IsEncrypted { get; set; }
		
		/// <summary>
		/// Key length for encryption at rest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyLength")]
		public System.Nullable<System.Int32> KeyLength { get; set; }
		
		/// <summary>
		/// Key protection method for encryption at rest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyProtection")]
		public string KeyProtection { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnvoyBulkUpdate
	{
		
		/// <summary>
		/// ID assigned to a Rubrik Envoy object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updateProperties")]
		public EnvoyUpdate UpdateProperties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnvoyUpdate
	{
		
		/// <summary>
		/// IPv4 address of a specified Rubrik Envoy object that can be accessed by the specified Rubrik cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Rubrik cluster port assigned to the specified organization for tunnel connections to the Rubrik web UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnvoyCreate
	{
		
		/// <summary>
		/// IPv4 address of a specified Rubrik Envoy object that can be accessed by the specified Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Rubrik cluster port assigned to the specified organization for tunnel connections to the Rubrik web UI.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnvoyDetail
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnvoyDetailList
	{
		
		/// <summary>
		/// A list of detailed view of Rubrik Envoy objects.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="envoyDetails")]
		public EnvoyDetail[] EnvoyDetails { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnvoyIdList
	{
		
		/// <summary>
		/// A list of Rubrik Envoy objects IDs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="envoyIds")]
		public string[] EnvoyIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnvoySummary
	{
		
		/// <summary>
		/// ID assigned to a Rubrik Envoy object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IPv4 address of a specified Rubrik Envoy object that can be accessed by the specified Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// ID assigned to the organization object that is associated with the specified Rubrik Envoy object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// Rubrik cluster port assigned to the specified organization for tunnel connections to the Rubrik web UI.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Connection state of the specified Rubrik Envoy object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnvoyUserInfo
	{
		
		/// <summary>
		/// Password of a specified Rubrik Envoy object that can be used to access envoy vm.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Username of a specified Rubrik Envoy object that can be used to access envoy vm.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventCsvDownloadResponse
	{
		
		/// <summary>
		/// The requested after date filter, if applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="afterDate")]
		public System.Nullable<System.DateTimeOffset> AfterDate { get; set; }
		
		/// <summary>
		/// The serialized AfterId of the response, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="afterIdResponse")]
		public string AfterIdResponse { get; set; }
		
		/// <summary>
		/// The requested before date filter, if applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="beforeDate")]
		public System.Nullable<System.DateTimeOffset> BeforeDate { get; set; }
		
		/// <summary>
		/// The download link for the CSV file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloadLink")]
		public string DownloadLink { get; set; }
		
		/// <summary>
		/// Status of an event series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventSeriesStatus")]
		public ActivityLogSummaryV1EventSeriesStatus EventSeriesStatus { get; set; }
		
		/// <summary>
		/// Level of event's severity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventSeverity")]
		public EventSummaryV1EventSeverity EventSeverity { get; set; }
		
		/// <summary>
		/// Status of an event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventStatus")]
		public EventSummaryV1EventStatus EventStatus { get; set; }
		
		/// <summary>
		/// Type of an event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventType")]
		public System.Nullable<EventCsvDownloadResponseEventType> EventType { get; set; }
		
		/// <summary>
		/// The requested list of object ID to filter events, if applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectIds")]
		public string[] ObjectIds { get; set; }
		
		/// <summary>
		/// The requested object name filter, if applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectName")]
		public string ObjectName { get; set; }
		
		/// <summary>
		/// Type of the object associated with the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public EventSummaryV1ObjectType ObjectType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventCsvDownloadResponseEventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Archive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Audit = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthDomain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsEvent = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Backup = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Classification = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeSource = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeVm = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Configuration = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connection = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Conversion = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Diagnostic = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Discovery = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failover = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fileset = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hardware = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HostEvent = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervScvmm = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervServer = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Index = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Instantiate = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LegalHold = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Maintenance = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixCluster = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Recovery = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replication = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResourceOperations = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Storage = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArray = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StormResource = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Support = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TestFailover = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrade = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VCenter = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcd = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnknownEventType = 37,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventNotification
	{
		
		/// <summary>
		/// An event name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="event")]
		public EventNotificationEvent Event { get; set; }
		
		/// <summary>
		/// Timestamp of the event in ISO8601 format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.DateTimeOffset Time { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventNotificationEvent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		upgradeStart = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		periodicPrechecks = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stageCdmSoftware = 2,
	}
	
	/// <summary>
	/// Status of an event series.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventSeriesStatusV1
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceling = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SuccessWithWarnings = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventSeriesSummaryV1
	{
		
		/// <summary>
		/// The name of the archive target related to the archival task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archiveTargetName")]
		public string ArchiveTargetName { get; set; }
		
		/// <summary>
		/// The amount of data the job corresponding to the event needs to transfer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataToTransfer")]
		public System.Nullable<System.Int64> DataToTransfer { get; set; }
		
		/// <summary>
		/// The total amount of data that has been transferred by the event or job to date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataTransferred")]
		public System.Nullable<System.Int64> DataTransferred { get; set; }
		
		/// <summary>
		/// The current run time of the job that corresponds to the event series. For completed jobs, this time is equal to the total run time of the job (endTime - startTime). For an in-progress job, this time is equal to the Current Time minus the startTime. This field is empty for event series that do not correspond to a job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// For event series that correspond to a job, the time when the job finished. For a completed event series, the time of the last event in the series. This field is empty for jobs that have not completed or for event series that do not correspond to a job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		/// <summary>
		/// The estimated time remaining of the job that corresponds to the event series. This field is empty for event series that do not correspond to a job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="estimatedTimeRemaining")]
		public string EstimatedTimeRemaining { get; set; }
		
		/// <summary>
		/// List of the events in the event series.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventDetailList")]
		public EventSummaryV1[] EventDetailList { get; set; }
		
		/// <summary>
		/// The ID of event series.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventSeriesId")]
		public string EventSeriesId { get; set; }
		
		/// <summary>
		/// Status of an event series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventSeriesStatus")]
		public ActivityLogSummaryV1EventSeriesStatus EventSeriesStatus { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether the event series is linked to a job on the backend. When this value is 'true,' the event series is linked to a job on the backend. When this value is 'false,' the event series is not linked to a job on the backend.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasJob")]
		public bool HasJob { get; set; }
		
		/// <summary>
		/// A Boolean value that determines whether the job associated with the event is a first full snapshot backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isFirstFullSnapshot")]
		public System.Nullable<System.Boolean> IsFirstFullSnapshot { get; set; }
		
		/// <summary>
		/// Boolean value of true indicates an on demand job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isOnDemand")]
		public System.Nullable<System.Boolean> IsOnDemand { get; set; }
		
		/// <summary>
		/// Boolean that indicates whether an SLA Domain is Retention Locked. When the value is true the SLA Domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isSlaRetentionLocked")]
		public System.Nullable<System.Boolean> IsSlaRetentionLocked { get; set; }
		
		/// <summary>
		/// The host of the object associated with the latest event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// The logical size of the object related to the event series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logicalSize")]
		public System.Nullable<System.Int64> LogicalSize { get; set; }
		
		/// <summary>
		/// The IDs of the nodes where the job associated with the event is running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeIds")]
		public string NodeIds { get; set; }
		
		/// <summary>
		/// The number of times the job has been retried.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numberOfRetries")]
		public System.Nullable<System.Int64> NumberOfRetries { get; set; }
		
		/// <summary>
		/// The ID of the object associated with the latest event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		public string ObjectId { get; set; }
		
		/// <summary>
		/// The name of the object associated with the latest event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectName")]
		public string ObjectName { get; set; }
		
		/// <summary>
		/// Type of the object associated with the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public EventSummaryV1ObjectType ObjectType { get; set; }
		
		/// <summary>
		/// The progress percentage of the event series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progressPercentage")]
		public string ProgressPercentage { get; set; }
		
		/// <summary>
		/// The name of the remote cluster related to the replication task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteClusterName")]
		public string RemoteClusterName { get; set; }
		
		/// <summary>
		/// The ID of the SLA Domain associated with this job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slaId")]
		public string SlaId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain associated with the job, if any. This field is empty for jobs that are not driven by a SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slaName")]
		public string SlaName { get; set; }
		
		/// <summary>
		/// The time when the job started. Only applicable to the event series that correspond to a job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		/// <summary>
		/// Status of an event.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public EventSummaryV1EventStatus Status { get; set; }
		
		/// <summary>
		/// Type of the event series. Matches the event type.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="taskType")]
		public string TaskType { get; set; }
		
		/// <summary>
		/// The average rate of data transfer, measured in bytes per second. This rate is the total amount of data transferred divided by the total time required by the transfer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="throughput")]
		public System.Nullable<System.Int64> Throughput { get; set; }
		
		/// <summary>
		/// The username of the user-initiated job. This field is empty for jobs that are not user-initiated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Level of event's severity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventSeverityV1
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Critical = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Warning = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Informational = 2,
	}
	
	/// <summary>
	/// Status of an event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventStatusV1
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failure = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Warning = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Info = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Queued = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Success = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceling = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskSuccess = 8,
	}
	
	/// <summary>
	/// Type of an event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventTypeV1
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Archive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Audit = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthDomain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsEvent = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Backup = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Classification = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeSource = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeVm = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Configuration = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connection = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Conversion = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Diagnostic = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Discovery = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failover = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fileset = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hardware = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HostEvent = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervScvmm = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervServer = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Index = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Instantiate = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LegalHold = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Maintenance = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixCluster = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Recovery = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replication = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResourceOperations = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Storage = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArray = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StormResource = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Support = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TestFailover = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrade = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VCenter = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcd = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnknownEventType = 37,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventsAndSeriesSummariesResponse
	{
		
		/// <summary>
		/// List of the events.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events")]
		public EventSummaryV1[] Events { get; set; }
		
		/// <summary>
		/// The event series summaries of all events.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seriesSummaries")]
		public EventSeriesSummaryV1[] SeriesSummaries { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventsAndSeriesSummariesV1
	{
		
		/// <summary>
		/// Current cluster time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentTime")]
		public System.DateTimeOffset CurrentTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="data")]
		public EventsAndSeriesSummariesResponse Data { get; set; }
		
		/// <summary>
		/// Whether there are more events.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public bool HasMore { get; set; }
	}
	
	/// <summary>
	/// Example enum.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ExampleEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		value1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		value2 = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExclusionPatternCreateConfig
	{
		
		/// <summary>
		/// The pattern is used for existing and future snapshots. The pattern can be a regular expression or filename. Files or directories that match the pattern are not shown in the results of searches and are excluded from restore and download operations.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pattern")]
		public string Pattern { get; set; }
		
		/// <summary>
		/// ID of the protectable object to which the pattern applies.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExclusionPatternDetail
	{
		
		/// <summary>
		/// ID of the exclusion pattern.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Indicates if the exclusion pattern applies.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isActive")]
		public bool IsActive { get; set; }
		
		/// <summary>
		/// Specifies whether the pattern is mutable. When this value is false, the pattern can not be altered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isMutable")]
		public bool IsMutable { get; set; }
		
		/// <summary>
		/// The pattern is used for existing and future snapshots. The pattern can be a regular expression or filename. Files or directories that match the pattern are not shown in the results of searches and are excluded from restore and download operations.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pattern")]
		public string Pattern { get; set; }
		
		/// <summary>
		/// Status of the exclusion pattern. The 'Applied' state indicates that a pattern is already in force. The 'Applying' state indicates that the index job that applies the pattern is still running. The 'Queued' state indicates that the indexing job to apply the pattern has not launched yet.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="patternStatus")]
		public ExclusionPatternDetailPatternStatus PatternStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// ID of the protectable object to which the pattern applies.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ExclusionPatternDetailPatternStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Applied = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Applying = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Queued = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExclusionPatternDetailList
	{
		
		/// <summary>
		/// A list of exclusion pattern objects.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exclusionPatternDetails")]
		public ExclusionPatternDetail[] ExclusionPatternDetails { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExclusionPatternDetailListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ExclusionPatternDetail[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExclusionPatternUpdateConfig
	{
		
		/// <summary>
		/// Specifies whether or not the exclusion pattern applies. Only applicable to mutable patterns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isActive")]
		public System.Nullable<System.Boolean> IsActive { get; set; }
		
		/// <summary>
		/// Specifies whether the pattern is mutable. When this value is false, the pattern can not be altered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isMutable")]
		public System.Nullable<System.Boolean> IsMutable { get; set; }
		
		/// <summary>
		/// The pattern is used for existing and future snapshots. The pattern can be a regular expression or filename. Files or directories that match the pattern are not shown in the results of searches and are excluded from restore and download operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pattern")]
		public string Pattern { get; set; }
	}
	
	/// <summary>
	/// Specifies the retention policy to apply to existing snapshots when unprotecting an object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ExistingSnapshotRetention
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RetainSnapshots = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KeepForever = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExpireImmediately = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpiredCustomRetentionSnapshotInfo
	{
		
		/// <summary>
		/// The SLA Domain in effect at the time the snapshot was taken. Identical to the SLA Domain assigned to the data source at that time.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="birthSlaDomainName")]
		public string BirthSlaDomainName { get; set; }
		
		/// <summary>
		/// Timestamp that indicates when the snapshot expires from all cluster-managed locations.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalExpirationDate")]
		public System.DateTimeOffset GlobalExpirationDate { get; set; }
		
		/// <summary>
		/// The snapshot ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The most recent SLA Domain assigned to the snapshot. Snapshots expire based on the last known configuration for the assigned SLA Domain.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastSlaDomainName")]
		public string LastSlaDomainName { get; set; }
		
		/// <summary>
		/// Creation timestamp for the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotDate")]
		public System.DateTimeOffset SnapshotDate { get; set; }
	}
	
	/// <summary>
	/// Array containing information of snapshot which have been expired due to snapshot-level SLA domain assignments.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpiredCustomRetentionSnapshots
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotInfo")]
		public ExpiredCustomRetentionSnapshotInfo[] SnapshotInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportMssqlDbJobConfig
	{
		
		/// <summary>
		/// A Boolean value that determines whether an existing database can be overwritten by a database this is exported from a backup. Set to false to prevent overwrites. This is the default. Set to true to allow overwrites.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowOverwrite")]
		public System.Nullable<System.Boolean> AllowOverwrite { get; set; }
		
		/// <summary>
		/// A Boolean value that determines the recovery option to use during database restore. When this value is 'true', the database is restored using the RECOVERY option and is fully functional at the end of the restore operation. When this value is 'false', the database is restored using the NORECOVERY option and remains in recovering mode at the end of the restore operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="finishRecovery")]
		public System.Nullable<System.Boolean> FinishRecovery { get; set; }
		
		/// <summary>
		/// Maximum number of parallel data streams that can be used to copy data to the target system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxDataStreams")]
		public System.Nullable<System.Int32> MaxDataStreams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoveryPoint")]
		public MssqlRecoveryPoint RecoveryPoint { get; set; }
		
		/// <summary>
		/// The target path to store all data files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetDataFilePath")]
		public string TargetDataFilePath { get; set; }
		
		/// <summary>
		/// Name of the new database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetDatabaseName")]
		public string TargetDatabaseName { get; set; }
		
		/// <summary>
		/// One target path for each individual database file. Overrides targetDataFilePath and targetLogFilePath.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetFilePaths")]
		public MssqlDbFileExportPath[] TargetFilePaths { get; set; }
		
		/// <summary>
		/// ID of the Microsoft SQL instance for the new database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetInstanceId")]
		public string TargetInstanceId { get; set; }
		
		/// <summary>
		/// The target path to store all log files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetLogFilePath")]
		public string TargetLogFilePath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlRecoveryPoint
	{
		
		/// <summary>
		/// Recovery point specified in ISO8601 format, such as "2016-01-01T01:23:45.678".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lsnPoint")]
		public LsnRecoveryPoint LsnPoint { get; set; }
		
		/// <summary>
		/// Recovery point specified in the form of a timestamp (in milliseconds). Deprecated. Please use 'date' instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestampMs")]
		public System.Nullable<System.Int64> TimestampMs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LsnRecoveryPoint
	{
		
		/// <summary>
		/// LSN of the recovery point.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lsn")]
		public string Lsn { get; set; }
		
		/// <summary>
		/// Recovery fork GUID of the recovery point. If not provided, the recovery fork GUID of the latest snapshot is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recoveryForkGuid")]
		public string RecoveryForkGuid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbFileExportPath
	{
		
		/// <summary>
		/// The target path for the database file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exportPath")]
		public string ExportPath { get; set; }
		
		/// <summary>
		/// Logical name of the database file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logicalName")]
		public string LogicalName { get; set; }
		
		/// <summary>
		/// New filename for the database file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newFilename")]
		public string NewFilename { get; set; }
		
		/// <summary>
		/// New logical name for the database file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newLogicalName")]
		public string NewLogicalName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportSnapshotJobConfigV1 : MountExportSnapshotJobCommonOptions
	{
		
		/// <summary>
		/// ID of the datastore to assign to the exported virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datastoreId")]
		public string DatastoreId { get; set; }
		
		/// <summary>
		/// ID of the ESXi host to export the new virtual machine to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// The job recovers any tags that were assigned to the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldRecoverTags")]
		public System.Nullable<System.Boolean> ShouldRecoverTags { get; set; }
		
		/// <summary>
		/// Determines whether the new virtual machine created from a snapshot is registered with the vCenter Server. Use 'true' to remove the registration from vCenter Server. Use 'false' to keep the registration with the vCenter Server. The default is 'false'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unregisterVm")]
		public System.Nullable<System.Boolean> UnregisterVm { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterAppConfig
	{
		
		/// <summary>
		/// ID of the SLA Domain that is assigned to the specified failover cluster app. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failoverClusterAppSource")]
		public FailoverClusterAppSource FailoverClusterAppSource { get; set; }
		
		/// <summary>
		/// Cluster ID of the failover cluster app.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failoverClusterId")]
		public string FailoverClusterId { get; set; }
		
		/// <summary>
		/// Cluster type options for the failover cluster app.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failoverClusterType")]
		public FailoverClusterAppConfigFailoverClusterType FailoverClusterType { get; set; }
		
		/// <summary>
		/// Name of the failover cluster app.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterAppSource
	{
		
		/// <summary>
		/// Specifies an order for the failover cluster nodes. Failover cluster app backups use the failover cluster nodes in the specified order.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeOrders")]
		public FailoverClusterNodeOrder[] NodeOrders { get; set; }
		
		/// <summary>
		/// Virtual IP addresses of the failover cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualIps")]
		public string[] VirtualIps { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterNodeOrder
	{
		
		/// <summary>
		/// ID of the failover cluster node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
		
		/// <summary>
		/// The name of the failover cluster node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeName")]
		public string NodeName { get; set; }
		
		/// <summary>
		/// An integer that specifies the place occupied by this node in the failover cluster app backup order.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="order")]
		public int Order { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterAppConfigFailoverClusterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnixLike = 1,
	}
	
	/// <summary>
	/// Connection type options for the failover cluster app.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterAppConnectionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disconnected = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ReplicationTarget = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterAppDetail : FailoverClusterAppSummary
	{
		
		/// <summary>
		/// Fileset detail for the failover cluster app object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filesets")]
		public FilesetDetail[] Filesets { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetDetail : FilesetUpdate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterAppSummary : SlaAssignable
	{
		
		/// <summary>
		/// The ID of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectId")]
		public string EffectiveSlaSourceObjectId { get; set; }
		
		/// <summary>
		/// The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectName")]
		public string EffectiveSlaSourceObjectName { get; set; }
		
		/// <summary>
		/// Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterAppSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public FailoverClusterAppSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterConfig
	{
		
		/// <summary>
		/// ID of the SLA Domain that is assigned to the specified failover cluster. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// Managed ID's of Hosts of the failover cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostIds")]
		public string[] HostIds { get; set; }
		
		/// <summary>
		/// Name of the failover cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Connection type options for the failover cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterConnectionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disconnected = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PartiallyConnected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ReplicationTarget = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterDetail : FailoverClusterSummary
	{
		
		/// <summary>
		/// Count of the number of failover cluster apps.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numApps")]
		public int NumApps { get; set; }
		
		/// <summary>
		/// Count of the number of nodes on the failover cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numNodes")]
		public int NumNodes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterHierarchyObjectDescendentCount
	{
		
		[System.Runtime.Serialization.DataMember(Name="failoverCluster")]
		public System.Nullable<System.Int32> FailoverCluster { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="failoverClusterApp")]
		public System.Nullable<System.Int32> FailoverClusterApp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fileset")]
		public System.Nullable<System.Int32> Fileset { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for failover cluster hierarchy objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterHierarchyObjectSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterHierarchyObjectSummary : SlaAssignable
	{
		
		/// <summary>
		/// The ID of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectId")]
		public string EffectiveSlaSourceObjectId { get; set; }
		
		/// <summary>
		/// The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectName")]
		public string EffectiveSlaSourceObjectName { get; set; }
		
		/// <summary>
		/// Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterHierarchyObjectSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public FailoverClusterHierarchyObjectSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterNode
	{
		
		/// <summary>
		/// Connection type options for the failover cluster node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionStatus")]
		public FailoverClusterNodeConnectionStatus ConnectionStatus { get; set; }
		
		/// <summary>
		/// ID of the node in the failover cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the node in the failover cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Operating system of the node in the failover cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatingSystem")]
		public string OperatingSystem { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterNodeConnectionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connecting = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connected = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disconnected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleted = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ConnectorNotDeployed = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PartiallyConnected = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ReplicationTarget = 7,
	}
	
	/// <summary>
	/// Operating system of a specified machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterNodeOsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AIX = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SunOS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HPUX = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linux = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 5,
	}
	
	/// <summary>
	/// Types of object that can be present in the failover cluster hierarchy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FailoverClusterApp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fileset = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HostFailoverCluster = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsCluster = 3,
	}
	
	/// <summary>
	/// Operating system type of the failover cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterOsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AIX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HPUX = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linux = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SunOS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnixLike = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterSummary : SlaAssignable
	{
		
		/// <summary>
		/// The ID of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectId")]
		public string EffectiveSlaSourceObjectId { get; set; }
		
		/// <summary>
		/// The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectName")]
		public string EffectiveSlaSourceObjectName { get; set; }
		
		/// <summary>
		/// Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailoverClusterSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public FailoverClusterSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Cluster type options for the failover cluster app.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FailoverClusterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnixLike = 1,
	}
	
	/// <summary>
	/// The type of the file system on this Volume.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FileSystemType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NTFS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ReFS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileVersion
	{
		
		/// <summary>
		/// The type of file, either a regular file or a directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileMode")]
		public string FileMode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastModified")]
		public string LastModified { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// The snapshot this file belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotId")]
		public string SnapshotId { get; set; }
		
		/// <summary>
		/// The location where the file is stored, either in the cloud or locally.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetArraySpec
	{
		
		/// <summary>
		/// ID assigned to a proxy host for array-enabled backups. This property is only required for array-enabled backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHostId")]
		public string ProxyHostId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetCreate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetDownloadFileJobConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="legalHoldDownloadConfig")]
		public LegalHoldDownloadConfig LegalHoldDownloadConfig { get; set; }
		
		/// <summary>
		/// Source directory to download from.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDir")]
		public string SourceDir { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetExportFileJobConfig : FilesetRestoreFileJobConfig
	{
		
		/// <summary>
		/// Host ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// Network share ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shareId")]
		public string ShareId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetOptions
	{
		
		/// <summary>
		/// Include or exclude hidden folders inside locally-mounted remote file systems from backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowBackupHiddenFoldersInNetworkMounts")]
		public System.Nullable<System.Boolean> AllowBackupHiddenFoldersInNetworkMounts { get; set; }
		
		/// <summary>
		/// Include or exclude locally-mounted remote file systems from backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowBackupNetworkMounts")]
		public System.Nullable<System.Boolean> AllowBackupNetworkMounts { get; set; }
		
		/// <summary>
		/// Use VSS during Windows backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useWindowsVss")]
		public System.Nullable<System.Boolean> UseWindowsVss { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetRestoreFileJobConfig
	{
		
		/// <summary>
		/// Destination directory.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDir")]
		public string DestinationDir { get; set; }
		
		/// <summary>
		/// Optional field to determine if we should ignore single error during restore. Default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ignoreErrors")]
		public System.Nullable<System.Boolean> IgnoreErrors { get; set; }
		
		/// <summary>
		/// Source directory to restore from.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDir")]
		public string SourceDir { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetSnapshotDetail : FilesetSnapshotSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastModified")]
		public string LastModified { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public long Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="verbose")]
		public FilesetSnapshotVerbose Verbose { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetSnapshotVerbose
	{
		
		/// <summary>
		/// Whether or not the fileset snapshot has fingerprint info.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasFingerprint")]
		public bool HasFingerprint { get; set; }
		
		/// <summary>
		/// List a partition paths for the fileset snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="partitionPaths")]
		public string[] PartitionPaths { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetSnapshotSummary : BaseSnapshotSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="fileCount")]
		public System.Nullable<System.Int64> FileCount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filesetName")]
		public string FilesetName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snapdiffUsed")]
		public System.Nullable<System.Boolean> SnapdiffUsed { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetSummary : FilesetOptions
	{
		
		/// <summary>
		/// The ID of the SLA Domain configured directly on the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain configured directly on the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainName")]
		public string ConfiguredSlaDomainName { get; set; }
		
		/// <summary>
		/// Specifies whether the SLA Domain is used for protection or retention.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainType")]
		public ConfiguredSlaType ConfiguredSlaDomainType { get; set; }
		
		/// <summary>
		/// The ID of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Indicates whether the configured SLA Domain is Retention Locked. When this value is 'true', the configured SLA Domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isConfiguredSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsConfiguredSlaDomainRetentionLocked { get; set; }
		
		/// <summary>
		/// The name of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the cluster that manages the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// The UTC time when the SLA Domain was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slaLastUpdateTime")]
		public System.Nullable<System.DateTimeOffset> SlaLastUpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public FilesetSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetTemplateCreate : FilesetOptions
	{
		
		/// <summary>
		/// Action taken if script fails. Options are "abort", "continue".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backupScriptErrorHandling")]
		public string BackupScriptErrorHandling { get; set; }
		
		/// <summary>
		/// Number of seconds after which the script is killed if it has not completed execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backupScriptTimeout")]
		public System.Nullable<System.Int64> BackupScriptTimeout { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceptions")]
		public string[] Exceptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="includes")]
		public string[] Includes { get; set; }
		
		/// <summary>
		/// Boolean value that determines whether the fileset is array-enabled. Set to true to indicate that the fileset is array-enabled. Set to false to indicate that the fileset is not array-enabled. When a fileset is array-enabled, the includes must be top-level LVM logical volume mount points.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isArrayEnabled")]
		public System.Nullable<System.Boolean> IsArrayEnabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Operating system type of filesets created by template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystemType")]
		public System.Nullable<FilesetTemplateCreateOperatingSystemType> OperatingSystemType { get; set; }
		
		/// <summary>
		/// Script to run after backup of this fileset ends.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postBackupScript")]
		public string PostBackupScript { get; set; }
		
		/// <summary>
		/// Script to run before backup of this fileset starts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preBackupScript")]
		public string PreBackupScript { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shareType")]
		public HostShareDetailShareType ShareType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FilesetTemplateCreateOperatingSystemType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnixLike = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetTemplateDetail : FilesetTemplateCreate
	{
		
		/// <summary>
		/// Number of hosts where this template has been applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostCount")]
		public System.Nullable<System.Int32> HostCount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isArchived")]
		public System.Nullable<System.Boolean> IsArchived { get; set; }
		
		/// <summary>
		/// Specifies whether this is created by a Kupr Host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isCreatedByKupr")]
		public System.Nullable<System.Boolean> IsCreatedByKupr { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// Number of shares where this template has been applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shareCount")]
		public System.Nullable<System.Int32> ShareCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetTemplateDetailListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public FilesetTemplateDetail[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetTemplatePatch : FilesetOptions
	{
		
		/// <summary>
		/// Action taken if script fails. Options are "abort", "continue".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backupScriptErrorHandling")]
		public string BackupScriptErrorHandling { get; set; }
		
		/// <summary>
		/// Number of seconds after which the script is killed if it has not completed execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backupScriptTimeout")]
		public System.Nullable<System.Int64> BackupScriptTimeout { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceptions")]
		public string[] Exceptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="includes")]
		public string[] Includes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Operating system type of filesets created by template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystemType")]
		public FilesetTemplateCreateOperatingSystemType OperatingSystemType { get; set; }
		
		/// <summary>
		/// Script to run after backup of this Fileset ends.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postBackupScript")]
		public string PostBackupScript { get; set; }
		
		/// <summary>
		/// Script to run before backup of this Fileset starts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preBackupScript")]
		public string PreBackupScript { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shareType")]
		public HostShareDetailShareType ShareType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilesetUpdate
	{
		
		/// <summary>
		/// Assign Fileset to SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// Whether to force a full on the whole fileset or certain partitions of the fileset. If this is set to true and no partitionIds are provided, then a full will be forced on the whole fileset. If set to true and partitionIds are provided, then we will force a full on only those partitions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceFull")]
		public System.Nullable<System.Boolean> ForceFull { get; set; }
		
		/// <summary>
		/// Assign partition ids to set the force full. In order for this to be valid input, forceFull must be set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceFullPartitionIds")]
		public int[] ForceFullPartitionIds { get; set; }
		
		/// <summary>
		/// Rubrik CDM uses a prefix match to select the latest SnapMirror snapshot that matches this value during a full backup of a SnapMirror destination share.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapMirrorLabelForFullBackup")]
		public string SnapMirrorLabelForFullBackup { get; set; }
		
		/// <summary>
		/// Rubrik CDM selects the latest SnapMirror snapshot that matches this value using a prefix match during an incremental backup of a SnapMirror destination share.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapMirrorLabelForIncrementalBackup")]
		public string SnapMirrorLabelForIncrementalBackup { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FipsStatus
	{
		
		/// <summary>
		/// Boolean that specifies whether FIPS mode is enabled for in-flight encryption. When this value is true, FIPS mode is enabled for in-flight data encryption.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEnabledInFlight")]
		public bool IsEnabledInFlight { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FipsStatusPatch
	{
		
		/// <summary>
		/// Boolean that specifies whether FIPS mode is enabled for in-flight encryption. When this value is true, FIPS mode is enabled for in-flight data encryption.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEnabledInFlight")]
		public System.Nullable<System.Boolean> IsEnabledInFlight { get; set; }
	}
	
	/// <summary>
	/// Information to request a forced full snapshot for a volume within a Volume Group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForceFullVolumeInfo
	{
		
		/// <summary>
		/// Specifies whether deduplication should be enabled for the forced full snapshot of the Volume. When set to true, deduplication is performed against local data on the cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shouldDedupe")]
		public bool ShouldDedupe { get; set; } = true;
		
		/// <summary>
		/// The unique ID of the volume within the Volume Group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	/// <summary>
	/// Filter to perform forecasts, with or without archival consolidation enabled.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ForecastConsolidationFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForecastWithConsolidation = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForecastWithoutConsolidation = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForecastWithAndWithoutConsolidation = 2,
	}
	
	/// <summary>
	/// Granularity of the cloud utilization forecast.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ForecastGranularity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Quarter = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Year = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FullyQualifiedDomainNameInfo
	{
		
		/// <summary>
		/// Fully qualified domain name where the filter should be hosted for install/upgrade operations.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GenericCsrRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="csrRequest")]
		public CsrRequest CsrRequest { get; set; }
		
		/// <summary>
		/// Display name for the generated CSR.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalBlackoutWindowStatus
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isGlobalBlackoutActive")]
		public bool IsGlobalBlackoutActive { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsBaseConfig
	{
		
		/// <summary>
		/// API token to access Hdfs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiToken")]
		public string ApiToken { get; set; }
		
		/// <summary>
		/// List of Hdfs Namenode Hosts.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public HdfsHost[] Hosts { get; set; }
		
		/// <summary>
		/// Ticket Cache Path of Kerberos Ticket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kerberosTicket")]
		public string KerberosTicket { get; set; }
		
		/// <summary>
		/// Logical name for nameservice for Hdfs HA.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservices")]
		public string Nameservices { get; set; }
		
		/// <summary>
		/// Username to access Hdfs API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsHost
	{
		
		/// <summary>
		/// Hostname or Ip of Namenode.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Port number of Namenode.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsConfig
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsCreate
	{
		
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="templateId")]
		public string TemplateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsDetail : HdfsUpdate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsExportFileJobConfig : HdfsRestoreFileJobConfig
	{
		
		/// <summary>
		/// Host ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsRestoreFileJobConfig
	{
		
		/// <summary>
		/// The destination directory.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDir")]
		public string DestinationDir { get; set; }
		
		/// <summary>
		/// An optional Boolean that determines whether to ignore single errors during the restore process. When this value is 'true', single errors are ignored. This field is 'false' by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldIgnoreErrors")]
		public System.Nullable<System.Boolean> ShouldIgnoreErrors { get; set; }
		
		/// <summary>
		/// The source directory being restored.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDir")]
		public string SourceDir { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsSnapshotDetail : HdfsSnapshotSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastModified")]
		public System.DateTimeOffset LastModified { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public long Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsSnapshotSummary : BaseSnapshotSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="fileCount")]
		public System.Nullable<System.Int64> FileCount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hdfsName")]
		public string HdfsName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsSummary : SlaAssignable
	{
		
		/// <summary>
		/// The ID of the effective SLA Domain for a HDFS directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the effective SLA Domain for this HDFS directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// An optional field that contains the Polaris managed ID of the effective SLA Domain. Only applicable to SLA Domains managed by Polaris.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceptions")]
		public string[] Exceptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostName")]
		public string HostName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="includes")]
		public string[] Includes { get; set; }
		
		/// <summary>
		/// An optional Boolean value that specifies whether the effective SLA Domain of a HDFS directory is Retention Locked. When this value is 'true,' the SLA Domain is retention locked. When this value is 'false,' the SLA Domain is not Retention Locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public bool IsRelic { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="templateId")]
		public string TemplateId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="templateName")]
		public string TemplateName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HdfsSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsTemplateCreate
	{
		
		[System.Runtime.Serialization.DataMember(Name="exceptions")]
		public string[] Exceptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="includes")]
		public string[] Includes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsTemplateDetail : HdfsTemplateCreate
	{
		
		/// <summary>
		/// Number of hosts where this template has been applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostCount")]
		public System.Nullable<System.Int32> HostCount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsTemplateDetailListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HdfsTemplateDetail[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsTemplatePatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="exceptions")]
		public string[] Exceptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="includes")]
		public string[] Includes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HdfsUpdate
	{
		
		/// <summary>
		/// Assign HDFS to SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthMonitorPolicy
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="causes")]
		public string[] Causes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configParams")]
		public ConfigParam[] ConfigParams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dependencies")]
		public string[] Dependencies { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEnabled")]
		public bool IsEnabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isHidden")]
		public bool IsHidden { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kbInfo")]
		public string KbInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notificationConfig")]
		public NotificationConfig NotificationConfig { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyId")]
		public string PolicyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyName")]
		public string PolicyName { get; set; }
		
		/// <summary>
		/// Type of policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyType")]
		public HealthMonitorPolicyPolicyType PolicyType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remedies")]
		public string[] Remedies { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runInState")]
		public NodeStatusEnum[] RunInState { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheduleFreqInSec")]
		public long ScheduleFreqInSec { get; set; }
		
		/// <summary>
		/// Scope of a policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public HealthMonitorPolicyScope Scope { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="script")]
		public string Script { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="criticalDetails")]
		public NotificationDetails CriticalDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="infoDetails")]
		public NotificationDetails InfoDetails { get; set; }
		
		/// <summary>
		/// Name of notification config.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notification Message.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationMessage")]
		public string NotificationMessage { get; set; }
		
		/// <summary>
		/// Notification type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationType")]
		public NotificationConfigNotificationType NotificationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="warnDetails")]
		public NotificationDetails WarnDetails { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="action")]
		public ActionDetails Action { get; set; }
		
		/// <summary>
		/// Window to check for number of failures.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failureWindow")]
		public long FailureWindow { get; set; }
		
		/// <summary>
		/// Number of failures before notification is triggered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numFailures")]
		public int NumFailures { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NotificationConfigNotificationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOTIFICATION_TYPE_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIAGNOSTIC = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HealthMonitorPolicyPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POLICY_TYPE_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHECKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLLECTOR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOTIFIER = 3,
	}
	
	/// <summary>
	/// Node status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NodeStatusEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BAD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRE_MAINTENANCE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAINTENANCE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOOTSTRAPPING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPGRADE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REMOVED = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HealthMonitorPolicyScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POLICY_SCOPE_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NODE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLUSTER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHASSIS = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HierarchyObjectIds
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	/// <summary>
	/// Defines the boolean type for host configuration. 'Enabled' specifies true, 'Disabled' specifies False, and 'Default' specifies to delete the entry and default to the global configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostConfigurationPropertyEnabled
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Default = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostDetail : HostSummary
	{
		
		/// <summary>
		/// ID of the Rubrik Backup Service (RBS) installed on the host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="agentId")]
		public string AgentId { get; set; }
		
		/// <summary>
		/// Indicates if compression is enabled while transferring data between the host and the Rubrik cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compressionEnabled")]
		public System.Nullable<System.Boolean> CompressionEnabled { get; set; }
		
		/// <summary>
		/// VFD host install state.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostVfdDriverState")]
		public HostDetailHostVfdDriverState HostVfdDriverState { get; set; }
		
		/// <summary>
		/// VFD host support status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostVfdEnabled")]
		public System.Nullable<HostDetailHostVfdEnabled> HostVfdEnabled { get; set; }
		
		/// <summary>
		/// Specifies whether this is an Oracle host. This indicates whether to show Oracle discovery fields in the UI.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isOracleHost")]
		public System.Nullable<System.Boolean> IsOracleHost { get; set; }
		
		/// <summary>
		/// A relic host is deleted, but still may have snapshots associated with its children (e.g. Fileset).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public bool IsRelic { get; set; }
		
		/// <summary>
		/// Indicates if the CBT driver is installed for SQL Server instances on the specified Windows host. Set to true when the CBT driver is installed. Set to false when the CBT driver is not installed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mssqlCbtDriverInstalled")]
		public bool MssqlCbtDriverInstalled { get; set; }
		
		/// <summary>
		/// Specifies the Oracle username for an account with query privileges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleQueryUser")]
		public string OracleQueryUser { get; set; }
		
		/// <summary>
		/// Specifies the Oracle username for an account with sysdba privileges.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleSysDbaUser")]
		public string OracleSysDbaUser { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostDetailHostVfdDriverState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotInstalled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Installed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		InstalledButRestartRequired = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UninstalledButRestartRequired = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostDetailHostVfdEnabled
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
	}
	
	/// <summary>
	/// Status of Rubrik Io Filter on Hosts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostFilterStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Installed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnsupportedByVmware = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OutOfDate = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PastExpectedDate = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Uninstalled = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostHierarchyObjectDescendantCount
	{
		
		/// <summary>
		/// Number of descendant share objects in a specified hierarchy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="share")]
		public System.Nullable<System.Int32> Share { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for host/share hierarchy objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostHierarchyObjectSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Status = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Name = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExportPoint = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareType = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hostname = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostHierarchyObjectSummary
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostHierarchyObjectSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HostHierarchyObjectSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostInfo
	{
		
		/// <summary>
		/// Name of the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// The managed id of the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Oracle discovery user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="oracleQueryUser")]
		public string OracleQueryUser { get; set; }
		
		/// <summary>
		/// Oracle sysdba user to use on the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="oracleSysDbaUser")]
		public string OracleSysDbaUser { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostMakePrimaryRequest
	{
		
		/// <summary>
		/// IDs of hosts to migrate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// For all hosts and virtual machines registered with this cluster, make itself the primary if the current primary is oldPrimaryClusterUuid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oldPrimaryClusterUuid")]
		public string OldPrimaryClusterUuid { get; set; }
	}
	
	/// <summary>
	/// Types of object that can be present in the host/share hierarchy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Host = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Share = 1,
	}
	
	/// <summary>
	/// The host operating system type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostOperatingSystemType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnixLike = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 3,
	}
	
	/// <summary>
	/// The status of the Rubrik Backup Service on the host.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostRbsStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Installed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotInstalled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disconnected = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostRegister
	{
		
		/// <summary>
		/// A user-specified string that returns this host in searches.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alias")]
		public string Alias { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hasAgent")]
		public System.Nullable<System.Boolean> HasAgent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hdfsConfig")]
		public HdfsConfig HdfsConfig { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether to discover Oracle information at registration. A value of 'true' discovers Oracle information at registration.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isOracleHost")]
		public System.Nullable<System.Boolean> IsOracleHost { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nasConfig")]
		public NasConfig NasConfig { get; set; }
		
		/// <summary>
		/// Specifies the Oracle username for an account with query privileges. The account must have query privileges for a specified Oracle installation to enable Oracle discovery queries for that installation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleQueryUser")]
		public string OracleQueryUser { get; set; }
		
		/// <summary>
		/// Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleSysDbaUser")]
		public string OracleSysDbaUser { get; set; }
		
		/// <summary>
		/// The ID of the organization to which the host is assigned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NasConfig
	{
		
		/// <summary>
		/// TLS certification to validate NAS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiCertificate")]
		public string ApiCertificate { get; set; }
		
		/// <summary>
		/// API endpoint to access NAS API 'FLASHBLADE'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiEndpoint")]
		public string ApiEndpoint { get; set; }
		
		/// <summary>
		/// Hostname or IP used in the NAS API calls.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiHostname")]
		public string ApiHostname { get; set; }
		
		/// <summary>
		/// Password to access NAS API 'ISILON/NETAPP'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiPassword")]
		public string ApiPassword { get; set; }
		
		/// <summary>
		/// API token to access NAS API 'FLASHBLADE'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiToken")]
		public string ApiToken { get; set; }
		
		/// <summary>
		/// Username to access NAS API 'ISILON/NETAPP'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiUsername")]
		public string ApiUsername { get; set; }
		
		/// <summary>
		/// Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isIsilonChangelistEnabled")]
		public System.Nullable<System.Boolean> IsIsilonChangelistEnabled { get; set; }
		
		/// <summary>
		/// Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isNetAppSnapDiffEnabled")]
		public System.Nullable<System.Boolean> IsNetAppSnapDiffEnabled { get; set; }
		
		/// <summary>
		/// Specifies whether shares on the NAS host are automatically discovered. When this value is 'true', Rubrik periodically (every 30 minutes by default) connects to the NAS host to discover NFS and SMB shares.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isShareAutoDiscoveryEnabled")]
		public System.Nullable<System.Boolean> IsShareAutoDiscoveryEnabled { get; set; }
		
		/// <summary>
		/// Type of NAS vendor 'ISILON/NETAPP/FLASHBLADE'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vendorType")]
		public string VendorType { get; set; }
		
		/// <summary>
		/// Name of the Isilon zone that data IP belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zoneName")]
		public string ZoneName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostSharePatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exportPoint")]
		public string ExportPoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostShareParameters")]
		public HostShareParameters HostShareParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostShareUpdate
	{
		
		/// <summary>
		/// ID of the network share.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shareId")]
		public string ShareId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updateProperties")]
		public HostSharePatch UpdateProperties { get; set; }
	}
	
	/// <summary>
	/// The NAS vendor for the host share.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostShareVendorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Isilon = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NetApp = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FlashBlade = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostSummary
	{
		
		/// <summary>
		/// A user-specified string that returns this host in searches.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alias")]
		public string Alias { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hdfsBaseConfig")]
		public HdfsBaseConfig HdfsBaseConfig { get; set; }
		
		/// <summary>
		/// Deprecated. Please use 'name' instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Unique identifier for host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Effective CBT host status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mssqlCbtEffectiveStatus")]
		public System.Nullable<HostSummaryMssqlCbtEffectiveStatus> MssqlCbtEffectiveStatus { get; set; }
		
		/// <summary>
		/// CBT host support status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mssqlCbtEnabled")]
		public HostConfigurationPropertyEnabled MssqlCbtEnabled { get; set; }
		
		/// <summary>
		/// IP address or hostname of the host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nasBaseConfig")]
		public NasBaseConfig NasBaseConfig { get; set; }
		
		/// <summary>
		/// Operating system of the host. One of Windows, Linux, AIX, HPUX, and SunOS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystem")]
		public string OperatingSystem { get; set; }
		
		/// <summary>
		/// The operating system of the host. Possible choices are Windows, Linux, AIX, HPUX, SunOS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystemType")]
		public string OperatingSystemType { get; set; }
		
		/// <summary>
		/// The ID of the organization to which the host is assigned (set by envoy).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// The name of the organization to which the host is assigned (set by envoy).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationName")]
		public string OrganizationName { get; set; }
		
		/// <summary>
		/// ID of the Rubrik cluster to which the host belongs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// Specifies the connect status for the host. Status is Refreshing while discovery is running or Connected once discovery was successful and the host is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostSummaryMssqlCbtEffectiveStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		On = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Off = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OnDefault = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OffDefault = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NasBaseConfig
	{
		
		/// <summary>
		/// TLS certification to validate NAS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiCertificate")]
		public string ApiCertificate { get; set; }
		
		/// <summary>
		/// API endpoint to access NAS API 'FLASHBLADE'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiEndpoint")]
		public string ApiEndpoint { get; set; }
		
		/// <summary>
		/// Hostname or IP used in the NAS API calls.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiHostname")]
		public string ApiHostname { get; set; }
		
		/// <summary>
		/// Username to access NAS API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiUsername")]
		public string ApiUsername { get; set; }
		
		/// <summary>
		/// Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isIsilonChangelistEnabled")]
		public System.Nullable<System.Boolean> IsIsilonChangelistEnabled { get; set; }
		
		/// <summary>
		/// Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isNetAppSnapDiffEnabled")]
		public System.Nullable<System.Boolean> IsNetAppSnapDiffEnabled { get; set; }
		
		/// <summary>
		/// Specifies whether shares on the NAS host are automatically discovered. When this value is 'true', Rubrik periodically (every 30 minutes by default) connects to the NAS host to discover NFS and SMB shares.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isShareAutoDiscoveryEnabled")]
		public System.Nullable<System.Boolean> IsShareAutoDiscoveryEnabled { get; set; }
		
		/// <summary>
		/// Type of NAS vendor 'ISILON/NETAPP/FLASHBLADE'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vendorType")]
		public string VendorType { get; set; }
		
		/// <summary>
		/// Name of the Isilon zone that data IP belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zoneName")]
		public string ZoneName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HostSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Status of Rubrik Io Filter on ESX Host.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostUiFilterStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ok = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		InstallInProgress = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UninstallInProgress = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpgradeInProgress = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpgradeNeeded = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RetryInstall = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CheckVcenter = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorContactSupport = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorMaintenanceMode = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NoFilter = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnsupportedByVmware = 11,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostUpdate
	{
		
		/// <summary>
		/// A user-specified string that returns this host in searches.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alias")]
		public string Alias { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="compressionEnabled")]
		public System.Nullable<System.Boolean> CompressionEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hdfsConfig")]
		public HdfsConfig HdfsConfig { get; set; }
		
		/// <summary>
		/// When VFD is disabled on the specified Windows host, set this property to false to instruct the Rubrik cluster to remove the VFD driver from a specified Windows host. Before using this property, disable VFD on the specified Windows host by setting the value of HostVfdEnabled to Disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostVfdDriverInstalled")]
		public System.Nullable<System.Boolean> HostVfdDriverInstalled { get; set; }
		
		/// <summary>
		/// VFD host support status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostVfdEnabled")]
		public HostDetailHostVfdEnabled HostVfdEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether to discover Oracle information during host refresh. A value of 'true' discovers Oracle information during host refresh.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isOracleHost")]
		public System.Nullable<System.Boolean> IsOracleHost { get; set; }
		
		/// <summary>
		/// When CBT is disabled on the specified Windows host, set this property to false to instruct the Rubrik cluster to remove the CBT driver from a specified Windows host. Before using this property, disable CBT on the specified Windows host by setting the value of mssqlCbtEnabled to Disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mssqlCbtDriverInstalled")]
		public System.Nullable<System.Boolean> MssqlCbtDriverInstalled { get; set; }
		
		/// <summary>
		/// CBT host support status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mssqlCbtEnabled")]
		public HostConfigurationPropertyEnabled MssqlCbtEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nasConfig")]
		public NasConfig NasConfig { get; set; }
		
		/// <summary>
		/// Specifies the Oracle username for an account with query privileges. The account must have query privileges for a specified Oracle installation to enable Oracle discovery queries for that installation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleQueryUser")]
		public string OracleQueryUser { get; set; }
		
		/// <summary>
		/// Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleSysDbaUser")]
		public string OracleSysDbaUser { get; set; }
	}
	
	/// <summary>
	/// VFD host support status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostVfdInstallConfig
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
	}
	
	/// <summary>
	/// VFD host install state.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HostVfdState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotInstalled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Installed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		InstalledButRestartRequired = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UninstalledButRestartRequired = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostVolumeSummary : VolumeGroupSnapshotVolumeSummary
	{
		
		/// <summary>
		/// Indicates whether a volume is present on the host. When 'true', the volume is present. When 'false', the volume is not present. Volumes that are not present on the host are still included in snapshots and trigger warnings until the missing volumes are excluded from snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isCurrentlyPresentOnSystem")]
		public bool IsCurrentlyPresentOnSystem { get; set; }
		
		/// <summary>
		/// The unique ID of the volume on the Windows host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="naturalId")]
		public string NaturalId { get; set; }
		
		/// <summary>
		/// The unique ID of the Volume Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeGroupId")]
		public string VolumeGroupId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostVolumeSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HostVolumeSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HotAddBandwidthInfo
	{
		
		/// <summary>
		/// The HotAdd bandwidth limit in Mbps for export.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exportLimit")]
		public int ExportLimit { get; set; }
		
		/// <summary>
		/// The HotAdd bandwidth limit in Mbps for ingest.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ingestLimit")]
		public int IngestLimit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HotAddNetworkConfigWithId
	{
		
		/// <summary>
		/// The ID of a user-configured vCenter network selected for HotAdd backup and recovery.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_id")]
		public string Network_id { get; set; }
		
		/// <summary>
		/// Information about static IP configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="static_ip_info")]
		public StaticIpInfo Static_ip_info { get; set; }
	}
	
	/// <summary>
	/// Information about static IP configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StaticIpInfo
	{
		
		/// <summary>
		/// DNS Servers for the specified IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns_servers")]
		public string[] Dns_servers { get; set; }
		
		/// <summary>
		/// Gateway for the specified IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// IP addresses and ranges, separated by commas.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip_addresses")]
		public string[] Ip_addresses { get; set; }
		
		/// <summary>
		/// Subnet mask for the specified IP addresses.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnet_mask")]
		public string Subnet_mask { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HotAddNetworkConfigWithName
	{
		
		/// <summary>
		/// The name of the HotAdd proxy virtual machine network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkName")]
		public string NetworkName { get; set; }
		
		/// <summary>
		/// Information about static IP configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticIpConfig")]
		public StaticIpInfo StaticIpConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HotAddProxiesNeededInfo
	{
		
		/// <summary>
		/// The number of HotAdd proxies the vCenter requires.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="needed")]
		public int Needed { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HotAddProxyVmInfo
	{
		
		/// <summary>
		/// The number of port in use for the HotAdd proxy virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int UsedPortCount { get; set; }
		
		/// <summary>
		/// The name of the compute cluster that contains the HotAdd proxy virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeClusterName")]
		public string ComputeClusterName { get; set; }
		
		/// <summary>
		/// The name of the datastore that the HotAdd proxy virtual machine uses.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datastoreName")]
		public string DatastoreName { get; set; }
		
		/// <summary>
		/// The name of the ESX host that contains the HotAdd proxy virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostName")]
		public string HostName { get; set; }
		
		/// <summary>
		/// The ID of the HotAdd proxy virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the HotAdd proxy virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="proxyNetworkInfo")]
		public HotAddNetworkConfigWithName ProxyNetworkInfo { get; set; }
		
		/// <summary>
		/// The type of the HotAdd proxy virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public HotAddProxyVmInfoStatus Status { get; set; }
		
		/// <summary>
		/// The name of the vCenter that contains the HotAdd proxy virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vcenterName")]
		public string VcenterName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HotAddProxyVmInfoStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Expired = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Maintaining = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HotAddProxyVmInfoListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HotAddProxyVmInfo[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// The type of the HotAdd proxy virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HotAddProxyVmStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Running = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Expired = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Maintaining = 3,
	}
	
	/// <summary>
	/// Information required to request a force full snapshot for a Hyper-V virtual disk running in a Hyper-V virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HypervVirtualDiskForceFullInfo
	{
		
		/// <summary>
		/// Indicates if deduplication should be enabled for the forced full snapshot of the Virtual Disk. When set to true, deduplication is performed against local data on the Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shouldDedupe")]
		public bool ShouldDedupe { get; set; } = true;
		
		/// <summary>
		/// ID of the virtual disk running in the Hyper-V virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualDiskId")]
		public string VirtualDiskId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HypervVirtualMachineForceFullRequest
	{
		
		/// <summary>
		/// Configuration to force a full snapshot for the virtual disks listed in the request. The configuration specifies which virtual disks in HyperV VM receive forced full snapshots, and whether to perform deduplication. If the configuration is missing, a forced full snapshot is not requested. If the configuration contains an empty array, a forced full snapshot is requested for all virtual disks in the HyperV virtual machine, and deduplication is performed by default. If the configuration array contains specific virtual disks, a forced full snapshot is requested only for these disks. The shouldDedupe flag determines if deduplication is performed. If a forced full snapshot is requested, the next backup job checks the configuration and takes the full snapshot according to the configuration. After the full snapshot is taken, the backup job clears the configuration to prevent additional full snapshots from being taken.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualDiskInfos")]
		public HypervVirtualDiskForceFullInfo[] VirtualDiskInfos { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HypervVirtualMachineForceFullResponse
	{
		
		/// <summary>
		/// Configuration for each virtual disk that requested a forced full snapshot. If the configuration does not exist, either a forced full snapshot was not requested for the HyperV virtual machine, or a backup job took the requested full snapshot and cleared the configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualDiskInfos")]
		public HypervVirtualDiskForceFullInfo[] VirtualDiskInfos { get; set; }
		
		/// <summary>
		/// ID of the Hyper-V virtual machine containing all virtual disks.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HypervVmSlaObjectCount
	{
		
		/// <summary>
		/// The number of Hyper-V virtual machines protected under this SLA domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numHypervVms")]
		public System.Nullable<System.Int32> NumHypervVms { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdNamePair
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdProviderAuthDomainInfo : IdProviderSamlInfo
	{
		
		/// <summary>
		/// Human friendly name of the Id Provider (IdP).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdProviderAuthDomainInfoUpdate : IdProviderSamlInfoUpdate
	{
		
		/// <summary>
		/// Human friendly name of the Id Provider (IdP).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdProviderAuthDomainSummary
	{
		
		/// <summary>
		/// Entity ID of the Id Provider (IdP).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="entityId")]
		public string EntityId { get; set; }
		
		/// <summary>
		/// ID of this authentication domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Domain name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the organization that added the authentication domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// The Identity Provider (IdP) X509 certificate, stored using the PEM format, used to sign the SAML assertion.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="signCert")]
		public string SignCert { get; set; }
		
		/// <summary>
		/// The expiry date of the Identity Provider (IdP) X509 certificate. The date is a string with the ISO-8601 format like 2017-01-23T20:12:45.000Z with milliseconds precision.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="signCertExpiryDate")]
		public string SignCertExpiryDate { get; set; }
		
		/// <summary>
		/// The clock skewness tolerance, in seconds, between the Identity Provider (IdP) and the Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="skewnessInSec")]
		public long SkewnessInSec { get; set; }
		
		/// <summary>
		/// The Identity Provider (IdP) endpoint that Rubrik sends authentication request to in order to initiate SSO login.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssoUrl")]
		public string SsoUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdProviderAuthDomainSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public IdProviderAuthDomainSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdProviderSamlInfo
	{
		
		/// <summary>
		/// Identity Provider (IdP) metadata XML file in a base64 encoded format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadataXmlBase64")]
		public string MetadataXmlBase64 { get; set; }
		
		/// <summary>
		/// The clock skewness tolerance, in seconds, between the Identity Provider (IdP) and the Rubrik cluster.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="skewnessInSec")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> SkewnessInSec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdProviderSamlInfoUpdate
	{
		
		/// <summary>
		/// Identity Provider (IdP) metadata XML file in a base64 encoded format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadataXmlBase64")]
		public string MetadataXmlBase64 { get; set; }
		
		/// <summary>
		/// The clock skewness tolerance, in seconds, between the Identity Provider (IdP) and the Rubrik cluster.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="skewnessInSec")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> SkewnessInSec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstantRecoveryJobConfig : MountExportSnapshotJobCommonOptions
	{
		
		/// <summary>
		/// ID of the ESXi host to use for Instant Recovery.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// Determines whether to preserve the moid of the source virtual machine in a restore operation. Use 'true' to keep the moid of the source. Use 'false' to assign a new moid. The default is 'false'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preserveMoid")]
		public System.Nullable<System.Boolean> PreserveMoid { get; set; }
		
		/// <summary>
		/// The job recovers the tags that were assigned to the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldRecoverTags")]
		public System.Nullable<System.Boolean> ShouldRecoverTags { get; set; }
		
		/// <summary>
		/// VLAN ID for the VLAN ESXi host prefer to use for mounting the datastore.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalJobInstanceDetail
	{
		
		/// <summary>
		/// Whether this job instance has been archived.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; }
		
		/// <summary>
		/// Some job types create other 'child' jobs to perform their work. Here we show information on how this job is being affected by its child jobs (if any).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childJobDebugInfo")]
		public string ChildJobDebugInfo { get; set; }
		
		/// <summary>
		/// End time of the job instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Error information of the job instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorInfo")]
		public string ErrorInfo { get; set; }
		
		/// <summary>
		/// ID of the instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Whether this job is disabled or not.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isDisabled")]
		public bool IsDisabled { get; set; }
		
		/// <summary>
		/// The current progress in terms of percentage of the async request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jobProgress")]
		public System.Nullable<System.Double> JobProgress { get; set; }
		
		/// <summary>
		/// Type of the job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobType")]
		public string JobType { get; set; }
		
		/// <summary>
		/// ID of the node where the job runs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
		
		/// <summary>
		/// Result of the job instance. Its meaning depends on the job type but is usually an ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public string Result { get; set; }
		
		/// <summary>
		/// Start time of the job instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// Status of the job instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	/// <summary>
	/// Status of Rubrik Io Filter on Cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum IoFilterStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Uninstalled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		InstallInProgress = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpgradeInProgress = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UninstallInProgress = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OutOfDate = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Installed = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		InstallError = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpgradeError = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UninstallError = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Inconsistent = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unsupported = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnsupportedByRubrik = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnsupportedByVmware = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unavailable = 14,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IoFilterSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public string ReleaseDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="summary")]
		public string Summary { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vendor")]
		public string Vendor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IoFilterSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public IoFilterSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringCsvDownloadResponse
	{
		
		/// <summary>
		/// The download link for the CSV file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloadLink")]
		public string DownloadLink { get; set; }
		
		/// <summary>
		/// Monitoring status of the job break down.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jobEventStatus")]
		public System.Nullable<JobMonitoringCsvDownloadResponseJobEventStatus> JobEventStatus { get; set; }
		
		/// <summary>
		/// Monitoring state of the job used for monitoring tabs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobMonitoringState")]
		public JobMonitoringCsvDownloadResponseJobMonitoringState JobMonitoringState { get; set; }
		
		/// <summary>
		/// Task type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jobTaskType")]
		public System.Nullable<JobMonitoringCsvDownloadResponseJobTaskType> JobTaskType { get; set; }
		
		/// <summary>
		/// The requested object name (if applicable).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectName")]
		public string ObjectName { get; set; }
		
		/// <summary>
		/// Object types that are reported on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public System.Nullable<JobMonitoringCsvDownloadResponseObjectType> ObjectType { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether log-related jobs are included. When this value is 'true,' log-related jobs are included.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shouldIncludeLogRelatedJob")]
		public bool ShouldIncludeLogRelatedJob { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringCsvDownloadResponseJobEventStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failure = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Success = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Queued = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceling = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SuccessfulWithWarnings = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CancelingScheduled = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringCsvDownloadResponseJobMonitoringState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failure = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Success = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringCsvDownloadResponseJobTaskType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Archival = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Backup = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Conversion = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Recovery = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replication = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Index = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogBackup = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogArchival = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogReplication = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogShipping = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringCsvDownloadResponseObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppBlueprint = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ec2Instance = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hdfs = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervVirtualMachine = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxFileset = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ManagedVolume = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Mssql = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixVirtualMachine = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleDatabase = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SapHanaDatabase = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFileset = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArrayVolumeGroup = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VcdVapp = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VmwareVirtualMachine = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsFileset = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsVolumeGroup = 15,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringInfo
	{
		
		/// <summary>
		/// Amount of data to transfer in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataToTransfer")]
		public System.Nullable<System.Int64> DataToTransfer { get; set; }
		
		/// <summary>
		/// The amount of data transferred as part of the job in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataTransferred")]
		public System.Nullable<System.Int64> DataTransferred { get; set; }
		
		/// <summary>
		/// The number of seconds since the job started to active jobs. The number of seconds the job ran for completed jobs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int64> Duration { get; set; }
		
		/// <summary>
		/// End time of the job. Leave this value empty for queued and running jobs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		/// <summary>
		/// Description of error information for the job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorInfo")]
		public string ErrorInfo { get; set; }
		
		/// <summary>
		/// The event series id associated with the job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventSeriesId")]
		public string EventSeriesId { get; set; }
		
		/// <summary>
		/// A Boolean value that determines whether or not the job associated with the event is a first full snapshot backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isFirstFullSnapshot")]
		public System.Nullable<System.Boolean> IsFirstFullSnapshot { get; set; }
		
		/// <summary>
		/// A boolean value indication if the job is a log related job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isLogTask")]
		public bool IsLogTask { get; set; }
		
		/// <summary>
		/// A boolean value indication if the job is a an on demand job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isOnDemand")]
		public bool IsOnDemand { get; set; }
		
		/// <summary>
		/// Monitoring state of the job used for monitoring tabs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobMonitoringState")]
		public JobMonitoringCsvDownloadResponseJobMonitoringState JobMonitoringState { get; set; }
		
		/// <summary>
		/// Monitoring status of the job break down.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobStatus")]
		public JobMonitoringCsvDownloadResponseJobEventStatus JobStatus { get; set; }
		
		/// <summary>
		/// Task type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobType")]
		public JobMonitoringCsvDownloadResponseJobTaskType JobType { get; set; }
		
		/// <summary>
		/// Time of the last successful job of the same job type. The return value is None if no successful jobs are present.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSuccessfulJobTime")]
		public System.Nullable<System.DateTimeOffset> LastSuccessfulJobTime { get; set; }
		
		/// <summary>
		/// The time the status for the job has been updated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedTime")]
		public System.DateTimeOffset LastUpdatedTime { get; set; }
		
		/// <summary>
		/// Id of the location of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Location Name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationName")]
		public string LocationName { get; set; }
		
		/// <summary>
		/// The maximum number of times the job will run in case of a failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAttemptsForJob")]
		public System.Nullable<System.Int32> MaximumAttemptsForJob { get; set; }
		
		/// <summary>
		/// Expected start time of the next job of the same job type. The return value is None if no new job is scheduled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextJobTime")]
		public System.Nullable<System.DateTimeOffset> NextJobTime { get; set; }
		
		/// <summary>
		/// Id of the node the job is running on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
		
		/// <summary>
		/// The managed id of the object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		public string ObjectId { get; set; }
		
		/// <summary>
		/// The object size in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectLogicalSize")]
		public System.Nullable<System.Int64> ObjectLogicalSize { get; set; }
		
		/// <summary>
		/// The name of the object in the job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectName")]
		public string ObjectName { get; set; }
		
		/// <summary>
		/// Object types that are reported on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public JobMonitoringCsvDownloadResponseObjectType ObjectType { get; set; }
		
		/// <summary>
		/// The number of times the job has retired.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryCount")]
		public System.Nullable<System.Int32> RetryCount { get; set; }
		
		/// <summary>
		/// Monitoring retry status of the job (default is NotRetried).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retryStatus")]
		public JobMonitoringInfoRetryStatus RetryStatus { get; set; }
		
		/// <summary>
		/// Sla Domain Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slaDomainId")]
		public string SlaDomainId { get; set; }
		
		/// <summary>
		/// Sla Domain name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slaDomainName")]
		public string SlaDomainName { get; set; }
		
		/// <summary>
		/// For replication jobs, this stores the source cluster name. Leave this value empty for other jobs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceClusterName")]
		public string SourceClusterName { get; set; }
		
		/// <summary>
		/// Start time for running or completed jobs. It is the scheduled start time for Queued jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// The throughput for running or completed jobs (measured in bytes/s). When no running or completed jobs exist no value is provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="throughput")]
		public System.Nullable<System.Int64> Throughput { get; set; }
		
		/// <summary>
		/// The number of warning events in the event series associated with the job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warningCount")]
		public System.Nullable<System.Int32> WarningCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringInfoRetryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RequestReceived = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ScheduleSuccess = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ScheduleFailure = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotRetried = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringJobProgressInfo
	{
		
		/// <summary>
		/// Amount of data to transfer in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataToTransfer")]
		public System.Nullable<System.Int64> DataToTransfer { get; set; }
		
		/// <summary>
		/// The amount of data transferred in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataTransferred")]
		public System.Nullable<System.Int64> DataTransferred { get; set; }
		
		/// <summary>
		/// Monitoring ID of the row.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="monitoring_id")]
		public string Monitoring_id { get; set; }
		
		/// <summary>
		/// The throughput for active jobs (measured in bytes/s). When no active jobs exist, no value is provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="throughput")]
		public System.Nullable<System.Int64> Throughput { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringObjectsCountByState
	{
		
		/// <summary>
		/// The total count of all jobs with the 'Running' status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="active")]
		public int Active { get; set; }
		
		/// <summary>
		/// The total count of all jobs with the 'Canceled' status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="canceled")]
		public int Canceled { get; set; }
		
		/// <summary>
		/// The total count of all jobs with the 'Failure' status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failure")]
		public int Failure { get; set; }
		
		/// <summary>
		/// The total count of all jobs with the 'Scheduled' status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheduled")]
		public int Scheduled { get; set; }
		
		/// <summary>
		/// The total count of all jobs with the 'Succeeded' status.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="success")]
		public int Success { get; set; }
		
		/// <summary>
		/// The total count of all jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringObjectsCountByType
	{
		
		/// <summary>
		/// The total count of all Archival jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archival")]
		public int Archival { get; set; }
		
		/// <summary>
		/// The total count of all Backup jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backup")]
		public int Backup { get; set; }
		
		/// <summary>
		/// The total count of all Conversion jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conversion")]
		public int Conversion { get; set; }
		
		/// <summary>
		/// The total count of all Index jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="index")]
		public int Index { get; set; }
		
		/// <summary>
		/// The total count of all Log Archival jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logArchival")]
		public int LogArchival { get; set; }
		
		/// <summary>
		/// The total count of all Log Backup jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logBackup")]
		public int LogBackup { get; set; }
		
		/// <summary>
		/// The total count of all Log Replication jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logReplication")]
		public int LogReplication { get; set; }
		
		/// <summary>
		/// The total count of all Log Shipping jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logShipping")]
		public int LogShipping { get; set; }
		
		/// <summary>
		/// The total count of all Recovery jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recovery")]
		public int Recovery { get; set; }
		
		/// <summary>
		/// The total count of all Replication jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="replication")]
		public int Replication { get; set; }
		
		/// <summary>
		/// The total count of all jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringResponse
	{
		
		/// <summary>
		/// Cursor of the last table row sent in the response. Used for setting the cursor when getting the next page of the table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="afterId")]
		public string AfterId { get; set; }
		
		/// <summary>
		/// The requested SLA domain id (if applicable).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether or not the list has more elements. This value is 'true' when the list has more elements. This value is 'false' when the list has no more elements.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public bool HasMore { get; set; }
		
		/// <summary>
		/// A Boolean to specify if the jobs are first full backups or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isFirstFull")]
		public System.Nullable<System.Boolean> IsFirstFull { get; set; }
		
		/// <summary>
		/// The requested event status of the jobs (if applicable).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jobEventStatus")]
		public JobMonitoringStatus[] JobEventStatus { get; set; }
		
		/// <summary>
		/// A list of jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobMonitoringInfoList")]
		public JobMonitoringInfo[] JobMonitoringInfoList { get; set; }
		
		/// <summary>
		/// Task type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jobType")]
		public JobMonitoringCsvDownloadResponseJobTaskType JobType { get; set; }
		
		/// <summary>
		/// The earliest possible time at which the latest update to all rows has been made.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdateTime")]
		public System.Nullable<System.DateTimeOffset> LastUpdateTime { get; set; }
		
		/// <summary>
		/// The requested node (if applicable).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeName")]
		public string NodeName { get; set; }
		
		/// <summary>
		/// The requested object name (if applicable).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectName")]
		public string ObjectName { get; set; }
		
		/// <summary>
		/// Object types that are reported on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public JobMonitoringCsvDownloadResponseObjectType ObjectType { get; set; }
		
		/// <summary>
		/// A Boolean to specify whether or not to include log-related jobs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shouldIncludeLogRelatedJob")]
		public bool ShouldIncludeLogRelatedJob { get; set; }
	}
	
	/// <summary>
	/// Monitoring status of the job break down.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failure = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Success = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Queued = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceling = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SuccessfulWithWarnings = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CancelingScheduled = 8,
	}
	
	/// <summary>
	/// Monitoring retry status of the job (default is NotRetried).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringRetryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RequestReceived = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ScheduleSuccess = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ScheduleFailure = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotRetried = 3,
	}
	
	/// <summary>
	/// Monitoring state of the job used for monitoring tabs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failure = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Success = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringStream
	{
		
		/// <summary>
		/// The ID to use with subsequent queries to get entires after this entry.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="afterId")]
		public string AfterId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="jobMonitoringResponse")]
		public JobMonitoringInfo JobMonitoringResponse { get; set; }
		
		/// <summary>
		/// Monitoring ID of the row.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="monitoringId")]
		public string MonitoringId { get; set; }
		
		/// <summary>
		/// The job monitoring row type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rowType")]
		public JobMonitoringStreamRowType RowType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringStreamRowType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upsert = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deletion = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringStreamingResponse
	{
		
		/// <summary>
		/// Current time of the cluster when the request was made.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clusterTime")]
		public System.DateTimeOffset ClusterTime { get; set; }
		
		/// <summary>
		/// Response data.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="data")]
		public JobMonitoringStream[] Data { get; set; }
		
		/// <summary>
		/// True if the list has more elements.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public bool HasMore { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringSummaryByState
	{
		
		/// <summary>
		/// Job types of the jobs included in the result.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobTypes")]
		public JobMonitoringTaskType[] JobTypes { get; set; }
		
		/// <summary>
		/// The time in the cluster time zone at which the counts were updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedTime")]
		public System.Nullable<System.DateTimeOffset> LastUpdatedTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectCounts")]
		public JobMonitoringObjectsCountByState ObjectCounts { get; set; }
	}
	
	/// <summary>
	/// Task type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JobMonitoringTaskType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Archival = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Backup = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Conversion = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Recovery = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replication = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Index = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogBackup = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogArchival = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogReplication = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogShipping = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobMonitoringSummaryByType
	{
		
		/// <summary>
		/// Monitoring state of the job used for monitoring tabs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobMonitoringState")]
		public JobMonitoringCsvDownloadResponseJobMonitoringState JobMonitoringState { get; set; }
		
		/// <summary>
		/// The time in the cluster time zone at which the counts were updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedTime")]
		public System.Nullable<System.DateTimeOffset> LastUpdatedTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectCounts")]
		public JobMonitoringObjectsCountByType ObjectCounts { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JobScheduledResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobInstanceId")]
		public string JobInstanceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmipClientConfiguration
	{
		
		/// <summary>
		/// The ID of an imported certificate in the CDM certificate management table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificateId")]
		public string ClientCertificateId { get; set; }
		
		/// <summary>
		/// The password for the KMIP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The username for the KMIP server.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmipClientDetail
	{
		
		/// <summary>
		/// The ID of an imported certificate in the CDM certificate management table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificateId")]
		public string ClientCertificateId { get; set; }
		
		/// <summary>
		/// Specifies whether a password is configured for authentication. When a password is configured, this value is 'true'. When a password is not configured, this value is 'false'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPasswordSet")]
		public System.Nullable<System.Boolean> IsPasswordSet { get; set; }
		
		/// <summary>
		/// The username for the KMIP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmipServerConfiguration
	{
		
		/// <summary>
		/// The KMIP server's address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serverAddress")]
		public string ServerAddress { get; set; }
		
		/// <summary>
		/// ID corresponding to KMIP server's X.509 certificate in Base64 encoded DER format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serverCertificateId")]
		public string ServerCertificateId { get; set; }
		
		/// <summary>
		/// The KMIP server's port number.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverPort")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> ServerPort { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KmipServerDetail
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KuprHostRegister
	{
		
		/// <summary>
		/// The agent certificate of the registered host. X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agentCertificate")]
		public string AgentCertificate { get; set; }
		
		/// <summary>
		/// The agent ID of the registered host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agentId")]
		public string AgentId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ipv4Addresses")]
		public string[] Ipv4Addresses { get; set; }
		
		/// <summary>
		/// Operating system information of a specified kupr host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatingSystemInfo")]
		public KuprHostRegisterOperatingSystemInfo OperatingSystemInfo { get; set; }
		
		/// <summary>
		/// Operating system of a specified kupr host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatingSystemType")]
		public KuprHostRegisterOperatingSystemType OperatingSystemType { get; set; }
		
		/// <summary>
		/// Operating system version of a specified kupr host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystemVersion")]
		public string OperatingSystemVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum KuprHostRegisterOperatingSystemInfo
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linux = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rhel = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ubuntu = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Suse = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Centos = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum KuprHostRegisterOperatingSystemType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linux = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KuprHostUpdate
	{
		
		/// <summary>
		/// The agent certificate of the registered host. X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="agentCertificate")]
		public string AgentCertificate { get; set; }
		
		/// <summary>
		/// The agent ID of the registered host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="agentId")]
		public string AgentId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// An array containing the IPv4 address to Kupr host.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4Addresses")]
		public string[] Ipv4Addresses { get; set; }
		
		/// <summary>
		/// Operating system information of a specified kupr host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystemInfo")]
		public KuprHostRegisterOperatingSystemInfo OperatingSystemInfo { get; set; }
		
		/// <summary>
		/// Operating system of a specified kupr host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystemType")]
		public KuprHostRegisterOperatingSystemType OperatingSystemType { get; set; }
		
		/// <summary>
		/// Operating system version of a specified kupr host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystemVersion")]
		public string OperatingSystemVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LdapDomainName
	{
		
		/// <summary>
		/// Name of an LDAP domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LdapDomainNameListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LdapDomainName[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LdapServiceInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="advancedOptions")]
		public AdvancedLdapConfiguration AdvancedOptions { get; set; }
		
		/// <summary>
		/// An ordered list of authentication servers. Servers on this list have priority over servers discovered using dynamic DNS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authServers")]
		public string[] AuthServers { get; set; }
		
		/// <summary>
		/// The path to the directory where searches for users begin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseDn")]
		public string BaseDn { get; set; }
		
		/// <summary>
		/// The name of the user that searches the authentication server for other users.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bindUserName")]
		public string BindUserName { get; set; }
		
		/// <summary>
		/// Password for the bind user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bindUserPassword")]
		public string BindUserPassword { get; set; }
		
		/// <summary>
		/// ID of the imported certificate to use for connections to this server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// Dynamic DNS name for locating authentication servers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamicDnsName")]
		public string DynamicDnsName { get; set; }
		
		/// <summary>
		/// Indicates whether the time-based one time password (TOTP) authentication method is being enforced. Returns true when TOTP is enforced and false when TOTP is not enforced.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTotpEnforced")]
		public System.Nullable<System.Boolean> IsTotpEnforced { get; set; }
		
		/// <summary>
		/// MFA server associated with LDAP service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mfaServerId")]
		public string MfaServerId { get; set; }
		
		/// <summary>
		/// Human friendly name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LdapServiceInfoUpdate
	{
		
		[System.Runtime.Serialization.DataMember(Name="advancedOptions")]
		public AdvancedLdapConfiguration AdvancedOptions { get; set; }
		
		/// <summary>
		/// An ordered list of authentication servers. Servers on this list have priority over servers discovered using dynamic DNS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authServers")]
		public string[] AuthServers { get; set; }
		
		/// <summary>
		/// The path to the directory where searches for users begin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseDn")]
		public string BaseDn { get; set; }
		
		/// <summary>
		/// The name of the user that searches the authentication server for other users.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindUserName")]
		public string BindUserName { get; set; }
		
		/// <summary>
		/// Password for the bind user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindUserPassword")]
		public string BindUserPassword { get; set; }
		
		/// <summary>
		/// ID of the imported certificate to use for connections to this server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// Dynamic DNS name for locating authentication servers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamicDnsName")]
		public string DynamicDnsName { get; set; }
		
		/// <summary>
		/// Indicates whether the time-based one time password (TOTP) authentication method is being enforced. Returns true when TOTP is enforced and false when TOTP is not enforced.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTotpEnforced")]
		public System.Nullable<System.Boolean> IsTotpEnforced { get; set; }
		
		/// <summary>
		/// MFA server associated with LDAP service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mfaServerId")]
		public string MfaServerId { get; set; }
		
		/// <summary>
		/// Human friendly name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LdapServiceSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="advancedOptions")]
		public AdvancedLdapConfiguration AdvancedOptions { get; set; }
		
		/// <summary>
		/// An ordered list of authentication servers. Servers on this list have priority over servers discovered using dynamic DNS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authServers")]
		public string[] AuthServers { get; set; }
		
		/// <summary>
		/// The path to the directory where searches for users begin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseDn")]
		public string BaseDn { get; set; }
		
		/// <summary>
		/// The name of the user that searches the authentication server for other users.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindUserName")]
		public string BindUserName { get; set; }
		
		/// <summary>
		/// ID of the imported certificate to use for connections to this server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// Domain type, for example local or LDAP/Active Directory.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domainType")]
		public string DomainType { get; set; }
		
		/// <summary>
		/// Dynamic DNS name for locating authentication servers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamicDnsName")]
		public string DynamicDnsName { get; set; }
		
		/// <summary>
		/// ID of this authentication domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Status message from the initial refresh.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initialRefreshStatus")]
		public string InitialRefreshStatus { get; set; }
		
		/// <summary>
		/// Indicates whether the time-based one time password (TOTP) authentication method is being enforced. Returns true when TOTP is enforced and false when TOTP is not enforced.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTotpEnforced")]
		public System.Nullable<System.Boolean> IsTotpEnforced { get; set; }
		
		/// <summary>
		/// MFA server associated with LDAP service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mfaServerId")]
		public string MfaServerId { get; set; }
		
		/// <summary>
		/// Domain name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Computer account name associated with this cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LdapServiceSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LdapServiceSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for objects whose snapshots are on Legal Hold.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LegalHoldObjectSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		objectName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		objectType = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		numberOfSnapshotsHeld = 2,
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for snapshots on Legal Hold.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LegalHoldSnapshotSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SnapshotTime = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PlaceOnHoldTime = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SnapshotType = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LegalHoldSummary : ObjectHolder
	{
		
		/// <summary>
		/// Date at which the snapshot will expire if the legal hold is dissolved.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedExpirationDateWithoutLegalHold")]
		public System.Nullable<System.DateTimeOffset> ExpectedExpirationDateWithoutLegalHold { get; set; }
		
		/// <summary>
		/// A Boolean value that indicates whether custom retention is applied to the specified snapshot. Value is true when custom retention is applied to the snapshot.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isCustomRetentionApplied")]
		public bool IsCustomRetentionApplied { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether a snapshot is an On Demand snapshot. When this value is 'true,' the snapshot is an On Demand snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isOnDemandSnapshot")]
		public bool IsOnDemandSnapshot { get; set; }
		
		/// <summary>
		/// Current locations of the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locationsPresent")]
		public string[] LocationsPresent { get; set; }
		
		/// <summary>
		/// Time at which the snapshot was put on hold.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="placeOnHoldTime")]
		public System.DateTimeOffset PlaceOnHoldTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotId")]
		public string SnapshotId { get; set; }
		
		/// <summary>
		/// Time at which the snapshot was taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotTime")]
		public System.DateTimeOffset SnapshotTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LegalHoldSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LegalHoldSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalUserAccountLockoutConfig
	{
		
		/// <summary>
		/// Specifies the duration in minutes after which a locked user account is automatically unlocked. When set to 0, the user account is not unlocked automatically.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountLockoutDurationInMinutes")]
		public System.Nullable<System.Int32> AccountLockoutDurationInMinutes { get; set; }
		
		/// <summary>
		/// Specifies whether local user accounts are locked. When 'true' the local user account is locked after 'x' failed consecutive login attempts where 'x' is specified by 'maxFailedLoginsForLocalUser'. When 'false' failed login attempts are not recorded and will not lock the local user account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Specifies the number of consecutive failed logins after which the local user account is locked.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxFailedLoginsForLocalUser")]
		public System.Nullable<System.Int32> MaxFailedLoginsForLocalUser { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalUserAccountLockoutStatus
	{
		
		/// <summary>
		/// Specifies the duration in minutes after which a locked user account is automatically unlocked. When set to 0, the user account is not unlocked automatically.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accountLockoutDurationInMinutes")]
		public int AccountLockoutDurationInMinutes { get; set; }
		
		/// <summary>
		/// Specifies whether local user accounts are locked. When 'true' the local user account is locked after 'x' failed consecutive login attempts where 'x' is specified by 'maxFailedLoginsForLocalUser'. When 'false' failed login attempts are not recorded and will not lock the local user account.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Specifies the number of consecutive failed logins after which the local user account is locked.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxFailedLoginsForLocalUser")]
		public int MaxFailedLoginsForLocalUser { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocationPathPoint
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="managedId")]
		public string ManagedId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedObjectDescendantCountVcdVappFields
	{
		
		/// <summary>
		/// Number of vCD vApps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vapp")]
		public System.Nullable<System.Int32> Vapp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedObjectPendingSlaInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="isPendingSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsPendingSlaDomainRetentionLocked { get; set; }
		
		/// <summary>
		/// Managed ID of the object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		public string ObjectId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pendingSlaDomainId")]
		public string PendingSlaDomainId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pendingSlaDomainName")]
		public string PendingSlaDomainName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedVolumeSlaObjectCount
	{
		
		/// <summary>
		/// The number of Managed volumes protected under this SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numManagedVolumes")]
		public System.Nullable<System.Int32> NumManagedVolumes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManualDiscoveryNodeInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeInfo")]
		public BootstrappableNodeInfoV1[] NodeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManualDiscoveryNodeIpv4Info
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeInfo")]
		public BootstrappableNodeIpv4Info[] NodeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Map_Boolean
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Map_String
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MfaServerConfig
	{
		
		/// <summary>
		/// Specifies the name to identify MFA server configuration.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies a number of seconds to wait for server response to a given authentication method.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int32> Timeout { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MissedSnapshot
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archivalLocationType")]
		public string[] ArchivalLocationType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="missedSnapshotTime")]
		public System.DateTimeOffset MissedSnapshotTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="missedSnapshotTimeUnits")]
		public MissedSnapshotTimeUnitConfig[] MissedSnapshotTimeUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MissedSnapshotTimeUnitConfig
	{
		
		/// <summary>
		/// Units for missed snapshot dayOfTime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOfTime")]
		public System.Nullable<MissedSnapshotTimeUnitConfigDayOfTime> DayOfTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public int Frequency { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retention")]
		public int Retention { get; set; }
		
		/// <summary>
		/// Units for frequency and retention. Accepted values are Minute, Hourly, Daily, Weekly, Monthly, Quarterly, and Yearly.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeUnit")]
		public AdvancedUiConfigAttributesRetentionType TimeUnit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MissedSnapshotTimeUnitConfigDayOfTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Monday = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Tuesday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Wednesday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Thursday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Friday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Saturday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Sunday = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstDay = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fifteenth = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastDay = 9,
	}
	
	/// <summary>
	/// Units for missed snapshot dayOfTime.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MissedSnapshotDayOfTimeUnit
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Monday = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Tuesday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Wednesday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Thursday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Friday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Saturday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Sunday = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstDay = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fifteenth = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastDay = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MissedSnapshotListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MissedSnapshot[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MonitoringEmailSubscriptionRequest
	{
		
		/// <summary>
		/// Attachment files to send with the subscription.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="attachments")]
		public SubscriptionAttachmentType[] Attachments { get; set; }
		
		/// <summary>
		/// Email addresses to send monitoring subscriptions to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emailAddresses")]
		public string[] EmailAddresses { get; set; }
		
		/// <summary>
		/// User-selected job states.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobStates")]
		public JobMonitoringState[] JobStates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeAttributes")]
		public SubscriptionScheduleTimeAttributes TimeAttributes { get; set; }
	}
	
	/// <summary>
	/// Email subscription attachment file type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubscriptionAttachmentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Csv = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubscriptionScheduleTimeAttributes
	{
		
		/// <summary>
		/// Hour of the day to send the scheduled email, if the user picks a daily schedule. 0 = 12AM, 23 = 11PM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dailyScheduleHour")]
		public System.Nullable<System.Int32> DailyScheduleHour { get; set; }
		
		/// <summary>
		/// Day of the month to send the scheduled email, if the user picks a monthly schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOfMonth")]
		public System.Nullable<System.Int32> DayOfMonth { get; set; }
		
		/// <summary>
		/// Day of the week, represented by numbers, to send the scheduled email, if the user picks a weekly schedule. 0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daysOfWeek")]
		public int[] DaysOfWeek { get; set; }
		
		/// <summary>
		/// Hour of the user-specified day to send the scheduled email, if the user picks a monthly schedule. 0 = 12AM, 23 = 11PM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyScheduleHour")]
		public System.Nullable<System.Int32> MonthlyScheduleHour { get; set; }
		
		/// <summary>
		/// Hour of the user-specified day to send the scheduled email, if the user picks a weekly schedule. 0 = 12AM, 23 = 11PM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weeklyScheduleHour")]
		public System.Nullable<System.Int32> WeeklyScheduleHour { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MonitoringEmailSubscriptionUpdate : MonitoringEmailSubscriptionRequest
	{
		
		/// <summary>
		/// Changes the owner of an email subscription object to the username of the account that is logged into the current session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assumeOwnership")]
		public System.Nullable<System.Boolean> AssumeOwnership { get; set; }
		
		/// <summary>
		/// ID assigned to an email subscription object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// The job monitoring row type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MonitoringRowType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upsert = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deletion = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MonitoringSubscriptionSummary : MonitoringEmailSubscriptionRequest
	{
		
		/// <summary>
		/// ID assigned to an email subscription object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public SubscriptionOwner Owner { get; set; }
		
		/// <summary>
		/// Status of email subscription.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MonitoringSubscriptionSummaryStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubscriptionOwner
	{
		
		/// <summary>
		/// User ID of the email subscription object owner.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
		
		/// <summary>
		/// Username of the email subscription object owner.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MonitoringSubscriptionSummaryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Suspended = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MonthlyConfig : FrequencyConfig
	{
		
		/// <summary>
		/// The day of the month when snapshot will be taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dayOfMonth")]
		public MonthlyConfigDayOfMonth DayOfMonth { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MonthlyConfigDayOfMonth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstDay = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fifteenth = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastDay = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MountExportSnapshotJobCommonOptions
	{
		
		/// <summary>
		/// Sets the state of the network interfaces when the virtual machine is mounted or exported. Use 'false' to enable the network interfaces. Use 'true' to disable the network interfaces. Disabling the interfaces can prevent IP conflicts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableNetwork")]
		public System.Nullable<System.Boolean> DisableNetwork { get; set; }
		
		/// <summary>
		/// Determines whether the MAC addresses of the network interfaces on the source virtual machine are assigned to the new virtual machine. Set to 'true' to assign the original MAC addresses to the new virtual machine. Set to 'false' to assign new MAC addresses. The default is 'false'. When removeNetworkDevices is set to true, this property is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keepMacAddresses")]
		public System.Nullable<System.Boolean> KeepMacAddresses { get; set; }
		
		/// <summary>
		/// Determines whether the virtual machine should be powered on after mount or export. Set to 'true' to power on the virtual machine. Set to 'false' to mount or export the virtual machine but not power it on. The default is 'true'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerOn")]
		public System.Nullable<System.Boolean> PowerOn { get; set; }
		
		/// <summary>
		/// Determines whether to remove the network interfaces from the mounted or exported virtual machine. Set to 'true' to remove all network interfaces. The default value is 'false'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="removeNetworkDevices")]
		public System.Nullable<System.Boolean> RemoveNetworkDevices { get; set; }
		
		/// <summary>
		/// Name of the new VM created by mount or export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmName")]
		public string VmName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MountMssqlDbConfig
	{
		
		/// <summary>
		/// Name to assign to the mounted database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mountedDatabaseName")]
		public string MountedDatabaseName { get; set; }
		
		/// <summary>
		/// Recovery model for a SQL Server database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recoveryModel")]
		public System.Nullable<MountMssqlDbConfigRecoveryModel> RecoveryModel { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoveryPoint")]
		public MssqlRecoveryPoint RecoveryPoint { get; set; }
		
		/// <summary>
		/// ID of the SQL Server instance to mount the database on. For availability source databases, this must be specified. When unspecified for non-availability source databases, the source SQL Server instance is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetInstanceId")]
		public string TargetInstanceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MountMssqlDbConfigRecoveryModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SIMPLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BULK_LOGGED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MountSnapshotJobConfigV1 : MountExportSnapshotJobCommonOptions
	{
		
		/// <summary>
		/// The job creates a datastore that contains the VMDK, but does not create the corresponding virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createDatastoreOnly")]
		public System.Nullable<System.Boolean> CreateDatastoreOnly { get; set; }
		
		/// <summary>
		/// Obsolete parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataStoreName")]
		public string DataStoreName { get; set; }
		
		/// <summary>
		/// ID of the ESXi host to mount the new virtual machine on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// The job recovers the tags that were assigned to the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldRecoverTags")]
		public System.Nullable<System.Boolean> ShouldRecoverTags { get; set; }
		
		/// <summary>
		/// VLAN ID for the VLAN ESXi host prefer to use for mounting the datastore.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlAvailabilityGroupDetail
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlAvailabilityGroupSummary : Snappable
	{
		
		/// <summary>
		/// Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copyOnly")]
		public System.Nullable<System.Boolean> CopyOnly { get; set; }
		
		/// <summary>
		/// Seconds between two log backups. A value of 0 disables log backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInSeconds")]
		public System.Nullable<System.Int32> LogBackupFrequencyInSeconds { get; set; }
		
		/// <summary>
		/// Number of hours to retain a log backup. When the value is set to -1 the Rubrik cluster retains the log backup until the database snapshots that precede the log backup have expired.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logRetentionHours")]
		public System.Nullable<System.Int32> LogRetentionHours { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlAvailabilityGroupSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlAvailabilityGroupSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlAvailabilityGroupUpdate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBackup
	{
		
		/// <summary>
		/// The unique identifier for the object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backupId")]
		public string BackupId { get; set; }
		
		/// <summary>
		/// The total uncompressed size of the files in bytes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backupSize")]
		public long BackupSize { get; set; }
		
		/// <summary>
		/// The type of the backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backupType")]
		public MssqlBackupBackupType BackupType { get; set; }
		
		/// <summary>
		/// Timestamp of the backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// LSN of the backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lsn")]
		public string Lsn { get; set; }
		
		/// <summary>
		/// The file path the backup will be stored at in downloaded zip files containing it.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// GUID of the recovery fork attached to the LSN.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoveryForkGuid")]
		public string RecoveryForkGuid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlBackupBackupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Snapshot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Log = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBackupJobConfig : BaseOnDemandSnapshotConfig
	{
		
		/// <summary>
		/// Whether to force a full snapshot or an incremental.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceFullSnapshot")]
		public System.Nullable<System.Boolean> ForceFullSnapshot { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBackupSelection
	{
		
		/// <summary>
		/// The type of the backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backupType")]
		public MssqlBackupBackupType BackupType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endPoint")]
		public MssqlRecoveryPoint EndPoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="legalHoldDownloadConfig")]
		public LegalHoldDownloadConfig LegalHoldDownloadConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recoveryPoint")]
		public MssqlRecoveryPoint RecoveryPoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startPoint")]
		public MssqlRecoveryPoint StartPoint { get; set; }
	}
	
	/// <summary>
	/// The type of the backup.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlBackupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Snapshot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Log = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBackups
	{
		
		/// <summary>
		/// A list of snapshots and logs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="items")]
		public MssqlBackup[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBatchBackupCanceledSummary
	{
		
		/// <summary>
		/// ID of the Microsoft SQL database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="databaseId")]
		public string DatabaseId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBatchBackupFailureSummary
	{
		
		/// <summary>
		/// ID of the Microsoft SQL database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="databaseId")]
		public string DatabaseId { get; set; }
		
		/// <summary>
		/// Information specifying why this snapshot failed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBatchBackupJobConfig : BaseOnDemandSnapshotConfig
	{
		
		/// <summary>
		/// IDs of the Microsoft SQL availability groups. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availabilityGroupIds")]
		public string[] AvailabilityGroupIds { get; set; }
		
		/// <summary>
		/// IDs of the Microsoft SQL databases. All databases in this list are considered for taking an on demand snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="databaseIds")]
		public string[] DatabaseIds { get; set; }
		
		/// <summary>
		/// Determines whether to force a full or incremental snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceFullSnapshot")]
		public System.Nullable<System.Boolean> ForceFullSnapshot { get; set; }
		
		/// <summary>
		/// IDs of the hosts. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostIds")]
		public string[] HostIds { get; set; }
		
		/// <summary>
		/// IDs of the Microsoft SQL instances. All non-availability databases on these instances are considered for taking an on demand snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceIds")]
		public string[] InstanceIds { get; set; }
		
		/// <summary>
		/// IDs of the Windows clusters. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowsClusterIds")]
		public string[] WindowsClusterIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBatchBackupSuccessSummary
	{
		
		/// <summary>
		/// ID of the Mirosoft SQL database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="databaseId")]
		public string DatabaseId { get; set; }
		
		/// <summary>
		/// ID of the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotId")]
		public string SnapshotId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlBatchBackupSummary
	{
		
		/// <summary>
		/// List of summary information for each canceled snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="canceledSnapshots")]
		public MssqlBatchBackupCanceledSummary[] CanceledSnapshots { get; set; }
		
		/// <summary>
		/// List of summary information for each failed snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failedSnapshots")]
		public MssqlBatchBackupFailureSummary[] FailedSnapshots { get; set; }
		
		/// <summary>
		/// ID of the on-demand backup request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// List of summary information for each successful snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="successfulSnapshots")]
		public MssqlBatchBackupSuccessSummary[] SuccessfulSnapshots { get; set; }
	}
	
	/// <summary>
	/// Effective CBT host status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlCbtEffectiveStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		On = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Off = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OnDefault = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OffDefault = 3,
	}
	
	/// <summary>
	/// CBT host support status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlCbtStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Default = 2,
	}
	
	/// <summary>
	/// File type of a database file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlDatabaseFileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Data = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Log = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Filestream = 2,
	}
	
	/// <summary>
	/// The field by which to sort when enumerating database summary information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlDatabaseListSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		copyOnly = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		logBackupRetentionHours = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 3,
	}
	
	/// <summary>
	/// Recovery model for a SQL Server database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlDatabaseRecoveryModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SIMPLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BULK_LOGGED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbDefaults
	{
		
		/// <summary>
		/// True to enable a CBT-based backup, false to disable a CBT-based backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cbtStatus")]
		public bool CbtStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInSeconds")]
		public long LogBackupFrequencyInSeconds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logRetentionTimeInHours")]
		public int LogRetentionTimeInHours { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbDefaultsUpdate
	{
		
		/// <summary>
		/// True to enable a CBT-based backup, false to disable a CBT-based backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cbtStatus")]
		public System.Nullable<System.Boolean> CbtStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInSeconds")]
		public System.Nullable<System.Int64> LogBackupFrequencyInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logRetentionTimeInHours")]
		public System.Nullable<System.Int32> LogRetentionTimeInHours { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbDetail : MssqlDbSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blackoutWindowStatus")]
		public BlackoutWindowStatus BlackoutWindowStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blackoutWindows")]
		public BlackoutWindows BlackoutWindows { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbReplica
	{
		
		[System.Runtime.Serialization.DataMember(Name="availabilityInfo")]
		public MssqlDbReplicaAvailabilityInfo AvailabilityInfo { get; set; }
		
		/// <summary>
		/// `True` when the Rubrik cluster has sufficient permissions to perform all necessary operations.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasPermissions")]
		public bool HasPermissions { get; set; }
		
		/// <summary>
		/// ID of the SQL Server instance managing the replica.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instanceId")]
		public string InstanceId { get; set; }
		
		/// <summary>
		/// Name of the SQL Server instance managing the replica.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instanceName")]
		public string InstanceName { get; set; }
		
		/// <summary>
		/// Deprecated. Please use 'isDeleted' instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isArchived")]
		public bool IsArchived { get; set; }
		
		/// <summary>
		/// `True` when the replica is deleted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isDeleted")]
		public bool IsDeleted { get; set; }
		
		/// <summary>
		/// `True` when the replica is in standby mode.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isStandby")]
		public bool IsStandby { get; set; }
		
		/// <summary>
		/// The recovery fork GUID of the replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recoveryForkGuid")]
		public string RecoveryForkGuid { get; set; }
		
		/// <summary>
		/// The recovery model of the replica.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoveryModel")]
		public MountMssqlDbConfigRecoveryModel RecoveryModel { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rootProperties")]
		public MssqlRootProperties RootProperties { get; set; }
		
		/// <summary>
		/// The state of the replica.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbReplicaAvailabilityInfo
	{
		
		/// <summary>
		/// Role of the availability database replica. Possible values are: `PRIMARY`, `SECONDARY`, or `RESOLVING`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public MssqlDbReplicaAvailabilityInfoRole Role { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlDbReplicaAvailabilityInfoRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIMARY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECONDARY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOLVING = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlRootProperties
	{
		
		/// <summary>
		/// ID of the root of this object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rootId")]
		public string RootId { get; set; }
		
		/// <summary>
		/// Name of the root of this object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rootName")]
		public string RootName { get; set; }
		
		/// <summary>
		/// Role of the root object for this object if the root object is a Host and part of a **_MssqlAvailabilityGroup_**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rootRole")]
		public string RootRole { get; set; }
		
		/// <summary>
		/// Type of the root object for this object. The root object is the top-level object from which this object is derived. If this object is an availability database, the root object is **_MssqlAvailabilityGroup_**. Otherwise, if this object is part of a cluster, the root object is **_WindowsCluster_**. Otherwise, the root object is **_Host_**.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rootType")]
		public MssqlRootPropertiesRootType RootType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlRootPropertiesRootType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Host = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsCluster = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MssqlAvailabilityGroup = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbSlaObjectCount
	{
		
		/// <summary>
		/// The number of actively protected databases under this SLA domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numDbs")]
		public System.Nullable<System.Int32> NumDbs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbSnapshotDetail : BaseSnapshotSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="config")]
		public string Config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isCorrupt")]
		public System.Nullable<System.Boolean> IsCorrupt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbSnapshotSummary : BaseSnapshotSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="canLiveMount")]
		public bool CanLiveMount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="databaseName")]
		public string DatabaseName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbSnapshotSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlDbSnapshotSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbSummary : Snappable
	{
		
		/// <summary>
		/// For an availability database, the ID of the availability group that the database belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availabilityGroupId")]
		public string AvailabilityGroupId { get; set; }
		
		/// <summary>
		/// Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="copyOnly")]
		public bool CopyOnly { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currentBackupTaskInfo")]
		public BackupTaskDiagnosticInfo CurrentBackupTaskInfo { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether the cluster has permission to back up the database. When this value is 'true', the cluster has permission to back up the database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasPermissions")]
		public bool HasPermissions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// True/false value indicating if backup task information is included in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeBackupTaskInfo")]
		public System.Nullable<System.Boolean> IncludeBackupTaskInfo { get; set; }
		
		/// <summary>
		/// This field is deprecated. Use the instanceId field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceId")]
		public string InstanceId { get; set; }
		
		/// <summary>
		/// This field is deprecated. Use the instanceName field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceName")]
		public string InstanceName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isInAvailabilityGroup")]
		public bool IsInAvailabilityGroup { get; set; }
		
		/// <summary>
		/// Boolean value that specifies whether a database object is a Live Mount. Value is 'true' when the database object is a Live Mount.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isLiveMount")]
		public bool IsLiveMount { get; set; }
		
		/// <summary>
		/// Boolean value that specifies whether a database object represents a secondary database. Value is 'true' when the database object represents a secondary database in a log shipping configuration.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isLogShippingSecondary")]
		public bool IsLogShippingSecondary { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether the database is in the ONLINE state. When this value is 'true', the database is in the ONLINE state.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isOnline")]
		public bool IsOnline { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public bool IsRelic { get; set; }
		
		/// <summary>
		/// The timestamp of the previous snapshot.. Only available in the /v1/mssql/db endpoint request body. The information will not be available for other endpoints.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSnapshotTime")]
		public System.Nullable<System.DateTimeOffset> LastSnapshotTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInSeconds")]
		public int LogBackupFrequencyInSeconds { get; set; }
		
		/// <summary>
		/// Hours to keep a log backup. A value of -1 indicates that a log will only expire when the preceding snapshots have expired.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logBackupRetentionHours")]
		public int LogBackupRetentionHours { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// An integer that specifies the number of missed snapshots. Only available in the /v1/mssql/db endpoint request body. The information will not be available for other endpoints.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numMissedSnapshot")]
		public int NumMissedSnapshot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pendingSlaDomain")]
		public ManagedObjectPendingSlaInfo PendingSlaDomain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// This field is deprecated. Use the recoveryModel field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recoveryModel")]
		public MountMssqlDbConfigRecoveryModel RecoveryModel { get; set; }
		
		/// <summary>
		/// List of replicas of this database. An availability database may have multiple replicas, while other databases will have only one replica.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="replicas")]
		public MssqlDbReplica[] Replicas { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rootProperties")]
		public MssqlRootProperties RootProperties { get; set; }
		
		/// <summary>
		/// This field is deprecated. Use the state field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unprotectableReasons")]
		public string[] UnprotectableReasons { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlDbSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbUpdate : MssqlSlaPatchProperties
	{
		
		/// <summary>
		/// Whether to pause or resume backups/archival for this database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPaused")]
		public System.Nullable<System.Boolean> IsPaused { get; set; }
		
		/// <summary>
		/// Maximum number of parallel data streams that can be used to back up the database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxDataStreams")]
		public System.Nullable<System.Int32> MaxDataStreams { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="postBackupScript")]
		public MssqlScriptDetail PostBackupScript { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="preBackupScript")]
		public MssqlScriptDetail PreBackupScript { get; set; }
		
		/// <summary>
		/// Determines whether to force a full for the next snapshot of a SQL Server database. When this value is true, the Rubrik cluster takes a full snapshot. This value is false by default and is reset to false after a successful full snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldForceFull")]
		public System.Nullable<System.Boolean> ShouldForceFull { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlScriptDetail
	{
		
		/// <summary>
		/// Action to take if the script returns an error or times out.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scriptErrorAction")]
		public MssqlScriptDetailScriptErrorAction ScriptErrorAction { get; set; }
		
		/// <summary>
		/// The script to be run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scriptPath")]
		public string ScriptPath { get; set; }
		
		/// <summary>
		/// Time (in ms) after which the script will be terminated if it has not completed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeoutMs")]
		public long TimeoutMs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlScriptDetailScriptErrorAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		abort = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="continue")]
		_continue = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDbUpdateId
	{
		
		/// <summary>
		/// ID of the Microsoft SQL database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="databaseId")]
		public string DatabaseId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updateProperties")]
		public MssqlDbUpdate UpdateProperties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlDownloadFromArchiveConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoveryPoint")]
		public MssqlRecoveryPoint RecoveryPoint { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlHierarchyObjectDescendantCount
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MssqlDatabase { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MssqlInstance { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlHierarchyObjectSummary : ManagedHierarchyObjectSummary
	{
		
		/// <summary>
		/// Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copyOnly")]
		public System.Nullable<System.Boolean> CopyOnly { get; set; }
		
		/// <summary>
		/// Seconds between two log backups. A value of 0 disables log backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInSeconds")]
		public System.Nullable<System.Int32> LogBackupFrequencyInSeconds { get; set; }
		
		/// <summary>
		/// Number of hours to retain a log backup. When the value is set to -1 the Rubrik cluster retains the log backup until the database snapshots that precede the log backup have expired.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logRetentionHours")]
		public System.Nullable<System.Int32> LogRetentionHours { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlHierarchyObjectSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlHierarchyObjectSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// The type of the SQL Server hierarchy object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlHierarchyObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Host = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MssqlInstance = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MssqlDatabase = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsCluster = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MssqlAvailabilityGroup = 4,
	}
	
	/// <summary>
	/// Effective CBT status for Host/Windows Failover Cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlHostCbtEffectiveStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		On = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Off = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PartiallyEnabled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OnDefault = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OffDefault = 4,
	}
	
	/// <summary>
	/// CBT host support status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlHostCbtStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Default = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlHostConfiguration
	{
		
		/// <summary>
		/// Defines the boolean type for host configuration. 'Enabled' specifies true, 'Disabled' specifies False, and 'Default' specifies to delete the entry and default to the global configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableDatabaseBatchSnapshots")]
		public HostConfigurationPropertyEnabled EnableDatabaseBatchSnapshots { get; set; }
		
		/// <summary>
		/// Defines the boolean type for host configuration. 'Enabled' specifies true, 'Disabled' specifies False, and 'Default' specifies to delete the entry and default to the global configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableGroupFetch")]
		public HostConfigurationPropertyEnabled EnableGroupFetch { get; set; }
		
		/// <summary>
		/// Defines the boolean type for host configuration. 'Enabled' specifies true, 'Disabled' specifies False, and 'Default' specifies to delete the entry and default to the global configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableVdi")]
		public HostConfigurationPropertyEnabled EnableVdi { get; set; }
		
		/// <summary>
		/// Defines the boolean type for host configuration. 'Enabled' specifies true, 'Disabled' specifies False, and 'Default' specifies to delete the entry and default to the global configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableVdiDb")]
		public HostConfigurationPropertyEnabled EnableVdiDb { get; set; }
		
		/// <summary>
		/// Number of concurrent read requests for restoring a file from the Rubrik cluster to a remote host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileRestoreReadParallelism")]
		public System.Nullable<System.Int32> FileRestoreReadParallelism { get; set; }
		
		/// <summary>
		/// Number of concurrent write requests for restoring a file from the Rubrik cluster to a remote host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileRestoreWriteParallelism")]
		public System.Nullable<System.Int32> FileRestoreWriteParallelism { get; set; }
		
		/// <summary>
		/// Number of concurrent requests for transferring a file from a remote host to the Rubrik cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileTransferParallelism")]
		public System.Nullable<System.Int32> FileTransferParallelism { get; set; }
		
		/// <summary>
		/// The default value for maximum number of data streams per database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mssqlDefaultMaxDataStreamsPerDatabase")]
		public System.Nullable<System.Int32> MssqlDefaultMaxDataStreamsPerDatabase { get; set; }
		
		/// <summary>
		/// The maximum number of concurrent database restore job running on a host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="physicalHostDatabaseRestoreThrottleMaxRefCount")]
		public System.Nullable<System.Int32> PhysicalHostDatabaseRestoreThrottleMaxRefCount { get; set; }
		
		/// <summary>
		/// Maximum number of concurrent SQL Server log backup jobs per physical host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="physicalHostLogBackupThrottleMaxRefCount")]
		public System.Nullable<System.Int32> PhysicalHostLogBackupThrottleMaxRefCount { get; set; }
		
		/// <summary>
		/// Maximum number of concurrent snapshots per physical host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="throttlePhysicalHostMaxRefCount")]
		public System.Nullable<System.Int32> ThrottlePhysicalHostMaxRefCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlHostConfigurationWithHostId : MssqlHostConfiguration
	{
		
		/// <summary>
		/// the ID of the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlHostConfigurationWithHostIdListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlHostConfigurationWithHostId[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlInstanceDetail
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlInstanceShortSummary
	{
		
		/// <summary>
		/// Active node of the instance in a Windows server failover cluster. Populated only if the node belongs to a Windows server failover cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activeNode")]
		public string ActiveNode { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network name of the instance in a Windows server failover cluster. Populated only if the node belongs to a Windows server failover cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkName")]
		public string NetworkName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlInstanceSummary : MssqlSlaRelatedProperties
	{
		
		/// <summary>
		/// The address of the instance in a Windows server failover cluster, populated only if it belongs to one.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterInstanceAddress")]
		public string ClusterInstanceAddress { get; set; }
		
		/// <summary>
		/// SLA Domain ID assigned to instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// SLA Domain name assigned to instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainName")]
		public string ConfiguredSlaDomainName { get; set; }
		
		/// <summary>
		/// Specifies whether the SLA Domain is used for protection or retention.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainType")]
		public string ConfiguredSlaDomainType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="internalTimestamp")]
		public System.Nullable<System.Int64> InternalTimestamp { get; set; }
		
		/// <summary>
		/// Boolean value that identifies a Retention Lock SLA Domain. Value is true when the SLA Domain assigned to the instance is Retention Locked and false when it is not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRetentionLocked")]
		public System.Nullable<System.Boolean> IsRetentionLocked { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protectionDate")]
		public System.Nullable<System.DateOnly> ProtectionDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rootProperties")]
		public MssqlRootProperties RootProperties { get; set; }
		
		/// <summary>
		/// A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by the Rubrik CDM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unprotectableReasons")]
		public string[] UnprotectableReasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlInstanceSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlInstanceSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlInstanceUpdate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingCreateConfig : MssqlLogShippingTargetStateOptions
	{
		
		/// <summary>
		/// Maximum number of parallel data streams that can be used to copy data to the target system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxDataStreams")]
		public System.Nullable<System.Int32> MaxDataStreams { get; set; }
		
		/// <summary>
		/// The path to the default target location for data file storage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetDataFilePath")]
		public string TargetDataFilePath { get; set; }
		
		/// <summary>
		/// The name of the secondary database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetDatabaseName")]
		public string TargetDatabaseName { get; set; }
		
		/// <summary>
		/// Array of database file storage paths. Each path is the target storage location for a database file. Values in this array override the values in targetDataFilePath and targetLogFilePath for the specified database files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetFilePaths")]
		public MssqlDbFileExportPath[] TargetFilePaths { get; set; }
		
		/// <summary>
		/// The ID of the SQL Server instance that hosts the secondary database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetInstanceId")]
		public string TargetInstanceId { get; set; }
		
		/// <summary>
		/// The path to the location of the log files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetLogFilePath")]
		public string TargetLogFilePath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingDetail : MssqlLogShippingSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="links")]
		public MssqlLogShippingLinks Links { get; set; }
		
		/// <summary>
		/// Whether to automatically disconnect users from a secondary database in Standby mode when a restore operation is performed. If this value is false and users remain connected, then any scheduled restore operations will fail. This is only returned when the secondary database is in Standby mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldDisconnectStandbyUsers")]
		public System.Nullable<System.Boolean> ShouldDisconnectStandbyUsers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingLinks
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryDatabase")]
		public Link PrimaryDatabase { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secondaryDatabase")]
		public Link SecondaryDatabase { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secondaryInstance")]
		public Link SecondaryInstance { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seedRequest")]
		public Link SeedRequest { get; set; }
	}
	
	/// <summary>
	/// Field used for sorts when enumerating log shipping entries.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlLogShippingListSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		secondaryDatabaseName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		primaryDatabaseName = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lastAppliedPoint = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		location = 3,
	}
	
	/// <summary>
	/// Secondary database states for log shipping configurations with a status of OK.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlLogShippingOkState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDBY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingReseedConfig
	{
	}
	
	/// <summary>
	/// Status of the log shipping configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlLogShippingStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Broken = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Initializing = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Stale = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingStatusInfo
	{
		
		/// <summary>
		/// Detailed message describing the status of the log shipping configuration.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Status of the log shipping configuration.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MssqlLogShippingStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingSummary
	{
		
		/// <summary>
		/// ID assigned to the log shipping configuration object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Number of milliseconds elapsed since the latest backup was applied to the secondary database and the time the backup was taken on the primary database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lagTime")]
		public System.Nullable<System.Int64> LagTime { get; set; }
		
		/// <summary>
		/// Timestamp of the last transaction applied using the specified log shipping configuration object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastAppliedPoint")]
		public System.Nullable<System.DateTimeOffset> LastAppliedPoint { get; set; }
		
		/// <summary>
		/// Location of a specified secondary database. Location uses this format: "host/instance".
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// ID of the primary database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryDatabaseId")]
		public string PrimaryDatabaseId { get; set; }
		
		/// <summary>
		/// Log backup frequency, in seconds, of the primary database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryDatabaseLogBackupFrequency")]
		public long PrimaryDatabaseLogBackupFrequency { get; set; }
		
		/// <summary>
		/// Name of the primary database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryDatabaseName")]
		public string PrimaryDatabaseName { get; set; }
		
		/// <summary>
		/// ID of the secondary database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryDatabaseId")]
		public string SecondaryDatabaseId { get; set; }
		
		/// <summary>
		/// Name of the secondary database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secondaryDatabaseName")]
		public string SecondaryDatabaseName { get; set; }
		
		/// <summary>
		/// The current state of the secondary database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MssqlLogShippingStatusInfo Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlLogShippingSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingTargetStateOptions
	{
		
		/// <summary>
		/// Specifies whether to automatically disconnect users from a secondary database in standby mode when a restore operation is performed. If this value is set to false and users remain connected, any scheduled restore operations fail. If the "state" field is `RESTORING`, this value can be omitted and is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldDisconnectStandbyUsers")]
		public System.Nullable<System.Boolean> ShouldDisconnectStandbyUsers { get; set; }
		
		/// <summary>
		/// Secondary database states for log shipping configurations with a status of OK.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public MssqlLogShippingOkState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlLogShippingUpdate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlMissedRecoverableRange
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="beginTime")]
		public System.DateTimeOffset BeginTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="errorType")]
		public string ErrorType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="firstError")]
		public MssqlMissedRecoverableRangeError FirstError { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastError")]
		public MssqlMissedRecoverableRangeError LastError { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlMissedRecoverableRangeError
	{
		
		[System.Runtime.Serialization.DataMember(Name="eventMessage")]
		public string EventMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="eventSeriesId")]
		public string EventSeriesId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.DateTimeOffset Time { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlMissedRecoverableRangeListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlMissedRecoverableRange[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlMountDetail : MssqlMountSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="links")]
		public MssqlMountLinks Links { get; set; }
		
		/// <summary>
		/// ID of the async request object for the mount task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mountRequestId")]
		public string MountRequestId { get; set; }
		
		/// <summary>
		/// ID of the async request object for the delete task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unmountRequestId")]
		public string UnmountRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlMountLinks
	{
		
		[System.Runtime.Serialization.DataMember(Name="mountRequest")]
		public Link MountRequest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mountedDatabase")]
		public Link MountedDatabase { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDatabase")]
		public Link SourceDatabase { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetInstance")]
		public Link TargetInstance { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unmountRequest")]
		public Link UnmountRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlMountSummary
	{
		
		/// <summary>
		/// The date this mount was created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// ID for the mounted SQL Server database, once it is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mountedDatabaseId")]
		public string MountedDatabaseId { get; set; }
		
		/// <summary>
		/// Name for the mounted SQL Server database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mountedDatabaseName")]
		public string MountedDatabaseName { get; set; }
		
		/// <summary>
		/// ID of the user who created this mount.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ownerId")]
		public string OwnerId { get; set; }
		
		/// <summary>
		/// Name of the user who created this mount.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ownerName")]
		public string OwnerName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDatabaseId")]
		public string SourceDatabaseId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDatabaseName")]
		public string SourceDatabaseName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceRecoveryPoint")]
		public MssqlRecoveryPoint SourceRecoveryPoint { get; set; }
		
		/// <summary>
		/// The status of this mount. The status is **_Available_** when the database is successfully mounted and ready to use.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MssqlMountSummaryStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetInstanceId")]
		public string TargetInstanceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetInstanceName")]
		public string TargetInstanceName { get; set; }
		
		/// <summary>
		/// Name of the top-level object on which the target instance resides.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetRootName")]
		public string TargetRootName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MssqlMountSummaryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Available = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unavailable = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Mounting = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unmounting = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlMountSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlMountSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlRecoverableRange
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="beginTime")]
		public System.DateTimeOffset BeginTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isMountAllowed")]
		public bool IsMountAllowed { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlRecoverableRangeListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MssqlRecoverableRange[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlRestoreEstimateResult
	{
		
		/// <summary>
		/// Estimate of the number of bytes to be downloaded from the cloud.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bytesFromCloud")]
		public long BytesFromCloud { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlRestoreFile
	{
		
		/// <summary>
		/// Original file ID of the database file to be restored.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fileId")]
		public long FileId { get; set; }
		
		/// <summary>
		/// File type of a database file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fileType")]
		public MssqlDatabaseFileType FileType { get; set; }
		
		/// <summary>
		/// Logical name of the database file to be restored.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logicalName")]
		public string LogicalName { get; set; }
		
		/// <summary>
		/// Original filename of the database file to be restored.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="originalName")]
		public string OriginalName { get; set; }
		
		/// <summary>
		/// Original path to the database file to be restored.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="originalPath")]
		public string OriginalPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlSlaDomainAssignInfo : MssqlSlaPatchProperties
	{
		
		/// <summary>
		/// Specifies the retention policy to apply to existing snapshots when unprotecting an object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="existingSnapshotRetention")]
		public ExistingSnapshotRetention ExistingSnapshotRetention { get; set; }
		
		/// <summary>
		/// List of SQL Server object IDs which should be assigned these properties.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlSlaDomainInfo
	{
		
		/// <summary>
		/// The ID of the SLA Domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Boolean value that identifies a Retention Lock SLA Domain. Value is true when an SLA Domain is Retention Locked and false when it is not.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRetentionLocked")]
		public bool IsRetentionLocked { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlSlaPatchProperties : MssqlSlaRelatedProperties
	{
		
		/// <summary>
		/// SLA Domain ID assigned to instance. Existing snapshots of the instance will be retained with the configuration of specified SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// Determines whether to use the configured default value of log backup retention.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useConfiguredDefaultLogRetention")]
		public System.Nullable<System.Boolean> UseConfiguredDefaultLogRetention { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlSlaRelatedProperties
	{
		
		/// <summary>
		/// Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copyOnly")]
		public System.Nullable<System.Boolean> CopyOnly { get; set; }
		
		/// <summary>
		/// Seconds between two log backups. A value of 0 disables log backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInSeconds")]
		public System.Nullable<System.Int32> LogBackupFrequencyInSeconds { get; set; }
		
		/// <summary>
		/// Number of hours to retain a log backup. When the value is set to -1 the Rubrik cluster retains the log backup until the database snapshots that precede the log backup have expired.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logRetentionHours")]
		public System.Nullable<System.Int32> LogRetentionHours { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MssqlSnappableId
	{
		
		/// <summary>
		/// ID of the protected object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snappableId")]
		public string SnappableId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NasSharesToAdd
	{
		
		/// <summary>
		/// The host ID of the NAS Share host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// The NAS shares to bulk add for the NAS host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nasShares")]
		public DiscoveredNasShare[] NasShares { get; set; }
	}
	
	/// <summary>
	/// NAS Vendor Type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NasVendorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETAPP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ISILON = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FLASHBLADE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkInfo
	{
		
		/// <summary>
		/// The ID of a user-configured vCenter network.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of a user-configured vCenter network.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkInfoListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkInfo[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeHostnameInfo
	{
		
		/// <summary>
		/// Hostname of a Rubrik node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// ID of a Rubrik node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeHostnameInfoListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeHostnameInfo[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeId
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodePolicyCheckResult
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="checkResults")]
		public PolicyCheckResult[] CheckResults { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyCheckResult
	{
		
		/// <summary>
		/// Output from the policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checkOutput")]
		public string CheckOutput { get; set; }
		
		/// <summary>
		/// Individual check results.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isCheckPassed")]
		public bool IsCheckPassed { get; set; }
		
		/// <summary>
		/// Node ID on which policy is enforced.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
		
		/// <summary>
		/// Policy ID for which result is collected.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyId")]
		public string PolicyId { get; set; }
	}
	
	/// <summary>
	/// Notification type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NotificationTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOTIFICATION_TYPE_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIAGNOSTIC = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NutanixVmSlaObjectCount
	{
		
		/// <summary>
		/// The number of Nutanix virtual machines protected under this SLA domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numNutanixVms")]
		public System.Nullable<System.Int32> NumNutanixVms { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ObjectHoldSummary : ObjectHolder
	{
		
		/// <summary>
		/// Number of snapshots for the object currently under legal hold.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numberOfSnapshotsHeld")]
		public int NumberOfSnapshotsHeld { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ObjectHoldSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ObjectHoldSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ObjectHolder
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		public string ObjectId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectName")]
		public string ObjectName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public string ObjectType { get; set; }
	}
	
	/// <summary>
	/// Type of the object associated with the event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ObjectTypeV1
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateAhvVm = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateAwsAzure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateHypervVm = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateLinuxUnixHosts = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateNasShares = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateOracleDb = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateSapHanaDb = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateStorageArrays = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateVcdVapps = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateVsphereVm = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AggregateWindowsHosts = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppBlueprint = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppFlows = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthDomain = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsAccount = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsEventType = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Certificate = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cluster = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ComputeInstance = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DataLocation = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ec2Instance = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Envoy = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Host = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervScvmm = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervServer = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervVm = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JobInstance = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ldap = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxHost = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxFileset = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ManagedVolume = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Mssql = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NasHost = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixCluster = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixVm = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleDb = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleHost = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleRac = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PublicCloudMachineInstance = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SamlSso = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SapHanaDb = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SapHanaSystem = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFileset = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SlaDomain = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SmbDomain = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArray = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArrayVolumeGroup = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Storm = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SupportBundle = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnknownObjectType = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrade = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UserActionAudit = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcd = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VcdVapp = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcenter = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VmwareVm = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsHost = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsFileset = 58,
	}
	
	/// <summary>
	/// The family type of the host operating system.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum OperatingSystemFamily
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AIX = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HPUX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linux = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Solaris = 3,
	}
	
	/// <summary>
	/// The operation mode determines if the API call waits until the operation is completed or returns immediately. The default operation mode is synchronous.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum OperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Synchronous = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Asynchronous = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleAcoParameterDetail
	{
		
		/// <summary>
		/// Name of the Advanced Cloning Options (ACO) parameter.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parameter")]
		public string Parameter { get; set; }
		
		/// <summary>
		/// Value for the Advanced Cloning Options (ACO) parameter.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleAcoParameterList
	{
		
		/// <summary>
		/// An array that contains the supported Advanced Cloning Options (ACO) parameters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public string[] Parameters { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleAcoValidationResult
	{
		
		/// <summary>
		/// List of Advanced Cloning Options (ACO) parameter values that were parsed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acoMap")]
		public OracleAcoParameterDetail[] AcoMap { get; set; }
		
		/// <summary>
		/// Other generic errors with the Advanced Cloning Options (ACO) parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acoParameterErrors")]
		public string[] AcoParameterErrors { get; set; }
		
		/// <summary>
		/// List of Advanced Cloning Options (ACO) errors pertaining to the specified values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acoValueValidationErrors")]
		public OracleAcoValueErrorDetail[] AcoValueValidationErrors { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleAcoValueErrorDetail
	{
		
		/// <summary>
		/// Validation error message for the provided value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		/// <summary>
		/// Name of the Advanced Cloning Options (ACO) parameter.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parameter")]
		public string Parameter { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleBulkUpdate : OracleUpdate
	{
		
		/// <summary>
		/// An array containing the IDs assigned to Oracle host, Oracle RAC, and Oracle Database objects.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleDataGuardGroupUpdate : OracleUpdateCommon
	{
		
		/// <summary>
		/// Ordered list of database unique names to use for backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferredDGMemberUniqueNames")]
		public string[] PreferredDGMemberUniqueNames { get; set; }
		
		/// <summary>
		/// Value that indicates whether to backup from the PRIMARY member only, or from any available member.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldBackupFromPrimaryOnly")]
		public System.Nullable<System.Boolean> ShouldBackupFromPrimaryOnly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleDbSummary : Snappable
	{
		
		/// <summary>
		/// An array that contains the archive log destinations for the specified Oracle database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archiveLogDestinations")]
		public string[] ArchiveLogDestinations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currentBackupTaskInfo")]
		public BackupTaskDiagnosticInfo CurrentBackupTaskInfo { get; set; }
		
		/// <summary>
		/// Rubrik ID of the Data Guard group to which this database belongs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataGuardGroupId")]
		public string DataGuardGroupId { get; set; }
		
		/// <summary>
		/// List of Data Guard group members.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataGuardGroupMembers")]
		public DataGuardGroupMember[] DataGuardGroupMembers { get; set; }
		
		/// <summary>
		/// Name of the Data Guard group to which this database belongs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataGuardGroupName")]
		public string DataGuardGroupName { get; set; }
		
		/// <summary>
		/// Specifies whether this database is a Data Guard member, Data Guard group, or a non-Data Guard database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataGuardType")]
		public DataGuardType DataGuardType { get; set; }
		
		/// <summary>
		/// Current role of the database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="databaseRole")]
		public string DatabaseRole { get; set; }
		
		/// <summary>
		/// Unique name for the Oracle database (DB_UNIQUE_NAME).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dbUniqueName")]
		public string DbUniqueName { get; set; }
		
		/// <summary>
		/// Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostLogRetentionHours")]
		public int HostLogRetentionHours { get; set; }
		
		/// <summary>
		/// ID assigned to the Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// True/false value indicating if backup task information is included in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeBackupTaskInfo")]
		public System.Nullable<System.Boolean> IncludeBackupTaskInfo { get; set; }
		
		/// <summary>
		/// An array that contains information about the objects in the infrastructure path of a specified Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="infraPath")]
		public ManagedHierarchyObjectAncestor[] InfraPath { get; set; }
		
		/// <summary>
		/// Details of the instances of the Oracle database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public OracleInstanceProperties[] Instances { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether the ARCHIVELOG mode is enabled on the Oracle database or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isArchiveLogModeEnabled")]
		public System.Nullable<System.Boolean> IsArchiveLogModeEnabled { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether the Oracle database is local to the cluster. When this value is 'true', the Oracle database is local to the cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isDbLocalToTheCluster")]
		public bool IsDbLocalToTheCluster { get; set; }
		
		/// <summary>
		/// Indicates whether the current DATABASE_ROLE is PRIMARY which specifies the database is accepting read/write transactions as the primary database in a Data Guard configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPrimary")]
		public System.Nullable<System.Boolean> IsPrimary { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether a Oracle database object is in an archived state and has retained snapshots. Value is true when the object is archived with retained snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public bool IsRelic { get; set; }
		
		/// <summary>
		/// The timestamp of the previous snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSnapshotTime")]
		public System.Nullable<System.DateTimeOffset> LastSnapshotTime { get; set; }
		
		/// <summary>
		/// Specifies an interval in minutes. This interval is the period between successive log backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInMinutes")]
		public System.Nullable<System.Int32> LogBackupFrequencyInMinutes { get; set; }
		
		/// <summary>
		/// Service name of the Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Count of the number of instances of the Oracle database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numInstances")]
		public System.Nullable<System.Int32> NumInstances { get; set; }
		
		/// <summary>
		/// An integer that specifies the number of missed snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numMissedSnapshot")]
		public int NumMissedSnapshot { get; set; }
		
		/// <summary>
		/// Count of the number of table spaces in Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numTablespaces")]
		public int NumTablespaces { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// Rubrik ID of the RAC on which this database is hosted. This field will be empty if the database is not hosted on a RAC environment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="racId")]
		public string RacId { get; set; }
		
		/// <summary>
		/// RAC name of the cluster database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="racName")]
		public string RacName { get; set; }
		
		/// <summary>
		/// System identifier (SID) of the Oracle database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		public string Sid { get; set; }
		
		/// <summary>
		/// Rubrik ID of the standalone Oracle host on which this database is hosted. This field will be empty if the database is not hosted on a standalone system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="standaloneHostId")]
		public string StandaloneHostId { get; set; }
		
		/// <summary>
		/// Hostname of the standalone Oracle database host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="standaloneHostName")]
		public string StandaloneHostName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleInstanceProperties
	{
		
		/// <summary>
		/// Name of the Oracle host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostName")]
		public string HostName { get; set; }
		
		/// <summary>
		/// System identifier (SID) of the Oracle database instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instanceSid")]
		public string InstanceSid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleDbSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public OracleDbSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleFileDownloadLink
	{
		
		/// <summary>
		/// Link for file download.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloadLink")]
		public string DownloadLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleHostSummary : SlaAssignable
	{
		
		/// <summary>
		/// ID assigned to the standalone Oracle host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// An array that contains information about the objects in the infrastructure path of a specified Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="infraPath")]
		public ManagedHierarchyObjectAncestor[] InfraPath { get; set; }
		
		/// <summary>
		/// Hostname of the standalone Oracle host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Count of the number of databases on the Oracle RAC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numDbs")]
		public int NumDbs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// Connectivity status of the Oracle RAC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleLastValidationResult
	{
		
		/// <summary>
		/// The eventseries ID for the last validation job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventSeriesId")]
		public string EventSeriesId { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether the last validation successfully completed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isSuccess")]
		public bool IsSuccess { get; set; }
		
		/// <summary>
		/// The timestamp of the recovery point to validate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="validationTime")]
		public System.DateTimeOffset ValidationTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleNodeOrder
	{
		
		/// <summary>
		/// Nodename of the Oracle RAC node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeName")]
		public string NodeName { get; set; }
		
		/// <summary>
		/// Order in which Rubrik uses this node for automated Oracle backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="order")]
		public int Order { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleNodeProperties
	{
		
		/// <summary>
		/// Node name of the Oracle RAC node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeName")]
		public string NodeName { get; set; }
		
		/// <summary>
		/// Connectivity status of the Oracle RAC node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleNonSlaProperties
	{
		
		/// <summary>
		/// Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostLogRetentionHours")]
		public int HostLogRetentionHours { get; set; }
		
		/// <summary>
		/// Path where the NFS share is mounted on the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostMount")]
		public string HostMount { get; set; }
		
		/// <summary>
		/// Specifies an interval in minutes. This interval is the period between successive log backups.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInMinutes")]
		public int LogBackupFrequencyInMinutes { get; set; }
		
		/// <summary>
		/// Specifies an interval in hours. Log backups are retained for the duration of the interval.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logRetentionHours")]
		public int LogRetentionHours { get; set; }
		
		/// <summary>
		/// Number of channels used to backup the Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numChannels")]
		public int NumChannels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleRacSummary : SlaAssignable
	{
		
		/// <summary>
		/// ID assigned to the Oracle RAC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Cluster name assigned to the Oracle RAC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies an order for the RAC nodes. Automated Oracle backups use the RAC nodes in the specified order.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeOrder")]
		public OracleNodeOrder[] NodeOrder { get; set; }
		
		/// <summary>
		/// Details of the nodes of this Oracle RAC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodes")]
		public OracleNodeProperties[] Nodes { get; set; }
		
		/// <summary>
		/// Count of the number of databases on the Oracle RAC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numDbs")]
		public int NumDbs { get; set; }
		
		/// <summary>
		/// Count of the number of nodes on the Oracle RAC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numNodes")]
		public int NumNodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// Connectivity status of the Oracle RAC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleRecoveryApiValidationErrors : OracleAcoValidationResult
	{
		
		/// <summary>
		/// Other generic validation error messages in the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="otherErrors")]
		public string[] OtherErrors { get; set; }
		
		/// <summary>
		/// Error message when post-script path is invalid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postScriptError")]
		public string PostScriptError { get; set; }
		
		/// <summary>
		/// Error message when pre-script path is invalid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preScriptError")]
		public string PreScriptError { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleRecoveryPoint
	{
		
		/// <summary>
		/// Snapshot ID of the Oracle database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotId")]
		public string SnapshotId { get; set; }
		
		/// <summary>
		/// A timestamp in milliseconds that specifies a recovery point.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestampMs")]
		public System.Nullable<System.Int64> TimestampMs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleRestoreEstimateResult
	{
		
		/// <summary>
		/// The estimated size, in bytes required to restore an Oracle database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bytesToRestore")]
		public long BytesToRestore { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleUpdate : OracleUpdateCommon
	{
		
		/// <summary>
		/// ID of the SLA domain protecting the specified Oracle object. Log backup jobs are no longer scheduled if the SLA domain indicates the Oracle object is unprotected. The specified SLA domain is not used to configure the protection or retention for this Oracle object. This is a DEPRECATED field, and will be removed in later releases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainIdDeprecated")]
		public string ConfiguredSlaDomainIdDeprecated { get; set; }
		
		/// <summary>
		/// Specifies an order for the RAC nodes. Automated Oracle backups use the RAC nodes in the specified order.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeOrder")]
		public OracleNodeOrder[] NodeOrder { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleUpdateCommon
	{
		
		/// <summary>
		/// Specifies an interval in hours. For Oracle archived redo log files whose nextTime is before (now - interval), the next log snapshot job will delete them from the host. Set to 0 for inheriting the value from its parent; -1 for immediate deletion; and -2 to skip log deletion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostLogRetentionHours")]
		public System.Nullable<System.Int32> HostLogRetentionHours { get; set; }
		
		/// <summary>
		/// Path where the NFS share is mounted on the host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostMount")]
		public string HostMount { get; set; }
		
		/// <summary>
		/// Specifies an interval in minutes. This interval is the period between successive log backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBackupFrequencyInMinutes")]
		public System.Nullable<System.Int32> LogBackupFrequencyInMinutes { get; set; }
		
		/// <summary>
		/// Specifies an interval in hours. Log backups are retained for the duration of the interval.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logRetentionHours")]
		public System.Nullable<System.Int32> LogRetentionHours { get; set; }
		
		/// <summary>
		/// Number of channels used to backup the Oracle database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numChannels")]
		public System.Nullable<System.Int32> NumChannels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleValidateConfig
	{
		
		/// <summary>
		/// Number of channels used during backup validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numChannels")]
		public System.Nullable<System.Int32> NumChannels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoveryPoint")]
		public OracleRecoveryPoint RecoveryPoint { get; set; }
		
		/// <summary>
		/// System Global Area(SGA) size used to create the instance on the target host with unit in MB. SGA is a group of shared memory structures for one Oracle Database instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sgaMaxSizeInMb")]
		public System.Nullable<System.Int64> SgaMaxSizeInMb { get; set; }
		
		/// <summary>
		/// The full path on the target host where the NFS share with the snapshot files will be mounted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetMountPath")]
		public string TargetMountPath { get; set; }
		
		/// <summary>
		/// The full path on the target host for the Oracle Home which is the directory location where all Oracle software is installed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetOracleHome")]
		public string TargetOracleHome { get; set; }
		
		/// <summary>
		/// ID of the Oracle host or Oracle RAC object that is the target for the validation job. The referenced Oracle host or Oracle RAC must have the Rubrik Backup Service (RBS) installed and connected.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetOracleHostOrRacId")]
		public string TargetOracleHostOrRacId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PasswordRequirementsPatchRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="blockPreviousPasswords")]
		public System.Nullable<System.Boolean> BlockPreviousPasswords { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clearApiTokens")]
		public System.Nullable<System.Boolean> ClearApiTokens { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clearWebSessions")]
		public System.Nullable<System.Boolean> ClearWebSessions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minLength")]
		public System.Nullable<System.Int32> MinLength { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minLowerCase")]
		public System.Nullable<System.Int32> MinLowerCase { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minNumerics")]
		public System.Nullable<System.Int32> MinNumerics { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minSpecial")]
		public System.Nullable<System.Int32> MinSpecial { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minUpperCase")]
		public System.Nullable<System.Int32> MinUpperCase { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="useZxcvbn")]
		public System.Nullable<System.Boolean> UseZxcvbn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PasswordRequirementsSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blockPreviousPasswords")]
		public bool BlockPreviousPasswords { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clearApiTokens")]
		public bool ClearApiTokens { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clearWebSessions")]
		public bool ClearWebSessions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxLength")]
		public int MaxLength { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minLength")]
		public int MinLength { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minLowerCase")]
		public int MinLowerCase { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minNumerics")]
		public int MinNumerics { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minSpecial")]
		public int MinSpecial { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minUpperCase")]
		public int MinUpperCase { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="useZxcvbn")]
		public bool UseZxcvbn { get; set; }
	}
	
	/// <summary>
	/// Status of the exclusion pattern. The 'Applied' state indicates that a pattern is already in force. The 'Applying' state indicates that the index job that applies the pattern is still running. The 'Queued' state indicates that the indexing job to apply the pattern has not launched yet.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PatternStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Applied = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Applying = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Queued = 2,
	}
	
	/// <summary>
	/// Scope of a policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PolicyScopeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POLICY_SCOPE_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NODE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLUSTER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHASSIS = 3,
	}
	
	/// <summary>
	/// Type of policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PolicyTypeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POLICY_TYPE_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHECKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLLECTOR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOTIFIER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrecheckFailureResult
	{
		
		/// <summary>
		/// The cause of the failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
		
		/// <summary>
		/// The precheck failure error code. This is used as a reference to a KB article about the error.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="errorCode")]
		public string ErrorCode { get; set; }
		
		/// <summary>
		/// The precheck failure message.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="errorMessage")]
		public string ErrorMessage { get; set; }
		
		/// <summary>
		/// The ID of the precheck error message.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Specifies whether a failed precheck prevents an upgrade from starting.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isUpgradeBlocker")]
		public bool IsUpgradeBlocker { get; set; }
		
		/// <summary>
		/// Can the user fix this precheck failure.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isUserRemediable")]
		public bool IsUserRemediable { get; set; }
		
		/// <summary>
		/// The name of the failed upgrade precheck.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="precheckName")]
		public string PrecheckName { get; set; }
		
		/// <summary>
		/// The user action needed to recover from this failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remedy")]
		public string Remedy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrecheckStatusNextRunInfo
	{
		
		/// <summary>
		/// Identifier corresponding to the currently running or next upgrade prechecks job instance.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobInstanceId")]
		public string JobInstanceId { get; set; }
		
		/// <summary>
		/// The Unix epoch timestamp, in milliseconds, corresponding to the start of the currently running or next upgrade prechecks job instance.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public long StartTime { get; set; }
		
		/// <summary>
		/// Status of the currently running or next upgrade prechecks job instance.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrecheckStatusResponse
	{
		
		/// <summary>
		/// The Unix epoch timestamp, in milliseconds, corresponding to the end of the last completed upgrade prechecks job instance.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public long EndTime { get; set; }
		
		/// <summary>
		/// The results of the failed prechecks. This includes the name of the failed prechecks and details of the error.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failureResults")]
		public PrecheckFailureResult[] FailureResults { get; set; }
		
		/// <summary>
		/// Specifies whether this result is from a user-triggered job.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isOnDemand")]
		public bool IsOnDemand { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextRunInfo")]
		public PrecheckStatusNextRunInfo NextRunInfo { get; set; }
		
		/// <summary>
		/// Total number of upgrade prechecks that were run.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numPrechecksRun")]
		public int NumPrechecksRun { get; set; }
		
		/// <summary>
		/// Time, in minutes, between consecutive runs of scheduled upgrade prechecks job instances.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runPeriodInMinutes")]
		public int RunPeriodInMinutes { get; set; }
		
		/// <summary>
		/// The Unix epoch timestamp, in milliseconds, corresponding to the start of the last completed upgrade prechecks job instance.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public long StartTime { get; set; }
	}
	
	/// <summary>
	/// The preferred network protocol to use for transferring CDP data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PreferredCdpNetworkProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPv4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPv6 = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreferredCdpNetworkProtocolObject
	{
		
		/// <summary>
		/// The preferred network protocol to use for transferring CDP data.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preferredCdpNetworkProtocol")]
		public PreferredCdpNetworkProtocol PreferredCdpNetworkProtocol { get; set; }
	}
	
	/// <summary>
	/// Attributes used to sort principal search results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PrincipalSearchSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PrincipalType = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Description = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstName = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastName = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EmailAddress = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DisplayName = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrincipalSummaryV1
	{
		
		/// <summary>
		/// ID of the authentication domain for a specified principal.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authDomainId")]
		public string AuthDomainId { get; set; }
		
		/// <summary>
		/// The type of authentication domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authDomainType")]
		public AuthDomainType AuthDomainType { get; set; }
		
		/// <summary>
		/// Short description for a principal of type group. For all other types the value is null.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Email address associated with a principal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emailAddress")]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// First name of a principal of type user. For all other types the value is null.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstName")]
		public string FirstName { get; set; }
		
		/// <summary>
		/// ID of a principal in an authentication domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether the principal has any roles assigned. When this value is 'true,' the principal has one or more roles assigned.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isAssignedRoles")]
		public bool IsAssignedRoles { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether the principal is a local user or has any roles assigned. When this value is 'true,' the principal either has one or more roles assigned or is a local user.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isAssignedRolesOrIsLocal")]
		public bool IsAssignedRolesOrIsLocal { get; set; }
		
		/// <summary>
		/// Boolean value that shows the lock state of a user account. Value is true when the account is locked and false when the account is not locked.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isLocked")]
		public bool IsLocked { get; set; }
		
		/// <summary>
		/// Indicates if the principal has TOTP authentication enabled. Returns true when TOTP is enabled, returns false when TOTP is not enabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTotpEnabled")]
		public System.Nullable<System.Boolean> IsTotpEnabled { get; set; }
		
		/// <summary>
		/// Indicates if the TOTP authentication is enforced. Returns true when TOTP is enforced, returns false when TOTP is not enforced.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTotpEnforced")]
		public System.Nullable<System.Boolean> IsTotpEnforced { get; set; }
		
		/// <summary>
		/// Last name of a principal of type user. For all other types the value is null.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastName")]
		public string LastName { get; set; }
		
		/// <summary>
		/// Name of the MFA server assgined to the user.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mfaServerName")]
		public string MfaServerName { get; set; }
		
		/// <summary>
		/// The name of a principal in an authentication domain.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Type of a principal in an authentication domain. Type can be user or group.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principalType")]
		public PrincipalSummaryV1PrincipalType PrincipalType { get; set; }
		
		/// <summary>
		/// Roles assigned to this principal.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public RoleInfo[] Roles { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PrincipalSummaryV1PrincipalType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Group = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoleInfo
	{
		
		/// <summary>
		/// The description of the role.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the role.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the organization that owns the role.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// The ID of the role.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roleId")]
		public string RoleId { get; set; }
		
		/// <summary>
		/// The role template associated with the role.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roleTemplate")]
		public string RoleTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrincipalSummaryV1ListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PrincipalSummaryV1[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// The Type of a principal in an authentication domain. Type can be user or group.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PrincipalType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Group = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrincipalWithRoleInfo
	{
		
		/// <summary>
		/// The principal that is assigned the roles.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principal")]
		public string Principal { get; set; }
		
		/// <summary>
		/// The roles that are assigned to the principal.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public RoleInfo[] Roles { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProtectedObjectsCount
	{
		
		[System.Runtime.Serialization.DataMember(Name="numDoNotProtect")]
		public System.Nullable<System.Int64> NumDoNotProtect { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="numNoSla")]
		public System.Nullable<System.Int64> NumNoSla { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numProtected")]
		public long NumProtected { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numTotal")]
		public long NumTotal { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QuarterlyConfig : FrequencyConfig
	{
		
		/// <summary>
		/// The day of the quarter when snapshot will be taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dayOfQuarter")]
		public QuarterlyConfigDayOfQuarter DayOfQuarter { get; set; }
		
		/// <summary>
		/// The month of the year when snapshot will be taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="firstQuarterStartMonth")]
		public QuarterlyConfigFirstQuarterStartMonth FirstQuarterStartMonth { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum QuarterlyConfigDayOfQuarter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstDay = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastDay = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum QuarterlyConfigFirstQuarterStartMonth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		January = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		February = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		March = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		April = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		May = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		June = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		July = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		August = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		September = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		October = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		November = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		December = 11,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RbsHostOperationRequest : RbsHostUserConfig
	{
		
		/// <summary>
		/// The operation mode determines if the API call waits until the operation is completed or returns immediately. The default operation mode is synchronous.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationMode")]
		public OperationMode OperationMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RbsHostOperationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="asyncRequestStatus")]
		public AsyncRequestStatus AsyncRequestStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rbsHostSummary")]
		public RbsHostSummary RbsHostSummary { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RbsHostSummary
	{
		
		/// <summary>
		/// UUID that uniquely identifies the Rubrik Backup Service on the Rubrik cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="agentId")]
		public string AgentId { get; set; }
		
		/// <summary>
		/// Version of the Rubrik Backup Service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="agentVersion")]
		public string AgentVersion { get; set; }
		
		/// <summary>
		/// IP address or hostname of the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Version of the operating system that the host is running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osInfo")]
		public string OsInfo { get; set; }
		
		/// <summary>
		/// Type of the operating system that the host is running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osType")]
		public string OsType { get; set; }
		
		/// <summary>
		/// The status of the Rubrik Backup Service on the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public HostRbsStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RbsHostUserConfig
	{
		
		/// <summary>
		/// IP address or hostname of the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Number of seconds after which the operation is terminated if it has not completed execution. Default value is 600 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationTimeout")]
		public System.Nullable<System.Int64> OperationTimeout { get; set; }
		
		/// <summary>
		/// Password associated with the username that has access to the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Name of the user account that has sudo/admin privileges on the RBS host. This is required to install/uninstall/upgrade RBS packages on the RBS host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReaderRefreshDataSourcesRequest
	{
		
		/// <summary>
		/// The owner cluster assigned IDs for data sources previously recovered from a reader archival location, which is a read only archival location connected from the local cluster to the archival location owned by some other cluster through connect-as-reader operation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archivalDataSourceIds")]
		public string[] ArchivalDataSourceIds { get; set; }
		
		/// <summary>
		/// The locally assigned IDs for data sources previously recovered from a reader archival location, which is a read only archival location connected from the local cluster to the archival location owned by some other cluster through connect-as-reader operation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localDataSourceIds")]
		public string[] LocalDataSourceIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RefreshableObjectConnectionStatus
	{
		
		/// <summary>
		/// Details about the object status. Will be populated if the status is "BadlyConfigured".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Status of the refreshable object. Possible values are "Disconnected" (no communication possible with object), "Refreshing" (able to communicate with object but has not refreshed yet), "Connected" (refreshed the metadata for the object), "BadlyConfigured" (object not configured correctly), "Deleting" (in process of removing the object), and "Remote" (replicated object that we should not connect to).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public RefreshableObjectConnectionStatusStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RefreshableObjectConnectionStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disconnected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Refreshing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadlyConfigured = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Remote = 5,
	}
	
	/// <summary>
	/// Status of the refreshable object. Possible values are "Disconnected" (no communication possible with object), "Refreshing" (able to communicate with object but has not refreshed yet), "Connected" (refreshed the metadata for the object), "BadlyConfigured" (object not configured correctly), "Deleting" (in process of removing the object), and "Remote" (replicated object that we should not connect to).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RefreshableObjectConnectionStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disconnected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Refreshing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadlyConfigured = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Remote = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RelocateMountConfig
	{
		
		/// <summary>
		/// The ID of the datastore that is the target of relocation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datastoreId")]
		public string DatastoreId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemediationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public RemediationRequestRunConfig Config { get; set; }
		
		/// <summary>
		/// List of identifiers to uniquely identify failed tasks.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public RemediationRequestSpec[] Spec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemediationRequestRunConfig
	{
		
		/// <summary>
		/// If false, Rubrik CDM uses the configured SLA domain backup window to reschedule the task.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runNow")]
		public bool RunNow { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemediationRequestSpec
	{
		
		/// <summary>
		/// Event series ID of the failed or cancelled task.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventSeriesId")]
		public string EventSeriesId { get; set; }
		
		/// <summary>
		/// Object id.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		public string ObjectId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemediationResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asyncRequestStatus")]
		public AsyncRequestStatus AsyncRequestStatus { get; set; }
		
		/// <summary>
		/// Aggregated ID for the series of events, including the status for all retry attempts.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventSeriesId")]
		public string EventSeriesId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicationSpec
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="locationName")]
		public string LocationName { get; set; }
		
		/// <summary>
		/// Specifies an interval in seconds. Logs are retained at the replication location until the specified interval expires.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logRetentionLimit")]
		public System.Nullable<System.Int64> LogRetentionLimit { get; set; }
		
		/// <summary>
		/// The type of replication for an SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicationType")]
		public System.Nullable<ReplicationSpecReplicationType> ReplicationType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retentionLimit")]
		public long RetentionLimit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReplicationSpecReplicationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPLICATION_TO_CLUSTER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPLICATION_TO_CLOUD_LOCATION = 1,
	}
	
	/// <summary>
	/// The type of replication for an SLA Domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReplicationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPLICATION_TO_CLUSTER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPLICATION_TO_CLOUD_LOCATION = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportConfigPatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="cleanupReportJobInstanceForLogJobs")]
		public System.Nullable<System.Int32> CleanupReportJobInstanceForLogJobs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportConfigResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="cleanupReportJobInstanceForLogJobs")]
		public System.Nullable<System.Int32> CleanupReportJobInstanceForLogJobs { get; set; }
	}
	
	/// <summary>
	/// Object types that are reported on.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReportableObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppBlueprint = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ec2Instance = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hdfs = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervVirtualMachine = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxFileset = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ManagedVolume = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Mssql = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixVirtualMachine = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleDatabase = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SapHanaDatabase = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFileset = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArrayVolumeGroup = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VcdVapp = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VmwareVirtualMachine = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsFileset = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsVolumeGroup = 15,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RequestFailedException
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="errorType")]
		public string ErrorType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="param")]
		public string Param { get; set; }
	}
	
	/// <summary>
	/// Provides the definition to create a new user-defined resource tag.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceTagDefinition
	{
		
		/// <summary>
		/// The key of the resource tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The ID of the archival location associated with the resource that has the specified user-defined resource tag.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scopeRefId")]
		public string ScopeRefId { get; set; }
		
		/// <summary>
		/// The value of the resource tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Lists the IDs of resource tags that were deleted successfully.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceTagDeleteResponse
	{
		
		/// <summary>
		/// List of deleted IDs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	/// <summary>
	/// Provides the details for a user-defined resource tag, which tags cloud compute resources created by CloudOn and CloudOut.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceTagDetail
	{
		
		/// <summary>
		/// The ID of the resource tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The key of the resource tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// A timestamp (in UTC) that indicates when the resource tag was last updated.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdateTime")]
		public string LastUpdateTime { get; set; }
		
		/// <summary>
		/// The ID of the archival location associated with the resource that has the specified user-defined resource tag.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scopeRefId")]
		public string ScopeRefId { get; set; }
		
		/// <summary>
		/// The value of the resource tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Returns the results of a query on user-defined resource tags.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceTagGetResponse
	{
		
		/// <summary>
		/// List of resource tags.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceTags")]
		public ResourceTagDetail[] ResourceTags { get; set; }
	}
	
	/// <summary>
	/// Updates an existing user-defined resource tag.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceTagUpdate
	{
		
		/// <summary>
		/// The value of the resource tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RestoreFileJobConfig
	{
		
		/// <summary>
		/// Domain name (Use . for local admin).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		public string DomainName { get; set; }
		
		/// <summary>
		/// Optional Boolean field to determine whether to ignore errors during restore jobs that use the Rubrik Backup Service. When 'true', errors are ignored. Default value is 'false', errors are not ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ignoreErrors")]
		public System.Nullable<System.Boolean> IgnoreErrors { get; set; }
		
		/// <summary>
		/// Password.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Absolute file path.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Directory of folder to copy files into.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restorePath")]
		public string RestorePath { get; set; }
		
		/// <summary>
		/// Boolean value that determines restore file settings for Linux systems and for Windows systems. For Linux, use 'true' to include the extended attributes of restored files. For Window, use 'true' to include alternate data streams for restored files. For both, use 'false' to exclude this additional metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldRestoreXAttrs")]
		public System.Nullable<System.Boolean> ShouldRestoreXAttrs { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether to save the user-entered credentials. When 'true', the user-entered credentials are saved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldSaveCredentials")]
		public System.Nullable<System.Boolean> ShouldSaveCredentials { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether to use the Rubrik Backup Service or VMware tools to restore file. When 'true', the RBS restores file. When 'false', the VMware tools restores file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldUseAgent")]
		public System.Nullable<System.Boolean> ShouldUseAgent { get; set; }
		
		/// <summary>
		/// Username.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RestoreMssqlDbJobConfig
	{
		
		/// <summary>
		/// A Boolean value that determines the recovery option to use during database restore. When this value is 'true', the database is restored using the RECOVERY option and is fully functional at the end of the restore operation. When this value is 'false', the database is restored using the NORECOVERY option and remains in recovering mode at the end of the restore operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="finishRecovery")]
		public System.Nullable<System.Boolean> FinishRecovery { get; set; }
		
		/// <summary>
		/// Maximum number of parallel data streams that can be used to copy data to the target system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxDataStreams")]
		public System.Nullable<System.Int32> MaxDataStreams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoveryPoint")]
		public MssqlRecoveryPoint RecoveryPoint { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoleAssignmentRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principals")]
		public string[] Principals { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public string[] Roles { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoleInfoCreate
	{
		
		/// <summary>
		/// The description of the role.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the role.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the organization that owns the role.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// The role template associated with the role.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roleTemplate")]
		public string RoleTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoleInfoListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RoleInfo[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoleInfoUpdate
	{
		
		/// <summary>
		/// The description of the role.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the role.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoleInfoWithPrincipals
	{
		
		/// <summary>
		/// The principals that are assigned the role.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principals")]
		public string[] Principals { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public RoleInfo Role { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for roles.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RoleListSortAttributes
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Description = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RoleTemplate = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RsaMfaServerConfig : RsaMfaServerConfigWithoutSecrets
	{
		
		/// <summary>
		/// A unique string that RSA SecurID Access uses to identify individual REST API clients (not to be confused with a REST API Key described above).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restApiAccessId")]
		public string RestApiAccessId { get; set; }
		
		/// <summary>
		/// A unique string that RSA SecurID Access generates and uses as a shared secret with REST API clients.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restApiKey")]
		public string RestApiKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RsaMfaServerConfigUpdate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RsaMfaServerConfigWithoutSecrets : MfaServerConfig
	{
		
		/// <summary>
		/// The name of a Cloud Authentication Service policy. This setting is only required for RSA Cloud Service configurations.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assurancePolicyName")]
		public string AssurancePolicyName { get; set; }
		
		/// <summary>
		/// The base url for RSA REST API server including the host name and port number. A valid input looks like https://<SECURID_ACCESS_HOST >:<REST_API_PORT>/mfa/v1_1.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="baseUrl")]
		public string BaseUrl { get; set; }
		
		/// <summary>
		/// ID corresponding to the imported certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// A unique name to identify the client. When the client is configured to use RSA Authentication Manager, the client ID must match an authentication agent name.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// LDAP attribute to query the username used for performing MFA.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ldapUsernameAttribute")]
		public string LdapUsernameAttribute { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RsaMfaServerDetail : RsaMfaServerConfigWithoutSecrets
	{
		
		/// <summary>
		/// Unique server identifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// LDAP attribute to query the username used for performing MFA.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ldapUsernameAttribute")]
		public string LdapUsernameAttribute { get; set; }
		
		/// <summary>
		/// Specifies a number of seconds to wait for server response to a given authentication method.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public int Timeout { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RsaMfaServerDetailListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RsaMfaServerDetail[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RubrikMibFileDownloadLink
	{
		
		/// <summary>
		/// Rubrik MIB file download link.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloadLink")]
		public string DownloadLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RubrikSamlMetadataDetail
	{
		
		/// <summary>
		/// Rubrik metadata XML file in a base64 encoded format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadataXmlBase64")]
		public string MetadataXmlBase64 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RubrikSamlMetadataInfo
	{
		
		/// <summary>
		/// The IP address or FQDN of the host that consumes the SAML assertions from the ID provider. When hostAddress is blank, an arbitrary floating IP address is assigned as the host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostAddress")]
		public string HostAddress { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RubrikSamlMetadataSummary
	{
		
		/// <summary>
		/// URL of the metadata file for downloading.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadataUrl")]
		public string MetadataUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RunPolicyArg
	{
		
		/// <summary>
		/// List of node IDs where policies will be enforced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeIds")]
		public string[] NodeIds { get; set; }
		
		/// <summary>
		/// List of policy IDs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policyIds")]
		public string[] PolicyIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SamlSsoAuthnRequestDetail
	{
		
		/// <summary>
		/// The SSO endpoint where the SAML authentication request is sent.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="idpSsoUrl")]
		public string IdpSsoUrl { get; set; }
		
		/// <summary>
		/// The SAML relay state associated with the SAML response and request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="relayState")]
		public string RelayState { get; set; }
		
		/// <summary>
		/// SAML authentication request XML in base-64 encoding.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="samlRequest")]
		public string SamlRequest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SamlSsoAuthnRequestInfo
	{
		
		/// <summary>
		/// A Boolean that determines whether the authentication request is part of an identity provider test. A value of 'true' indicates that the authentication request is part of an identity provider test. A value of 'false' indicates that the authentication request is not part of an identity provider test.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isForIdpTest")]
		public System.Nullable<System.Boolean> IsForIdpTest { get; set; }
		
		/// <summary>
		/// The resource location that the Rubrik cluster redirects the browser to after a successful login. The value is the resource path portion of the URL of the resource. For example, for resource1 at http://example-host.com/resources/resource1, the value is "/resources/resource1".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectPath")]
		public string RedirectPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SamlSsoStatus
	{
		
		/// <summary>
		/// The name of the default IdP authentication domain used for SSO.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultIdp")]
		public string DefaultIdp { get; set; }
		
		/// <summary>
		/// To specify whether Federated Login is enabled. When the value is 'true', Federated Login is enabled. When this value is 'false', or this field not present, Federated Login is disabled. Federated login enables the inheritance of user roles and privileges from Polaris to CDM clusters registered on Polaris.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isGpsLoginEnabled")]
		public System.Nullable<System.Boolean> IsGpsLoginEnabled { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether SAML SSO is enabled. When this value is 'true', SAML SSO is enabled. When this value is 'false', SAML SSO is disabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isSsoEnabled")]
		public bool IsSsoEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaAddSystemResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asyncRequestStatus")]
		public AsyncRequestStatus AsyncRequestStatus { get; set; }
		
		/// <summary>
		/// The ID of the added SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaDataPathSpec
	{
		
		/// <summary>
		/// The name of the data backup storage. For on-premises backups, this value is the name of the Managed Volume. For GCP backups, this value is the name of the Google Cloud Platform bucket.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Data path of the SAP HANA BACKINT interface specifying the location where the BACKINT interface stores backups. Supported data path types are MANAGED_VOLUME, GCP, and LOCAL. MANAGED_VOLUME specifies a data path used by the BACKINT interface to store backups on an on-premises Rubrik CDM cluster. GCP specifies that backups are stored on Google Cloud Platform. LOCAL indicates the backup is stored locally.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaDataPathType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GCP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANAGED_VOLUME = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaDatabaseDetail : SapHanaDatabaseSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="dataPathSpec")]
		public SapHanaDataPathSpec DataPathSpec { get; set; }
		
		/// <summary>
		/// Determines whether to force a full snapshot for the next backup of the SAP HANA database. Use true to force a full snapshot and false to use the default. The backup job resets the parameter to false after a successful full backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forceFull")]
		public bool ForceFull { get; set; }
		
		/// <summary>
		/// The most recent recovery point for the database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestRecoveryPoint")]
		public System.Nullable<System.DateTimeOffset> LatestRecoveryPoint { get; set; }
		
		/// <summary>
		/// The log snapshot job interval in minutes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logSnapshotJobIntervalInMinutes")]
		public int LogSnapshotJobIntervalInMinutes { get; set; }
		
		/// <summary>
		/// The number of channels for multistream backups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numChannels")]
		public System.Nullable<System.Int32> NumChannels { get; set; }
		
		/// <summary>
		/// The earliest recovery point for the database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oldestRecoveryPoint")]
		public System.Nullable<System.DateTimeOffset> OldestRecoveryPoint { get; set; }
		
		/// <summary>
		/// The Prefixes of previous failed backup jobs. Prefix is an identifier used by SAP HANA BACKINT to uniquely identify backups.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previousFailedBackupPrefixes")]
		public string[] PreviousFailedBackupPrefixes { get; set; }
		
		/// <summary>
		/// The total number of SAP HANA snapshots that have been taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotCount")]
		public int SnapshotCount { get; set; }
	}
	
	/// <summary>
	/// The SAP HANA database attribute to use in sorting the responses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaDatabaseListSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sapHanaSystemName = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaDatabasePatch
	{
		
		/// <summary>
		/// The ID of the SLA Domain that is configured for the SAP HANA database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// The log snapshot job interval in minutes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logSnapshotJobIntervalInMinutes")]
		public System.Nullable<System.Int32> LogSnapshotJobIntervalInMinutes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaDatabaseSnapshotDetail : BaseSnapshotDetail
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaDatabaseSnapshotSummary : BaseSnapshotSummary
	{
		
		/// <summary>
		/// ID of the SAP HANA backup. This ID uniquely identifies a backup to SAP HANA. All backup files from a single backup share the same backup ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backupId")]
		public long BackupId { get; set; }
		
		/// <summary>
		/// The backup prefix that was used while taking the backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backupPrefix")]
		public string BackupPrefix { get; set; }
		
		/// <summary>
		/// Type of the SAP HANA backup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backupType")]
		public SapHanaDatabaseSnapshotSummaryBackupType BackupType { get; set; }
		
		/// <summary>
		/// The backup ID of the full data backup or the delta backup on which the current delta backup is based.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseBackupId")]
		public System.Nullable<System.Int64> BaseBackupId { get; set; }
		
		/// <summary>
		/// This specifies whether the backup was triggered by HANA studio, SAP HANA cockpit, or using HDBSQL commands.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isExternalBackup")]
		public bool IsExternalBackup { get; set; }
		
		/// <summary>
		/// This specifies whether the backup was triggered by Rubrik and and whether the backup is an on-demand snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRubrikTriggeredOnDemandBackup")]
		public bool IsRubrikTriggeredOnDemandBackup { get; set; }
		
		/// <summary>
		/// The end time, in UTC, of the backup with respect to the Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rubrikSnapshotEndTime")]
		public System.DateTimeOffset RubrikSnapshotEndTime { get; set; }
		
		/// <summary>
		/// The start time, in UTC, of the backup with respect to the Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rubrikSnapshotStartTime")]
		public System.DateTimeOffset RubrikSnapshotStartTime { get; set; }
		
		/// <summary>
		/// The end time, in UTC, of the backup with respect to the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sapHanaEndTime")]
		public System.DateTimeOffset SapHanaEndTime { get; set; }
		
		/// <summary>
		/// The start time, in UTC, of the backup with respect to the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sapHanaStartTime")]
		public System.DateTimeOffset SapHanaStartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaDatabaseSnapshotSummaryBackupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCREMENTAL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaDatabaseSnapshotSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SapHanaDatabaseSnapshotSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaDatabaseSummary : Snappable
	{
		
		/// <summary>
		/// Data path of the SAP HANA BACKINT interface specifying the location where the BACKINT interface stores backups. Supported data path types are MANAGED_VOLUME, GCP, and LOCAL. MANAGED_VOLUME specifies a data path used by the BACKINT interface to store backups on an on-premises Rubrik CDM cluster. GCP specifies that backups are stored on Google Cloud Platform. LOCAL indicates the backup is stored locally.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataPathType")]
		public SapHanaDataPathType DataPathType { get; set; }
		
		/// <summary>
		/// Whether the database is in an ACTIVE,INACTIVE, or UNKNOWN state.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dbStatus")]
		public SapHanaDatabaseSummaryDbStatus DbStatus { get; set; }
		
		/// <summary>
		/// The type of SAP HANA database. Possible values are SYSTEM or TENANT. The SYSTEM database stores information about SAP HANA users and central system management. The TENANT database contains databases used by applications.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dbType")]
		public SapHanaDatabaseSummaryDbType DbType { get; set; }
		
		/// <summary>
		/// The ID of the SAP HANA database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Specifies whether the SAP HANA database is accessible on the CDM cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public bool IsRelic { get; set; }
		
		/// <summary>
		/// The log backup interval in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBackupIntervalInSecs")]
		public System.Nullable<System.Int32> LogBackupIntervalInSecs { get; set; }
		
		/// <summary>
		/// The name of the SAP HANA database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the CDM cluster that protects the SAP HANA database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterUuid")]
		public string PrimaryClusterUuid { get; set; }
		
		/// <summary>
		/// The UTC timestamp for when the SAP HANA database was first protected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectionDate")]
		public System.Nullable<System.DateTimeOffset> ProtectionDate { get; set; }
		
		/// <summary>
		/// The ID of the SAP HANA system that owns the database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sapHanaSystemId")]
		public string SapHanaSystemId { get; set; }
		
		/// <summary>
		/// Name of the SAP HANA system that owns the database.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sapHanaSystemName")]
		public string SapHanaSystemName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaDatabaseSummaryDbStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaDatabaseSummaryDbType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYSTEM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TENANT = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaDatabaseSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SapHanaDatabaseSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaHost
	{
		
		/// <summary>
		/// The IP address or fully qualified domain name of the SAP HANA host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostName")]
		public string HostName { get; set; }
		
		/// <summary>
		/// The type of the SAP HANA system host. Possible values are MASTER, SLAVE, SECONDARY_MASTER or SECONDARY_SLAVE .
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostType")]
		public System.Nullable<SapHanaHostHostType> HostType { get; set; }
		
		/// <summary>
		/// The ID of the SAP HANA system host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostUuid")]
		public string HostUuid { get; set; }
		
		/// <summary>
		/// The local name of the SAP HANA host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sapHanaHostName")]
		public string SapHanaHostName { get; set; }
		
		/// <summary>
		/// The status of the SAP HANA system host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaHostHostType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MASTER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SLAVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECONDARY_MASTER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECONDARY_SLAVE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaPatchSystemResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asyncRequestStatus")]
		public AsyncRequestStatus AsyncRequestStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="systemSummary")]
		public SapHanaSystemSummary SystemSummary { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaRecoverableRange
	{
		
		/// <summary>
		/// Start time of the SAP HANA recoverable range.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="beginTime")]
		public System.DateTimeOffset BeginTime { get; set; }
		
		/// <summary>
		/// End time of the SAP HANA recoverable range.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaRecoverableRangeListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SapHanaRecoverableRange[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaRestoreSourceConfig
	{
		
		/// <summary>
		/// ID of the source database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snappable_id")]
		public string Snappable_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaSslInfo
	{
		
		/// <summary>
		/// The encryption provider for the SAPA HANA system. Possible values are OPENSSL, COMMON_CRYPTO, SAP_CRYPTO.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encryptionProvider")]
		public SapHanaSslInfoEncryptionProvider EncryptionProvider { get; set; }
		
		/// <summary>
		/// The path where the encryption key for the SAP HANA system is stored.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyStorePath")]
		public string KeyStorePath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaSslInfoEncryptionProvider
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENSSL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMON_CRYPTO = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SAP_CRYPTO = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaSystemConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="dataPathSpec")]
		public SapHanaSystemDataPathSpec DataPathSpec { get; set; }
		
		/// <summary>
		/// The SAP HANA system hosts.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostIds")]
		public string[] HostIds { get; set; }
		
		/// <summary>
		/// The instance number of the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instanceNumber")]
		public string InstanceNumber { get; set; }
		
		/// <summary>
		/// The password of the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The SAP System Identification (SID) code for the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sid")]
		public string Sid { get; set; }
		
		/// <summary>
		/// The username of the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaSystemDataPathSpec
	{
		
		/// <summary>
		/// Data path of the SAP HANA BACKINT interface specifying the location where the BACKINT interface stores backups. Supported data path types are MANAGED_VOLUME, GCP, and LOCAL. MANAGED_VOLUME specifies a data path used by the BACKINT interface to store backups on an on-premises Rubrik CDM cluster. GCP specifies that backups are stored on Google Cloud Platform. LOCAL indicates the backup is stored locally.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataPathType")]
		public SapHanaDataPathType DataPathType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaSystemInfo
	{
		
		/// <summary>
		/// The version of the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hanaVersion")]
		public string HanaVersion { get; set; }
		
		/// <summary>
		/// Indicates whether the SAP HANA system has replication enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isSystemReplicationEnabled")]
		public bool IsSystemReplicationEnabled { get; set; }
	}
	
	/// <summary>
	/// The SAP HANA system attribute to use in sorting the responses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaSystemListSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sid = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaSystemPatch
	{
		
		/// <summary>
		/// The ID of the SLA Domain that is configured for the SAP HANA system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// The SAP HANA system hosts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostIds")]
		public string[] HostIds { get; set; }
		
		/// <summary>
		/// The instance number of the SAP HANA system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceNumber")]
		public string InstanceNumber { get; set; }
		
		/// <summary>
		/// The password of the SAP HANA system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The SAP System Identification (SID) code for the SAP HANA system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		public string Sid { get; set; }
		
		/// <summary>
		/// The username of the SAP HANA system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaSystemSummary : SlaAssignable
	{
		
		/// <summary>
		/// The container type of the SAP HANA system. Possible values are SINGLE_CONTAINER, MULTI_CONTAINER.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="containerType")]
		public System.Nullable<SapHanaSystemSummaryContainerType> ContainerType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public SapHanaHost[] Hosts { get; set; }
		
		/// <summary>
		/// The ID of the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The instance number of the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instanceNumber")]
		public string InstanceNumber { get; set; }
		
		/// <summary>
		/// The UTC timestamp for when the SAP HANA system was last refreshed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastRefreshTime")]
		public System.Nullable<System.DateTimeOffset> LastRefreshTime { get; set; }
		
		/// <summary>
		/// The number of databases in the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numDbs")]
		public int NumDbs { get; set; }
		
		/// <summary>
		/// The SAP System Identification (SID) code for the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sid")]
		public string Sid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sslInfo")]
		public SapHanaSslInfo SslInfo { get; set; }
		
		/// <summary>
		/// The status of the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public SapHanaSystemSummaryStatus Status { get; set; }
		
		/// <summary>
		/// The message associated with the current SAP HANA system status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="systemInfo")]
		public SapHanaSystemInfo SystemInfo { get; set; }
		
		/// <summary>
		/// The username of the SAP HANA system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaSystemSummaryContainerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SINGLE_CONTAINER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MULTI_CONTAINER = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SapHanaSystemSummaryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SapHanaSystemSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SapHanaSystemSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Action to take if the script returns an error or times out.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ScriptErrorAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		abort = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="continue")]
		_continue = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SearchResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="fileVersions")]
		public FileVersion[] FileVersions { get; set; }
		
		/// <summary>
		/// Just the filename without the whole path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SearchResponseListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SearchResponse[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SessionSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="expiration")]
		public string Expiration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public string[] Groups { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaAssignable
	{
		
		/// <summary>
		/// The ID of the SLA Domain configured directly on the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain configured directly on the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainName")]
		public string ConfiguredSlaDomainName { get; set; }
		
		/// <summary>
		/// Specifies whether the SLA Domain is used for protection or retention.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainType")]
		public ConfiguredSlaType ConfiguredSlaDomainType { get; set; }
		
		/// <summary>
		/// The ID of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Indicates whether the configured SLA Domain is Retention Locked. When this value is 'true', the configured SLA Domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isConfiguredSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsConfiguredSlaDomainRetentionLocked { get; set; }
		
		/// <summary>
		/// The name of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the cluster that manages the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// The UTC time when the SLA Domain was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slaLastUpdateTime")]
		public System.Nullable<System.DateTimeOffset> SlaLastUpdateTime { get; set; }
	}
	
	/// <summary>
	/// Specifies the method used to apply an SLA Domain to an object. Possible values are Derived, Direct, and Unassigned.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SlaAssignment
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Derived = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Direct = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unassigned = 2,
	}
	
	/// <summary>
	/// The day of the month when snapshot will be taken.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SlaDayOfMonth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstDay = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fifteenth = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastDay = 2,
	}
	
	/// <summary>
	/// The day of the quarter when snapshot will be taken.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SlaDayOfQuarter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstDay = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastDay = 1,
	}
	
	/// <summary>
	/// The day of the week when snapshot will be taken.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SlaDayOfWeek
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Monday = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Tuesday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Wednesday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Thursday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Friday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Saturday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Sunday = 6,
	}
	
	/// <summary>
	/// The day of the year when snapshot will be taken.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SlaDayOfYear
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstDay = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LastDay = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaDomainDefinition
	{
		
		[System.Runtime.Serialization.DataMember(Name="allowedBackupWindows")]
		public BackupWindow[] AllowedBackupWindows { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archivalSpecs")]
		public ArchivalSpec[] ArchivalSpecs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="firstFullAllowedBackupWindows")]
		public BackupWindow[] FirstFullAllowedBackupWindows { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequencies")]
		public SlaFrequency[] Frequencies { get; set; }
		
		/// <summary>
		/// Boolean value that identifies a Retention Lock SLA Domain. Value is true when an SLA Domain is Retention Locked and false when it is not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRetentionLocked")]
		public System.Nullable<System.Boolean> IsRetentionLocked { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="localRetentionLimit")]
		public System.Nullable<System.Int64> LocalRetentionLimit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="replicationSpecs")]
		public ReplicationSpec[] ReplicationSpecs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaFrequency
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public int Frequency { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retention")]
		public int Retention { get; set; }
		
		/// <summary>
		/// Units for frequency and retention. Accepted values are Hourly, Daily, Weekly, Monthly, and Yearly.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeUnit")]
		public string TimeUnit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaDomainPatchDefinition
	{
		
		[System.Runtime.Serialization.DataMember(Name="allowedBackupWindows")]
		public BackupWindow[] AllowedBackupWindows { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="archivalSpecs")]
		public ArchivalSpec[] ArchivalSpecs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="firstFullAllowedBackupWindows")]
		public BackupWindow[] FirstFullAllowedBackupWindows { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="frequencies")]
		public SlaFrequency[] Frequencies { get; set; }
		
		/// <summary>
		/// Boolean value that identifies a Retention Lock SLA Domain. Value is true when an SLA Domain is Retention Locked and false when it is not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRetentionLocked")]
		public System.Nullable<System.Boolean> IsRetentionLocked { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="localRetentionLimit")]
		public System.Nullable<System.Int64> LocalRetentionLimit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="replicationSpecs")]
		public ReplicationSpec[] ReplicationSpecs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaDomainSummary : SlaObjectCounts
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowedBackupWindows")]
		public BackupWindow[] AllowedBackupWindows { get; set; }
		
		/// <summary>
		/// Specification for archival locations on this SLA.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archivalSpecs")]
		public ArchivalSpec[] ArchivalSpecs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="firstFullAllowedBackupWindows")]
		public BackupWindow[] FirstFullAllowedBackupWindows { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequencies")]
		public SlaFrequency[] Frequencies { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isDefault")]
		public bool IsDefault { get; set; }
		
		/// <summary>
		/// A Boolean value that specifies whether protection for all the snappables that are protected by the specified SLA Domain is paused. When the value is 'true' protection is paused.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPaused")]
		public System.Nullable<System.Boolean> IsPaused { get; set; }
		
		/// <summary>
		/// Boolean value that identifies a Retention Lock SLA Domain. Value is true when an SLA Domain is Retention Locked and false when it is not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRetentionLocked")]
		public System.Nullable<System.Boolean> IsRetentionLocked { get; set; }
		
		/// <summary>
		/// Retention limit for snapshots on the local Rubrik system. If none, they will remain as long as SLA requires.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localRetentionLimit")]
		public System.Nullable<System.Int64> LocalRetentionLimit { get; set; }
		
		/// <summary>
		/// Maximum limit for snapshots to be retained on the local Rubrik system. For local sla, it would be max of frequencies but for remote sla, it would be the retentionLimit set on the replication target location. (Local location is the replication target location for remote sla).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxLocalRetentionLimit")]
		public long MaxLocalRetentionLimit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// Specification for replication locations on this SLA.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicationSpecs")]
		public ReplicationSpec[] ReplicationSpecs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uiColor")]
		public string UiColor { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaDomainSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SlaDomainSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// The month of the year when snapshot will be taken.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SlaMonth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		January = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		February = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		March = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		April = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		May = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		June = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		July = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		August = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		September = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		October = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		November = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		December = 11,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlaObjectCounts : NutanixVmSlaObjectCount
	{
		
		/// <summary>
		/// The number of EC2 instances protected under this SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numEc2Instances")]
		public System.Nullable<System.Int32> NumEc2Instances { get; set; }
	}
	
	/// <summary>
	/// Units for frequency and retention. Accepted values are Minute, Hourly, Daily, Weekly, Monthly, Quarterly, and Yearly.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SlaTimeUnit
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Minute = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hourly = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Daily = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Weekly = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Monthly = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Quarterly = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Yearly = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Snappable : SlaAssignable
	{
		
		/// <summary>
		/// The ID of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainId")]
		public string EffectiveSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain that controls the protection of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainName")]
		public string EffectiveSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaDomainPolarisManagedId")]
		public string EffectiveSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectId")]
		public string EffectiveSlaSourceObjectId { get; set; }
		
		/// <summary>
		/// The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="effectiveSlaSourceObjectName")]
		public string EffectiveSlaSourceObjectName { get; set; }
		
		/// <summary>
		/// Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEffectiveSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsEffectiveSlaDomainRetentionLocked { get; set; }
	}
	
	/// <summary>
	/// Whether the data source passes additional privilege checks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnappablePrivilegeStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Protectable = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnappableRecoveryInfo
	{
		
		/// <summary>
		/// Indicates whether snapshot metadata refresh is in progress for this data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRefreshInProgressOpt")]
		public System.Nullable<System.Boolean> IsRefreshInProgressOpt { get; set; }
		
		/// <summary>
		/// The time when the recovery infomation was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedTimeOpt")]
		public System.Nullable<System.DateTimeOffset> LastUpdatedTimeOpt { get; set; }
		
		/// <summary>
		/// The reader location ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// The newly assigned ID of the recovered data source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="newSnappableId")]
		public string NewSnappableId { get; set; }
		
		/// <summary>
		/// The original data source ID used in the owner cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="oldSnappableId")]
		public string OldSnappableId { get; set; }
	}
	
	/// <summary>
	/// The current cloud storage tier of a snapshot. A snapshot's cloud storage tier determines how the cloud provider will determine storage and retrieval costs, as well as retrieval latency. Accepted values are Hot, Cool, AzureArchive (with Azure locations), Glacier, and GlacierDeepArchive (for AWS S3 locations). The value Cold has been deprecated in favor of AzureArchive, which is the recommended replacement value.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnapshotCloudStorageTier
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cool = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cold = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AzureArchive = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Glacier = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GlacierDeepArchive = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotEventSeries
	{
		
		/// <summary>
		/// The event series ID for the events triggered during the verification process for that snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventSeriesId")]
		public string EventSeriesId { get; set; }
		
		/// <summary>
		/// The ID of the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotId")]
		public string SnapshotId { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for snapshots.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnapshotSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SnapshotDateAndTime = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LocalExpirationDate = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ArchivalLocation = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotStorageStats
	{
		
		/// <summary>
		/// Amount of bytes actually ingested for the snapshot. This value reflects the amount of bytes ingested during snapshot capture and remains consistent across different physical representations.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="historicIngestedBytes")]
		public long HistoricIngestedBytes { get; set; }
		
		/// <summary>
		/// Amount of bytes inferred to be ingested to our system for the snapshot. This may change for existing logical content, as physical representation of content changes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ingestedBytes")]
		public long IngestedBytes { get; set; }
		
		/// <summary>
		/// Amount of logical bytes the snapshot represents.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logicalBytes")]
		public long LogicalBytes { get; set; }
		
		/// <summary>
		/// Amount of bytes physically stored for the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="physicalBytes")]
		public long PhysicalBytes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotSummary
	{
		
		/// <summary>
		/// Time at which the snapshot was taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// ID of the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A Boolean value that indicates whether custom retention is applied to the specified snapshot. Value is true when custom retention is applied to the snapshot.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isCustomRetentionApplied")]
		public bool IsCustomRetentionApplied { get; set; }
		
		/// <summary>
		/// Indicates whether the snapshot is protected by a Retention Locked SLA Domain.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRetentionLockApplied")]
		public bool IsRetentionLockApplied { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotRetentionInfo")]
		public SnapshotRetentionInfo SnapshotRetentionInfo { get; set; }
		
		/// <summary>
		/// Attributes that are available to use when filtering query results based on snapshot type.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotType")]
		public SnapshotSummarySnapshotType SnapshotType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnapshotSummarySnapshotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OnDemand = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PolicyBased = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Retrieved = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SnapshotSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Specifies the type of snapshots to be returned.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnapshotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OnDemand = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Protected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unprotected = 3,
	}
	
	/// <summary>
	/// Specifies the source from which the CDM software is available.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SoftwareAvailability
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LocalCluster = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LocalNode = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Remote = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Downloading = 3,
	}
	
	/// <summary>
	/// Columns that jobs can be sorted on.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SortColumn
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StartTime = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JobStatus = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JobType = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ObjectType = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SlaDomainName = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EndTime = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ObjectLogicalSize = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DataTransferred = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Duration = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ObjectName = 9,
	}
	
	/// <summary>
	/// Sort order.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asc = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		desc = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StageCdmSoftwareInfo
	{
		
		/// <summary>
		/// The MD5 checksum for the CDM software package.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="md5sum")]
		public string Md5sum { get; set; }
		
		/// <summary>
		/// The URL where the package that contains CDM software is located.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="packageUrl")]
		public string PackageUrl { get; set; }
		
		/// <summary>
		/// Size, in bytes, of the package containing CDM software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// Specifies whether to download the CDM software externally. When this value is false, the CDM software package must be available on the cluster. When this value is true, provide the version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="skipDownload")]
		public System.Nullable<System.Boolean> SkipDownload { get; set; }
		
		/// <summary>
		/// The version of the CDM software package. If the version is not provided, an attempt is made to parse the version from the package URL. The version is not needed unless the Rubrik provided software package has been renamed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Status
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StringResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
	}
	
	/// <summary>
	/// Status of email subscription.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubscriptionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Suspended = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SupportDataConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataTypeToConfig")]
		public SupportDataTypeConfig[] DataTypeToConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SupportDataTypeConfig
	{
		
		/// <summary>
		/// The type of data that the Rubrik cluster uploads to Rubrik support. Valid data types are systemstats, errorlogs, traces, or uploads. System metrics such as CPU, memory, or storage are systemstats data. Errors encountered by the system, services or apps are errorlogs data. Routes followed by processes are traces data. Bundled data such as support bundles, report bundles, or metadata tables are uploads data.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataType")]
		public SupportDataTypeConfigDataType DataType { get; set; }
		
		/// <summary>
		/// Controls all the traffic to/from the Rubrik cluster. If set to true, and the user opts-out, this flag will be used to disable all telemetry, including the creation of the support tunnel. If the user opts-in, the flag will be used to enable a service to allow traffic movement to/from the Rubrik cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldToggleChisel")]
		public System.Nullable<System.Boolean> ShouldToggleChisel { get; set; }
		
		/// <summary>
		/// Specifies whether upload of support data of a given type is enabled or disabled.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public SupportDataTypeConfigStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SupportDataTypeConfigDataType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		systemstats = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		errorlogs = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		traces = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		uploads = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		capacityutilization = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SupportDataTypeConfigStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
	}
	
	/// <summary>
	/// The type of data that the Rubrik cluster uploads to Rubrik support. Valid data types are systemstats, errorlogs, traces, or uploads. System metrics such as CPU, memory, or storage are systemstats data. Errors encountered by the system, services or apps are errorlogs data. Routes followed by processes are traces data. Bundled data such as support bundles, report bundles, or metadata tables are uploads data.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SupportDataType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		systemstats = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		errorlogs = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		traces = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		uploads = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		capacityutilization = 4,
	}
	
	/// <summary>
	/// Specifies whether upload of support data of a given type is enabled or disabled.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SupportDataTypeStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SyslogExportRuleFull
	{
		
		/// <summary>
		/// The ID corresponding to the imported certificate used by the syslog server.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// Specifies whether TLS should be used to communicate with the syslog server.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enableTls")]
		public bool EnableTls { get; set; }
		
		/// <summary>
		/// The syslog message classification based on RFC 5424.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="facility")]
		public SyslogExportRuleFullFacility Facility { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// The network protocol to use, either UDP or TCP.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public SyslogExportRuleFullProtocol Protocol { get; set; }
		
		/// <summary>
		/// The syslog message severity based on RFC 5424.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public SyslogExportRuleFullSeverity Severity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SyslogExportRuleFullFacility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Kernel = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Mail = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Daemon = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Auth = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Syslog = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Lpr = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		News = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UUCP = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cron = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Security = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FTP = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NTP = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogAudit = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogAlert = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Clock = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RubrikEvent = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RubrikCLI = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RubrikSSH = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RubrikApp = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		All = 20,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SyslogExportRuleFullProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SyslogExportRuleFullSeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Emergency = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Alert = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Critical = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Error = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Warning = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Notice = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Informational = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Debug = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		All = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SyslogExportRulePartial
	{
		
		/// <summary>
		/// The ID corresponding to the imported certificate used by the syslog server.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// Specifies whether TLS should be used to communicate with the syslog server.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableTls")]
		public System.Nullable<System.Boolean> EnableTls { get; set; }
		
		/// <summary>
		/// The syslog message classification based on RFC 5424.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facility")]
		public SyslogExportRuleFullFacility Facility { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// The network protocol to use, either UDP or TCP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public SyslogExportRuleFullProtocol Protocol { get; set; }
		
		/// <summary>
		/// The syslog message severity based on RFC 5424.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public SyslogExportRuleFullSeverity Severity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SyslogExportRuleSummary : SyslogExportRuleFull
	{
		
		/// <summary>
		/// ID corresponding to the syslog export rule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SyslogExportRuleSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SyslogExportRuleSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// The syslog message classification based on RFC 5424.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SyslogFacility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Kernel = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Mail = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Daemon = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Auth = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Syslog = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Lpr = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		News = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UUCP = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cron = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Security = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FTP = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NTP = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogAudit = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LogAlert = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Clock = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RubrikEvent = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RubrikCLI = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RubrikSSH = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RubrikApp = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		All = 20,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SyslogMsgMibFileDownloadLink
	{
		
		/// <summary>
		/// Download link for the SYSLOG-MSG-MIB file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloadLink")]
		public string DownloadLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SyslogServerTestResult
	{
		
		/// <summary>
		/// The test message that was sent.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// The syslog message severity based on RFC 5424.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SyslogSeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Emergency = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Alert = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Critical = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Error = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Warning = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Notice = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Informational = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Debug = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		All = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SyslogTcMibFileDownloadLink
	{
		
		/// <summary>
		/// Download link for the SYSLOG-TC-MIB file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloadLink")]
		public string DownloadLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TelemetryConfig
	{
		
		/// <summary>
		/// The level of telemetry set for the cluster. Basic is only stats while Full includes stats and logs.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="telemetryLevel")]
		public TelemetryConfigTelemetryLevel TelemetryLevel { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TelemetryConfigTelemetryLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Basic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Full = 2,
	}
	
	/// <summary>
	/// The level of telemetry set for the cluster. Basic is only stats while Full includes stats and logs.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TelemetryLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Basic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Full = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TotpConfigUpdateRequest
	{
		
		/// <summary>
		/// String containing a one time password for the time-based one time password (TOTP) authentication method.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="otpForValidation")]
		public string OtpForValidation { get; set; }
		
		/// <summary>
		/// String containing a secret key for the time-based one time password (TOTP) authentication method.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TotpGlobalSetting
	{
		
		/// <summary>
		/// Indicates whether the TOTP is enforced globally or not.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEnforced")]
		public bool IsEnforced { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TotpGlobalSettingUpdate
	{
		
		/// <summary>
		/// Indicates whether the TOTP is enforced globally or not.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEnforced")]
		public bool IsEnforced { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TotpSecret
	{
		
		/// <summary>
		/// String containing a generated secret key for the time-based one time password (TOTP) authentication method.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// String containing a generated URI for the time-based one time password (TOTP) authentication method. The URI includes the secret key and configuration information.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretUri")]
		public string SecretUri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TotpStatus
	{
		
		/// <summary>
		/// Boolean value that indicates whether the time-based one time password (TOTP) authentication method is enabled. Returns Yes when TOTP is enable and No when it is not.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEnabled")]
		public bool IsEnabled { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether the time-based one time password (TOTP) authentication method is being enforced. Returns Yes when TOTP is enforced and No when it is not.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isEnforced")]
		public bool IsEnforced { get; set; }
	}
	
	/// <summary>
	/// The network protocol to use, either UDP or TCP.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TransportLayerProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TruststorePayload
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certIds")]
		public string[] CertIds { get; set; }
		
		/// <summary>
		/// The truststore type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="truststoreType")]
		public TruststorePayloadTruststoreType TruststoreType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TruststorePayloadTruststoreType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Gcp = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TruststoreSummary
	{
		
		/// <summary>
		/// Signed certificate associated with truststore.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public CertificateSummary[] Certificates { get; set; }
		
		/// <summary>
		/// The truststore type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="truststoreType")]
		public TruststoreSummaryTruststoreType TruststoreType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TruststoreSummaryTruststoreType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Gcp = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TruststoreSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TruststoreSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// The truststore type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TruststoreType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Gcp = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnmanagedObjectDetails
	{
		
		/// <summary>
		/// The amount of storage on the archival location used by unmanaged snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archiveStorage")]
		public long ArchiveStorage { get; set; }
		
		/// <summary>
		/// A boolean that specifies whether any of the snapshots for this object are being retained by a SLA Domain at any location.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasSnapshotsWithPolicy")]
		public bool HasSnapshotsWithPolicy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Boolean that specifies whether the object is remote or local. A value of true indicates that the object is remote.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRemote")]
		public System.Nullable<System.Boolean> IsRemote { get; set; }
		
		/// <summary>
		/// The amount of storage on the local cluster used by unmanaged snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="localStorage")]
		public long LocalStorage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The type of the unmanaged object. Valid object types are VirtualMachine, MssqlDatabase, LinuxFileset, ShareFileset, WindowsFileset, NutanixVirtualMachine, Ec2Instance and StorageArrayVolumeGroup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public UnmanagedObjectDetailsObjectType ObjectType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pendingSlaDomain")]
		public ManagedObjectPendingSlaInfo PendingSlaDomain { get; set; }
		
		/// <summary>
		/// Summary information of all objects on the physical path to this object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="physicalLocation")]
		public LocationPathPoint[] PhysicalLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recoveryInfo")]
		public SnappableRecoveryInfo RecoveryInfo { get; set; }
		
		/// <summary>
		/// ID assigned to an SLA Domain retention policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retentionSlaDomainId")]
		public string RetentionSlaDomainId { get; set; }
		
		/// <summary>
		/// Name of an SLA Domain retention policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retentionSlaDomainName")]
		public string RetentionSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional field with the ID assigned to an SLA Domain by Polaris.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retentionSlaDomainPolarisManagedId")]
		public string RetentionSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// Total number of snapshots to for the specified object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotCount")]
		public long SnapshotCount { get; set; }
		
		/// <summary>
		/// Unmanaged Status of this object. Protected means that this object is still protected by an SLA Policy. Unprotected means that this object has become unprotected. Relic means that Rubrik has lost contact with this object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unmanagedStatus")]
		public UnmanagedObjectDetailsUnmanagedStatus UnmanagedStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UnmanagedObjectDetailsObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VirtualMachine = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MssqlDatabase = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxFileset = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsFileset = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFileset = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixVirtualMachine = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervVirtualMachine = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ManagedVolume = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ec2Instance = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArrayVolumeGroup = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VcdVapp = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxHost = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsHost = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleDatabase = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppBlueprint = 15,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UnmanagedObjectDetailsUnmanagedStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Protected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Relic = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unprotected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ReplicatedRelic = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RemoteUnprotected = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnmanagedObjectDetailsListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public UnmanagedObjectDetails[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnmanagedObjectSlaAssignmentInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="managedIds")]
		public string[] ManagedIds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shouldApplyToNonPolicySnapshots")]
		public System.Nullable<System.Boolean> ShouldApplyToNonPolicySnapshots { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slaDomainId")]
		public string SlaDomainId { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for unmanaged objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UnmanagedObjectSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnmanagedStatus = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Location = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnmanagedSnapshotCount = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LocalStorage = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ArchiveStorage = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RetentionSlaDomainName = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ObjectType = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SnapshotCount = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AutoSnapshotCount = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ManualSnapshotCount = 10,
	}
	
	/// <summary>
	/// Attributes that are available to use when filtering query results based on unmanaged object status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UnmanagedObjectStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Protected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Relic = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unprotected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ReplicatedRelic = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RemoteUnprotected = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnmanagedObjectSummary
	{
		
		/// <summary>
		/// Storage being taken up in the archival location by unmanaged snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archiveStorage")]
		public long ArchiveStorage { get; set; }
		
		/// <summary>
		/// Number of policy-based snapshots to retain for the specified object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="autoSnapshotCount")]
		public long AutoSnapshotCount { get; set; }
		
		/// <summary>
		/// A boolean that specifies whether any of the snapshots for this object are being retained by a SLA  at any location.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasSnapshotsWithPolicy")]
		public bool HasSnapshotsWithPolicy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A boolean that specifies if the object is remote or local. When this value is true, the object is remote.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRemote")]
		public System.Nullable<System.Boolean> IsRemote { get; set; }
		
		/// <summary>
		/// Storage being taken up on the local cluster by unmanaged snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="localStorage")]
		public long LocalStorage { get; set; }
		
		/// <summary>
		/// Number of on-demand snapshots and snapshots retrieved from an archival location for specified object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="manualSnapshotCount")]
		public long ManualSnapshotCount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The type of the unmanaged object. This may be VirtualMachine, MssqlDatabase, LinuxFileset, ShareFileset, WindowsFileset, NutanixVirtualMachine, Ec2Instance or StorageArrayVolumeGroup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public UnmanagedObjectDetailsObjectType ObjectType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pendingSlaDomain")]
		public ManagedObjectPendingSlaInfo PendingSlaDomain { get; set; }
		
		/// <summary>
		/// Brief info of all the objects in the physical path to this Object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="physicalLocation")]
		public LocationPathPoint[] PhysicalLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recoveryInfo")]
		public SnappableRecoveryInfo RecoveryInfo { get; set; }
		
		/// <summary>
		/// ID assigned to an SLA retention policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retentionSlaDomainId")]
		public string RetentionSlaDomainId { get; set; }
		
		/// <summary>
		/// Name of an SLA retention policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retentionSlaDomainName")]
		public string RetentionSlaDomainName { get; set; }
		
		/// <summary>
		/// Optional field with the ID assigned to an SLA Domain by Polaris.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retentionSlaDomainPolarisManagedId")]
		public string RetentionSlaDomainPolarisManagedId { get; set; }
		
		/// <summary>
		/// Unmanaged Status of this object. Protected means that this object is still protected by an SLA Policy. Unprotected means that this object has become unprotected. Relic means that Rubrik has lost contact with this object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unmanagedStatus")]
		public UnmanagedObjectDetailsUnmanagedStatus UnmanagedStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnmanagedObjectSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public UnmanagedObjectSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when filtering query results based on unmanaged object type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UnmanagedObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VirtualMachine = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MssqlDatabase = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxFileset = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsFileset = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ShareFileset = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixVirtualMachine = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervVirtualMachine = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ManagedVolume = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ec2Instance = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArrayVolumeGroup = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VcdVapp = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LinuxHost = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WindowsHost = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OracleDatabase = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppBlueprint = 15,
	}
	
	/// <summary>
	/// Attributes that are available to use when filtering query results based on snapshot type.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UnmanagedSnapshotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OnDemand = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PolicyBased = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Retrieved = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateMountConfig
	{
		
		/// <summary>
		/// True to power on, false to power off.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="powerStatus")]
		public bool PowerStatus { get; set; }
		
		/// <summary>
		/// A Boolean that specifies whether to forcibly power down a virtual machine that is already mounted with Storage vMotion. When this value is 'true', the virtual machine is forcibly powered down. The default value for this Boolean is 'false'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldForce")]
		public System.Nullable<System.Boolean> ShouldForce { get; set; }
	}
	
	/// <summary>
	/// Type of an user action.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UserActionV1
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Assign = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Create = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Delete = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Update = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappAttributes
	{
		
		/// <summary>
		/// Indicates whether the vCD hierarchy object is a vApp template object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isVappTemplate")]
		public bool IsVappTemplate { get; set; }
	}
	
	/// <summary>
	/// Target type for the specified vApp export.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VappExportMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExportToNewVapp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExportToTargetVapp = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappExportOptions
	{
		
		/// <summary>
		/// Array containing summary information for the vApp virtual machines in the specified vApp snapshot, including the default network mappings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allChildVmsWithDefaultNetworkConnections")]
		public VappVmRestoreSpec[] AllChildVmsWithDefaultNetworkConnections { get; set; }
		
		/// <summary>
		/// Storage policies that can be used as a target for virtual machines being exported.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="availableStoragePolicies")]
		public VcdOrgVdcStorageProfile[] AvailableStoragePolicies { get; set; }
		
		/// <summary>
		/// Array of vApp networks in the vApp snapshot being exported that can be enabled at the export location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restorableNetworks")]
		public CreateVappNetworkParams[] RestorableNetworks { get; set; }
		
		/// <summary>
		/// Array of vApp networks at the export location that can be connected to the vApp virtual machines in the exported vApp snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetVappNetworks")]
		public VappNetworkSummary[] TargetVappNetworks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappVmRestoreSpec
	{
		
		/// <summary>
		/// Name of the specified vApp virtual machine within vCloud.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkConnections")]
		public VappVmNetworkConnection[] NetworkConnections { get; set; }
		
		/// <summary>
		/// Storage policy where this vApp virtual machine should be restored to. If omitted, the virtual machines will be exported to the default storage policy of the target Organization VDC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storagePolicyId")]
		public string StoragePolicyId { get; set; }
		
		/// <summary>
		/// vCloud managed object ID (moid) of the specified vApp virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vcdMoid")]
		public string VcdMoid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappVmNetworkConnection
	{
		
		/// <summary>
		/// Method used to allocate IP addresses for the specified vApp network.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="addressingMode")]
		public VappVmNetworkConnectionAddressingMode AddressingMode { get; set; }
		
		/// <summary>
		/// IPv4 address to assign to the specified vApp network connection. Set this value only when the network address allocation method is 'Static'. Otherwise, the value should be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether the specified vApp network connection is enabled. Set the value to 'true' to enable the connection or 'false' to disable the connection.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isConnected")]
		public bool IsConnected { get; set; }
		
		/// <summary>
		/// MAC address of the NIC that is used by the specified vApp network connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAddress")]
		public string MacAddress { get; set; }
		
		/// <summary>
		/// The network adapter type of the NIC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkAdapterType")]
		public string NetworkAdapterType { get; set; }
		
		/// <summary>
		/// Index assigned to the NIC that is used by the specified vApp network connection.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nicIndex")]
		public int NicIndex { get; set; }
		
		/// <summary>
		/// Name of the vApp network to which the NIC corresponding to this connection will connect to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vappNetworkName")]
		public string VappNetworkName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VappVmNetworkConnectionAddressingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DHCP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Manual = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Pool = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdOrgVdcStorageProfile
	{
		
		/// <summary>
		/// ID assigned to the Organization VDC storage profile.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Organization VDC storage profile.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappNetworkSummary
	{
		
		/// <summary>
		/// Boolean value that indicates whether the specified vApp network object has been deployed. Value is 'true' when the vApp network object has been deployed and 'false' when it has not been deployed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isDeployed")]
		public bool IsDeployed { get; set; }
		
		/// <summary>
		/// Name of the specified vApp network object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// vCloud Director ID of the associated organization VDC network object. For an Isolated network, the value is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentNetworkId")]
		public string ParentNetworkId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappExportSnapshotJobConfig
	{
		
		/// <summary>
		/// Target type for the specified vApp export.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exportMode")]
		public VappExportMode ExportMode { get; set; }
		
		/// <summary>
		/// Array of vApp networks that are in the specified vApp snapshot and should be set up as part of the export operation. A vApp network that is not included in the array will not be set up in the exported vApp.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networksToRestore")]
		public CreateVappNetworkParams[] NetworksToRestore { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="newVappParams")]
		public CreateNewVappParams NewVappParams { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether to power on the exported vApp. Use 'true' to turn the power on for the exported vApp or use 'false' to leave the power off for the exported vApp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldPowerOnVappAfterExport")]
		public System.Nullable<System.Boolean> ShouldPowerOnVappAfterExport { get; set; }
		
		/// <summary>
		/// ID assigned to the target vApp object, when the export is into an existing vApp. When the export is not into a target vApp, remove the 'targetVappId' member.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetVappId")]
		public string TargetVappId { get; set; }
		
		/// <summary>
		/// An array containing summary information for the virtual machines included in the vApp export.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmsToExport")]
		public VappVmRestoreSpec[] VmsToExport { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappInstantRecoveryJobConfig
	{
		
		/// <summary>
		/// Boolean value that indicates whether to power on the recovered virtual machines in a vApp after Instant Recovery. Use 'true' to turn the power on for the recovered virtual machines or use 'false' to leave the power off for the virtual machines.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldPowerOnVmsAfterRecovery")]
		public System.Nullable<System.Boolean> ShouldPowerOnVmsAfterRecovery { get; set; }
		
		/// <summary>
		/// An array containing the restore specification for an Instant Recovery of virtual machines in a vApp snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmsToRestore")]
		public VappVmRestoreSpec[] VmsToRestore { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappInstantRecoveryOptions
	{
		
		/// <summary>
		/// An array of network connections available through the specified vApp object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="availableVappNetworks")]
		public VappNetworkSummary[] AvailableVappNetworks { get; set; }
		
		/// <summary>
		/// An array of virtual machines that can be restored and their associated default network connections.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restorableVms")]
		public VappVmRestoreSpec[] RestorableVms { get; set; }
	}
	
	/// <summary>
	/// Mode of connection of a vApp network to a vCloud organization VDC network.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VappNetworkMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Isolated = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NATRouted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Bridged = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappTemplateExportJobConfig
	{
		
		/// <summary>
		/// ID of the target catalog.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="catalogId")]
		public string CatalogId { get; set; }
		
		/// <summary>
		/// Name of vApp template.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the target organization vDC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="orgVdcId")]
		public string OrgVdcId { get; set; }
		
		/// <summary>
		/// ID of the storage policy of the organization VDC used to create the template. When this field is absent, the default from the organization vDC is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storagePolicyId")]
		public string StoragePolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappTemplateExportOptions
	{
		
		/// <summary>
		/// An array of the available storage profile policies where the vApp snapshot can be exported.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="availableStoragePolicies")]
		public VcdOrgVdcStorageProfile[] AvailableStoragePolicies { get; set; }
		
		/// <summary>
		/// The ID of the organization vDC where the vApp template can be exported.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="orgVdcId")]
		public string OrgVdcId { get; set; }
	}
	
	/// <summary>
	/// Provides different options available for a vApp template snapshot export. Fields that correspond to unavailable choices are skipped.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappTemplateExportOptionsUnion
	{
		
		[System.Runtime.Serialization.DataMember(Name="advancedExportOptions")]
		public VappTemplateExportOptions AdvancedExportOptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultCatalogExportOptions")]
		public VappTemplateExportOptions DefaultCatalogExportOptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="originalVdcExportOptions")]
		public VappTemplateExportOptions OriginalVdcExportOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappVmDetail : VappVmSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="vcenterVm")]
		public VirtualMachineDetail VcenterVm { get; set; }
	}
	
	/// <summary>
	/// Method used to allocate IP addresses for the specified vApp network.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VappVmIpAddressingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DHCP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Manual = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Pool = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VappVmSummary : VappVmRestoreSpec
	{
		
		/// <summary>
		/// Storage policy where this vApp virtual machine should be restored to. If omitted, the virtual machines will be exported to the default storage policy of the target Organization VDC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storagePolicyId")]
		public string StoragePolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdClusterBaseConfig
	{
		
		/// <summary>
		/// Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCerts")]
		public string CaCerts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdClusterConfig : VcdClusterBaseConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdClusterDetail
	{
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for vCD Cluster objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VcdClusterListSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Status = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdClusterPatch
	{
		
		/// <summary>
		/// Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCerts")]
		public string CaCerts { get; set; }
		
		/// <summary>
		/// Assign this Vcd Cluster to the given SLA Domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdClusterSummary : SlaAssignable
	{
		
		/// <summary>
		/// Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCerts")]
		public string CaCerts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdClusterSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VcdClusterSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdConnectionStatus
	{
		
		/// <summary>
		/// Status details for a specified vCD Cluster object. Empty except when the status of the vCD Cluster object is 'BadlyConfigured'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Status of the refreshable object. Possible values are "Disconnected" (no communication possible with object), "Refreshing" (able to communicate with object but has not refreshed yet), "Connected" (refreshed the metadata for the object), "BadlyConfigured" (object not configured correctly), "Deleting" (in process of removing the object), and "Remote" (replicated object that we should not connect to).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public RefreshableObjectConnectionStatusStatus Status { get; set; }
	}
	
	/// <summary>
	/// attributes pertaining to each vCD hierarchy object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdHierarchyObjectAttributes
	{
		
		[System.Runtime.Serialization.DataMember(Name="vappAtributes")]
		public VappAttributes VappAtributes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdHierarchyObjectDescendantCount
	{
		
		/// <summary>
		/// Number of descendant vCD catalog objects in a specified; hierarchy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="catalog")]
		public System.Nullable<System.Int32> Catalog { get; set; }
		
		/// <summary>
		/// Number of descendant VIM Server objects that are linked to a vCenter Server object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectedVimServer")]
		public System.Nullable<System.Int32> ConnectedVimServer { get; set; }
		
		/// <summary>
		/// Number of descendant VIM Server objects that are not linked to a vCenter Server object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disconnectedVimServer")]
		public System.Nullable<System.Int32> DisconnectedVimServer { get; set; }
		
		/// <summary>
		/// Number of descendant Organization objects in a specified hierarchy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="org")]
		public System.Nullable<System.Int32> Org { get; set; }
		
		/// <summary>
		/// Number of descendant virtual data center objects in a specified hierarchy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgVdc")]
		public System.Nullable<System.Int32> OrgVdc { get; set; }
		
		/// <summary>
		/// Number of descendant vApp objects in a specified hierarchy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vApp")]
		public System.Nullable<System.Int32> VApp { get; set; }
		
		/// <summary>
		/// Number of descendant vCD cluster objects in a specified hierarchy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcdCluster")]
		public System.Nullable<System.Int32> VcdCluster { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for vCD hierarchy objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VcdHierarchyObjectSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EffectiveSlaDomainName = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SlaAssignment = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ConnectionStatus = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VappCount = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdHierarchyObjectSummary : ManagedHierarchyObjectSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="connectionStatus")]
		public VcdConnectionStatus ConnectionStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="descendantCount")]
		public VcdHierarchyObjectDescendantCount DescendantCount { get; set; }
		
		/// <summary>
		/// attributes pertaining to each vCD hierarchy object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extendedAttributes")]
		public VcdHierarchyObjectAttributes ExtendedAttributes { get; set; }
		
		/// <summary>
		/// IPv4 address for a vCD cluster or vCenter Server that is managed through a VIM Server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Indicates whether the vCD hierarchy object is deleted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isDeleted")]
		public bool IsDeleted { get; set; }
		
		/// <summary>
		/// Types of object that can be present in the vCD hierarchy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public VcdHierarchyObjectSummaryObjectType ObjectType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pendingSlaDomain")]
		public ManagedObjectPendingSlaInfo PendingSlaDomain { get; set; }
		
		/// <summary>
		/// ID assigned to a vCenter Server instance that is managed through a VIM Server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcenterId")]
		public string VcenterId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VcdHierarchyObjectSummaryObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cluster = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VimServer = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Org = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OrgVdc = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Catalog = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vApp = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdHierarchyObjectSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VcdHierarchyObjectSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Types of object that can be present in the vCD hierarchy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VcdObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cluster = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VimServer = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Org = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OrgVdc = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Catalog = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vApp = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappDetail : VcdVappPatch
	{
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for vApp objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VcdVappObjectSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EffectiveSlaDomainName = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SlaAssignment = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappPatch
	{
		
		/// <summary>
		/// ID assigned to the SLA Domain object that manages protection for the specified vApp object. Existing snapshots of the object will be retained with the configuration of the specified SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether the Rubrik cluster should attempt taking synchronized snapshots across all child virtual machines of the vApp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBestEffortSynchronizationEnabled")]
		public System.Nullable<System.Boolean> IsBestEffortSynchronizationEnabled { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether protection activity is paused for the specified vApp. Set to 'true' when protection activity is paused and 'false' when protection activity is not paused. Protection activity includes backup, replication, and archiving.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPaused")]
		public System.Nullable<System.Boolean> IsPaused { get; set; }
		
		/// <summary>
		/// Array containing vCloud Director virtual machine moids that will be excluded from vApp snapshots.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcdVmMoidsToExcludeFromSnapshot")]
		public string[] VcdVmMoidsToExcludeFromSnapshot { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappSlaObjectCount
	{
		
		/// <summary>
		/// The number of vApps protected under this SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numVcdVapps")]
		public System.Nullable<System.Int32> NumVcdVapps { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappSnapshotDetail : BaseSnapshotSummary
	{
		
		/// <summary>
		/// Boolean value that indicates whether a vApp snapshot is synchronized with the source vApp. Set to 'true' when the vApp snapshot is synchronized, and set to 'false' when it is not synchronized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isSynchronized")]
		public System.Nullable<System.Boolean> IsSynchronized { get; set; }
		
		/// <summary>
		/// ID assigned to the vApp object that is the source of the specified snapshot object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vappName")]
		public string VappName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappSnapshotSummary : BaseSnapshotSummary
	{
		
		/// <summary>
		/// Boolean value that indicates whether a vApp snapshot is synchronized with the source vApp. Set to 'true' when the vApp snapshot is synchronized, and set to 'false' when it is not synchronized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isSynchronized")]
		public System.Nullable<System.Boolean> IsSynchronized { get; set; }
		
		/// <summary>
		/// ID assigned to the vApp object that is the source of the specified snapshot object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vappName")]
		public string VappName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappSnapshotSummaryDetailSharedFields
	{
		
		/// <summary>
		/// Boolean value that indicates whether a vApp snapshot is synchronized with the source vApp. Set to 'true' when the vApp snapshot is synchronized, and set to 'false' when it is not synchronized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isSynchronized")]
		public System.Nullable<System.Boolean> IsSynchronized { get; set; }
		
		/// <summary>
		/// ID assigned to the vApp object that is the source of the specified snapshot object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vappName")]
		public string VappName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappSnapshotSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VcdVappSnapshotSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappSummary : Snappable
	{
		
		/// <summary>
		/// ID of the parent catalog if the vApp object is a template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="catalogId")]
		public string CatalogId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currentBackupTaskInfo")]
		public BackupTaskDiagnosticInfo CurrentBackupTaskInfo { get; set; }
		
		/// <summary>
		/// ID assigned to a vCD vApp object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Boolean value that indicates if backup task information isincluded in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeBackupTaskInfo")]
		public System.Nullable<System.Boolean> IncludeBackupTaskInfo { get; set; }
		
		/// <summary>
		/// Brief information of all the objects in the infrastructure path to this vCD vApp object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="infraPath")]
		public ManagedHierarchyObjectAncestor[] InfraPath { get; set; }
		
		/// <summary>
		/// Boolean value that indicates whether a vApp is present on the specified vCD cluster. Set to 'true' when the vApp is present and 'false' when the vApp is not present.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public System.Nullable<System.Boolean> IsRelic { get; set; }
		
		/// <summary>
		/// A Boolean value that indicates whether the vApp object is a template. When this value is 'true,' the vApp object is a template. When this value is 'false,' the vApp object is not a template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTemplate")]
		public System.Nullable<System.Boolean> IsTemplate { get; set; }
		
		/// <summary>
		/// The timestamp of the previous snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSnapshotTime")]
		public System.Nullable<System.DateTimeOffset> LastSnapshotTime { get; set; }
		
		/// <summary>
		/// Name assigned to a vCD vApp object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// An integer that specifies the number of missed snapshots.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numMissedSnapshot")]
		public int NumMissedSnapshot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pendingSlaDomain")]
		public ManagedObjectPendingSlaInfo PendingSlaDomain { get; set; }
		
		/// <summary>
		/// ID assigned to a vCD Cluster object that contains a specified vApp object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcdClusterId")]
		public string VcdClusterId { get; set; }
		
		/// <summary>
		/// Name assigned to a vCD Cluster object that contains a specified vApp object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcdClusterName")]
		public string VcdClusterName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVappSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VcdVappSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVmSnapshotDetail : VcdVmSnapshotSummary
	{
		
		/// <summary>
		/// Array of networks present in the virtual machine at the time of the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkConnections")]
		public VappVmNetworkConnection[] NetworkConnections { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcdVmSnapshotSummary
	{
		
		/// <summary>
		/// Integer value representing the state of the indexing job for a snapshot. 0 means that the indexing has not begun or is in progress. 1 means indexing completed successfully. 2 means that the indexer failed to process this snapshot.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indexState")]
		public System.Nullable<System.Int64> IndexState { get; set; }
		
		/// <summary>
		/// Id assigned by vCloud Director to the virtual machine of the specified snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vcdVmMoid")]
		public string VcdVmMoid { get; set; }
		
		/// <summary>
		/// ID assigned to the object that represents the virtual machine that is the source of a specified snapshot object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vcenterVmId")]
		public string VcenterVmId { get; set; }
		
		/// <summary>
		/// Name of the virtual machine object of the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmName")]
		public string VmName { get; set; }
		
		/// <summary>
		/// ID assigned to the object that represents a virtual machine snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmSnapshotId")]
		public string VmSnapshotId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcenterConfig
	{
		
		/// <summary>
		/// Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCerts")]
		public string CaCerts { get; set; }
		
		/// <summary>
		/// Select compute clusters that must be visible to this Rubrik cluster. All other compute resources are hidden. If 'computeVisibilityFilter' is not specified, all resources are visible. If 'hostGroupFilter' is not specified for a compute cluster, all compute resources in the compute cluster are visible. If 'hostGroupFilter' is specified for a compute cluster, only virtual machinesthat currently reside on these hosts are visible. For the stretched cluster configuration (vMSC), specify the appropriate host groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeVisibilityFilter")]
		public ClusterVisibilityConfig[] ComputeVisibilityFilter { get; set; }
		
		/// <summary>
		/// Set to 'AllowAutoConflictResolution' to link the relic virtual machine objects of a virtual machine to the current object for the virtual machine or to 'NoConflictResolution' to prevent linking. The Rubrik cluster generates a unique ID for each virtual machine when a vCenter Server is added. When a virtual machine changes to another vCenter Server or unregisters and registers with the same vCenter Server, a new unique ID is generated for that virtual machine. When this happens, the virtual machine object associated with the original ID becomes a relic. This option links relic virtual machine objects with the current virtual machine object of a specific virtual machine, and makes the collective snapshot history available through the current object. Default value is 'NoConflictResolution'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conflictResolutionAuthz")]
		public System.Nullable<VcenterConfigConflictResolutionAuthz> ConflictResolutionAuthz { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VcenterConfigConflictResolutionAuthz
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AllowAutoConflictResolution = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NoConflictResolution = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcenterConnectionConfig
	{
		
		/// <summary>
		/// Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCerts")]
		public string CaCerts { get; set; }
		
		/// <summary>
		/// Hostname of the new vCenter.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Password for the new vCenter.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Username of the new vCenter.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcenterDetail : VcenterSummary
	{
		
		/// <summary>
		/// Status of a vCenter. DEPRECATED. Please use connectionStatus.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcenterPatch
	{
		
		/// <summary>
		/// Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----. Use an empty string to remove the existing certificates for the vCenter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCerts")]
		public string CaCerts { get; set; }
		
		/// <summary>
		/// ID of the SLA Domain that is configured for this vCenter Server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcenterPreAddConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="connectionConfig")]
		public VcenterConnectionConfig ConnectionConfig { get; set; }
		
		/// <summary>
		/// Id of the vCenter. Specify this if the vCenter is already added to the Rubrik cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcenterPreAddInfo
	{
		
		/// <summary>
		/// List of compute clusters present in the vCenter, including the host groups each cluster contains.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clusterHostGroupInfo")]
		public ClusterHostGroupInfo[] ClusterHostGroupInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcenterSummary : VcenterPatch
	{
		
		/// <summary>
		/// The ID of the SLA Domain configured directly on the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// The name of the SLA Domain configured directly on the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainName")]
		public string ConfiguredSlaDomainName { get; set; }
		
		/// <summary>
		/// Specifies whether the SLA Domain is used for protection or retention.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainType")]
		public ConfiguredSlaType ConfiguredSlaDomainType { get; set; }
		
		/// <summary>
		/// The ID of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Indicates whether the configured SLA Domain is Retention Locked. When this value is 'true', the configured SLA Domain is a Retention Lock SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isConfiguredSlaDomainRetentionLocked")]
		public System.Nullable<System.Boolean> IsConfiguredSlaDomainRetentionLocked { get; set; }
		
		/// <summary>
		/// The name of the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the cluster that manages the Rubrik object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
		
		/// <summary>
		/// The UTC time when the SLA Domain was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slaLastUpdateTime")]
		public System.Nullable<System.DateTimeOffset> SlaLastUpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VcenterSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VcenterSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VerificationParameters
	{
		
		/// <summary>
		/// Snapshot stored in the provided data location id will be verified. If not provided, we will use Rubrik cluster ID. Currently it only verifies Snapshot present Rubrik cluster.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationIdOpt")]
		public string LocationIdOpt { get; set; }
		
		/// <summary>
		/// ID assigned to the object. This objectId will be used to fetch the associated object.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		public string ObjectId { get; set; }
		
		/// <summary>
		/// The backup should be verified exactly once after the given timestamp. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678". If not provided, it will default to "1970-01-01T00:00:00.000".
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldVerifyAfterOpt")]
		public System.Nullable<System.DateTimeOffset> ShouldVerifyAfterOpt { get; set; }
		
		/// <summary>
		/// ID assigned to a snapshot. This snapshotId will be used to fetch the associated snapshot. The scheduled job will verify this snapshot.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotIdsOpt")]
		public string[] SnapshotIdsOpt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VerificationResponse : AsyncRequestStatus
	{
		
		/// <summary>
		/// List of IDs of the snapshots requested for verification and their corresponding event series IDs.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotVerificationInfo")]
		public SnapshotEventSeries[] SnapshotVerificationInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VimserverSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionStatus")]
		public VcdConnectionStatus ConnectionStatus { get; set; }
		
		/// <summary>
		/// Hostname of a vCenter Server that is the target of a connection from a specified VimServer object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// ID assigned to a VimServer object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of a VimServer object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID assigned to a vCD Cluster object that contains a specified VimServer object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vcdClusterId")]
		public string VcdClusterId { get; set; }
		
		/// <summary>
		/// Name of a vCD Cluster object that contains a specified VimServer object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vcdClusterName")]
		public string VcdClusterName { get; set; }
		
		/// <summary>
		/// ID assigned to a vCenter Server object that is attached to a specified VimServer object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcenterId")]
		public string VcenterId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VimserverSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VimserverSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualDiskDetail
	{
		
		/// <summary>
		/// Unique and reusable key that vSphere uses to identify VMDK files and other devices in the hardware of a virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceKey")]
		public System.Nullable<System.Int64> DeviceKey { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludeFromSnapshots")]
		public System.Nullable<System.Boolean> ExcludeFromSnapshots { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fileName")]
		public string FileName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualDiskUpdate
	{
		
		[System.Runtime.Serialization.DataMember(Name="excludeFromSnapshots")]
		public System.Nullable<System.Boolean> ExcludeFromSnapshots { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualMachineDetail : VirtualMachineUpdate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualMachineScriptDetail
	{
		
		/// <summary>
		/// Action to take if the script returns an error or times out.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failureHandling")]
		public VirtualMachineScriptDetailFailureHandling FailureHandling { get; set; }
		
		/// <summary>
		/// The command to be run in VM guest OS.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scriptPath")]
		public string ScriptPath { get; set; }
		
		/// <summary>
		/// Time (in ms) after which the script will be terminated if it has not completed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeoutMs")]
		public long TimeoutMs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VirtualMachineScriptDetailFailureHandling
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		abort = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="continue")]
		_continue = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualMachineSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VirtualMachineSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualMachineUpdate
	{
		
		[System.Runtime.Serialization.DataMember(Name="cloudInstantiationSpec")]
		public CloudInstantiationSpec CloudInstantiationSpec { get; set; }
		
		/// <summary>
		/// Assign this VM to the given SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// User setting to dictate whether to use storage array snaphots for ingest. This setting only makes sense for VMs where array based ingest is possible.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isArrayIntegrationEnabled")]
		public System.Nullable<System.Boolean> IsArrayIntegrationEnabled { get; set; }
		
		/// <summary>
		/// Whether to pause or resume backups/archival for this VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isVmPaused")]
		public System.Nullable<System.Boolean> IsVmPaused { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxNestedVsphereSnapshots")]
		public System.Nullable<System.Int32> MaxNestedVsphereSnapshots { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="postBackupScript")]
		public VirtualMachineScriptDetail PostBackupScript { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="postSnapScript")]
		public VirtualMachineScriptDetail PostSnapScript { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="preBackupScript")]
		public VirtualMachineScriptDetail PreBackupScript { get; set; }
		
		/// <summary>
		/// Consistency level mandated for this VM or empty string for none.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotConsistencyMandate")]
		public VirtualMachineSummarySnapshotConsistencyMandate SnapshotConsistencyMandate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="throttlingSettings")]
		public VmwareAdaptiveThrottlingSettings ThrottlingSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualMachineUpdateWithSecret : VirtualMachineUpdate
	{
		
		[System.Runtime.Serialization.DataMember(Name="guestCredential")]
		public BaseGuestCredential GuestCredential { get; set; }
		
		/// <summary>
		/// A boolean value that specifies whether an update also refreshes the in-memory cache. When 'false' updates do not refresh the in-memory cache. When 'true' updates refresh the in-memory cache. By default, this value is 'true'. Setting this value to 'false' reduces the time required for updates to complete.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shouldRefreshCacheAfterUpdate")]
		public System.Nullable<System.Boolean> ShouldRefreshCacheAfterUpdate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmForceFullRequest
	{
		
		/// <summary>
		/// List of virtual disks to be configured to force a full snapshot. The configuration specifies which virtual disks in VMware VM should do forced full snapshots and whether to perform deduplication. If it contains an empty array, a forced full snapshot is requested for all virtual disks in the VMware VM and deduplication is performed by default; otherwise a forced full snapshot is requested for the virtual disks in the array and the shouldDedupe determines whether deduplication is performed. The next backup job checks the configuration and takes full snapshot according to the specification. After the backup job is done, it clears the configuration in order to prevent further full snapshots.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualDiskInfos")]
		public VmwareVdiskForceFullInfo[] VirtualDiskInfos { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareVdiskForceFullInfo
	{
		
		/// <summary>
		/// Specifies whether deduplication should be enabled for the forced full snapshot of the virtual disk.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shouldDedupe")]
		public bool ShouldDedupe { get; set; } = true;
		
		/// <summary>
		/// Virtual disk ID within the VMware virtual machine.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualDiskId")]
		public string VirtualDiskId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmForceFullResponse
	{
		
		/// <summary>
		/// List of objects that provide information about each virtual disk that has requested a forced full snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualDiskInfos")]
		public VmwareVdiskForceFullInfo[] VirtualDiskInfos { get; set; }
		
		/// <summary>
		/// VMware virtual machine ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmGuestScriptRunConfig
	{
		
		/// <summary>
		/// Run the script configured (if any) for this phase.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="phase")]
		public VmGuestScriptRunConfigPhase Phase { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VmGuestScriptRunConfigPhase
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PreBackup = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PostSnap = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PostBackup = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmSnapshotDetail : VmSnapshotSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="config")]
		public string Config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isCorrupt")]
		public System.Nullable<System.Boolean> IsCorrupt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmSnapshotDiskDetail
	{
		
		/// <summary>
		/// Unique and reusable key that vSphere uses to identify VMDK files and other devices in the hardware of a virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceKey")]
		public System.Nullable<System.Int64> DeviceKey { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fileName")]
		public string FileName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="virtualDiskId")]
		public string VirtualDiskId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmSnapshotSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VmSnapshotSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareHierarchyInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datastores")]
		public DataStoreSummary[] Datastores { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasChildren")]
		public bool HasChildren { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Vmware Hierarchy Object Type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectType")]
		public VmwareHierarchyInfoObjectType ObjectType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recoverableTo")]
		public bool RecoverableTo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rootId")]
		public string RootId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VmwareHierarchyInfoObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ComputeCluster = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Host = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResourcePool = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareHierarchyInfoListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VmwareHierarchyInfo[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	/// <summary>
	/// Vmware Hierarchy Object Type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VmwareHierarchyObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ComputeCluster = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Host = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResourcePool = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareHostDatastoreDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="datastores")]
		public DataStoreSummary[] Datastores { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostName")]
		public string HostName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareHostDetail : VmwareHostUpdate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareHostSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VmwareHostSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareHostUpdate
	{
		
		/// <summary>
		/// ID of the SLA Domain that is configured for this ESXi hypervisor. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
	}
	
	/// <summary>
	/// A collection of VMware networks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareNetworkCollection
	{
		
		/// <summary>
		/// A list of VMware network information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public VmwareNetworkInfo[] Networks { get; set; }
	}
	
	/// <summary>
	/// VMware network type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VmwareNetworkType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_NETWORK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISTRIBUTED_PORT_GROUP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPAQUE_NETWORK = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OTHER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareRecoverableRangeListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VmwareRecoverableRange[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareVmMountDetailV1 : VmwareVmMountSummaryV1
	{
		
		/// <summary>
		/// The power status of the mounted VM(ON,OFF,SLEEP etc.).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerStatus")]
		public string PowerStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareVmMountSummaryV1
	{
		
		/// <summary>
		/// An integer value that identifies how many disks are attached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attachingDiskCount")]
		public System.Nullable<System.Int32> AttachingDiskCount { get; set; }
		
		/// <summary>
		/// This boolean value determines whether or not the mount is created as a datastore only. When 'true,' the mount is created with datastore and not the associated virtual machine. When 'false,' the mount is created with both the datastore and the associated virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createDatastoreOnlyMount")]
		public System.Nullable<System.Boolean> CreateDatastoreOnlyMount { get; set; }
		
		/// <summary>
		/// The name of the datastore that contains the mounted VMDK.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datastoreName")]
		public string DatastoreName { get; set; }
		
		/// <summary>
		/// A boolean value that specifies whether the datastore is ready. When 'true,' the datastore is ready. When 'false,' the datastore is not ready.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datastoreReady")]
		public System.Nullable<System.Boolean> DatastoreReady { get; set; }
		
		/// <summary>
		/// A Boolean value that determines whether this job is an attaching disk mount job. When 'true,' this is an attaching disk mount job. When 'false,' this is not an attaching disk mount job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasAttachingDisk")]
		public System.Nullable<System.Boolean> HasAttachingDisk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isReady")]
		public bool IsReady { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mountRequestId")]
		public string MountRequestId { get; set; }
		
		/// <summary>
		/// Gives the timestamp at which the mount was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mountTimestamp")]
		public System.Nullable<System.DateTimeOffset> MountTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mountedVmId")]
		public string MountedVmId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotDate")]
		public System.DateTimeOffset SnapshotDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unmountRequestId")]
		public string UnmountRequestId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareVmMountSummaryV1ListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VmwareVmMountSummaryV1[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupDetail : VolumeGroupSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blackoutWindowStatus")]
		public BlackoutWindowStatus BlackoutWindowStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blackoutWindows")]
		public BlackoutWindows BlackoutWindows { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupForceFullRequest
	{
		
		/// <summary>
		/// Configuration for forcing a full snapshot for the listed volumes in the request. The configuration specifies which volumes in a Volume Group should get forced full snapshots, and whether to perform deduplication. If the configuration is missing, no forced full snapshot is requested. If the configuration contains an empty array, a forced full snapshot is requested for all volumes in the Volume Group and deduplication is performed by default. If the configuration array contains specific volumes, a forced full snapshot is requested for these volumes only. The shouldDedupe flag determines whether deduplication is performed. If a forced full snapshot is requested, the next backup job checks the configuration and takes the full snapshot according to the specification. After the full snapshot is taken, the backup job clears the configuration to prevent additional full snapshots from being taken.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeInfos")]
		public ForceFullVolumeInfo[] VolumeInfos { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupForceFullResponse
	{
		
		/// <summary>
		/// The ID of the Volume group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="volumeGroupId")]
		public string VolumeGroupId { get; set; }
		
		/// <summary>
		/// Configuration for each volume that has requested a forced full snapshot. If the configuration is absent, that means either a forced full snapshot has not been requested for the Volume Group, or a backup job has taken the requested full snapshot and cleared the configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeInfos")]
		public ForceFullVolumeInfo[] VolumeInfos { get; set; }
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for Volume Groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VolumeGroupListSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 1,
	}
	
	/// <summary>
	/// Attributes that are available to use when sorting query results for Volume Group snapshot mounts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VolumeGroupMountListSortAttribute
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sourceHostName = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		snapshotDate = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mountedDate = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupMountSummary
	{
		
		/// <summary>
		/// Indicates if the logged-in user has the authority to remove the specified mount.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canUnmount")]
		public System.Nullable<System.Boolean> CanUnmount { get; set; }
		
		/// <summary>
		/// The unique ID of the mount.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Specifies whether the volume mount operation has successfully completed and is ready to use.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isReady")]
		public bool IsReady { get; set; }
		
		/// <summary>
		/// The ID of the job instance that initiated the request for the specified mount.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mountRequestId")]
		public string MountRequestId { get; set; }
		
		/// <summary>
		/// The UTC timestamp at which the mount was created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mountedDate")]
		public System.DateTimeOffset MountedDate { get; set; }
		
		/// <summary>
		/// Configuration details for each of the mounted Volumes in the Volume Group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mountedVolumes")]
		public VolumeMountInfo[] MountedVolumes { get; set; }
		
		/// <summary>
		/// The name of the Volume Group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The link to the script that can perform bare-metal recovery for the mounted snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restoreScriptSmbPath")]
		public string RestoreScriptSmbPath { get; set; }
		
		/// <summary>
		/// The UTC timestamp at which the snapshot was originally taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotDate")]
		public System.DateTimeOffset SnapshotDate { get; set; }
		
		/// <summary>
		/// Rubrik release version that supports volume group snappable.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="snapshotSourceVersion")]
		public VolumeGroupMountSummarySnapshotSourceVersion SnapshotSourceVersion { get; set; }
		
		/// <summary>
		/// The ID of the Host on which the snapshot was originally taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceHostId")]
		public string SourceHostId { get; set; }
		
		/// <summary>
		/// The name of the Host on which the snapshot was originally taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceHostName")]
		public string SourceHostName { get; set; }
		
		/// <summary>
		/// The ID of the Volume Group from which this snapshot was created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceVolumeGroupId")]
		public string SourceVolumeGroupId { get; set; }
		
		/// <summary>
		/// The ID of the host where the volumes are mounted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetHostId")]
		public string TargetHostId { get; set; }
		
		/// <summary>
		/// The name of the host where the volumes are mounted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetHostName")]
		public string TargetHostName { get; set; }
		
		/// <summary>
		/// The ID of the job instance that initiated the request to remove the specified mount.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unmountRequestId")]
		public string UnmountRequestId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeMountInfo
	{
		
		/// <summary>
		/// The type of the file system on this Volume.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fileSystemType")]
		public FileSystemType FileSystemType { get; set; }
		
		/// <summary>
		/// The mount path of volume on the new host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostMountedPath")]
		public string HostMountedPath { get; set; }
		
		/// <summary>
		/// The unique ID of the mount.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The source host mount points of the specified volume.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="originalMountPoints")]
		public string[] OriginalMountPoints { get; set; }
		
		/// <summary>
		/// The size of the volume in bytes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public long Size { get; set; }
		
		/// <summary>
		/// The SMB path to the VHD file that contains the snapshot volume. This path is available when the mount is ready.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smbPath")]
		public string SmbPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VolumeGroupMountSummarySnapshotSourceVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WithLayoutInfo = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WithoutLayoutInfo = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupMountSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VolumeGroupMountSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupOnDemandSnapshotConfig : BaseOnDemandSnapshotConfig
	{
		
		/// <summary>
		/// The unique ID of each volume included in the Volume Group snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeIdsIncludedInSnapshot")]
		public string[] VolumeIdsIncludedInSnapshot { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupPatch
	{
		
		/// <summary>
		/// The ID of the SLA Domain policy to assign to the Volume Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuredSlaDomainId")]
		public string ConfiguredSlaDomainId { get; set; }
		
		/// <summary>
		/// Determines whether the next snapshot of the Volume Group is a full. After the snapshot has completed, this parameter will be reset to the default false value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceFull")]
		public System.Nullable<System.Boolean> ForceFull { get; set; }
		
		/// <summary>
		/// Indicates whether backup, archival, and replicated is paused for this Volume Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPaused")]
		public System.Nullable<System.Boolean> IsPaused { get; set; }
		
		/// <summary>
		/// The unique ID of each volume included in the Volume Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeIdsIncludedInSnapshots")]
		public string[] VolumeIdsIncludedInSnapshots { get; set; }
	}
	
	/// <summary>
	/// Rubrik release version that supports volume group snappable.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VolumeGroupReleaseVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WithLayoutInfo = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WithoutLayoutInfo = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupRestoreVolumeSpec
	{
		
		/// <summary>
		/// Path of the target volume for the restore operation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetVolumePath")]
		public string TargetVolumePath { get; set; }
		
		/// <summary>
		/// ID of volume in snapshot to restore.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupRestoreVolumesConfig
	{
		
		/// <summary>
		/// Array of volume ID and target volume path pairs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="restoreSpec")]
		public VolumeGroupRestoreVolumeSpec[] RestoreSpec { get; set; }
		
		/// <summary>
		/// ID of the host where this restore operation restores volumes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetHostId")]
		public string TargetHostId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupSnapshotDetail
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupSnapshotSummary : BaseSnapshotSummary
	{
		
		/// <summary>
		/// The logical size of the Volume Group snapshot in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileSizeInBytes")]
		public System.Nullable<System.Int64> FileSizeInBytes { get; set; }
		
		/// <summary>
		/// Configuration details of the volume(s) included in the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="includedVolumes")]
		public VolumeGroupSnapshotVolumeSummary[] IncludedVolumes { get; set; }
		
		/// <summary>
		/// A human-readable name of the mount points included in the snapshot.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies whether the snapshot was taken using the fast VHDX builder, which became available in the Rubrik CDM 5.1 release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usedFastVhdx")]
		public System.Nullable<System.Boolean> UsedFastVhdx { get; set; }
		
		/// <summary>
		/// The unique ID of the Volume Group that was snapshoted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="volumeGroupId")]
		public string VolumeGroupId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupSnapshotVolumeSummary
	{
		
		/// <summary>
		/// The type of the file system on this Volume.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fileSystemType")]
		public FileSystemType FileSystemType { get; set; }
		
		/// <summary>
		/// The unique ID of the snapshot volume summary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The mount points of the volume on the host.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mountPoints")]
		public string[] MountPoints { get; set; }
		
		/// <summary>
		/// The size of the volume in bytes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public long Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupSnapshotSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VolumeGroupSnapshotSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupSummary : Snappable
	{
		
		/// <summary>
		/// Specifies whether the Volume Group is set to take a full snapshot for the next backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceFull")]
		public System.Nullable<System.Boolean> ForceFull { get; set; }
		
		/// <summary>
		/// The unique ID of the host that contains the Volume Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// The name of the host that contains the Volume Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// The unique ID of the Volume Group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Specifies whether the Volume Group is accessible on the Rubrik cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isRelic")]
		public bool IsRelic { get; set; }
		
		/// <summary>
		/// The name of the Volume Group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies whether the Volume Group needs to be migrated in order to use the fast VHDX builder. This flag is set only when the Volume Group's last backup job failed due to an error during data fetch, and the backup job did not use the fast VHDX builder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="needsMigration")]
		public System.Nullable<System.Boolean> NeedsMigration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VolumeGroupSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VolumeGroupSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WebServerCertificatePayload
	{
		
		/// <summary>
		/// ID assigned to the imported certificate object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WebServerCertificateSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="cert")]
		public CertificateSummary Cert { get; set; }
		
		/// <summary>
		/// A Boolean value that indicates if the web server is configured to use a certificate signed by an external CA.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="webServerConfiguredWithCASignedCertificate")]
		public bool WebServerConfiguredWithCASignedCertificate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WeeklyConfig : FrequencyConfig
	{
		
		/// <summary>
		/// The day of the week when snapshot will be taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dayOfWeek")]
		public SlaDayOfWeek DayOfWeek { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WindowsClusterDetail : WindowsClusterSummary
	{
		
		/// <summary>
		/// Obtained from ClusterInstanceID under the registry key HKLM\Cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="naturalId")]
		public string NaturalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WindowsClusterSummary
	{
		
		/// <summary>
		/// Fully qualified domain name of this cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
		
		/// <summary>
		/// IDs of the hosts in this cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostIds")]
		public string[] HostIds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Indicates whether the Rubrik Backup Service is installed on hosts in a Windows cluster. The value is true when all hosts in the cluster do not have the Rubrik Backup Service installed. The value is false when one or more of the hosts in the cluster have the Rubrik Backup Service installed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isAgentless")]
		public bool IsAgentless { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primaryClusterId")]
		public string PrimaryClusterId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WindowsClusterSummaryListResponse
	{
		
		/// <summary>
		/// List of matching objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public WindowsClusterSummary[] Data { get; set; }
		
		/// <summary>
		/// If there is more.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasMore")]
		public System.Nullable<System.Boolean> HasMore { get; set; }
		
		/// <summary>
		/// Total list responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class YearlyConfig : FrequencyConfig
	{
		
		/// <summary>
		/// The day of the year when snapshot will be taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dayOfYear")]
		public QuarterlyConfigDayOfQuarter DayOfYear { get; set; }
		
		/// <summary>
		/// The month of the year when snapshot will be taken.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="yearStartMonth")]
		public QuarterlyConfigFirstQuarterStartMonth YearStartMonth { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get the AWS account ID of an AWS S3 archival location
		/// Get the AWS account ID of an AWS S3 archival location.
		/// ArchiveAwsS3_idAccount_idGet archive/aws/s3/{id}/account_id
		/// </summary>
		/// <param name="id">ID of an AWS archival location that uses the S3 protocol.</param>
		/// <returns>Account ID of the AWS account of the archival location.</returns>
		public async Task<StringResponse> ArchiveAwsS3_idAccount_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archive/aws/s3/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/account_id";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StringResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable location for archival and modification operations
		/// Disables archiving and any changes to the data for the specified archival location. This operation disables snapshot upload, snapshot expiration, consolidation, and garbage collection operations on the archival location.
		/// 
		/// ArchiveLocation_idOwnerDisablePost archive/location/{id}/owner/disable
		/// </summary>
		/// <param name="id">ID assigned to an archival location object.</param>
		public async Task ArchiveLocation_idOwnerDisablePostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archive/location/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/owner/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable archival location for archival and modification operations
		/// Enable archiving and other operations that were previously disabled on the specified archival location.
		/// 
		/// ArchiveLocation_idOwnerEnablePost archive/location/{id}/owner/enable
		/// </summary>
		/// <param name="id">ID assigned to an archival location object.</param>
		public async Task ArchiveLocation_idOwnerEnablePostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archive/location/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/owner/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Refresh archive information for a list of data sources
		/// Update the current Rubrik CDM cluster with information about the changes made to a list of data sources in an archival location by the Rubrik CDM cluster that owns the archival location.
		/// 
		/// ArchiveLocation_location_idReaderRefreshData_sourcesPost archive/location/{location_id}/reader/refresh/data_sources
		/// </summary>
		/// <param name="location_id">ID assigned to an archival location object.</param>
		/// <param name="requestBody">A set of local and archival IDs for data sources to refresh. For a data source, either a local or archival data source ID should be specified. The operation will fail if `none` is specified.
		///</param>
		public async Task ArchiveLocation_location_idReaderRefreshData_sourcesPostAsync(string location_id, ReaderRefreshDataSourcesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archive/location/"+ (location_id==null? "" : System.Uri.EscapeDataString(location_id))+"/reader/refresh/data_sources";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Clear cached authorization information
		/// Clears the node of cached authorization information for the current user.
		/// AuthorizationCacheDelete authorization/cache
		/// </summary>
		public async Task AuthorizationCacheDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "authorization/cache";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reschedule unsuccessful backup tasks
		/// Create an asynchronous task for rescheduling unsuccessful backup tasks.
		/// 
		/// BackupRetryPost backup/retry
		/// </summary>
		/// <param name="requestBody">Parameters required to reschedule unsuccessful backup tasks.
		///</param>
		/// <returns>Status details of the async request.</returns>
		public async Task<RemediationResponse> BackupRetryPostAsync(RemediationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "backup/retry";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemediationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get status of reschedule attempt
		/// Retrieve the details of a specified asynchronous task to use for rescheduling unsuccessful tasks.
		/// 
		/// BackupRetry_idGet backup/retry/{id}
		/// </summary>
		/// <param name="id">Async request id.</param>
		/// <returns>Status details of async request.</returns>
		public async Task<AsyncRequestStatus> BackupRetry_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "backup/retry/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Trigger a job for snapshot verification
		/// This REST API triggers the job "BACKUP_INTEGRITY_VERIFICATION", which verifies whether or not the specified snapshot is restorable.
		/// 
		/// BackupVerifyPost backup/verify
		/// </summary>
		/// <param name="requestBody">Parameters needed to schedule a snapshot verification job.
		///</param>
		/// <returns>Sucessfully scheduled the job to verify the snapshot.</returns>
		public async Task<VerificationResponse> BackupVerifyPostAsync(VerificationParameters requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "backup/verify";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VerificationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get asynchronous request details for Backup Verification
		/// Get the details of an asynchronous request for a backup verification job.
		/// 
		/// BackupVerify_idGet backup/verify/{id}
		/// </summary>
		/// <param name="id">ID of the asynchronous request.</param>
		/// <returns>Status of the asynchronous request.</returns>
		public async Task<VerificationResponse> BackupVerify_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "backup/verify/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VerificationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get current status of global blackout window
		/// Determine whether global blackout window is currently active.
		/// Blackout_windowGet blackout_window
		/// </summary>
		/// <returns>Current status of blackout window.</returns>
		public async Task<GlobalBlackoutWindowStatus> Blackout_windowGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "blackout_window";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GlobalBlackoutWindowStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts or stops the global blackout window in local Rubrik cluster
		/// Returns whether or not the system is in a blackout window.
		/// Blackout_windowPatch blackout_window
		/// </summary>
		/// <param name="requestBody">Whether to start or stop the global blackout window.</param>
		/// <returns>Returned the updated blackout window status.</returns>
		public async Task<GlobalBlackoutWindowStatus> Blackout_windowPatchAsync(GlobalBlackoutWindowStatus requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "blackout_window";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GlobalBlackoutWindowStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all certificates
		/// Get all certificates.
		/// CertificateGetByNameAndHas_keyAndDescriptionAndExpirationAndInclude_expiredAndSort_byAndSort_order certificate
		/// </summary>
		/// <param name="name">Search by certificate name.</param>
		/// <param name="has_key">Search certificates by whether or not they contain a private key.
		///</param>
		/// <param name="description">Search certificates by description.</param>
		/// <param name="expiration">Search certificates by expiration.</param>
		/// <param name="include_expired">Specifies whether to include expired certificates. The default is false.</param>
		/// <param name="sort_by">Attribute by which the list of certificates is sorted.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>List of certificates.</returns>
		public async Task<CertificateSummaryListResponse> CertificateGetByNameAndHas_keyAndDescriptionAndExpirationAndInclude_expiredAndSort_byAndSort_orderAsync(string name, bool has_key, string description, string expiration, bool include_expired, CertificateListSortAttributes sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificate?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&has_key="+has_key+"&description=" + (description==null? "" : System.Uri.EscapeDataString(description))+"&expiration=" + (expiration==null? "" : System.Uri.EscapeDataString(expiration))+"&include_expired="+include_expired+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Import a certificate
		/// Import a certificate.
		/// CertificatePost certificate
		/// </summary>
		/// <param name="requestBody">Request to import a certificate.</param>
		/// <returns>Summary of the certificate.</returns>
		public async Task<CertificateSummary> CertificatePostAsync(CertificateImportRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all potential agent secondary cluster certificates
		/// Get all certificates that have been added to the cluster and qualify to be secondary cluster certificates for the Rubrik Backup Service. This call retrieves any certificates that are detected to be Rubrik cluster certificates.
		/// CertificateAgentGetByIs_agent_enabled certificate/agent
		/// </summary>
		/// <param name="is_agent_enabled">Filter based on whether or not certificates have been marked for use by agents.</param>
		/// <returns>List of certificates.</returns>
		public async Task<AgentSecondaryCertificateInfoListResponse> CertificateAgentGetByIs_agent_enabledAsync(bool is_agent_enabled, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificate/agent?is_agent_enabled="+is_agent_enabled;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AgentSecondaryCertificateInfoListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Mark a certificate to be added to agents
		/// Mark a secondary cluster certificate to be asynchronously synced to all Rubrik Backup Service instances for which this cluster is the primary.
		/// CertificateAgentPost certificate/agent
		/// </summary>
		/// <param name="requestBody">ID of certificate to add.</param>
		public async Task CertificateAgentPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificate/agent";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Unmark a certificate that was previously marked
		/// Unmark a previously marked secondary cluster certificate to be asynchronously removed from all Rubrik Backup Service instances for which this cluster is the primary.
		/// CertificateAgent_idDelete certificate/agent/{id}
		/// </summary>
		/// <param name="id">ID of certificate to remove.</param>
		public async Task CertificateAgent_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificate/agent/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete imported certificate object
		/// Deletes an imported certificate.
		/// Certificate_idDelete certificate/{id}
		/// </summary>
		/// <param name="id">The certificate ID.</param>
		public async Task Certificate_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificate/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a certificate summary to export
		/// Get a certificate summary.
		/// Certificate_idGet certificate/{id}
		/// </summary>
		/// <param name="id">ID of certificate to export.</param>
		/// <returns>Summary of the certificate to export.</returns>
		public async Task<CertificateSummary> Certificate_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificate/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a certificate entry
		/// Provide updated information for a certificate object.
		/// Certificate_idPatch certificate/{id}
		/// </summary>
		/// <param name="id">ID of certificate object to update.</param>
		/// <param name="requestBody">Patch request to update a certificate object.</param>
		/// <returns>Updated certificate object.</returns>
		public async Task<CertificateSummary> Certificate_idPatchAsync(string id, CertificatePatchRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificate/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Forecast of the cloud utilization for CloudOut
		/// Forecast of the cloud storage and compute utilization on cloud archival location according to the SLA Domain parameters.
		/// Cloud_utilizationCloud_out_forecastPost cloud_utilization/cloud_out_forecast
		/// </summary>
		/// <param name="requestBody">Object that contains the CloudOut forecast request.</param>
		/// <returns>Object that contains the CloudOut forecast summary.</returns>
		public async Task<CloudOutForecastSummary> Cloud_utilizationCloud_out_forecastPostAsync(CloudOutForecastRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cloud_utilization/cloud_out_forecast";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CloudOutForecastSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get event notifications
		/// Gets notifications about events from a specified set of possible events.
		/// 
		/// ClusterMeUpgradeMonitor_eventsGetByEvent_notification_query cluster/me/upgrade/monitor_events
		/// </summary>
		/// <param name="event_notification_query">Specifies a list of events to monitor for notifications.</param>
		/// <returns>Name and timestamp of an event sent as a notification.
		///</returns>
		public async Task<EventNotification[]> ClusterMeUpgradeMonitor_eventsGetByEvent_notification_queryAsync(string[] event_notification_query, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/me/upgrade/monitor_events?"+string.Join("&", event_notification_query.Select(z => $"event_notification_query={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventNotification[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get cluster details
		/// Retrieve public information about the Rubrik cluster.
		/// Cluster_idGet cluster/{id}
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>Information about the cluster.</returns>
		public async Task<ClusterInfo> Cluster_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Change Rubrik cluster properties
		/// Change the properties of a specified Rubrik cluster. Changes to cluster name could take upto 10 minutes to be propagated to all nodes.
		/// Cluster_idPatch cluster/{id}
		/// </summary>
		/// <param name="id">ID of a Rubrik cluster object, or use *me* for the Rubrik cluster that is hosting the current API session.</param>
		/// <param name="requestBody">Array that contains the changed information for the Rubrik cluster object.</param>
		/// <returns>Updated information for a specified Rubrik cluster.</returns>
		public async Task<ClusterInfo> Cluster_idPatchAsync(string id, ClusterUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get cluster REST API version
		/// Retrieves software version of the Rubrik cluster.
		/// Cluster_idApi_versionGet cluster/{id}/api_version
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>REST API version running on the cluster.</returns>
		public async Task<ClusterApiVersion> Cluster_idApi_versionGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/api_version";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterApiVersion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the cluster certificate
		/// Returns the cluster certificate.
		/// Cluster_idCertificateGet cluster/{id}/certificate
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>Returns the cluster certificate.</returns>
		public async Task<ClusterCertificate> Cluster_idCertificateGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/certificate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterCertificate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Manually discover nodes
		/// Manually specifies mDNS discovery data. Output for this endpoint is identical to the output of the 'discover' endpoint.
		/// Cluster_idManual_discoverPost cluster/{id}/manual_discover
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="requestBody">Manual discovery input data.</param>
		/// <returns>List of nodes available to bootstrap into the specified cluster along with their IPv6 addresses.</returns>
		public async Task<ManualDiscoveryNodeInfo> Cluster_idManual_discoverPostAsync(string id, ManualDiscoveryNodeInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/manual_discover";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManualDiscoveryNodeInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Manually discover nodes over IPv4 address
		/// Manually specifies discovery data. This endpoint output is identical to the output of the 'discover' endpoint.
		/// Cluster_idManual_discover_ipv4Post cluster/{id}/manual_discover_ipv4
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster, or *me* for the current cluster.</param>
		/// <param name="requestBody">Manual discovery input data.</param>
		/// <returns>List of nodes available to bootstrap into the specified cluster, including their link-local IPv4 addresses.</returns>
		public async Task<ManualDiscoveryNodeIpv4Info> Cluster_idManual_discover_ipv4PostAsync(string id, ManualDiscoveryNodeIpv4Info requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/manual_discover_ipv4";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManualDiscoveryNodeIpv4Info>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the node ID to hostname mapping for all the nodes in a Rubrik cluster
		/// 
		/// Retrieve the ID to hostname mapping for all the nodes that belong to a specified Rubrik cluster.
		/// 
		/// Cluster_idNode_hostnameGet cluster/{id}/node_hostname
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>List of node ID to hostname mappings.</returns>
		public async Task<NodeHostnameInfoListResponse> Cluster_idNode_hostnameGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/node_hostname";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeHostnameInfoListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Change hostname for nodes in a Rubrik cluster
		/// Change hostnames for multiple nodes at a time, for a specified Rubrik cluster.
		/// 
		/// Cluster_idNode_hostnamePost cluster/{id}/node_hostname
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="requestBody">Node ID to hostname mapping.</param>
		public async Task Cluster_idNode_hostnamePostAsync(string id, NodeHostnameInfo[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/node_hostname";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the name of the nodes in the cluster
		/// Retrieve the list of node IDs for the nodes in this Rubrik CDM cluster.
		/// Cluster_idNode_idGet cluster/{id}/node_id
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>List of node IDs.</returns>
		public async Task<NodeId[]> Cluster_idNode_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/node_id";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeId[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check credentials to the Rubrik support portal
		/// Check whether the specified Rubrik cluster has an existing set of credentials for the Rubrik support portal.
		/// 
		/// Cluster_idRubrik_support_portal_credentialsGet cluster/{id}/rubrik_support_portal_credentials
		/// </summary>
		/// <param name="id">The ID of a Rubrik cluster, or use *me* for the Rubrik cluster that is hosting the current session.
		///</param>
		/// <returns>Returns 'True' if the specified Rubrik cluster already has credentials for the Rubrik support portal.
		///</returns>
		public async Task<BooleanResponse> Cluster_idRubrik_support_portal_credentialsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/rubrik_support_portal_credentials";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BooleanResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update credentials to the Rubrik support portal
		/// Update credentials for the specified Rubrik cluster to connect to the Rubrik support portal.
		/// 
		/// Cluster_idRubrik_support_portal_credentialsPost cluster/{id}/rubrik_support_portal_credentials
		/// </summary>
		/// <param name="id">The ID of a Rubrik cluster, or use *me* for the Rubrik cluster that is hosting the current session.
		///</param>
		/// <param name="requestBody">The credentials used to connect to the Rubrik support portal.
		///</param>
		public async Task Cluster_idRubrik_support_portal_credentialsPostAsync(string id, CommunityUserCredentials requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/rubrik_support_portal_credentials";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get CORS configuration
		/// Get the current CORS support configuration for a web server.
		/// Cluster_idSecurityCorsGet cluster/{id}/security/cors
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>The current CORS support configuration for a web server.</returns>
		public async Task<CorsConfiguration> Cluster_idSecurityCorsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/cors";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CorsConfiguration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update CORS configuration
		/// Update the CORS support configuration for a web server.
		/// Cluster_idSecurityCorsPatch cluster/{id}/security/cors
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="requestBody">CORS configuration.</param>
		/// <returns>The updated CORS support configuration for a web server.</returns>
		public async Task<CorsConfiguration> Cluster_idSecurityCorsPatchAsync(string id, CorsConfigurationPatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/cors";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CorsConfiguration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get encryption at rest status
		/// Get the current encryption at rest status of the cluster.
		/// Cluster_idSecurityEncryptionGet cluster/{id}/security/encryption
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>The current encryption at rest status for the cluster.</returns>
		public async Task<EncryptionStatus> Cluster_idSecurityEncryptionGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/encryption";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EncryptionStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get FIPS enablement status
		/// Returns the current status of FIPS on the specified cluster. When the status is true, FIPS is enabled.
		/// Cluster_idSecurityFipsGet cluster/{id}/security/fips
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>The current FIPS enablement status for a cluster.</returns>
		public async Task<FipsStatus> Cluster_idSecurityFipsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/fips";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FipsStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update FIPS enablement status
		/// Update the current FIPS enablement status for a cluster.
		/// Cluster_idSecurityFipsPatch cluster/{id}/security/fips
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="requestBody">Update FIPS enablement status.</param>
		/// <returns>The current FIPS enablement status for a cluster.</returns>
		public async Task<FipsStatus> Cluster_idSecurityFipsPatchAsync(string id, FipsStatusPatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/fips";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FipsStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the KMIP client configuration
		/// Return the currently configured KMIP client information. The response object contains empty fields when KMIP is not configured.
		/// Cluster_idSecurityKmipClientGet cluster/{id}/security/kmip/client
		/// </summary>
		/// <param name="id">ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.</param>
		/// <returns>Current KMIP client configuration detail.</returns>
		public async Task<KmipClientDetail> Cluster_idSecurityKmipClientGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/kmip/client";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<KmipClientDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Specify KMIP client credentials for nodes
		/// Specify KMIP client credentials for each of the Rubrik cluster nodes.
		/// Cluster_idSecurityKmipClientPut cluster/{id}/security/kmip/client
		/// </summary>
		/// <param name="id">ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.</param>
		/// <param name="requestBody">KMIP client configuration.</param>
		public async Task Cluster_idSecurityKmipClientPutAsync(string id, KmipClientConfiguration requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/kmip/client";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove the specified KMIP server
		/// Remove the server with the specified server address from the set of active KMIP servers.
		/// Cluster_idSecurityKmipServerDeleteByServer_address cluster/{id}/security/kmip/server
		/// </summary>
		/// <param name="id">ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.</param>
		/// <param name="server_address">IPv4 address or FQDN (fully qualified domain name) of the KMIP server.</param>
		public async Task Cluster_idSecurityKmipServerDeleteByServer_addressAsync(string id, string server_address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/kmip/server&server_address=" + (server_address==null? "" : System.Uri.EscapeDataString(server_address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get KMIP server information
		/// Returns the KMIP server information for the specified server address. When no server address is specified, this call returns information on all active KMIP servers. The response array is empty when KMIP is not configured or when the server address cannot be found.
		/// Cluster_idSecurityKmipServerGetByServer_address cluster/{id}/security/kmip/server
		/// </summary>
		/// <param name="id">ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.</param>
		/// <param name="server_address">The address of the KMIP server.</param>
		/// <returns>Information for the specified KMIP server(s).</returns>
		public async Task<KmipServerDetail[]> Cluster_idSecurityKmipServerGetByServer_addressAsync(string id, string server_address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/kmip/server&server_address=" + (server_address==null? "" : System.Uri.EscapeDataString(server_address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<KmipServerDetail[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a KMIP server
		/// Add the specified KMIP server to the set of active KMIP servers.
		/// Cluster_idSecurityKmipServerPut cluster/{id}/security/kmip/server
		/// </summary>
		/// <param name="id">ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.</param>
		/// <param name="requestBody">Object containing the configuration details for a KMIP server.</param>
		public async Task Cluster_idSecurityKmipServerPutAsync(string id, KmipServerConfiguration requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/kmip/server";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get password requirements
		/// Query user password requirements for a cluster.
		/// Cluster_idSecurityPassword_requirementsGet cluster/{id}/security/password_requirements
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>Active password requirements.</returns>
		public async Task<PasswordRequirementsSummary> Cluster_idSecurityPassword_requirementsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/password_requirements";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PasswordRequirementsSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set password requirements
		/// Update user password requirements for a cluster.
		/// Cluster_idSecurityPassword_requirementsPatch cluster/{id}/security/password_requirements
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="requestBody">Password requirements.</param>
		/// <returns>Succesfully patched password requirements.</returns>
		public async Task<PasswordRequirementsSummary> Cluster_idSecurityPassword_requirementsPatchAsync(string id, PasswordRequirementsPatchRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/password_requirements";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PasswordRequirementsSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get global TOTP setting
		/// Returns TOTP global setting, including whether TOTP is enforced or not.
		/// Cluster_idSecurityTotpSettingGet cluster/{id}/security/totp/setting
		/// </summary>
		/// <param name="id">ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.</param>
		/// <returns>TOTP global setting for the specified Rubrik cluster.</returns>
		public async Task<TotpGlobalSetting> Cluster_idSecurityTotpSettingGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/totp/setting";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TotpGlobalSetting>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update TOTP global setting
		/// Update TOTP global setting, including whether TOTP is enforced or not.
		/// Cluster_idSecurityTotpSettingPut cluster/{id}/security/totp/setting
		/// </summary>
		/// <param name="id">ID assigned to a Rubrik cluster. Use *me* to refer to the Rubrik cluster that is hosting the current API session.</param>
		/// <returns>Updated TOTP global setting for the specified Rubrik cluster.</returns>
		public async Task<TotpGlobalSetting> Cluster_idSecurityTotpSettingPutAsync(string id, TotpGlobalSettingUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/totp/setting";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TotpGlobalSetting>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove certificate associated with specified truststore
		/// Remove certificate associated with specified truststore.
		/// Cluster_idSecurityTruststoreDeleteByTruststores cluster/{id}/security/truststore
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="truststores">Comma separated list of truststore types.</param>
		public async Task Cluster_idSecurityTruststoreDeleteByTruststoresAsync(string id, string[] truststores, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/truststore&"+string.Join("&", truststores.Select(z => $"truststores={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary of all truststores
		/// Get summary of all truststores.
		/// Cluster_idSecurityTruststoreGet cluster/{id}/security/truststore
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>List of truststore summaries.</returns>
		public async Task<TruststoreSummaryListResponse> Cluster_idSecurityTruststoreGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/truststore";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TruststoreSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set certificates for one or more truststores
		/// Setting the given certificate for each node's truststores.
		/// Cluster_idSecurityTruststorePatch cluster/{id}/security/truststore
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="requestBody">Request to update certificate for truststore.</param>
		public async Task Cluster_idSecurityTruststorePatchAsync(string id, TruststorePayload[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/truststore";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reset the signed certificate for Web server
		/// Resetting the customer-given certificate for each node's web server.
		/// Cluster_idSecurityWeb_signed_certDelete cluster/{id}/security/web_signed_cert
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		public async Task Cluster_idSecurityWeb_signed_certDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/web_signed_cert";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the signed certificate for Web server
		/// If the web server uses a signed certificate, fetch it.
		/// Cluster_idSecurityWeb_signed_certGet cluster/{id}/security/web_signed_cert
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>Signed certificate of the web server.</returns>
		public async Task<WebServerCertificateSummary> Cluster_idSecurityWeb_signed_certGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/web_signed_cert";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WebServerCertificateSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set a signed certificate for Web server
		/// Setting the given certificate for each node's web server to use.
		/// Cluster_idSecurityWeb_signed_certPut cluster/{id}/security/web_signed_cert
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="requestBody">Request to update certificate for web server.</param>
		public async Task Cluster_idSecurityWeb_signed_certPutAsync(string id, WebServerCertificatePayload requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/security/web_signed_cert";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the link for Rubrik SNMP MIB file
		/// Retrieve the download link for the Rubrik SNMP MIB file. The retrieval is a synchronous operation.
		/// Cluster_idSnmp_mib_linkGet cluster/{id}/snmp_mib_link
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>Download link for the Rubrik SNMP MIB file.</returns>
		public async Task<RubrikMibFileDownloadLink> Cluster_idSnmp_mib_linkGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snmp_mib_link";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RubrikMibFileDownloadLink>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the link for SYSLOG-MSG-MIB file
		/// Retrieve the download link for the SYSLOG-MSG-MIB file. The retrieval is a synchronous operation.
		/// Cluster_idSyslog_msg_mib_linkGet cluster/{id}/syslog_msg_mib_link
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>Download link for the SYSLOG-MSG-MIB file.</returns>
		public async Task<SyslogMsgMibFileDownloadLink> Cluster_idSyslog_msg_mib_linkGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/syslog_msg_mib_link";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SyslogMsgMibFileDownloadLink>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the link for SYSLOG-TC-MIB file
		/// Retrieve the download link for the SYSLOG-TC-MIB file. The retrieval is a synchronous operation.
		/// Cluster_idSyslog_tc_mib_linkGet cluster/{id}/syslog_tc_mib_link
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>Download link for the SYSLOG-TC-MIB file.</returns>
		public async Task<SyslogTcMibFileDownloadLink> Cluster_idSyslog_tc_mib_linkGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/syslog_tc_mib_link";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SyslogTcMibFileDownloadLink>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve CDM versions available for upgrade
		/// Retrieve a list of Rubrik CDM versions available to upgrade the Rubrik cluster.
		/// Cluster_idUpgradeAvailable_versionGetByFilter_versionAndFetch_linksAndSource_versionAndIgnore_localAndIgnore_remoteAndIgnore_downloadingAndDownload_job_instance_idAndFilter_upgradableAndShow_all cluster/{id}/upgrade/available_version
		/// </summary>
		/// <param name="id">The ID of the Rubrik cluster. To query the local cluster, use *me*.</param>
		/// <param name="filter_version">A string that filters the results based on the prefix. For example, the string "5.1" filters all releases in the 5.1 family. If more than one result is desired then this parameter can be used in conjunction with the `show_all` parameter.</param>
		/// <param name="fetch_links">Include a download URL for the single version passed in the 'filter_version' parameter. A link response will not be provided if the chosen version is locally available, or if 'filter_version' is not specified.
		///</param>
		/// <param name="source_version">The source version of Rubrik CDM used for the upgradeability check if 'filter_upgradable' if specified. If 'filter_upgradable' is not specified, this parameter is ignored.
		///</param>
		/// <param name="ignore_local">If specified, ignore locally available versions.</param>
		/// <param name="ignore_remote">If specified, ignore versions available in the Rubrik remote central repository.
		///</param>
		/// <param name="ignore_downloading">If specified, ignore versions currently being downloaded.</param>
		/// <param name="download_job_instance_id">If specified, filter results for downloading versions to the provided job instance ID.
		///</param>
		/// <param name="filter_upgradable">When this parameter is set, the query only returns versions of the Rubrik CDM that can be upgraded to from the version specified in the 'source_version' parameter. If 'source_version' is not specified, we use the cluster version as the source_version.
		///</param>
		/// <param name="show_all">When this parameter is set, the query shows all patch releases including releases with a newer version released in the same family. When set to false, the query returns only the latest version from each release family.
		///</param>
		/// <returns>List of available software versions.</returns>
		public async Task<AvailableVersionInfo[]> Cluster_idUpgradeAvailable_versionGetByFilter_versionAndFetch_linksAndSource_versionAndIgnore_localAndIgnore_remoteAndIgnore_downloadingAndDownload_job_instance_idAndFilter_upgradableAndShow_allAsync(string id, string filter_version, bool fetch_links, string source_version, bool ignore_local, bool ignore_remote, bool ignore_downloading, string download_job_instance_id, bool filter_upgradable, bool show_all, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/upgrade/available_version&filter_version=" + (filter_version==null? "" : System.Uri.EscapeDataString(filter_version))+"&fetch_links="+fetch_links+"&source_version=" + (source_version==null? "" : System.Uri.EscapeDataString(source_version))+"&ignore_local="+ignore_local+"&ignore_remote="+ignore_remote+"&ignore_downloading="+ignore_downloading+"&download_job_instance_id=" + (download_job_instance_id==null? "" : System.Uri.EscapeDataString(download_job_instance_id))+"&filter_upgradable="+filter_upgradable+"&show_all="+show_all;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AvailableVersionInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the result of the latest run of the upgrade prechecks
		/// Get the result of the latest run of the upgrade prechecks.
		/// 
		/// Cluster_idUpgradePrecheck_statusGetByFetch_next_run_info cluster/{id}/upgrade/precheck_status
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="fetch_next_run_info">If specified, fetch information corresponding to next upgrade prechecks job instance. If an upgrade prechecks job instance is currently running, results corresponding to it are returned.
		///</param>
		/// <returns>Returns the list of precheck failures during the latest run of the upgrade prechecks job.
		///</returns>
		public async Task<PrecheckStatusResponse> Cluster_idUpgradePrecheck_statusGetByFetch_next_run_infoAsync(string id, bool fetch_next_run_info, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/upgrade/precheck_status&fetch_next_run_info="+fetch_next_run_info;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PrecheckStatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start an on demand run of the prechecks
		/// Start an on demand run of the prechecks.
		/// 
		/// Cluster_idUpgradePrecheck_statusPost cluster/{id}/upgrade/precheck_status
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		public async Task Cluster_idUpgradePrecheck_statusPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/upgrade/precheck_status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get asynchronous request details
		/// Get asynchronous request details for an upgrade request.
		/// Cluster_idUpgradeRequest_request_idGet cluster/{id}/upgrade/request/{request_id}
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="request_id">ID of the request.</param>
		public async Task Cluster_idUpgradeRequest_request_idGetAsync(string id, string request_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/upgrade/request/"+ (request_id==null? "" : System.Uri.EscapeDataString(request_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stage software on CDM for upgrade
		/// Stage software corresponding to a given CDM version on the cluster, in preparation for an upgrade.
		/// Cluster_idUpgradeStage_cdm_softwarePost cluster/{id}/upgrade/stage_cdm_software
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <param name="requestBody">Information about the provided CDM software package.</param>
		public async Task Cluster_idUpgradeStage_cdm_softwarePostAsync(string id, StageCdmSoftwareInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/upgrade/stage_cdm_software";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get cluster software version
		/// Retrieves software version of the Rubrik cluster.
		/// Cluster_idVersionGet cluster/{id}/version
		/// </summary>
		/// <param name="id">ID of the Rubrik cluster or *me* for self.</param>
		/// <returns>Software version running on the cluster.</returns>
		public async Task<ClusterVersion> Cluster_idVersionGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/version";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterVersion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// View a list of filtered configuration updates
		/// View a list of cluster configuration options that have updated within a specified time window.
		/// ConfigHistoryList_updatesGetByLimitAndOffsetAndApi_userAndNode_idAnd_namespaceAndNameAndSourceAndAfter_timeAndBefore_time config/history/list_updates
		/// </summary>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Ignore these many matches in the beginning.</param>
		/// <param name="api_user">The username of the account. Applies a filter to the configuration updates performed by the specified username.</param>
		/// <param name="node_id">The node ID. Applies a filter to the configuration updates for the specified node. When no node_id is specified, the filter shows both local and cluster-wide configurations. Specify 'cluster' for filtering out cluster-wide configuration updates.</param>
		/// <param name="_namespace">The configuration namespace. Applies a filter to the configuration updates for the specified namespace.</param>
		/// <param name="name">Name of the configuration. Applies a filter to the configuration updates for the specified configuration name.</param>
		/// <param name="source">Source for configuration updates. Applies a filter to the configuration updates for the specified source.</param>
		/// <param name="after_time">The earliest time configuration history is needed. Applies a filter that only shows configuration updates after the specified time.</param>
		/// <param name="before_time">The latest time configuration history is needed. Applies filter to display only configuration updates prior to the specified time. The default value is the current time.</param>
		/// <returns>A summary of configuration updates that satisfy the filters in place.</returns>
		public async Task<ConfigurationUpdateSummaryListResponse> ConfigHistoryList_updatesGetByLimitAndOffsetAndApi_userAndNode_idAnd_namespaceAndNameAndSourceAndAfter_timeAndBefore_timeAsync(int limit, int offset, string api_user, string node_id, string _namespace, string name, ConfigChangeSource source, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "config/history/list_updates?limit="+limit+"&offset="+offset+"&api_user=" + (api_user==null? "" : System.Uri.EscapeDataString(api_user))+"&node_id=" + (node_id==null? "" : System.Uri.EscapeDataString(node_id))+"&namespace=" + (_namespace==null? "" : System.Uri.EscapeDataString(_namespace))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&source=" + source+"&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ConfigurationUpdateSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// View a list of configurations and their values on a given date
		/// View a list of configurations and their values on a given date.
		/// ConfigHistoryOndateGetByLimitAndOffsetAndNode_idAnd_namespaceAndNameAndOn_date config/history/ondate
		/// </summary>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Ignore these many matches in the beginning.</param>
		/// <param name="node_id">The name of the node that require configuration values. Applies a filter specific to the name of node. When no node_id is specified, the filter shows both local and cluster-wide configurations.</param>
		/// <param name="_namespace">The configuration namespace. Applies a filter to the configuration updates for the specified namespace.</param>
		/// <param name="name">The name of the configuration option. Applies a filter to the configuration updates for the specified option.</param>
		/// <param name="on_date">The timestamp for which to retrieve configuration values.</param>
		/// <returns>Summary of the values of configuration options, as of a specified timestamp, that match the filters in place.</returns>
		public async Task<ConfigurationSummaryListResponse> ConfigHistoryOndateGetByLimitAndOffsetAndNode_idAnd_namespaceAndNameAndOn_dateAsync(int limit, int offset, string node_id, string _namespace, string name, System.DateTimeOffset on_date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "config/history/ondate?limit="+limit+"&offset="+offset+"&node_id=" + (node_id==null? "" : System.Uri.EscapeDataString(node_id))+"&namespace=" + (_namespace==null? "" : System.Uri.EscapeDataString(_namespace))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&on_date=" + on_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ConfigurationSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all certificate signing requests
		/// Returns a list of summaries for every outstanding certificate signing request (CSR).
		/// CsrGet csr
		/// </summary>
		/// <returns>List of certifcate signing requests.</returns>
		public async Task<CsrSummaryListResponse> CsrGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "csr";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CsrSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Generate a new private key and return a certificate signing request
		/// Generates a new private key and returns a base64 encoded PKCS#10 certificate signing request (CSR).
		/// CsrPost csr
		/// </summary>
		/// <param name="requestBody">Information for client certificate request.</param>
		/// <returns>Certificate signing request.</returns>
		public async Task<CsrSummary> CsrPostAsync(GenericCsrRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "csr";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CsrSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a certificate signing request
		/// Deletes a certificate signing request corresponding to the provided ID.
		/// Csr_idDelete csr/{id}
		/// </summary>
		/// <param name="id">Certificate signing request ID.</param>
		public async Task Csr_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "csr/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Bulk delete all snapshots for the given objects
		/// This endpoint deletes all snapshots from all locations for the objects with the IDs specified by the 'objectIds' parameter. API returning success does not guarantee that the snapshots will be expired.
		/// 
		/// Data_sourceSnapshotBulk_deletePost data_source/snapshot/bulk_delete
		/// </summary>
		/// <param name="requestBody">A list of object IDs.
		///</param>
		public async Task Data_sourceSnapshotBulk_deletePostAsync(BulkDeleteSnapshotsConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "data_source/snapshot/bulk_delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of snapshots that have expired according to their snapshot-level SLA Domain assignments
		/// 
		/// Gets a list of the snapshots of a specified data source that have expired according to the snapshot-level SLA Domain assignments. This list does not include remote snapshots.
		/// 
		/// Data_source_idExpired_custom_retention_snapshotsGet data_source/{id}/expired_custom_retention_snapshots
		/// </summary>
		/// <param name="id">The object ID.</param>
		/// <returns>Array containing information of snapshots which have been expired due to snapshot-level SLA Domain assignments.
		///</returns>
		public async Task<ExpiredCustomRetentionSnapshots> Data_source_idExpired_custom_retention_snapshotsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "data_source/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/expired_custom_retention_snapshots";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExpiredCustomRetentionSnapshots>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Bulk delete specified snapshots for the given object
		/// Bulk deletion of the snapshots specified by a list of snapshot IDs for a given object. Object type is required. Location ID is optional. API returning success does not guarantee that the snapshot will be expired.
		/// 
		/// Data_source_idSnapshotBulk_deletePost data_source/{id}/snapshot/bulk_delete
		/// </summary>
		/// <param name="id">ID of the object.</param>
		/// <param name="requestBody">A list of snapshot IDs specifying snapshots to delete. Optionally specifies a location ID. Snapshot deletion is global when the location ID is absent.
		///</param>
		public async Task Data_source_idSnapshotBulk_deletePostAsync(string id, BulkDeleteObjectSnapshotsConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "data_source/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot/bulk_delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the database log backup delay information
		/// Get the database log backup delay information.
		/// DatabaseLog_reportGetByEffective_sla_domain_idAndNameAndDatabase_typeAndLocationAndLog_backup_delayAndLimitAndOffsetAndSort_byAndSort_order database/log_report
		/// </summary>
		/// <param name="effective_sla_domain_id">Filter by effective SLA domain.</param>
		/// <param name="name">Filter by the database name substring.</param>
		/// <param name="database_type">Filter by the database type.</param>
		/// <param name="location">Filter by the database location.</param>
		/// <param name="log_backup_delay">Filter by the database log backup delay in seconds, greater than this value.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Integer specifying the number of initial matches to ignore.</param>
		/// <param name="sort_by">Specifies the attribute to use while sorting the summary information. Performs an ASCII sort using the specified attribute, in the order specified by sort_order.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>If the query was successful, Returns the array of DbLogReportSummary objects.</returns>
		public async Task<DbLogReportSummaryListResponse> DatabaseLog_reportGetByEffective_sla_domain_idAndNameAndDatabase_typeAndLocationAndLog_backup_delayAndLimitAndOffsetAndSort_byAndSort_orderAsync(string effective_sla_domain_id, string name, string database_type, string location, int log_backup_delay, int limit, int offset, DbLogReportSummaryListSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "database/log_report?effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&database_type=" + (database_type==null? "" : System.Uri.EscapeDataString(database_type))+"&location=" + (location==null? "" : System.Uri.EscapeDataString(location))+"&log_backup_delay="+log_backup_delay+"&limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DbLogReportSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the database log backup report properties
		/// Get the properties for the database (SQL and Oracle) log backup delay email notification creation. The properties are logDelayThresholdInMin and logDelayNotificationFrequencyInMin.
		/// DatabaseLog_reportDefaultsGet database/log_report/defaults
		/// </summary>
		/// <returns>Returns the current properties of logDelayThresholdInMin and logDelayNotificationFrequencyInMin.</returns>
		public async Task<DbLogReportProperties> DatabaseLog_reportDefaultsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "database/log_report/defaults";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DbLogReportProperties>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the database log backup report properties
		/// Update the properties for the database (SQL and Oracle) log backup delay email notification creation. The properties are logDelayThresholdInMin and logDelayNotificationFrequencyInMin.
		/// DatabaseLog_reportDefaultsPatch database/log_report/defaults
		/// </summary>
		/// <param name="requestBody">Updated report properties.</param>
		/// <returns>Returns the updated properties of logDelayThresholdInMin and logDelayNotificationFrequencyInMin.</returns>
		public async Task<DbLogReportProperties> DatabaseLog_reportDefaultsPatchAsync(DbLogReportPropertiesUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "database/log_report/defaults";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DbLogReportProperties>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get information for all events
		/// Returns information for all events. Only Global or Read Only Admins and Support users have authorization to use this endpoint. Accepts filters. For similar functionality to the previous /internal/event endpoint, use the /v1/event/latest endpoint.
		/// EventGetByLimitAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeAndShould_include_event_series event
		/// </summary>
		/// <param name="limit">Maximum number of events retrieved.</param>
		/// <param name="after_id">An (event_id, time) tuple. When specified, returns all events with timestamps that come after the time value of after_id based on the sort order defined by the order_by_time parameter.</param>
		/// <param name="before_date">Filter the events occurring after the specified date.</param>
		/// <param name="after_date">Filter the events occurring before the specified date.</param>
		/// <param name="order_by_time">The events are ordered by timestamp. Specify desc to show the latest entries first. Specify asc to show the oldest entries first. The default behavior is asc.</param>
		/// <param name="should_include_event_series">A Boolean value that determines whether to include event series summary for every event. If set to 'true', a list of event series summary will be returned and each summary has an empty list of events. If set to 'false', an empty list of event series summary will be returned. The default value is 'false'. Setting it to 'true' will increase the response time.</param>
		/// <returns>Returns information for the events that match the query parameters.</returns>
		public async Task<EventsAndSeriesSummariesV1> EventGetByLimitAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeAndShould_include_event_seriesAsync(int limit, string after_id, System.DateTimeOffset before_date, System.DateTimeOffset after_date, SortOrder order_by_time, bool should_include_event_series, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "event?limit="+limit+"&after_id=" + (after_id==null? "" : System.Uri.EscapeDataString(after_id))+"&before_date=" + before_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&after_date=" + after_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&order_by_time=" + order_by_time+"&should_include_event_series="+should_include_event_series;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventsAndSeriesSummariesV1>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download summary of events as a CSV file
		/// Download summary of the related events that match the value specified in the following categories: event type, status, object name or ID, eventSeriesId, object type, and limit events by dates.
		/// EventCsv_download_linkGetByLimitAndEvent_series_statusAndEvent_statusAndEvent_typeAndEvent_severityAndObject_idsAndObject_typeAndObject_nameAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_time event/csv_download_link
		/// </summary>
		/// <param name="limit">Maximum number of events to retrieve. Default value is 100.</param>
		/// <param name="event_series_status">Filter by the current status of the event series.</param>
		/// <param name="event_status">Filter by the status of the latest event in the event series.</param>
		/// <param name="event_type">Filter by the type of the latest event in the event series.</param>
		/// <param name="event_severity">Filter by the severity of the latest event in the event series.</param>
		/// <param name="object_ids">Filter the object IDs in the latest event series by matches to a comma-separated list of object IDs.</param>
		/// <param name="object_type">Filter the events in the event series by a specified object type.</param>
		/// <param name="object_name">Filter latest events according to the provided name using prefix search for resources and exact search for usernames.</param>
		/// <param name="after_id">An (event_series_id, time) tuple. When specified, returns all event series whose latest event timestamp comes after the time value of after_id based on the sort order defined by the order_by_time parameter.</param>
		/// <param name="before_date">Filter out event series that have events occurring after the specified date.</param>
		/// <param name="after_date">Filter out event series that have events occurring before the specified date.</param>
		/// <param name="order_by_time">The events in a series are ordered by timestamp. Specify desc to show the latest entries first. Specify asc to show the oldest entries first. The default behavior is desc.</param>
		/// <returns>Returns the download link of the csv.</returns>
		public async Task<EventCsvDownloadResponse> EventCsv_download_linkGetByLimitAndEvent_series_statusAndEvent_statusAndEvent_typeAndEvent_severityAndObject_idsAndObject_typeAndObject_nameAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeAsync(int limit, ActivityLogSummaryV1EventSeriesStatus event_series_status, EventSummaryV1EventStatus event_status, EventCsv_download_linkGetByLimitAndEvent_series_statusAndEvent_statusAndEvent_typeAndEvent_severityAndObject_idsAndObject_typeAndObject_nameAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeEvent_type event_type, EventSummaryV1EventSeverity event_severity, string[] object_ids, EventSummaryV1ObjectType object_type, string object_name, string after_id, System.DateTimeOffset before_date, System.DateTimeOffset after_date, SortOrder order_by_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "event/csv_download_link?limit="+limit+"&event_series_status=" + event_series_status+"&event_status=" + event_status+"&event_type=" + event_type+"&event_severity=" + event_severity+"&"+string.Join("&", object_ids.Select(z => $"object_ids={System.Uri.EscapeDataString(z.ToString())}"))+"&object_type=" + object_type+"&object_name=" + (object_name==null? "" : System.Uri.EscapeDataString(object_name))+"&after_id=" + (after_id==null? "" : System.Uri.EscapeDataString(after_id))+"&before_date=" + before_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&after_date=" + after_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&order_by_time=" + order_by_time;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventCsvDownloadResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get latest events with their associated event series information
		/// Get the latest event, event series status, and the number of warning events for all event series. This endpoint has similar/enhanced functionality to the previously deprecated /internal/event endpoint.
		/// EventLatestGetByLimitAndEvent_series_statusAndEvent_statusAndEvent_typeAndEvent_severityAndObject_idsAndObject_typeAndObject_nameAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeAndShould_include_event_series event/latest
		/// </summary>
		/// <param name="limit">Maximum number of events retrieved.</param>
		/// <param name="event_series_status">Filter by the current status of the event series.</param>
		/// <param name="event_status">Filter by the status of the latest event in the event series.</param>
		/// <param name="event_type">Filter by the type of the latest event in the event series.</param>
		/// <param name="event_severity">Filter by the severity of the latest event in the event series.</param>
		/// <param name="object_ids">Filter the object IDs in the latest event series by matches to a comma-separated list of object IDs.</param>
		/// <param name="object_type">Filter the events in the event series by a specified object type.</param>
		/// <param name="object_name">Filter latest events according to the provided name using prefix search for resources and exact search for usernames.</param>
		/// <param name="after_id">An (event_series_id, time) tuple. When specified, returns all event series whose latest event timestamp comes after the time value of after_id based on the sort order defined by the order_by_time parameter.</param>
		/// <param name="before_date">Filter out event series that have events occurring after the specified date.</param>
		/// <param name="after_date">Filter out event series that have events occurring before the specified date.</param>
		/// <param name="order_by_time">The events in a series are ordered by timestamp. Specify desc to show the latest entries first. Specify asc to show the oldest entries first. The default behavior is desc.</param>
		/// <param name="should_include_event_series">A Boolean value that determines whether to include all events in the event series. The default value is 'false'. Setting it to 'true' will significantly increase the response time.</param>
		/// <returns>Returns information for the events that match the query parameters.</returns>
		public async Task<ActivityLogSummaryV1ListResponse> EventLatestGetByLimitAndEvent_series_statusAndEvent_statusAndEvent_typeAndEvent_severityAndObject_idsAndObject_typeAndObject_nameAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeAndShould_include_event_seriesAsync(int limit, ActivityLogSummaryV1EventSeriesStatus event_series_status, EventSummaryV1EventStatus event_status, EventLatestGetByLimitAndEvent_series_statusAndEvent_statusAndEvent_typeAndEvent_severityAndObject_idsAndObject_typeAndObject_nameAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeAndShould_include_event_seriesEvent_type event_type, EventSummaryV1EventSeverity event_severity, string[] object_ids, EventSummaryV1ObjectType object_type, string object_name, string after_id, System.DateTimeOffset before_date, System.DateTimeOffset after_date, SortOrder order_by_time, bool should_include_event_series, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "event/latest?limit="+limit+"&event_series_status=" + event_series_status+"&event_status=" + event_status+"&event_type=" + event_type+"&event_severity=" + event_severity+"&"+string.Join("&", object_ids.Select(z => $"object_ids={System.Uri.EscapeDataString(z.ToString())}"))+"&object_type=" + object_type+"&object_name=" + (object_name==null? "" : System.Uri.EscapeDataString(object_name))+"&after_id=" + (after_id==null? "" : System.Uri.EscapeDataString(after_id))+"&before_date=" + before_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&after_date=" + after_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&order_by_time=" + order_by_time+"&should_include_event_series="+should_include_event_series;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActivityLogSummaryV1ListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all events and relevant information associated with an event series ID
		/// Gets all events, event series, SLA Domain, and object information that is associated with a specified event series ID.
		/// Event_series_idGet event_series/{id}
		/// </summary>
		/// <param name="id">The ID of the event series.</param>
		/// <returns>Returns the list of events by event series ID and a summary of the event series.</returns>
		public async Task<EventSeriesSummaryV1> Event_series_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "event_series/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventSeriesSummaryV1>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a summary of all exclusion patterns
		/// Get a summary of all exclusion patterns.
		/// Exclusion_patternGetByPatternAndIs_mutableAndSource_idAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_order exclusion_pattern
		/// </summary>
		/// <param name="pattern">Filter a response by making an infix comparison of the exclusion patttern in the response with the specified value.</param>
		/// <param name="is_mutable">Filter a response based on the mutability of the pattern.</param>
		/// <param name="source_id">Filter a response based on the protectable object to which the exclusion pattern applies.</param>
		/// <param name="primary_cluster_id">Limit a response to the results that have the specified primary cluster value.</param>
		/// <param name="limit">Limit the summary information to a specified maximum number of matches. Optionally, use with offset to start the count at a specified point. Optionally, use with sort_by to perform sort on given attributes. Include sort_order to determine the ascending or descending direction of the sort.</param>
		/// <param name="offset">Starting position in the list of matches. The response includes the specified numbered entry and all higher numbered entries. Use with limit to retrieve the response as smaller groups of entries, for example for paging of results.</param>
		/// <param name="sort_by">Specifies a comma-separated list of attributes to use in sorting the matches. Performs an ASCII sort of the values in the response using each specified attribute, in the order specified.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Successful query results for exclusion pattern.</returns>
		public async Task<ExclusionPatternDetailListResponse> Exclusion_patternGetByPatternAndIs_mutableAndSource_idAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderAsync(string pattern, bool is_mutable, string source_id, string primary_cluster_id, int limit, int offset, Exclusion_patternGetByPatternAndIs_mutableAndSource_idAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exclusion_pattern?pattern=" + (pattern==null? "" : System.Uri.EscapeDataString(pattern))+"&is_mutable="+is_mutable+"&source_id=" + (source_id==null? "" : System.Uri.EscapeDataString(source_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExclusionPatternDetailListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an exclusion pattern
		/// Create a exclusion pattern.
		/// Exclusion_patternPost exclusion_pattern
		/// </summary>
		/// <param name="requestBody">Create configuration parameters for a exclusion pattern.</param>
		public async Task Exclusion_patternPostAsync(ExclusionPatternCreateConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exclusion_pattern";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Bulk delete the provided mutable exclusion patterns
		/// Bulk deletes the mutable patterns in a specified set of exclusion patterns.
		/// Exclusion_patternBulkDeleteByIds exclusion_pattern/bulk
		/// </summary>
		/// <param name="ids">The ID of each exclusion pattern to delete.</param>
		public async Task Exclusion_patternBulkDeleteByIdsAsync(string[] ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exclusion_pattern/bulk?"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Bulk create exclusion patterns
		/// Bulk create exclusion patterns.
		/// Exclusion_patternBulkPost exclusion_pattern/bulk
		/// </summary>
		/// <param name="requestBody">Create configuration parameters for a exclusion pattern.</param>
		public async Task Exclusion_patternBulkPostAsync(ExclusionPatternCreateConfig[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exclusion_pattern/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a mutable exclusion pattern
		/// Deletes an exclusion pattern if that pattern is mutable.
		/// Exclusion_pattern_idDelete exclusion_pattern/{id}
		/// </summary>
		/// <param name="id">ID of the exclusion pattern.</param>
		public async Task Exclusion_pattern_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exclusion_pattern/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get details of a exclusion pattern
		/// Get details of a exclusion pattern.
		/// Exclusion_pattern_idGet exclusion_pattern/{id}
		/// </summary>
		/// <param name="id">ID of the exclusion pattern.</param>
		/// <returns>Details about the exclusion pattern.</returns>
		public async Task<ExclusionPatternDetail> Exclusion_pattern_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exclusion_pattern/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExclusionPatternDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a mutable exclusion pattern
		/// Update mutable exclusion pattern with specified properties. The exclusion pattern which is mutable can be modified.
		/// Exclusion_pattern_idPost exclusion_pattern/{id}
		/// </summary>
		/// <param name="id">ID of exclusion pattern.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Return details about the exclusion pattern.</returns>
		public async Task<ExclusionPatternDetail> Exclusion_pattern_idPostAsync(string id, ExclusionPatternUpdateConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "exclusion_pattern/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExclusionPatternDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a summary of all failover clusters
		/// Get a summary of all failover clusters.
		/// Failover_clusterGetByNameAndOperating_system_typeAndSla_assignmentAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_order failover_cluster
		/// </summary>
		/// <param name="name">Filter a response by making an infix comparison of the failover cluster name in the response, with the specified value.</param>
		/// <param name="operating_system_type">Filter a response based on the operating system type.</param>
		/// <param name="sla_assignment">Limit a response to the results that have the specified SLA Domain assignment type.</param>
		/// <param name="primary_cluster_id">Limit a response to the results that have the specified primary cluster value.</param>
		/// <param name="limit">Limit the summary information to a specified maximum number of matches. Optionally, use with offset to start the count at a specified point. Optionally, use with sort_by to perform sort on given attributes. Include sort_order to determine the ascending or descending direction of the sort.</param>
		/// <param name="offset">Starting position in the list of matches. The response includes the specified numbered entry and all higher numbered entries. Use with limit to retrieve the response as smaller groups of entries, for example for paging of results.</param>
		/// <param name="sort_by">Specifies a comma-separated list of attributes to use in sorting the matches. Performs an ASCII sort of the values in the response using each specified attribute, in the order specified.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Successful query results for failover cluster.</returns>
		public async Task<FailoverClusterSummaryListResponse> Failover_clusterGetByNameAndOperating_system_typeAndSla_assignmentAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderAsync(string name, FailoverClusterOsType operating_system_type, SlaAssignment sla_assignment, string primary_cluster_id, int limit, int offset, Failover_clusterGetByNameAndOperating_system_typeAndSla_assignmentAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&operating_system_type=" + operating_system_type+"&sla_assignment=" + sla_assignment+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a failover cluster
		/// Create a failover cluster.
		/// Failover_clusterPost failover_cluster
		/// </summary>
		/// <param name="requestBody">Create configuration parameters for a failover cluster.</param>
		public async Task Failover_clusterPostAsync(FailoverClusterConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete the provided failover clusters
		/// Delete the provided failover clusters.
		/// Failover_clusterBulkDeleteByIdsAndPreserve_snapshots failover_cluster/bulk
		/// </summary>
		/// <param name="ids">The ID of each failover cluster to delete.</param>
		/// <param name="preserve_snapshots">Specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.</param>
		public async Task Failover_clusterBulkDeleteByIdsAndPreserve_snapshotsAsync(string[] ids, bool preserve_snapshots, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/bulk?"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&preserve_snapshots="+preserve_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a summary of all failover cluster apps
		/// Get a summary of all failover cluster apps.
		/// Failover_clusterFailover_cluster_appGetByNameAndSla_assignmentAndPrimary_cluster_idAndOperating_system_typeAndLimitAndOffsetAndSort_byAndSort_order failover_cluster/failover_cluster_app
		/// </summary>
		/// <param name="name">Filter the response by comparing the failover cluster app name with the specified value.</param>
		/// <param name="sla_assignment">Limit a response to the results that have the specified SLA Domain assignment type.</param>
		/// <param name="primary_cluster_id">Limit a response to the results that have the specified primary cluster value.</param>
		/// <param name="operating_system_type">Filter a response based on the failover cluster operating system type.</param>
		/// <param name="limit">Limit the summary information to a specified maximum number of matches. Optionally, use with offset to start the count at a specified point. Optionally, use with sort_by to perform sort on given attributes. Include sort_order to determine the ascending or descending direction of the sort.</param>
		/// <param name="offset">Starting position in the list of matches. The response includes the specified numbered entry and all higher numbered entries. Use with limit to retrieve the response as smaller groups of entries, for example for paging of results.</param>
		/// <param name="sort_by">Specifies a comma-separated list of attributes to use in sorting the matches. Performs an ASCII sort of the values in the response using each specified attribute, in the order specified.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Successful query results for failover cluster app.</returns>
		public async Task<FailoverClusterAppSummaryListResponse> Failover_clusterFailover_cluster_appGetByNameAndSla_assignmentAndPrimary_cluster_idAndOperating_system_typeAndLimitAndOffsetAndSort_byAndSort_orderAsync(string name, SlaAssignment sla_assignment, string primary_cluster_id, FailoverClusterOsType operating_system_type, int limit, int offset, Failover_clusterGetByNameAndOperating_system_typeAndSla_assignmentAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/failover_cluster_app?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sla_assignment=" + sla_assignment+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&operating_system_type=" + operating_system_type+"&limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterAppSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a failover cluster app
		/// Create a failover cluster app.
		/// Failover_clusterFailover_cluster_appPost failover_cluster/failover_cluster_app
		/// </summary>
		/// <param name="requestBody">Create configuration parameters for a failover cluster app.</param>
		public async Task Failover_clusterFailover_cluster_appPostAsync(FailoverClusterAppConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/failover_cluster_app";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete failover cluster applications
		/// Delete failover cluster applications from Rubrik cluster.
		/// Failover_clusterFailover_cluster_appBulkDeleteByIdsAndPreserve_snapshots failover_cluster/failover_cluster_app/bulk
		/// </summary>
		/// <param name="ids">The ID of each failover cluster application to delete.</param>
		/// <param name="preserve_snapshots">Specifies whether to preserve the snapshots of the fileset that belongs to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.</param>
		public async Task Failover_clusterFailover_cluster_appBulkDeleteByIdsAndPreserve_snapshotsAsync(string[] ids, bool preserve_snapshots, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/failover_cluster_app/bulk?"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&preserve_snapshots="+preserve_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a failover cluster app
		/// Delete a failover cluster app.
		/// Failover_clusterFailover_cluster_app_idDeleteByPreserve_snapshots failover_cluster/failover_cluster_app/{id}
		/// </summary>
		/// <param name="id">ID of the failover cluster app.</param>
		/// <param name="preserve_snapshots">A Boolean that specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.</param>
		public async Task Failover_clusterFailover_cluster_app_idDeleteByPreserve_snapshotsAsync(string id, bool preserve_snapshots, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/failover_cluster_app/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&preserve_snapshots="+preserve_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get details of a failover cluster app
		/// Get details of a failover cluster app.
		/// Failover_clusterFailover_cluster_app_idGet failover_cluster/failover_cluster_app/{id}
		/// </summary>
		/// <param name="id">ID of the failover cluster app.</param>
		/// <returns>Details about the failover cluster app.</returns>
		public async Task<FailoverClusterAppDetail> Failover_clusterFailover_cluster_app_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/failover_cluster_app/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterAppDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a failover cluster app
		/// Update the failover cluster app with specified properties.
		/// Failover_clusterFailover_cluster_app_idPatch failover_cluster/failover_cluster_app/{id}
		/// </summary>
		/// <param name="id">ID of failover cluster app.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Return details about the failover cluster app.</returns>
		public async Task<FailoverClusterAppSummary> Failover_clusterFailover_cluster_app_idPatchAsync(string id, FailoverClusterAppConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/failover_cluster_app/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterAppSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary of a hierarchy object
		/// Retrieve details for the specified hierarchy object.
		/// Failover_clusterHierarchy_idGet failover_cluster/hierarchy/{id}
		/// </summary>
		/// <param name="id">ID of the hierarchy object.</param>
		/// <returns>Details of the hierarchy object.</returns>
		public async Task<FailoverClusterHierarchyObjectSummary> Failover_clusterHierarchy_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterHierarchyObjectSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of immediate descendant objects
		/// Retrieve the list of immediate descendant objects for the specified parent.
		/// Failover_clusterHierarchy_idChildrenGetByNameAndOperating_system_typeAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndConfigured_sla_domain_idAndSla_assignmentAndSort_byAndSort_order failover_cluster/hierarchy/{id}/children
		/// </summary>
		/// <param name="name">Filter a response by making an infix comparison of the failover cluster name or failover cluster app name.</param>
		/// <param name="operating_system_type">Filter a response based on the failover cluster operating system type.</param>
		/// <param name="id">ID of the parent failover cluster hierarchy object. To get top-level nodes, use **root** as the ID.</param>
		/// <param name="object_type">Filter by node object type.</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="limit">An integer that specifies the maximum number of matches to return.</param>
		/// <param name="offset">An integer that specifies a number of initial matches to ignore.</param>
		/// <param name="configured_sla_domain_id">Filter by configured SLA domain.</param>
		/// <param name="sla_assignment">Filter by SLA assignment type.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Summary list of descendant objects.</returns>
		public async Task<FailoverClusterHierarchyObjectSummaryListResponse> Failover_clusterHierarchy_idChildrenGetByNameAndOperating_system_typeAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndConfigured_sla_domain_idAndSla_assignmentAndSort_byAndSort_orderAsync(string name, FailoverClusterOsType operating_system_type, string id, FailoverClusterObjectType object_type, string primary_cluster_id, int limit, int offset, string configured_sla_domain_id, SlaAssignment sla_assignment, FailoverClusterHierarchyObjectSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/children?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&operating_system_type=" + operating_system_type+"&object_type=" + object_type+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&limit="+limit+"&offset="+offset+"&configured_sla_domain_id=" + (configured_sla_domain_id==null? "" : System.Uri.EscapeDataString(configured_sla_domain_id))+"&sla_assignment=" + sla_assignment+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterHierarchyObjectSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of descendant objects
		/// Retrieve the list of descendant objects for the specified parent.
		/// Failover_clusterHierarchy_idDescendantsGetByNameAndOperating_system_typeAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndConfigured_sla_domain_idAndSla_assignmentAndSort_byAndSort_order failover_cluster/hierarchy/{id}/descendants
		/// </summary>
		/// <param name="name">Filter a response by making an infix comparison of the failover cluster name or failover cluster app name.</param>
		/// <param name="operating_system_type">Filter a response based on the failover cluster operating system type.</param>
		/// <param name="id">ID of the parent failover cluster hierarchy object. To get top-level nodes, use **root** as the ID.</param>
		/// <param name="object_type">Filter by node object type.</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="limit">An integer that specifies the maximum number of matches to return.</param>
		/// <param name="offset">An integer that specifies a number of initial matches to ignore.</param>
		/// <param name="configured_sla_domain_id">Filter by configured SLA domain.</param>
		/// <param name="sla_assignment">Filter by SLA assignment type.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Summary list of descendant objects.</returns>
		public async Task<FailoverClusterHierarchyObjectSummaryListResponse> Failover_clusterHierarchy_idDescendantsGetByNameAndOperating_system_typeAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndConfigured_sla_domain_idAndSla_assignmentAndSort_byAndSort_orderAsync(string name, FailoverClusterOsType operating_system_type, string id, FailoverClusterObjectType object_type, string primary_cluster_id, int limit, int offset, string configured_sla_domain_id, SlaAssignment sla_assignment, FailoverClusterHierarchyObjectSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/descendants?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&operating_system_type=" + operating_system_type+"&object_type=" + object_type+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&limit="+limit+"&offset="+offset+"&configured_sla_domain_id=" + (configured_sla_domain_id==null? "" : System.Uri.EscapeDataString(configured_sla_domain_id))+"&sla_assignment=" + sla_assignment+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterHierarchyObjectSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a failover cluster
		/// Delete a failover cluster.
		/// Failover_cluster_idDeleteByPreserve_snapshots failover_cluster/{id}
		/// </summary>
		/// <param name="id">ID of the failover cluster.</param>
		/// <param name="preserve_snapshots">A Boolean that specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.</param>
		public async Task Failover_cluster_idDeleteByPreserve_snapshotsAsync(string id, bool preserve_snapshots, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&preserve_snapshots="+preserve_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get details of a failover cluster
		/// Get details of a failover cluster.
		/// Failover_cluster_idGet failover_cluster/{id}
		/// </summary>
		/// <param name="id">ID of the failover cluster.</param>
		/// <returns>Details about the failover cluster.</returns>
		public async Task<FailoverClusterDetail> Failover_cluster_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a failover cluster
		/// Update failover cluster with specified properties.
		/// Failover_cluster_idPatch failover_cluster/{id}
		/// </summary>
		/// <param name="id">ID of failover cluster.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Return details about the failover cluster.</returns>
		public async Task<FailoverClusterDetail> Failover_cluster_idPatchAsync(string id, FailoverClusterConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "failover_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FailoverClusterDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for all filesets
		/// Retrieve summary information for each fileset. Optionally, filter the retrieved information.
		/// FilesetGetByPrimary_cluster_idAndHost_idAndShare_idAndIs_relicAndEffective_sla_domain_idAndTemplate_idAndLimitAndOffsetAndNameAndHost_nameAndSort_byAndSort_order fileset
		/// </summary>
		/// <param name="primary_cluster_id">Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.
		///Use **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session.</param>
		/// <param name="host_id">Filter the summary information based on the ID of the host referenced by the fileset.</param>
		/// <param name="share_id">Filter the summary information based on the ID of the host share referenced by the fileset.
		///Use **_NONE_** to only return information for filesets that were not created based on a host share.
		///Use **_ANY_** to only return information for filesets that were created based on a host share.</param>
		/// <param name="is_relic">Filter the summary information based on the relic status of the fileset. Returns both relic and non relic if the parameter is not set.</param>
		/// <param name="effective_sla_domain_id">Filter the summary information based on the ID of the effective SLA Domain inherited by a fileset.
		///Use **_UNPROTECTED_** to only return information for filesets that do not have an effective SLA Domain.
		///Use **_PROTECTED_** to only return information for filesets that do have an effective SLA Domain.</param>
		/// <param name="template_id">Filter the summary information based on the ID of a fileset template.
		///
		///Use **_NONE_** to only return information for filesets that were not created from a fileset template.
		///
		///Use **_ANY_** to only return information for filesets that were created from a fileset template.</param>
		/// <param name="limit">Limit the summary information to a specified maximum number of filesets.
		///
		///Optionally, use with **_offset_** to start the count at a specified point.
		///
		///Optionally, use with **_sort_by_** to perform sort on given attributes. Include **_sort_order_** to determine the ascending or descending direction of sort.</param>
		/// <param name="offset">Starting position in the list of fileset entries contained in the response. The summary information includes the specified numbered entry and all higher numbered entries. Use with **_limit_** to retrieve the summary information as smaller groups of entries, e.g. for paging of results.</param>
		/// <param name="name">Retrieve filesets with a name matching the provided name. The search is performed as a case-insensitive infix search.</param>
		/// <param name="host_name">Retrieve filesets with a host name matching the provided name. The search is performed as a case-insensitive infix search.</param>
		/// <param name="sort_by">Specifies a comma-separated list of fileset attributes to use in sorting the fileset summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.
		///
		///Valid attributes are: **_name_**, **_hostName_**, **_templateType_**, **_slaName_**, **_includes_**, **_excludes_**, and **_exceptions_**. Requires **_sort_order_**.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Summary information for filesets.</returns>
		public async Task<FilesetSummaryListResponse> FilesetGetByPrimary_cluster_idAndHost_idAndShare_idAndIs_relicAndEffective_sla_domain_idAndTemplate_idAndLimitAndOffsetAndNameAndHost_nameAndSort_byAndSort_orderAsync(string primary_cluster_id, string host_id, string share_id, bool is_relic, string effective_sla_domain_id, string template_id, int limit, int offset, string name, string host_name, FilesetGetByPrimary_cluster_idAndHost_idAndShare_idAndIs_relicAndEffective_sla_domain_idAndTemplate_idAndLimitAndOffsetAndNameAndHost_nameAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&host_id=" + (host_id==null? "" : System.Uri.EscapeDataString(host_id))+"&share_id=" + (share_id==null? "" : System.Uri.EscapeDataString(share_id))+"&is_relic="+is_relic+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&template_id=" + (template_id==null? "" : System.Uri.EscapeDataString(template_id))+"&limit="+limit+"&offset="+offset+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&host_name=" + (host_name==null? "" : System.Uri.EscapeDataString(host_name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FilesetSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create one fileset for a host
		/// Create a fileset for a network host. A fileset is a fileset template applied to a host.
		/// FilesetPost fileset
		/// </summary>
		/// <param name="requestBody">Specify a template ID and either a host ID or a share ID. When a share ID is provided, the host ID is derived from the host share. Also specify whether or not this backup is a direct archive backup.</param>
		public async Task FilesetPostAsync(FilesetCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get details about an async request
		/// Get details about a fileset related async request.
		/// FilesetRequest_idGet fileset/request/{id}
		/// </summary>
		/// <param name="id">ID of the request.</param>
		/// <returns>Status for the async request.</returns>
		public async Task<AsyncRequestStatus> FilesetRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a fileset snapshot
		/// Delete a fileset snapshot. A snapshot is deleted only if it is an on-demand snapshot, a snapshot of an unprotected fileset or a local snapshot that was downloaded from an archive location.
		/// FilesetSnapshot_idDeleteByLocation fileset/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="location">Snapshot location to delete. Use **_local_** to delete all local snapshots and **_all_** to delete the snapshot in all locations.</param>
		public async Task FilesetSnapshot_idDeleteByLocationAsync(string id, FilesetSnapshot_idDeleteByLocationLocation location, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&location=" + location;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information for a fileset snapshot
		/// Retrieve summary information for a fileset snapshot by specifying the snapshot ID.
		/// FilesetSnapshot_idGetByVerbose fileset/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="verbose">Whether or not to fetch verbose fileset snapshot information. The performance of this endpoint will decrease if set to true.</param>
		/// <returns>Detailed information for the specified fileset snapshot.</returns>
		public async Task<FilesetSnapshotDetail> FilesetSnapshot_idGetByVerboseAsync(string id, bool verbose, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&verbose="+verbose;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FilesetSnapshotDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all files and directories in a given path
		/// Lists all files and directories in a given path.
		/// FilesetSnapshot_idBrowseGetByPathAndOffsetAndLimit fileset/snapshot/{id}/browse
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="path">The absolute path of the starting point for the directory listing.</param>
		/// <param name="offset">Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries.</param>
		/// <param name="limit">Maximum number of entries in the response.</param>
		/// <returns>List of files and directories at the specified path.</returns>
		public async Task<BrowseResponseListResponse> FilesetSnapshot_idBrowseGetByPathAndOffsetAndLimitAsync(string id, string path, int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/browse&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BrowseResponseListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a download fileset snapshot from archival request
		/// Create a download fileset snapshot from archival request.
		/// FilesetSnapshot_idDownloadPost fileset/snapshot/{id}/download
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		public async Task FilesetSnapshot_idDownloadPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a file download job from a fileset backup
		/// Initiate a job to download a file from a backup of a fileset. Returns a job instance ID.
		/// An email notification will be sent out when the download is ready. When the download is ready, the file can be downloaded from the corresponding event which includes the job instance ID as the value of **jobInstanceId**.
		/// FilesetSnapshot_idDownload_filePost fileset/snapshot/{id}/download_file
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="requestBody">Configuration for a download job.</param>
		public async Task FilesetSnapshot_idDownload_filePostAsync(string id, FilesetDownloadFileJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download_file";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create export job
		/// Initiate a job to copy a file or folder from a fileset backup to a destination host other than the source host. Returns the job instance ID.
		/// FilesetSnapshot_idExport_filePost fileset/snapshot/{id}/export_file
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="requestBody">Configuration for job to export a file or folder from a fileset backup.</param>
		public async Task FilesetSnapshot_idExport_filePostAsync(string id, FilesetExportFileJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/export_file";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create restore job
		/// Initiate a job to copy a file or folder from a fileset backup to the source host. Returns the job instance ID.
		/// FilesetSnapshot_idRestore_filePost fileset/snapshot/{id}/restore_file
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="requestBody">Configuration for job to restore a file or folder from a fileset backup.</param>
		public async Task FilesetSnapshot_idRestore_filePostAsync(string id, FilesetRestoreFileJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/restore_file";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a fileset
		/// Delete a fileset by specifying the fileset ID.
		/// Fileset_idDeleteByPreserve_snapshots fileset/{id}
		/// </summary>
		/// <param name="id">Provide a fileset ID to delete.</param>
		/// <param name="preserve_snapshots">Flag to indicate whether to preserve snapshots of the fileset or to delete them. Default behavior is to preserve them.</param>
		public async Task Fileset_idDeleteByPreserve_snapshotsAsync(string id, bool preserve_snapshots, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&preserve_snapshots="+preserve_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information for a single fileset
		/// Retrieve summary information for a fileset by specifying the fileset ID.
		/// Fileset_idGet fileset/{id}
		/// </summary>
		/// <param name="id">Specify the fileset ID.</param>
		/// <returns>Detailed information for the specified fileset.</returns>
		public async Task<FilesetDetail> Fileset_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FilesetDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Fileset
		/// Update a Fileset with the specified properties.
		/// Fileset_idPatch fileset/{id}
		/// </summary>
		/// <param name="id">ID of the Fileset. to update.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Returned if the update was successful.</returns>
		public async Task<FilesetDetail> Fileset_idPatchAsync(string id, FilesetUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FilesetDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get missed snapshots for a fileset
		/// Retrieve summary information about all missed snapshots for a fileset.
		/// Fileset_idMissed_snapshotGet fileset/{id}/missed_snapshot
		/// </summary>
		/// <param name="id">ID of the fileset.</param>
		/// <returns>Summary information about missed snapshots for the specified fileset.</returns>
		public async Task<MissedSnapshotListResponse> Fileset_idMissed_snapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/missed_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MissedSnapshotListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for a file within the fileset
		/// Search for a file within the fileset. Search via full path prefix or filename prefix.
		/// Fileset_idSearchGetByPathAndLimitAndCursor fileset/{id}/search
		/// </summary>
		/// <param name="id">Fileset ID to search.</param>
		/// <param name="path">The path query. Either path prefix or filename prefix.</param>
		/// <param name="limit">Maximum number of entries in the response.</param>
		/// <param name="cursor">Pagination cursor returned by the previous request.</param>
		/// <returns>Search results.</returns>
		public async Task<SearchResponseListResponse> Fileset_idSearchGetByPathAndLimitAndCursorAsync(string id, string path, int limit, string cursor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/search&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&limit="+limit+"&cursor=" + (cursor==null? "" : System.Uri.EscapeDataString(cursor));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchResponseListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all snapshots of a fileset
		/// Delete all snapshots that were created based on a fileset by providing the fileset ID.
		/// Requires an unprotected fileset. Remove the fileset from all SLA Domains.
		/// Fileset_idSnapshotDelete fileset/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the fileset.</param>
		public async Task Fileset_idSnapshotDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiate an on-demand backup for a fileset
		/// Create an on-demand backup request for the given fileset.
		/// Fileset_idSnapshotPost fileset/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the Fileset.</param>
		/// <param name="requestBody">Configuration for the on-demand backup.</param>
		public async Task Fileset_idSnapshotPostAsync(string id, BaseOnDemandSnapshotConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for all fileset templates
		/// Retrieve summary information for all fileset templates, including: ID and name of the fileset template, fileset template creation timestamp, array of the included filepaths, array of the excluded filepaths.
		/// Fileset_templateGetByPrimary_cluster_idAndOperating_system_typeAndShare_typeAndNameAndSort_byAndSort_order fileset_template
		/// </summary>
		/// <param name="primary_cluster_id">Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.
		///Use **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session.</param>
		/// <param name="operating_system_type">Filter the summary information based on the operating system type of the fileset. Accepted values: 'Windows', 'UnixLike', 'ANY', 'NONE'.
		///Use **_NONE_** to only return information for fileset templates that do not have operating system type set.
		///Use **_ANY_** to only return information for fileset templates that have operating system type set.</param>
		/// <param name="share_type">Filter the summary information based on the share type where the fileset is assigned to. Accepted values: 'NFS', 'SMB', 'ANY', 'NONE'.
		///Use **_NONE_** to only return information for fileset templates that do not have share type set.
		///Use **_ANY_** to only return information for fileset templates that have share type set.</param>
		/// <param name="name">Retrieve fileset templates with a name matching the provided name. The search is performed as a case-insensitive infix search.</param>
		/// <param name="sort_by">Specifies a comma-separated list of fileset attributes to use in sorting the fileset summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.
		///
		///Valid attributes are: **_name_**, **_includes_**, **_excludes_**, **_exceptions_**, **_hostCount_**, **_shareType_**. Default sort_order is ascending.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Summary information for all fileset templates.</returns>
		public async Task<FilesetTemplateDetailListResponse> Fileset_templateGetByPrimary_cluster_idAndOperating_system_typeAndShare_typeAndNameAndSort_byAndSort_orderAsync(string primary_cluster_id, Fileset_templateGetByPrimary_cluster_idAndOperating_system_typeAndShare_typeAndNameAndSort_byAndSort_orderOperating_system_type operating_system_type, Fileset_templateGetByPrimary_cluster_idAndOperating_system_typeAndShare_typeAndNameAndSort_byAndSort_orderShare_type share_type, string name, Fileset_templateGetByPrimary_cluster_idAndOperating_system_typeAndShare_typeAndNameAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset_template?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&operating_system_type=" + operating_system_type+"&share_type=" + share_type+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FilesetTemplateDetailListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a fileset template
		/// Create a fileset template. The template is applied to the host.  Each template is a set of paths on the host.
		/// 
		/// A template uses full paths and wildcards to define the objects to include, exclude, and exempt from exclusion.
		/// 
		/// The **_exceptions_** value specifies paths that should not be excluded from the fileset by the **_exclude_** value.
		/// 
		/// Specify an array of full path descriptions for each property **_include_**, **_exclude_**, and **_exceptions_**.
		/// 
		/// Acceptable wildcard characters are.
		/// + **_\*_** Single asterisk matches zero or more characters up to a path deliminator.
		/// + **_\*\*_** Double asterisk matches zero or more characters.
		/// 
		/// The following rules apply to path descriptions.
		/// + Accepts UTF-8 characters.
		/// + Case sensitive.
		/// + Forward slash character **_/_** is the path deliminator.
		/// + Symbolic links must point to a subset of a non symbolic link path.
		/// + Paths that do not start with **_/_** are modified to start with **_\*\*/_**.
		/// + Paths that do not end with **_\*_** are modified to end with **_/\*\*_**.
		/// Fileset_templatePost fileset_template
		/// </summary>
		/// <param name="requestBody">Provide an object with the fileset template definition.</param>
		public async Task Fileset_templatePostAsync(FilesetTemplateCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset_template";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a fileset template
		/// Deletes the specfied fileset template. All associated filesets are deleted.
		/// Fileset_template_idDeleteByPreserve_snapshots fileset_template/{id}
		/// </summary>
		/// <param name="id">ID of the fileset template to remove.</param>
		/// <param name="preserve_snapshots">Flag to indicate whether to convert snapshots of all filesets of this template to relics or to delete them.  Default is true.</param>
		public async Task Fileset_template_idDeleteByPreserve_snapshotsAsync(string id, bool preserve_snapshots, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset_template/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&preserve_snapshots="+preserve_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information for a fileset template
		/// Retrieve summary information for a specified fileset template.
		/// Fileset_template_idGet fileset_template/{id}
		/// </summary>
		/// <param name="id">The ID of the fileset template.</param>
		/// <returns>Summary information for the specified fileset template.</returns>
		public async Task<FilesetTemplateDetail> Fileset_template_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset_template/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FilesetTemplateDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify a fileset template
		/// Modify the values of specified fileset template.
		/// Fileset_template_idPatch fileset_template/{id}
		/// </summary>
		/// <param name="id">ID of the fileset template to update.</param>
		/// <param name="requestBody">Provide an object with the fileset template definition.</param>
		/// <returns>Detailed information for modified fileset template.</returns>
		public async Task<FilesetTemplateDetail> Fileset_template_idPatchAsync(string id, FilesetTemplatePatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "fileset_template/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FilesetTemplateDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for all HDFS directories
		/// Retrieve summary information for each HDFS directory. Optionally, filter the retrieved information.
		/// HdfsGetByPrimary_cluster_idAndHost_idAndIs_relicAndEffective_sla_domain_idAndTemplate_idAndLimitAndOffsetAndNameAndHost_nameAndSort_byAndSort_order hdfs
		/// </summary>
		/// <param name="primary_cluster_id">Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.
		///Use **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session.</param>
		/// <param name="host_id">Filter the summary information based on the ID of the host referenced by the HDFS directory (name node).</param>
		/// <param name="is_relic">Filter the summary information based on the relic status of the HDFS directory. When this parameter is not set, the returned HDFS directory summary information is not filtered by relic status.</param>
		/// <param name="effective_sla_domain_id">Filter the summary information based on the ID of the effective SLA Domain inherited by a HDFS directory.
		///Use **_UNPROTECTED_** to only return information for HDFS directories that do not have an effective SLA Domain.
		///Use **_PROTECTED_** to only return information for HDFS directories that have an effective SLA Domain.</param>
		/// <param name="template_id">Filter the summary information based on the ID of a HDFS directory template.
		///Use **_NONE_** to only return information for HDFS directories that were not created from a HDFS directory template.
		///Use **_ANY_** to only return information for HDFS directories that were created from a HDFS directory template.</param>
		/// <param name="limit">Limit the summary information to a specified maximum number of HDFS directories.
		///Optionally, use with **_offset_** to start the count at a specified point.
		///Optionally, use with **_sort_by_** to perform sort on given attributes. Include **_sort_order_** to determine the ascending or descending direction of sort.</param>
		/// <param name="offset">Starting position in the list of HDFS directory entries contained in the response. The summary information includes the specified numbered entry and all higher numbered entries. Use with **_limit_** to retrieve the summary information as a collection of grouped entries for paging.</param>
		/// <param name="name">Retrieve HDFS directories with a name matching the provided name. The search is performed as a case-insensitive infix search.</param>
		/// <param name="host_name">Retrieve HDFS directories with a host name (name node) matching the provided name. The search is performed as a case-insensitive infix search.</param>
		/// <param name="sort_by">Specifies a comma-separated list of HDFS directory attributes to use in sorting the HDFS directory summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.
		///Valid attributes are: **_name_**, **_hostName_**, **_templateType_**, **_slaName_**, **_includes_**, **_excludes_**, and **_exceptions_**. Requires **_sort_order_**.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Summary information for HDFS directories.</returns>
		public async Task<HdfsSummaryListResponse> HdfsGetByPrimary_cluster_idAndHost_idAndIs_relicAndEffective_sla_domain_idAndTemplate_idAndLimitAndOffsetAndNameAndHost_nameAndSort_byAndSort_orderAsync(string primary_cluster_id, string host_id, bool is_relic, string effective_sla_domain_id, string template_id, int limit, int offset, string name, string host_name, FilesetGetByPrimary_cluster_idAndHost_idAndShare_idAndIs_relicAndEffective_sla_domain_idAndTemplate_idAndLimitAndOffsetAndNameAndHost_nameAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&host_id=" + (host_id==null? "" : System.Uri.EscapeDataString(host_id))+"&is_relic="+is_relic+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&template_id=" + (template_id==null? "" : System.Uri.EscapeDataString(template_id))+"&limit="+limit+"&offset="+offset+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&host_name=" + (host_name==null? "" : System.Uri.EscapeDataString(host_name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HdfsSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create one HDFS directory for a host
		/// Create a HDFS directory for a network host. A HDFS directory is a HDFS directory template applied to a host.
		/// HdfsPost hdfs
		/// </summary>
		/// <param name="requestBody">Specify a template ID and a host ID.</param>
		public async Task HdfsPostAsync(HdfsCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get details about an asynchronous request
		/// Get details about a hdfs related asynchronous request.
		/// HdfsRequest_idGet hdfs/request/{id}
		/// </summary>
		/// <param name="id">ID of the request.</param>
		/// <returns>Status for the asynchronous request.</returns>
		public async Task<AsyncRequestStatus> HdfsRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a HDFS directory snapshot
		/// Delete a HDFS directory snapshot. A snapshot is deleted only if it is an on-demand snapshot, or a snapshot of an unprotected HDFS directory.
		/// HdfsSnapshot_idDelete hdfs/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		public async Task HdfsSnapshot_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information for a HDFS directory snapshot
		/// Retrieve summary information for a HDFS directory snapshot by specifying the snapshot ID.
		/// HdfsSnapshot_idGet hdfs/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <returns>Detailed information for the specified HDFS directory snapshot.</returns>
		public async Task<HdfsSnapshotDetail> HdfsSnapshot_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HdfsSnapshotDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all files and directories in a given path
		/// Lists all files and directories in a given path.
		/// HdfsSnapshot_idBrowseGetByPathAndOffsetAndLimit hdfs/snapshot/{id}/browse
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="path">The absolute path of the starting point for the directory listing.</param>
		/// <param name="offset">Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries.</param>
		/// <param name="limit">Maximum number of entries in the response.</param>
		/// <returns>List of files and directories at the specified path.</returns>
		public async Task<BrowseResponseListResponse> HdfsSnapshot_idBrowseGetByPathAndOffsetAndLimitAsync(string id, string path, int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/browse&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BrowseResponseListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create export job
		/// Initiate a job to copy a file or folder from a hdfs backup to a destination host other than the source host. Returns the job instance ID.
		/// HdfsSnapshot_idExport_filePost hdfs/snapshot/{id}/export_file
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="requestBody">Configuration for job to export a file or folder from a hdfs backup.</param>
		public async Task HdfsSnapshot_idExport_filePostAsync(string id, HdfsExportFileJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/export_file";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create restore job
		/// Initiate a job to copy a file or folder from a HDFS directory backup to the source host. Returns the job instance ID.
		/// HdfsSnapshot_idRestore_filePost hdfs/snapshot/{id}/restore_file
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="requestBody">Configuration for job to restore a file or folder from a HDFS directory backup.</param>
		public async Task HdfsSnapshot_idRestore_filePostAsync(string id, HdfsRestoreFileJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/restore_file";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a HDFS directory
		/// Delete a HDFS directory by specifying the HDFS directory ID.
		/// Hdfs_idDeleteByPreserve_snapshots hdfs/{id}
		/// </summary>
		/// <param name="id">Provide a HDFS directory ID to delete.</param>
		/// <param name="preserve_snapshots">A flag that indicates whether the snapshots of the HDFS directory are preserved or deleted. By default, snapshots are preserved.</param>
		public async Task Hdfs_idDeleteByPreserve_snapshotsAsync(string id, bool preserve_snapshots, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&preserve_snapshots="+preserve_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information for a single HDFS directory
		/// Retrieve summary information for a HDFS directory by specifying the HDFS directory ID.
		/// Hdfs_idGet hdfs/{id}
		/// </summary>
		/// <param name="id">Specify the HDFS directory ID.</param>
		/// <returns>Detailed information for the specified HDFS directory.</returns>
		public async Task<HdfsDetail> Hdfs_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HdfsDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a HDFS directory
		/// Update a HDFS directory with the specified properties.
		/// Hdfs_idPatch hdfs/{id}
		/// </summary>
		/// <param name="id">ID of the HDFS directory to update.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Returned if the update was successful.</returns>
		public async Task<HdfsDetail> Hdfs_idPatchAsync(string id, HdfsUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HdfsDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get missed snapshots for a HDFS directory
		/// Retrieve summary information about all missed snapshots for a HDFS directory.
		/// Hdfs_idMissed_snapshotGet hdfs/{id}/missed_snapshot
		/// </summary>
		/// <param name="id">ID of the HDFS directory.</param>
		/// <returns>Summary information about missed snapshots for the specified HDFS directory.</returns>
		public async Task<MissedSnapshotListResponse> Hdfs_idMissed_snapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/missed_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MissedSnapshotListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for a file within the HDFS directory
		/// Search for a file within the HDFS directory. Search using full path prefix or filename prefix.
		/// Hdfs_idSearchGetByPathAndLimitAndCursor hdfs/{id}/search
		/// </summary>
		/// <param name="id">HDFS directory ID to search.</param>
		/// <param name="path">The path query. The query can be a path refix or a filename prefix.</param>
		/// <param name="limit">Maximum number of entries in the response.</param>
		/// <param name="cursor">Pagination cursor returned by the previous request.</param>
		/// <returns>Search results.</returns>
		public async Task<SearchResponseListResponse> Hdfs_idSearchGetByPathAndLimitAndCursorAsync(string id, string path, int limit, string cursor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/search&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&limit="+limit+"&cursor=" + (cursor==null? "" : System.Uri.EscapeDataString(cursor));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchResponseListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all snapshots of a HDFS directory
		/// Delete all snapshots that were created based on a hdfs by providing the HDFS directory ID.
		/// Requires an unprotected HDFS directory. Remove the HDFS directory from all SLA Domains.
		/// Hdfs_idSnapshotDelete hdfs/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the HDFS directory.</param>
		public async Task Hdfs_idSnapshotDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiate an on-demand backup for a HDFS directory
		/// Create on-demand backup request for HDFS directory.
		/// Hdfs_idSnapshotPost hdfs/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the HDFS directory.</param>
		/// <param name="requestBody">Configuration for the on-demand backup.</param>
		public async Task Hdfs_idSnapshotPostAsync(string id, BaseOnDemandSnapshotConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for all HDFS directory templates
		/// Retrieve summary information for all HDFS directory templates, including: ID and name of the HDFS directory template, HDFS directory template creation timestamp, array of the included filepaths, array of the excluded filepaths.
		/// Hdfs_templateGetByPrimary_cluster_idAndNameAndSort_byAndSort_order hdfs_template
		/// </summary>
		/// <param name="primary_cluster_id">Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.
		///Use **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session.</param>
		/// <param name="name">Retrieve HDFS directory templates with a name matching the provided name. The search is performed as a case-insensitive infix search.</param>
		/// <param name="sort_by">Specifies a comma-separated list of HDFS directory attributes to use in sorting the HDFS directory summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.
		///Valid attributes are: **_name_**, **_includes_**, **_excludes_**, **_exceptions_**, **_hostCount_**. Default sort_order is ascending.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Summary information for all HDFS directory templates.</returns>
		public async Task<HdfsTemplateDetailListResponse> Hdfs_templateGetByPrimary_cluster_idAndNameAndSort_byAndSort_orderAsync(string primary_cluster_id, string name, Hdfs_templateGetByPrimary_cluster_idAndNameAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs_template?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HdfsTemplateDetailListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a HDFS directory template
		/// Create a HDFS directory template. The template is applied to the host.  Each template is a set of paths on the host.
		/// A template uses full paths and wildcards to define the objects to include, exclude, and exempt from exclusion.
		/// The **_exceptions_** value specifies paths that should not be excluded from the HDFS directory by the **_exclude_** value.
		/// Specify an array of full path descriptions for each property **_include_**, **_exclude_**, and **_exceptions_**.
		/// Acceptable wildcard characters are.
		/// + **_\*_** Single asterisk matches zero or more characters up to a path deliminator.
		/// + **_\*\*_** Double asterisk matches zero or more characters.
		/// The following rules apply to path descriptions.
		/// + Accepts UTF-8 characters.
		/// + Case sensitive.
		/// + Forward slash character **_/_** is the path deliminator.
		/// + Symbolic links must point to a subset of a non symbolic link path.
		/// + Paths that do not start with **_/_** are modified to start with **_\*\*/_**.
		/// + Paths that do not end with **_\*_** are modified to end with **_/\*\*_**.
		/// Hdfs_templatePost hdfs_template
		/// </summary>
		/// <param name="requestBody">Provide an object with the HDFS directory template definition.</param>
		public async Task Hdfs_templatePostAsync(HdfsTemplateCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs_template";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a HDFS directory template
		/// Deletes the specfied HDFS directory template. All associated HDFS directories are deleted.
		/// Hdfs_template_idDeleteByPreserve_snapshots hdfs_template/{id}
		/// </summary>
		/// <param name="id">ID of the HDFS directory template to remove.</param>
		/// <param name="preserve_snapshots">A flag that indicates whether the snapshots of the HDFS directories of this template are converted to relics or deleted. By default, snapshots are converted. Set this flag to 'false' to delete the snapshots.</param>
		public async Task Hdfs_template_idDeleteByPreserve_snapshotsAsync(string id, bool preserve_snapshots, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs_template/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&preserve_snapshots="+preserve_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information for a HDFS directory template
		/// Retrieve summary information for a specified HDFS directory template.
		/// Hdfs_template_idGet hdfs_template/{id}
		/// </summary>
		/// <param name="id">The ID of the HDFS directory template.</param>
		/// <returns>Summary information for the specified HDFS directory template.</returns>
		public async Task<HdfsTemplateDetail> Hdfs_template_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs_template/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HdfsTemplateDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify a HDFS directory template
		/// Modify the values of specified HDFS directory template.
		/// Hdfs_template_idPatch hdfs_template/{id}
		/// </summary>
		/// <param name="id">ID of the HDFS directory template to update.</param>
		/// <param name="requestBody">Provide an object with the HDFS directory template definition.</param>
		/// <returns>Detailed information for modified HDFS directory template.</returns>
		public async Task<HdfsTemplateDetail> Hdfs_template_idPatchAsync(string id, HdfsTemplatePatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hdfs_template/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HdfsTemplateDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get details of health monitor policies
		/// Retrieves the details of all the health monitor policies when policy IDs are not specified in the query parameter. If the request includes a list of policy IDs in the query parameter, the response will include the details of the specified policies.
		/// Health_monitorPoliciesGetByPolicy_ids health_monitor/policies
		/// </summary>
		/// <param name="policy_ids">Optional list of policy IDs.</param>
		/// <returns>List of health monitor policies.</returns>
		public async Task<HealthMonitorPolicy[]> Health_monitorPoliciesGetByPolicy_idsAsync(string[] policy_ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health_monitor/policies?"+string.Join("&", policy_ids.Select(z => $"policy_ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthMonitorPolicy[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the status of health monitor policy enforcement
		/// Retrieves the status of the policy enforcement for a list of nodes if specified. If nodes are not specified, the response includes the policy enforcement status for all the nodes on the Rubrik cluster.
		/// Health_monitorPolicy_statusGetByPolicy_idsAndNode_idsAndHas_detailed_status health_monitor/policy_status
		/// </summary>
		/// <param name="policy_ids">Optional list of policy IDs. If not provided, the response includes the status of all the policies.</param>
		/// <param name="node_ids">Optional list of Node IDs. If not provided, the response includes the status of all the nodes.</param>
		/// <param name="has_detailed_status">Indicates if the policy enforcement status should include expanded result for each policy.</param>
		/// <returns>Enforcement status of policies.</returns>
		public async Task<NodePolicyCheckResult[]> Health_monitorPolicy_statusGetByPolicy_idsAndNode_idsAndHas_detailed_statusAsync(string[] policy_ids, string[] node_ids, bool has_detailed_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health_monitor/policy_status?"+string.Join("&", policy_ids.Select(z => $"policy_ids={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", node_ids.Select(z => $"node_ids={System.Uri.EscapeDataString(z.ToString())}"))+"&has_detailed_status="+has_detailed_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodePolicyCheckResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enforce health monitor policies
		/// Triggers on-demand enforcement of the set of policies specified in the request body. If a list of nodes is provided, policies are run against these nodes, otherwise the policies are run on all active nodes of the Rubrik cluster.
		/// Health_monitorRun_policyPost health_monitor/run_policy
		/// </summary>
		/// <param name="requestBody">The request object.</param>
		/// <returns>Policy enforcement result.</returns>
		public async Task<NodePolicyCheckResult[]> Health_monitorRun_policyPostAsync(RunPolicyArg requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health_monitor/run_policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodePolicyCheckResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve the list of descendant objects with SLA conflicts in bulk
		/// Retrieve the list of descendant objects with an explicitly configured SLA domain, or inherit an SLA domain from a different parent for each managed ID.
		/// HierarchyBulk_sla_conflictsPost hierarchy/bulk_sla_conflicts
		/// </summary>
		/// <param name="requestBody">List of hierarchy object IDs.</param>
		/// <returns>List of SLA domain conflict summaries for the specified managed IDs.
		///</returns>
		public async Task<BulkSlaConflictsSummary> HierarchyBulk_sla_conflictsPostAsync(HierarchyObjectIds requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hierarchy/bulk_sla_conflicts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BulkSlaConflictsSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for hosts
		/// Retrieve summary information for all hosts that are registered with a Rubrik cluster.
		/// HostGetByOperating_system_typeAndOperating_systemAndPrimary_cluster_idAndNameAndHostnameAndSort_byAndSort_orderAndSnappable_status host
		/// </summary>
		/// <param name="operating_system_type">Filter the summary information based on the operating system type. Accepted values are 'Windows', 'UnixLike', 'ANY', 'NONE'.
		///Use **_NONE_** to only return information for hosts templates that do not have operating system type set.
		///Use **_ANY_** to only return information for hosts that have operating system type set.</param>
		/// <param name="operating_system">Filter the summary information based on the operating system.
		///Use **_AIX_**, **_Linux_** or **_Solaris_** to restrict the returned information to hosts with operating systems within the specified operating system family.
		///Use a specific operating system release version to restrict the returned information to hosts with operating systems that match the specified version.</param>
		/// <param name="primary_cluster_id">Filters the summary information based on the Rubrik cluster specified by the value of primary_cluster_id. Use 'local' for the Rubrik cluster that is hosting the current REST API session.</param>
		/// <param name="name">Retrieve hosts with a host name matching the provided name. The search type is infix.</param>
		/// <param name="hostname">(Deprecated) Retrieve hosts with a host name matching the provided name. The search type is infix.</param>
		/// <param name="sort_by">Specifies the host attribute to use in sorting the host summary information. Performs an ASCII sort of the summary information using the specified attribute, in the order specified.
		///Valid attributes are 'hostname'.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <param name="snappable_status">Determines whether to fetch hosts with additional privilege checks.</param>
		/// <returns>Summary information for registered hosts.</returns>
		public async Task<HostSummaryListResponse> HostGetByOperating_system_typeAndOperating_systemAndPrimary_cluster_idAndNameAndHostnameAndSort_byAndSort_orderAndSnappable_statusAsync(HostOperatingSystemType operating_system_type, string operating_system, string primary_cluster_id, string name, string hostname, HostGetByOperating_system_typeAndOperating_systemAndPrimary_cluster_idAndNameAndHostnameAndSort_byAndSort_orderAndSnappable_statusSort_by sort_by, SortOrder sort_order, SnappablePrivilegeStatus snappable_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host?operating_system_type=" + operating_system_type+"&operating_system=" + (operating_system==null? "" : System.Uri.EscapeDataString(operating_system))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&hostname=" + (hostname==null? "" : System.Uri.EscapeDataString(hostname))+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Register a host
		/// Register a host.
		/// HostPost host
		/// </summary>
		/// <param name="requestBody">Registration definition for a host.</param>
		public async Task HostPostAsync(HostRegister requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Register a host
		/// Register a host and perform discovery for databases and Microsoft SQL Server instances. When called, this API returns a success message, but completes the host registration in the background. Monitor the status of the background host discovery with the "status" field in GET API on /hosts. The POST API on /hosts can take longer for discovery, depending on the number of hosts on the system. POST on this API can be used instead to perform the discovery in the background and quickly register the host. Doing this requires that you install RBS for Linux and Windows hosts, similar to regular register using POST on /hosts.
		/// HostBackgroundPost host/background
		/// </summary>
		/// <param name="requestBody">Registration definition for a host.</param>
		public async Task HostBackgroundPostAsync(HostRegister requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/background";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Register hosts
		/// Register multiple hosts and perform discovery for databases and Microsoft SQL Server instances. When called, this API returns a success message, but completes the host registration in the background. Monitor the status of the background host discovery with the "status" field in GET API on /hosts. The POST API on /hosts can take longer for discovery, depending on the number of hosts on the system. POST on this API can be used instead to perform the discovery in the background and quickly register the host. Doing this requires that you install RBS for Linux and Windows hosts, similar to regular register using POST on /hosts.
		/// HostBulk_backgroundPost host/bulk_background
		/// </summary>
		/// <param name="requestBody">Registration definition for each host.</param>
		public async Task HostBulk_backgroundPostAsync(HostRegister[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/bulk_background";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update certificate
		/// Provide an updated certificate for a specified host.
		/// HostCertificate_idPut host/certificate/{id}
		/// </summary>
		/// <param name="id">ID of the host.</param>
		/// <returns>Returns a detailed view of the update host.</returns>
		public async Task<HostDetail> HostCertificate_idPutAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/certificate/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary of a host/share hierarchy object
		/// Retrieve details for the specified object in the host/share hierarchy.
		/// 
		/// HostHierarchy_idGet host/hierarchy/{id}
		/// </summary>
		/// <param name="id">ID of the host hierarchy object.</param>
		/// <returns>Details of the hierarchy object.</returns>
		public async Task<HostHierarchyObjectSummary> HostHierarchy_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostHierarchyObjectSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get immediate descendant objects
		/// Retrieve the list of immediate descendant objects for the specified parent.
		/// HostHierarchy_idChildrenGetByNameAndObject_typeAndEffective_sla_domain_idAndPrimary_cluster_idAndSla_assignmentAndTemplate_idAndVendor_typeAndExport_pointAndOperating_system_typeAndSort_byAndSort_orderAndLimitAndOffset host/hierarchy/{id}/children
		/// </summary>
		/// <param name="id">ID of the parent host hierarchy object. To get top-level nodes, use **root** as the ID.</param>
		/// <param name="name">Search object by object name.</param>
		/// <param name="object_type">Filter by node object type.</param>
		/// <param name="effective_sla_domain_id">Filter by ID of effective SLA domain.</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="sla_assignment">Limit a response to the results that have the specified SLA Domain assignment type.</param>
		/// <param name="template_id">Filter by fileset template ID.</param>
		/// <param name="vendor_type">Filter by NAS vendor.</param>
		/// <param name="export_point">Search object by export point.</param>
		/// <param name="operating_system_type">Filter the summary information based on the operating system type. Accepted values are 'Windows', 'UnixLike', 'ANY', 'NONE'.
		///Use **_NONE_** to only return information for hosts templates that do not have operating system type set.
		///Use **_ANY_** to only return information for hosts that have operating system type set.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Order for sorting the results, either ascending or descending.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Number of matches to ignore from the beginning of the results.</param>
		/// <returns>Summary list of immediate descendant objects.</returns>
		public async Task<HostHierarchyObjectSummaryListResponse> HostHierarchy_idChildrenGetByNameAndObject_typeAndEffective_sla_domain_idAndPrimary_cluster_idAndSla_assignmentAndTemplate_idAndVendor_typeAndExport_pointAndOperating_system_typeAndSort_byAndSort_orderAndLimitAndOffsetAsync(string id, string name, HostObjectType object_type, string effective_sla_domain_id, string primary_cluster_id, SlaAssignment sla_assignment, string template_id, HostShareVendorType vendor_type, string export_point, HostOperatingSystemType operating_system_type, HostHierarchyObjectSortAttribute sort_by, SortOrder sort_order, int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/children&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&object_type=" + object_type+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&sla_assignment=" + sla_assignment+"&template_id=" + (template_id==null? "" : System.Uri.EscapeDataString(template_id))+"&vendor_type=" + vendor_type+"&export_point=" + (export_point==null? "" : System.Uri.EscapeDataString(export_point))+"&operating_system_type=" + operating_system_type+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostHierarchyObjectSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Make this cluster the primary for agents on a set of hosts
		/// Migrate the primary cluster with which the agent is able to perform regular operations (backup, restore etc). This can be done on a specified set of hosts or for all hosts that currently have a specified primary cluster for disaster recovery. Specify exactly one of `ids` or `oldPrimaryClusterUuid`.
		/// HostMake_primaryPost host/make_primary
		/// </summary>
		/// <param name="requestBody">Description of hosts to migrate.</param>
		public async Task HostMake_primaryPostAsync(HostMakePrimaryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/make_primary";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the Rubrik Backup Service details for a host
		/// Get the details of the Rubrik Backup Service (RBS) installed on a specific host. Specify the details of the host to check whether RBS is installed on the host or not. If RBS is installed, the response will include the RBS details.
		/// HostRbsGetByNameAndUsernameAndPasswordAndOperation_timeout host/rbs
		/// </summary>
		/// <param name="name">IP address or hostname of the host.</param>
		/// <param name="username">Name of the user account that has sudo/admin privileges on the RBS host. This is required to install/uninstall/upgrade RBS packages on the RBS host.</param>
		/// <param name="password">Password associated with the username that has access to the host.</param>
		/// <param name="operation_timeout">Number of seconds after which the operation is terminated if it has not completed execution. Default value is 600 seconds.</param>
		/// <returns>Rubrik Backup Service details for the specified host.</returns>
		public async Task<RbsHostSummary> HostRbsGetByNameAndUsernameAndPasswordAndOperation_timeoutAsync(string name, string username, string password, long operation_timeout, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/rbs?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&password=" + (password==null? "" : System.Uri.EscapeDataString(password))+"&operation_timeout="+operation_timeout;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RbsHostSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Install Rubrik Backup Service on a host
		/// Install Rubrik Backup Service on a host.
		/// HostRbsInstallPost host/rbs/install
		/// </summary>
		/// <param name="requestBody">Configuration parameters to install RBS on a host.</param>
		/// <returns>Response for the Rubrik Backup Service installation request.</returns>
		public async Task<RbsHostOperationResponse> HostRbsInstallPostAsync(RbsHostOperationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/rbs/install";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RbsHostOperationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Uninstall Rubrik Backup Service from a host
		/// Uninstall Rubrik Backup Service from a host.
		/// HostRbsUninstallPost host/rbs/uninstall
		/// </summary>
		/// <param name="requestBody">Configuration parameters to uninstall RBS from a host.</param>
		/// <returns>Successfully uninstalled RBS from the host.</returns>
		public async Task<RbsHostOperationResponse> HostRbsUninstallPostAsync(RbsHostOperationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/rbs/uninstall";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RbsHostOperationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Upgrade Rubrik Backup Service on a host
		/// Upgrade Rubrik Backup Service on a host.
		/// HostRbsUpgradePost host/rbs/upgrade
		/// </summary>
		/// <param name="requestBody">Configuration parameters to upgrade RBS on a host.</param>
		/// <returns>Rubrik Backup Service upgrade response.</returns>
		public async Task<RbsHostOperationResponse> HostRbsUpgradePostAsync(RbsHostOperationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/rbs/upgrade";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RbsHostOperationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update network shares
		/// Update the properties of the objects that represent the specified network share.
		/// HostShareBulkPatch host/share/bulk
		/// </summary>
		/// <param name="requestBody">Properties to use for the update of network share objects.</param>
		/// <returns>Returns a detailed view of all updated network share objects.</returns>
		public async Task<HostShareDetail[]> HostShareBulkPatchAsync(HostShareUpdate[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/share/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostShareDetail[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add NAS shares in bulk
		/// Add NAS shares for a NAS host to the Rubrik cluster in bulk. This operation does not validate share credentials. If the default share credentials are incorrect, the share status on shares UI displays as "Wrong credential". Use the PATCH /v1/host/share/bulk endpoint to enter the correct credentials when this status displays.
		/// HostShareBulkPost host/share/bulk
		/// </summary>
		/// <param name="requestBody">The properties used to add the NAS Shares to the Rubrik cluster.</param>
		/// <returns>Returns a detailed view of all added network share objects and status of the job that validates the default credentials added to each object.</returns>
		public async Task<BulkShareAddResponse> HostShareBulkPostAsync(NasSharesToAdd requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/share/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BulkShareAddResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a registered host
		/// Delete host by specifying the host ID.
		/// Host_idDelete host/{id}
		/// </summary>
		/// <param name="id">ID of the host to delete.</param>
		public async Task Host_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary information for a host
		/// Retrieve summary information for a registered host.
		/// Host_idGet host/{id}
		/// </summary>
		/// <param name="id">ID of the registered host.</param>
		/// <returns>Summary information for the specified host.</returns>
		public async Task<HostDetail> Host_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify information for a registered host
		/// Change the FQDN and IPv4 address that is assigned to a host object. Enable or disable pre-transfer data compression. Enable or disable change block tracking (CBT) for backups of SQL Server databases on Windows hosts. Enable or disable volume filter driver (VFD) for volume backups on Windows hosts. Set an Oracle user with sysdba privileges to permit Oracle discovery queries.
		/// Host_idPatch host/{id}
		/// </summary>
		/// <param name="id">ID of the registered host.</param>
		/// <param name="requestBody">Properties of host to update.</param>
		/// <returns>Summary information for the specified host.</returns>
		public async Task<HostDetail> Host_idPatchAsync(string id, HostUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Discover and return all shares on a NAS host
		/// Discover and return all shares on the identified NAS host.
		/// Host_idNas_share_discoverGet host/{id}/nas_share_discover
		/// </summary>
		/// <param name="id">The discoverable NAS host ID.</param>
		/// <returns>The discovered NAS shares.</returns>
		public async Task<DiscoveredNasShare[]> Host_idNas_share_discoverGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/nas_share_discover";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiscoveredNasShare[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Refresh a host
		/// Refresh the properties of a host object when changes on the host are not seen in the Rubrik web UI.
		/// Host_idRefreshPost host/{id}/refresh
		/// </summary>
		/// <param name="id">ID assigned to a host object.</param>
		/// <returns>Refreshed the properties shown for the specified host.</returns>
		public async Task<HostDetail> Host_idRefreshPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/refresh";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for a file within the host
		/// Search for a file within the host. Search via full path prefix or filename prefix.
		/// Host_idSearchGetByPath host/{id}/search
		/// </summary>
		/// <param name="id">ID of the host to search.</param>
		/// <param name="path">The path query. Either path prefix or filename prefix.</param>
		/// <returns>Search results.</returns>
		public async Task<SearchResponseListResponse> Host_idSearchGetByPathAsync(string id, string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/search&path=" + (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchResponseListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of Volume Group volumes
		/// Retrieve summary information for each volume on a specified Volume Group host.
		/// Host_idVolumeGet host/{id}/volume
		/// </summary>
		/// <param name="id">The ID of the host.</param>
		/// <returns>Get volume summary from the host.</returns>
		public async Task<HostVolumeSummaryListResponse> Host_idVolumeGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "host/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/volume";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HostVolumeSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the configuration which has been set for forcing a full snapshot for a Hyper-V Virtual Machine
		/// Retrieve the configuration created to force a full snapshot for a Hyper-V Virtual Machine.
		/// HypervVm_idRequestForce_full_snapshotGet hyperv/vm/{id}/request/force_full_snapshot
		/// </summary>
		/// <param name="id">The ID of the Hyper-V virtual machine.</param>
		/// <returns>Return the configuration created to force a full snapshot on the Hyper-V virtual machine.</returns>
		public async Task<HypervVirtualMachineForceFullResponse> HypervVm_idRequestForce_full_snapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hyperv/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/request/force_full_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HypervVirtualMachineForceFullResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request a full snapshot during next backup job of a Hyper-V virtual machine
		/// Request a full snapshot during the next backup job of a Hyper-V virtual machine.
		/// HypervVm_idRequestForce_full_snapshotPost hyperv/vm/{id}/request/force_full_snapshot
		/// </summary>
		/// <param name="id">ID of the Hyper-V virtual machine.</param>
		/// <param name="requestBody">Configuration created to force a full snapshot on the Hyper-V virtual machine.</param>
		public async Task HypervVm_idRequestForce_full_snapshotPostAsync(string id, HypervVirtualMachineForceFullRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "hyperv/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/request/force_full_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a list of IdP authentication domains
		/// Get a list of IdP authentication domains.
		/// Idp_auth_domainGet idp_auth_domain
		/// </summary>
		/// <returns>Returns the list of IdP authentication domains.</returns>
		public async Task<IdProviderAuthDomainSummaryListResponse> Idp_auth_domainGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "idp_auth_domain";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdProviderAuthDomainSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a new IdP authentication domain
		/// Add a new IdP authentication domain.
		/// Idp_auth_domainPost idp_auth_domain
		/// </summary>
		/// <param name="requestBody">Information for joining an IdP authentication domain.</param>
		public async Task Idp_auth_domainPostAsync(IdProviderAuthDomainInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "idp_auth_domain";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an IdP authentication domain for the given ID
		/// Delete an IdP authentication domain for the given ID.
		/// Idp_auth_domain_idDelete idp_auth_domain/{id}
		/// </summary>
		/// <param name="id">ID of the IdP authentication domain to be deleted.</param>
		public async Task Idp_auth_domain_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "idp_auth_domain/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an IdP authentication domain for the given id
		/// Get an IdP authentication domain for the given id.
		/// Idp_auth_domain_idGet idp_auth_domain/{id}
		/// </summary>
		/// <param name="id">ID of the IdP Authentication Domain to be retrieved.</param>
		/// <returns>Returns a summary of the requested IdP authentication domain.</returns>
		public async Task<IdProviderAuthDomainSummary> Idp_auth_domain_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "idp_auth_domain/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdProviderAuthDomainSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing IdP authentication domain
		/// Update an existing IdP authentication domain.
		/// Idp_auth_domain_idPatch idp_auth_domain/{id}
		/// </summary>
		/// <param name="id">ID of the IdP authentication domain to be updated.</param>
		/// <param name="requestBody">Information for updating an IdP authentication domain.</param>
		/// <returns>Returns a summary of the newly updated IdP authentication domain.</returns>
		public async Task<IdProviderAuthDomainSummary> Idp_auth_domain_idPatchAsync(string id, IdProviderAuthDomainInfoUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "idp_auth_domain/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdProviderAuthDomainSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get job monitoring information
		/// Get the job summary for protection and recovery jobs that are currently running, scheduled to run, or completed in the past 24 hours.
		/// Job_monitoringGetByLimitAndJob_event_statusAndJob_typeAndShould_include_log_related_jobAndIs_first_fullAndObject_typeAndObject_nameAndNode_nameAndEffective_sla_domain_idAndIs_on_demandAndLast_update_timeAndAfter_idAndSort_byAndSort_order job_monitoring
		/// </summary>
		/// <param name="limit">Maximum number of entries to retrieve. The default value is 25. Value needs to be a positive number.</param>
		/// <param name="job_event_status">Filters results by the current event status of the job. The filters should be separated by ','.</param>
		/// <param name="job_type">Filters results by job type.</param>
		/// <param name="should_include_log_related_job">A Boolean that specifies whether or not to include log- related jobs. Default value is 'false'.</param>
		/// <param name="is_first_full">Filter results by first full status.</param>
		/// <param name="object_type">Filters results by a specified object type.</param>
		/// <param name="object_name">Filters results by the provided value for object_name, using infix search.</param>
		/// <param name="node_name">Filter results by node name.</param>
		/// <param name="effective_sla_domain_id">Filters results by the provided sla doimain id.</param>
		/// <param name="is_on_demand">Filters results according to their on-demand status.</param>
		/// <param name="last_update_time">All rows updated at or after this time will be returned.</param>
		/// <param name="after_id">Fetches all rows after given row cursor.</param>
		/// <param name="sort_by">The column by which to sort the entries.</param>
		/// <param name="sort_order">The sorting order.</param>
		/// <returns>Returns job information.</returns>
		public async Task<JobMonitoringResponse> Job_monitoringGetByLimitAndJob_event_statusAndJob_typeAndShould_include_log_related_jobAndIs_first_fullAndObject_typeAndObject_nameAndNode_nameAndEffective_sla_domain_idAndIs_on_demandAndLast_update_timeAndAfter_idAndSort_byAndSort_orderAsync(int limit, string[] job_event_status, JobMonitoringCsvDownloadResponseJobTaskType job_type, bool should_include_log_related_job, bool is_first_full, JobMonitoringCsvDownloadResponseObjectType object_type, string object_name, string node_name, string effective_sla_domain_id, bool is_on_demand, System.DateTimeOffset last_update_time, string after_id, SortColumn sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring?limit="+limit+"&"+string.Join("&", job_event_status.Select(z => $"job_event_status={System.Uri.EscapeDataString(z.ToString())}"))+"&job_type=" + job_type+"&should_include_log_related_job="+should_include_log_related_job+"&is_first_full="+is_first_full+"&object_type=" + object_type+"&object_name=" + (object_name==null? "" : System.Uri.EscapeDataString(object_name))+"&node_name=" + (node_name==null? "" : System.Uri.EscapeDataString(node_name))+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&is_on_demand="+is_on_demand+"&last_update_time=" + last_update_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&after_id=" + (after_id==null? "" : System.Uri.EscapeDataString(after_id))+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<JobMonitoringResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download job monitoring information as a CSV file
		/// Download the job summary for protection and recovery jobs that are currently running, scheduled to run, or completed in the past 24 hours as a CSV file. This is a synchronous operation.
		/// Job_monitoringCsv_download_linkGetByJob_monitoring_stateAndJob_event_statusAndJob_typeAndShould_include_log_related_jobAndObject_typeAndObject_name job_monitoring/csv_download_link
		/// </summary>
		/// <param name="job_monitoring_state">State of the jobs in the CSV.</param>
		/// <param name="job_event_status">Filters results by the current event status of the job.</param>
		/// <param name="job_type">Filters results by job type.</param>
		/// <param name="should_include_log_related_job">A Boolean that specifies whether or not to include log- related jobs. Default value is 'false'.</param>
		/// <param name="object_type">Filters results by a specified object type.</param>
		/// <param name="object_name">Filters results by the provided value for object_name, using infix search.</param>
		/// <returns>Download link of the requested CSV file.</returns>
		public async Task<JobMonitoringCsvDownloadResponse> Job_monitoringCsv_download_linkGetByJob_monitoring_stateAndJob_event_statusAndJob_typeAndShould_include_log_related_jobAndObject_typeAndObject_nameAsync(JobMonitoringCsvDownloadResponseJobMonitoringState job_monitoring_state, JobMonitoringCsvDownloadResponseJobEventStatus job_event_status, JobMonitoringCsvDownloadResponseJobTaskType job_type, bool should_include_log_related_job, JobMonitoringCsvDownloadResponseObjectType object_type, string object_name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring/csv_download_link?job_monitoring_state=" + job_monitoring_state+"&job_event_status=" + job_event_status+"&job_type=" + job_type+"&should_include_log_related_job="+should_include_log_related_job+"&object_type=" + object_type+"&object_name=" + (object_name==null? "" : System.Uri.EscapeDataString(object_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<JobMonitoringCsvDownloadResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all email subscriptions for the monitoring page
		/// Return all unarchived email subscriptions for monitoring page in a list of summaries sorted by creation time (earliest created first). Each summary contains information for each subscription -- Time attributes - when to send the email -- Email addresses - who to send the email -- Attachments - what attachments should the email include -- Job states - which job states to include in the email (Failure, Scheduled, Success, Active, Canceled). -- Id - the tring that identifies the subscription -- Status - the status of the subscription (Active, Suspended, or Unknown) -- Owner - information about the owner of the subscription -- user id - unique id used to identify the owner -- user name - human-readable name of user the time schedule to send the subscription.
		/// Job_monitoringSubscriptionGet job_monitoring/subscription
		/// </summary>
		/// <returns>Summary of email subscriptions for the monitoring page.</returns>
		public async Task<MonitoringSubscriptionSummary[]> Job_monitoringSubscriptionGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring/subscription";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MonitoringSubscriptionSummary[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an email subscription to the job monitoring page
		/// Creates an email subscription to the job monitoring page, which provides information on jobs based on their type (active, in progress, canceled, scheduled, or succeeded). Users can choose which job states to include in the subscription. The email summarizes the job counts by type in the body, and includes the option to include CSV attachments for every job state selected.
		/// Job_monitoringSubscriptionPost job_monitoring/subscription
		/// </summary>
		/// <param name="requestBody">All information required to create a job-monitoring email subscription.</param>
		/// <returns>Summary of the email subscription.</returns>
		public async Task<MonitoringSubscriptionSummary> Job_monitoringSubscriptionPostAsync(MonitoringEmailSubscriptionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring/subscription";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MonitoringSubscriptionSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a monitoring page email subscription
		/// Deletes the specified monitoring page email subscription.
		/// Job_monitoringSubscription_subscription_idDelete job_monitoring/subscription/{subscription_id}
		/// </summary>
		/// <param name="subscription_id">ID of the monitoring subscription to delete.</param>
		public async Task Job_monitoringSubscription_subscription_idDeleteAsync(string subscription_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring/subscription/"+ (subscription_id==null? "" : System.Uri.EscapeDataString(subscription_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific monitoring email subscription by id
		/// Returns a summary of the provided monitoring subscription.
		/// Job_monitoringSubscription_subscription_idGet job_monitoring/subscription/{subscription_id}
		/// </summary>
		/// <param name="subscription_id">ID of the monitoring subscription to acquire.</param>
		/// <returns>Summary of the email subscription.</returns>
		public async Task<MonitoringSubscriptionSummary> Job_monitoringSubscription_subscription_idGetAsync(string subscription_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring/subscription/"+ (subscription_id==null? "" : System.Uri.EscapeDataString(subscription_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MonitoringSubscriptionSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a monitoring email subscription
		/// Updates the monitoring email subscription with the subscription ID provided.
		/// Job_monitoringSubscription_subscription_idPatch job_monitoring/subscription/{subscription_id}
		/// </summary>
		/// <param name="subscription_id">ID of the monitoring subscription.</param>
		/// <param name="requestBody">Information required to update a monitoring subscription.</param>
		/// <returns>Summary of the email subscription.</returns>
		public async Task<MonitoringSubscriptionSummary> Job_monitoringSubscription_subscription_idPatchAsync(string subscription_id, MonitoringEmailSubscriptionUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring/subscription/"+ (subscription_id==null? "" : System.Uri.EscapeDataString(subscription_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MonitoringSubscriptionSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get job monitoring summary information separated by job state
		/// Get job summary separated by job state for all running jobs, jobs that have been scheduled and jobs that are complete, for protection and recovery jobs in the past 24 hours.
		/// Job_monitoringSummary_by_job_stateGetByJob_types job_monitoring/summary_by_job_state
		/// </summary>
		/// <param name="job_types">Filter by a comma separated list of job types.</param>
		/// <returns>Returns information about the job counts for the events that match the query parameters.</returns>
		public async Task<JobMonitoringSummaryByState> Job_monitoringSummary_by_job_stateGetByJob_typesAsync(string[] job_types, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring/summary_by_job_state?"+string.Join("&", job_types.Select(z => $"job_types={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<JobMonitoringSummaryByState>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get job monitoring summary information separated by job type
		/// Get job summaries for protection and recovery jobs, separated by job type, that have been scheduled, are currently running, or completed in the past 24 hours.
		/// Job_monitoringSummary_by_job_typeGetByJob_monitoring_state job_monitoring/summary_by_job_type
		/// </summary>
		/// <param name="job_monitoring_state">Filter by job state.</param>
		/// <returns>Returns information about the job counts for the events that match the query parameters.</returns>
		public async Task<JobMonitoringSummaryByType> Job_monitoringSummary_by_job_typeGetByJob_monitoring_stateAsync(JobMonitoringCsvDownloadResponseJobMonitoringState job_monitoring_state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "job_monitoring/summary_by_job_type?job_monitoring_state=" + job_monitoring_state;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<JobMonitoringSummaryByType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of LDAP services
		/// Get a list of LDAP services.
		/// Ldap_serviceGet ldap_service
		/// </summary>
		/// <returns>Returns the list of authentication domains.</returns>
		public async Task<LdapServiceSummaryListResponse> Ldap_serviceGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ldap_service";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LdapServiceSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a new authentication domain
		/// Add a new authentication domain.
		/// Ldap_servicePost ldap_service
		/// </summary>
		/// <param name="requestBody">Information for joining an authentication domain.</param>
		public async Task Ldap_servicePostAsync(LdapServiceInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ldap_service";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an authentication domain for the given ID
		/// Delete an authentication domain for the given ID.
		/// Ldap_service_idDelete ldap_service/{id}
		/// </summary>
		/// <param name="id">ID of the authentication domain to be deleted.</param>
		public async Task Ldap_service_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ldap_service/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a LDAP service for the given ID
		/// Get a LDAP service for the given ID.
		/// Ldap_service_idGet ldap_service/{id}
		/// </summary>
		/// <param name="id">ID of the authentication domain to be retrieved.</param>
		/// <returns>Returns a summary of the requested authentication domain.</returns>
		public async Task<LdapServiceSummary> Ldap_service_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ldap_service/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LdapServiceSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing authentication domain
		/// Modify the values of a specified authentication domain object.
		/// Ldap_service_idPatch ldap_service/{id}
		/// </summary>
		/// <param name="id">ID of the authentication domain to be updated.</param>
		/// <param name="requestBody">Information for updating an authentication domain.</param>
		/// <returns>Returns a summary of the newly updated authentication domain.</returns>
		public async Task<LdapServiceSummary> Ldap_service_idPatchAsync(string id, LdapServiceInfoUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ldap_service/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LdapServiceSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Replace the values of an authentication domain
		/// Replace the values of a specified authentication domain object.
		/// Ldap_service_idPut ldap_service/{id}
		/// </summary>
		/// <param name="id">ID of the authentication domain to be updated.</param>
		/// <param name="requestBody">Information for updating an authentication domain.</param>
		/// <returns>Returns a summary of the newly updated authentication domain.</returns>
		public async Task<LdapServiceSummary> Ldap_service_idPutAsync(string id, LdapServiceInfoUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ldap_service/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LdapServiceSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get objects part of Legal Hold
		/// Returns the object details for object with snapshots under legal hold.
		/// Legal_holdObjectGetByObject_idAndLimitAndOffsetAndObject_nameAndObject_typeAndSort_byAndSort_order legal_hold/object
		/// </summary>
		/// <param name="object_id">Limit the list to a particular object.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Specifies a number of initial matches to ignore.</param>
		/// <param name="object_name">Limits the list to objects that match a specified value for the object name.</param>
		/// <param name="object_type">Limits the list to objects that match a specified type.</param>
		/// <param name="sort_by">The attribute used to sort summary information. The optional parameter _sort_order_ specifies ascending or descending sort order.</param>
		/// <param name="sort_order">Specifies ascending or descending sort order. Summary results are sorted in ascending order when this parameter is not specified.</param>
		/// <returns>List of details for objects with snasphots in a legal hold status.</returns>
		public async Task<ObjectHoldSummaryListResponse> Legal_holdObjectGetByObject_idAndLimitAndOffsetAndObject_nameAndObject_typeAndSort_byAndSort_orderAsync(string object_id, int limit, int offset, string object_name, string object_type, LegalHoldObjectSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "legal_hold/object?object_id=" + (object_id==null? "" : System.Uri.EscapeDataString(object_id))+"&limit="+limit+"&offset="+offset+"&object_name=" + (object_name==null? "" : System.Uri.EscapeDataString(object_name))+"&object_type=" + (object_type==null? "" : System.Uri.EscapeDataString(object_type))+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectHoldSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Dissolve a collection of snapshots of specified data source from Legal Hold
		/// Dissolve a collection of snapshots of specified data source from Legal Hold.
		/// Legal_holdObject_idDissolvePost legal_hold/object/{id}/dissolve
		/// </summary>
		/// <param name="id">ID of the data source.</param>
		/// <param name="requestBody">An object that contains the IDs of the snapshots to remove from legal hold status.</param>
		/// <returns>List of snapshots whose legal holds have been successfully dissolved.</returns>
		public async Task<DissolveLegalHoldResponse> Legal_holdObject_idDissolvePostAsync(string id, DissolveLegalHoldDefinition requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "legal_hold/object/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/dissolve";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DissolveLegalHoldResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get snasphots held under legal hold
		/// Get summary for snapshots under legal hold. If object_id is passed, return summary information only for snapshots of the object under legal hold else return summary for all snapshots under legal hold.
		/// Legal_holdSnapshotGetByObject_idAndLimitAndOffsetAndObject_nameAndObject_typeAndBefore_dateAndAfter_dateAndPlaced_on_hold_before_dateAndPlaced_on_hold_after_dateAndSort_byAndSort_orderAndSnapshot_type legal_hold/snapshot
		/// </summary>
		/// <param name="object_id">Limit the list to snapshot for the particular object.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">An integer that specifies a number of initial matches to ignore.</param>
		/// <param name="object_name">Limits the list to objects that match a specified value for the object name.</param>
		/// <param name="object_type">Limits the list to objects that match a specified type.</param>
		/// <param name="before_date">Limits the list to snapshots with holds created before a specified date.</param>
		/// <param name="after_date">Limits the list to snapshots with holds created after a specified date.</param>
		/// <param name="placed_on_hold_before_date">Limits the list to snapshots which were placed on legal hold before a specified date.</param>
		/// <param name="placed_on_hold_after_date">Limits the list to snapshots which were placed on legal hold after a specified date.</param>
		/// <param name="sort_by">The attribute used to sort summary information. The optional parameter **_sort_order_** specifies ascending or descending sort order.</param>
		/// <param name="sort_order">Specifies ascending or descending sort order. Summary results are sorted in ascending order when this parameter is not specified.</param>
		/// <param name="snapshot_type">Specifies the type of snapshots to be returned.</param>
		/// <returns>Summary information for legal holds.</returns>
		public async Task<LegalHoldSummaryListResponse> Legal_holdSnapshotGetByObject_idAndLimitAndOffsetAndObject_nameAndObject_typeAndBefore_dateAndAfter_dateAndPlaced_on_hold_before_dateAndPlaced_on_hold_after_dateAndSort_byAndSort_orderAndSnapshot_typeAsync(string object_id, int limit, int offset, string object_name, string object_type, System.DateTimeOffset before_date, System.DateTimeOffset after_date, System.DateTimeOffset placed_on_hold_before_date, System.DateTimeOffset placed_on_hold_after_date, LegalHoldSnapshotSortAttribute sort_by, SortOrder sort_order, SnapshotType snapshot_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "legal_hold/snapshot?object_id=" + (object_id==null? "" : System.Uri.EscapeDataString(object_id))+"&limit="+limit+"&offset="+offset+"&object_name=" + (object_name==null? "" : System.Uri.EscapeDataString(object_name))+"&object_type=" + (object_type==null? "" : System.Uri.EscapeDataString(object_type))+"&before_date=" + before_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&after_date=" + after_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&placed_on_hold_before_date=" + placed_on_hold_before_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&placed_on_hold_after_date=" + placed_on_hold_after_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&snapshot_type=" + snapshot_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LegalHoldSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Apply a Legal Hold
		/// Places a snapshot on legal hold by specifying the hold requirements.
		/// Legal_holdSnapshotPost legal_hold/snapshot
		/// </summary>
		public async Task Legal_holdSnapshotPostAsync(ApplyLegalHoldDefinition requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "legal_hold/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Generate and download unified view script
		/// Start an asynchronous job to generate and download a script to unify export paths across channels in managed volume export.
		/// Managed_volumeSnapshotExport_idScriptPost managed_volume/snapshot/export/{id}/script
		/// </summary>
		/// <param name="id">ID of snapshot export.</param>
		public async Task Managed_volumeSnapshotExport_idScriptPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed_volume/snapshot/export/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/script";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get RSA server configuration
		/// Get RSA server configuration.
		/// MfaRsaServerGet mfa/rsa/server
		/// </summary>
		/// <returns>Configuration summary of known RSA servers.</returns>
		public async Task<RsaMfaServerDetailListResponse> MfaRsaServerGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mfa/rsa/server";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RsaMfaServerDetailListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Register a new RSA server
		/// Register a new RSA server using specified configuration.
		/// MfaRsaServerPost mfa/rsa/server
		/// </summary>
		/// <param name="requestBody">Configuration of RSA server.</param>
		public async Task MfaRsaServerPostAsync(RsaMfaServerConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mfa/rsa/server";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete RSA server
		/// Delete RSA server configuration.
		/// MfaRsaServer_idDelete mfa/rsa/server/{id}
		/// </summary>
		/// <param name="id">ID of the RSA server.</param>
		public async Task MfaRsaServer_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mfa/rsa/server/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get RSA server configuration
		/// Get RSA server configuration.
		/// MfaRsaServer_idGet mfa/rsa/server/{id}
		/// </summary>
		/// <param name="id">ID of the RSA server.</param>
		/// <returns>Configuration summary of known RSA servers.</returns>
		public async Task<RsaMfaServerDetail> MfaRsaServer_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mfa/rsa/server/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RsaMfaServerDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update RSA server configuration
		/// Update an existing RSA server using specified configuration.
		/// MfaRsaServer_idPatch mfa/rsa/server/{id}
		/// </summary>
		/// <param name="id">ID of the RSA server.</param>
		/// <param name="requestBody">Configuration of RSA server.</param>
		/// <returns>Updated RSA server configuration.</returns>
		public async Task<RsaMfaServerDetail> MfaRsaServer_idPatchAsync(string id, RsaMfaServerConfigUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mfa/rsa/server/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RsaMfaServerDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns summary information for Microsoft SQL availability groups
		/// Returns a list of summary information for Microsoft SQL availability groups.
		/// MssqlAvailability_groupGetByPrimary_cluster_id mssql/availability_group
		/// </summary>
		/// <param name="primary_cluster_id">Filter by primary cluster.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<MssqlAvailabilityGroupSummaryListResponse> MssqlAvailability_groupGetByPrimary_cluster_idAsync(string primary_cluster_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/availability_group?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlAvailabilityGroupSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns detailed information for a Microsoft SQL availability group
		/// Returns a detailed view of a Microsoft SQL availability group.
		/// MssqlAvailability_group_idGet mssql/availability_group/{id}
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL availability group to fetch.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<MssqlAvailabilityGroupDetail> MssqlAvailability_group_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/availability_group/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlAvailabilityGroupDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Microsoft SQL availability group
		/// Update a Microsoft SQL availability group with the specified properties.
		/// MssqlAvailability_group_idPatch mssql/availability_group/{id}
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL availability group to update.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Returned if the update was successful.</returns>
		public async Task<MssqlAvailabilityGroupDetail> MssqlAvailability_group_idPatchAsync(string id, MssqlAvailabilityGroupUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/availability_group/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlAvailabilityGroupDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for SQL Server databases
		/// Returns a list of summary information for Microsoft SQL databases.
		/// MssqlDbGetByInstance_idAndAvailability_group_idAndEffective_sla_domain_idAndPrimary_cluster_idAndNameAndSla_assignmentAndLimitAndOffsetAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndSort_byAndSort_orderAndInclude_backup_task_info mssql/db
		/// </summary>
		/// <param name="instance_id">Filter by Microsoft SQL instance.</param>
		/// <param name="availability_group_id">Filter by the `id` of an Always On Availability Group.</param>
		/// <param name="effective_sla_domain_id">Filter by effective SLA domain.</param>
		/// <param name="primary_cluster_id">Filter by primary cluster.</param>
		/// <param name="name">Filter by a substring of the database name.</param>
		/// <param name="sla_assignment">SLA Assignment of the database.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">An integer that specifies a number of initial matches to ignore.</param>
		/// <param name="is_relic">Filter database summary information by the value of the `isRelic` field.</param>
		/// <param name="is_live_mount">Filter database summary information by the value of the `isLiveMount` field.</param>
		/// <param name="is_log_shipping_secondary">Filter database summary information by the value of the `isLogShippingSecondary` field.</param>
		/// <param name="sort_by">Specifies the SQL Server Database attribute to use in sorting the summary information. Performs an ASCII sort using the specified attribute, in the order specified by sort_order.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <param name="include_backup_task_info">Include backup task information in response.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<MssqlDbSummaryListResponse> MssqlDbGetByInstance_idAndAvailability_group_idAndEffective_sla_domain_idAndPrimary_cluster_idAndNameAndSla_assignmentAndLimitAndOffsetAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndSort_byAndSort_orderAndInclude_backup_task_infoAsync(string instance_id, string availability_group_id, string effective_sla_domain_id, string primary_cluster_id, string name, string sla_assignment, int limit, int offset, bool is_relic, bool is_live_mount, bool is_log_shipping_secondary, MssqlDatabaseListSortAttribute sort_by, SortOrder sort_order, bool include_backup_task_info, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db?instance_id=" + (instance_id==null? "" : System.Uri.EscapeDataString(instance_id))+"&availability_group_id=" + (availability_group_id==null? "" : System.Uri.EscapeDataString(availability_group_id))+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sla_assignment=" + (sla_assignment==null? "" : System.Uri.EscapeDataString(sla_assignment))+"&limit="+limit+"&offset="+offset+"&is_relic="+is_relic+"&is_live_mount="+is_live_mount+"&is_log_shipping_secondary="+is_log_shipping_secondary+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&include_backup_task_info="+include_backup_task_info;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlDbSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update multiple Microsoft SQL databases
		/// Update multiple Microsoft SQL databases with the specified properties.
		/// MssqlDbBulkPatch mssql/db/bulk
		/// </summary>
		/// <param name="requestBody">Properties to update for each database.</param>
		/// <returns>Returns a detailed view of all updated databases.</returns>
		public async Task<MssqlDbDetail[]> MssqlDbBulkPatchAsync(MssqlDbUpdateId[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlDbDetail[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Take an on-demand backup of multiple Microsoft SQL databases
		/// Take an on-demand backup of one or more Microsoft SQL databases. Set the forceFullSnapshot property to true to force a full snapshot for every database that is specified. Only one snapshot will be taken for each database, even if a database is included multiple times in the fields of the request body. To check the result of the request, poll /mssql/request/{id}.
		/// MssqlDbBulkSnapshotPost mssql/db/bulk/snapshot
		/// </summary>
		/// <param name="requestBody">Configuration for the on-demand backups.</param>
		public async Task MssqlDbBulkSnapshotPostAsync(MssqlBatchBackupJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/bulk/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns details for an on-demand backup of multiple Microsoft SQL databases
		/// Returns the details for an on-demand backup of multiple Microsoft SQL databases. This only returns details for requests that have finished successfully. To check the status of the request, poll /mssql/request/{id}.
		/// MssqlDbBulkSnapshot_idGet mssql/db/bulk/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of the on-demand backup request.</param>
		/// <returns>Result of the on-demand backup request.</returns>
		public async Task<MssqlBatchBackupSummary> MssqlDbBulkSnapshot_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/bulk/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlBatchBackupSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a count of Microsoft SQL databases
		/// Returns a count of Microsoft SQL databases.
		/// MssqlDbCountGetByRoot_id mssql/db/count
		/// </summary>
		/// <param name="root_id">Include only instances that belong to this root.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<ProtectedObjectsCount> MssqlDbCountGetByRoot_idAsync(string root_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/count?root_id=" + (root_id==null? "" : System.Uri.EscapeDataString(root_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProtectedObjectsCount>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the current default properties for Microsoft SQL databases
		/// The default properties are Log Backup Frequency (in seconds), Log Retention Time (in hours) and CBT status. New databases added to the Rubrik cluster are provided the log backup frequency value and log backup retention value by default. New hosts added to the Rubrik cluster are provided the CBT status by default.
		/// MssqlDbDefaultsGet mssql/db/defaults
		/// </summary>
		/// <returns>Returns the current default properties.</returns>
		public async Task<MssqlDbDefaults> MssqlDbDefaultsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/defaults";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlDbDefaults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the default properties for Microsoft SQL databases
		/// The default properties are Log Backup Frequency (in seconds), Log Retention Time (in hours) and CBT status. New databases added to the Rubrik cluster are provided the log backup frequency value and log backup retention value by default. New hosts added to the Rubrik cluster are provided the CBT status by default.
		/// MssqlDbDefaultsPatch mssql/db/defaults
		/// </summary>
		/// <param name="requestBody">Updated default properties.</param>
		/// <returns>Returns the updated default properties.</returns>
		public async Task<MssqlDbDefaults> MssqlDbDefaultsPatchAsync(MssqlDbDefaultsUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/defaults";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlDbDefaults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get log shipping configurations
		/// Retrieves all log shipping configuration objects. Results can be filtered and sorted.
		/// MssqlDbLog_shippingGetByPrimary_database_idAndPrimary_database_nameAndSecondary_database_nameAndLocationAndStatusAndLimitAndOffsetAndSort_byAndSort_order mssql/db/log_shipping
		/// </summary>
		/// <param name="primary_database_id">ID of a primary database object.</param>
		/// <param name="primary_database_name">Filter log shipping configuration objects by performing an infix search using the name of a primary database.</param>
		/// <param name="secondary_database_name">Filter log shipping configuration objects by performing an infix search using the name of a secondary database.</param>
		/// <param name="location">Filter log shipping configuration objects by performing an infix search using the location string value (host/instance) for a secondary database.</param>
		/// <param name="status">Filter log shipping configuration objects based on the status value for the secondary database.</param>
		/// <param name="limit">Limit the summary information to a specified maximum number of results.</param>
		/// <param name="offset">Starting position in the list of results contained in the response. The summary information includes the specified numbered result and all higher numbered results.</param>
		/// <param name="sort_by">Specifies an attribute used to ASCII-sort the results. Sorting by the last_applied attribute represents the timestamp as an ISO 8601-encoded string.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Summary list of descendant objects.</returns>
		public async Task<MssqlLogShippingSummaryListResponse> MssqlDbLog_shippingGetByPrimary_database_idAndPrimary_database_nameAndSecondary_database_nameAndLocationAndStatusAndLimitAndOffsetAndSort_byAndSort_orderAsync(string primary_database_id, string primary_database_name, string secondary_database_name, string location, MssqlLogShippingStatus status, int limit, int offset, MssqlLogShippingListSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/log_shipping?primary_database_id=" + (primary_database_id==null? "" : System.Uri.EscapeDataString(primary_database_id))+"&primary_database_name=" + (primary_database_name==null? "" : System.Uri.EscapeDataString(primary_database_name))+"&secondary_database_name=" + (secondary_database_name==null? "" : System.Uri.EscapeDataString(secondary_database_name))+"&location=" + (location==null? "" : System.Uri.EscapeDataString(location))+"&status=" + status+"&limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlLogShippingSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a specified log shipping configuration
		/// Deletes the specified log shipping configuration.
		/// MssqlDbLog_shipping_idDeleteByDelete_secondary_database mssql/db/log_shipping/{id}
		/// </summary>
		/// <param name="id">ID of a log shipping configuration object.</param>
		/// <param name="delete_secondary_database">Boolean value that determines whether to attempt to delete the secondary database associated with the specified log shipping configuration. The default value is false. When set to false, no attempt is made to delete the secondary database. When set to true, starts an asynchronous job to delete the secondary database.</param>
		public async Task MssqlDbLog_shipping_idDeleteByDelete_secondary_databaseAsync(string id, bool delete_secondary_database, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/log_shipping/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&delete_secondary_database="+delete_secondary_database;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a log shipping configuration
		/// Retrieves a particular log shipping configuration with all the details of the configuration.
		/// MssqlDbLog_shipping_idGet mssql/db/log_shipping/{id}
		/// </summary>
		/// <param name="id">ID of a log shipping configuration.</param>
		/// <returns>Returned when the request for the log shipping configuration details is successful.</returns>
		public async Task<MssqlLogShippingDetail> MssqlDbLog_shipping_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/log_shipping/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlLogShippingDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a specified log shipping configuration
		/// Updates a specified log shipping configuration.
		/// MssqlDbLog_shipping_idPatch mssql/db/log_shipping/{id}
		/// </summary>
		/// <param name="id">ID of a log shipping configuration object.</param>
		/// <param name="requestBody">Configuration parameters for the update operation.</param>
		public async Task MssqlDbLog_shipping_idPatchAsync(string id, MssqlLogShippingUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/log_shipping/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reseed a secondary database
		/// Starts an asynchronous job to reseed a secondary database. Reseeding restores the data in the secondary database based on a log shipping configuration.
		/// MssqlDbLog_shipping_idReseedPost mssql/db/log_shipping/{id}/reseed
		/// </summary>
		/// <param name="id">ID of the log shipping configuration object for the specified secondary database.</param>
		/// <param name="requestBody">Configuration parameters for the reseed operation.</param>
		public async Task MssqlDbLog_shipping_idReseedPostAsync(string id, MssqlLogShippingReseedConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/log_shipping/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/reseed";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for all Live Mounts SQL Server databases
		/// Returns a list with summary information for all Live Mount SQL Server databases.
		/// MssqlDbMountGetBySource_database_idAndSource_database_nameAndTarget_instance_idAndMounted_database_nameAndSort_byAndSort_orderAndOffsetAndLimit mssql/db/mount
		/// </summary>
		/// <param name="source_database_id">Filters by the ID of the source SQL Server database.</param>
		/// <param name="source_database_name">Filters by the name of the source SQL Server database using infix search.</param>
		/// <param name="target_instance_id">Filters by the ID of the target SQL Server instance.</param>
		/// <param name="mounted_database_name">Filters by the name of the mounted SQL Server database using infix search.</param>
		/// <param name="sort_by">Specifies the SQL Server Live Mount attribute to use in sorting the summary information. Performs an ASCII sort using the specified attribute, in the order specified by sort_order.</param>
		/// <param name="sort_order">Specifies the sort order, either ascending or descending. Default order is ascending.</param>
		/// <param name="offset">Returns the portion of the ordered list that starts after the element specified by the offset number.</param>
		/// <param name="limit">Sets the maximum number of a elements to include in the data array of the response.</param>
		/// <returns>Returns summary information for all Live Mounts.</returns>
		public async Task<MssqlMountSummaryListResponse> MssqlDbMountGetBySource_database_idAndSource_database_nameAndTarget_instance_idAndMounted_database_nameAndSort_byAndSort_orderAndOffsetAndLimitAsync(string source_database_id, string source_database_name, string target_instance_id, string mounted_database_name, MssqlDbMountGetBySource_database_idAndSource_database_nameAndTarget_instance_idAndMounted_database_nameAndSort_byAndSort_orderAndOffsetAndLimitSort_by sort_by, SortOrder sort_order, int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/mount?source_database_id=" + (source_database_id==null? "" : System.Uri.EscapeDataString(source_database_id))+"&source_database_name=" + (source_database_name==null? "" : System.Uri.EscapeDataString(source_database_name))+"&target_instance_id=" + (target_instance_id==null? "" : System.Uri.EscapeDataString(target_instance_id))+"&mounted_database_name=" + (mounted_database_name==null? "" : System.Uri.EscapeDataString(mounted_database_name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlMountSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a Live Mount of a SQL Server database
		/// Create an async request to delete a Live Mount of a SQL Server database. Poll the task status by using /mssql/request/{id}.
		/// MssqlDbMount_idDeleteByForce mssql/db/mount/{id}
		/// </summary>
		/// <param name="id">ID of the Live Mount to delete.</param>
		/// <param name="force">Remove all data within the Rubrik cluster related to the Live Mount, even if the SQL Server database cannot be contacted. Default value is false.</param>
		public async Task MssqlDbMount_idDeleteByForceAsync(string id, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/mount/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&force="+force;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detailed information for a Live Mount of a SQL Server database
		/// Returns detailed information for the specified Live Mount of a SQL Server database.
		/// MssqlDbMount_idGet mssql/db/mount/{id}
		/// </summary>
		/// <param name="id">ID of the Live Mount to fetch.</param>
		/// <returns>Returns detailed information for a specified Live Mount of a SQL Server database.</returns>
		public async Task<MssqlMountDetail> MssqlDbMount_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/mount/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlMountDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the deletion status of downloaded recoverable ranges
		/// Get the details of the progress made in deleting recoverable ranges. The recoverable ranges to delete are those specified by the DELETE request to /mssql/db/{id}/recoverable_range/download which yielded the response with the job id.
		/// MssqlDbRecoverable_rangeDownload_idGet mssql/db/recoverable_range/download/{id}
		/// </summary>
		/// <param name="id">Job ID of the deletion for which to check progress.</param>
		/// <returns>Returns the progress made in deleting the recoverable ranges.</returns>
		public async Task<InternalJobInstanceDetail> MssqlDbRecoverable_rangeDownload_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/recoverable_range/download/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InternalJobInstanceDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get details information about a Microsoft SQL database snapshot
		/// Returns detailed information about a Microsoft SQL database snapshot.
		/// MssqlDbSnapshot_idGet mssql/db/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of the snapshot.</param>
		/// <returns>Returns details about a Microsoft SQL database snapshot.</returns>
		public async Task<MssqlDbSnapshotDetail> MssqlDbSnapshot_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlDbSnapshotDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detailed information for a Microsoft SQL database
		/// Returns a detailed view of a Microsoft SQL database.
		/// MssqlDb_idGet mssql/db/{id}
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database to fetch.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<MssqlDbDetail> MssqlDb_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlDbDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Microsoft SQL database
		/// Update a Microsoft SQL database with the specified properties.
		/// MssqlDb_idPatch mssql/db/{id}
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database to update.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Returned if the update was successful.</returns>
		public async Task<MssqlDbDetail> MssqlDb_idPatchAsync(string id, MssqlDbUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlDbDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List snapshots and logs from a Microsoft SQL database
		/// When a recovery point is set, this API endpoint returns the snapshot and list of logs needed to restore the database to the recovery point. When a time range or LSN range is specified, this API endpoint returns the snapshots and logs that overlap the specified range.
		/// Specify only a recovery point or a range. Specify only LSNs or times.
		/// This endpoint is only used to fetch data, but uses POST instead of GET due to limitations on parameters used in the body of a GET request. The parameter set for this endpoint is shared with the download_file endpoint.
		/// 
		/// MssqlDb_idBrowsePost mssql/db/{id}/browse
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="requestBody">Configuration for the browse request.</param>
		/// <returns>List of backups requested.</returns>
		public async Task<MssqlBackups> MssqlDb_idBrowsePostAsync(string id, MssqlBackupSelection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/browse";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlBackups>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get compatible instances for the recovery of a Microsoft SQL database
		/// Returns all compatible instances for export for the specified recovery time.
		/// MssqlDb_idCompatible_instanceGetByRecovery_timeAndRecovery_type mssql/db/{id}/compatible_instance
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="recovery_time">Time, in ISO8601 format, to recover to. For example "2016-01-01T01:23:45.678Z". If this is not specified, the latest recoverable time is used.</param>
		/// <param name="recovery_type">Recovery type.</param>
		/// <returns>Returns summary information for all compatible Microsoft SQL instances for export.</returns>
		public async Task<MssqlInstanceSummaryListResponse> MssqlDb_idCompatible_instanceGetByRecovery_timeAndRecovery_typeAsync(string id, System.DateTimeOffset recovery_time, MssqlDb_idCompatible_instanceGetByRecovery_timeAndRecovery_typeRecovery_type recovery_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/compatible_instance&recovery_time=" + recovery_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&recovery_type=" + recovery_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlInstanceSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download snapshots and log backups from archival
		/// Starts an asynchronous request to download snapshots and logs from archival for a given database and recovery point.
		/// If the specified point in time is already available locally, this endpoint throws an error.
		/// 
		/// MssqlDb_idDownloadPost mssql/db/{id}/download
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="requestBody">Configuration for the archive download request.</param>
		public async Task MssqlDb_idDownloadPostAsync(string id, MssqlDownloadFromArchiveConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Download snapshots and logs backups from a Microsoft SQL Database
		/// Starts an asynchronous request to download a set of backup files as a single compressed zipfile.
		/// When a recovery point is set, this API endpoint returns the snapshot and list of logs that Rubrik CDM would use to restore the database to the recovery point. When a time range or LSN range is specified, this API endpoint returns the snapshots and logs that overlap the specified range.
		/// Specify only a point in time or a range. Specify only LSNs or times.
		/// 
		/// MssqlDb_idDownload_filesPost mssql/db/{id}/download_files
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="requestBody">Configuration for a download files job.</param>
		public async Task MssqlDb_idDownload_filesPostAsync(string id, MssqlBackupSelection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download_files";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Downloads a list of snapshot and log backups from a Microsoft SQL database
		/// Downloads a list of snapshot and log backups from a Microsoft SQL database.
		/// MssqlDb_idDownload_files_by_idPost mssql/db/{id}/download_files_by_id
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="requestBody">Configuration for a download files by id job.</param>
		public async Task MssqlDb_idDownload_files_by_idPostAsync(string id, DownloadMssqlBackupFilesByIdJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download_files_by_id";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Export a Microsoft SQL database to a new location
		/// Create a request to export a Microsoft SQL database. To check the result of the request, poll /mssql/request/{id}.
		/// MssqlDb_idExportPost mssql/db/{id}/export
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="requestBody">Configuration for the export.</param>
		public async Task MssqlDb_idExportPostAsync(string id, ExportMssqlDbJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Take an on-demand log backup for a Microsoft SQL database
		/// Take an on-demand log backup for a Microsoft SQL database.
		/// MssqlDb_idLog_backupPost mssql/db/{id}/log_backup
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		public async Task MssqlDb_idLog_backupPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/log_backup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a log shipping configuration
		/// Create a log shipping configuration between a specified primary database and a specified secondary database. The transaction logs from the primary database are regularly restored to the secondary database in order to maintain the secondary database as a point-in-time copy of the primary database. The primary database must have log backups configured, and it must be in the full or bulk-logged recovery model.
		/// MssqlDb_idLog_shippingPost mssql/db/{id}/log_shipping
		/// </summary>
		/// <param name="id">ID of the primary database object.</param>
		/// <param name="requestBody">Object containing the values of a log shipping configuration.</param>
		public async Task MssqlDb_idLog_shippingPostAsync(string id, MssqlLogShippingCreateConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/log_shipping";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get missed recoverable ranges of a Microsoft SQL database
		/// Retrieve a list of missed recoverable ranges for a Microsoft SQL database. For each run of one type of error, the first and last occurrence of the error are given.
		/// MssqlDb_idMissed_recoverable_rangeGetByAfter_timeAndBefore_time mssql/db/{id}/missed_recoverable_range
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="after_time">Filter the missed ranges to end after this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <param name="before_time">Filter the missed ranges to start before this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <returns>Returns the missed recoverable ranges for the Microsoft SQL database.</returns>
		public async Task<MssqlMissedRecoverableRangeListResponse> MssqlDb_idMissed_recoverable_rangeGetByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/missed_recoverable_range&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlMissedRecoverableRangeListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary information for missed snapshots of a SQL database
		/// Returns a list of summary information for the missed snapshots of a Microsoft SQL database, including the time of day and the locations where the snapshot was missed.
		/// MssqlDb_idMissed_snapshotGetByAfter_timeAndBefore_time mssql/db/{id}/missed_snapshot
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="after_time">Filter snapshots to those missed on or after this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <param name="before_time">Filter snapshots to those missed on or before this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <returns>Returns details about the missed snapshots.</returns>
		public async Task<MissedSnapshotListResponse> MssqlDb_idMissed_snapshotGetByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/missed_snapshot&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MissedSnapshotListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Live Mount SQL Server database from a point in time copy
		/// Create an asynchronous request to create a Live Mount SQL Server database. Poll the task status by using /mssql/request/{id}.
		/// MssqlDb_idMountPost mssql/db/{id}/mount
		/// </summary>
		/// <param name="id">ID of the SQL Server database.</param>
		/// <param name="requestBody">Configuration for the Live Mount.</param>
		public async Task MssqlDb_idMountPostAsync(string id, MountMssqlDbConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/mount";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get recoverable ranges of a Microsoft SQL database
		/// Retrieve the recoverable ranges for a specified Microsoft SQL database. A begin and/or end timestamp can be provided to retrieve only the ranges that fall within the window.
		/// MssqlDb_idRecoverable_rangeGetByAfter_timeAndBefore_time mssql/db/{id}/recoverable_range
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="after_time">Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678Z".</param>
		/// <param name="before_time">Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <returns>Returns the recoverable ranges for the Microsoft SQL database.</returns>
		public async Task<MssqlRecoverableRangeListResponse> MssqlDb_idRecoverable_rangeGetByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/recoverable_range&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlRecoverableRangeListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete downloaded recoverable ranges of a Microsoft SQL database
		/// Deletes all local snapshots and logs that have previously been downloaded. Provide a begin or end time to delete only the downloaded snapshots and logs that fall within this time frame. The time is relative to when the snapshot or log backup was originally taken, not downloaded. Parts of the window may not be deleted if certain log files must be kept to preserve times outside the window. Data is deleted in the background. To check the status of the deletion, poll /mssql/db/recoverable_range/download/{id}.
		/// MssqlDb_idRecoverable_rangeDownloadDeleteByAfter_timeAndBefore_time mssql/db/{id}/recoverable_range/download
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="after_time">Delete only the downloaded snapshots and logs taken after this time. The date-time string should be in ISO8601 format. For example, "2016-01-01T01:23:45.678".</param>
		/// <param name="before_time">Delete only the downloaded snapshots and logs taken before this time. The date-time string should be in ISO8601 format. For example, "2016-01-01T01:23:45.678".</param>
		public async Task MssqlDb_idRecoverable_rangeDownloadDeleteByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/recoverable_range/download&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Restore a Microsoft SQL database
		/// Create a request to restore a SQL Server database. To check the result of the request, poll /mssql/request/{id}.
		/// MssqlDb_idRestorePost mssql/db/{id}/restore
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="requestBody">Restore configuration.</param>
		public async Task MssqlDb_idRestorePostAsync(string id, RestoreMssqlDbJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/restore";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a size estimate for a restore or export
		/// Provides an estimate of resources needed for the specified restore or export operation.
		/// MssqlDb_idRestore_estimateGetByTimeAndLsnAndRecovery_fork_guid mssql/db/{id}/restore_estimate
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="time">Time, in ISO8601 date-time format, to recover to. For example, "2016-01-01T01:23:45.678". This value or the LSN are required.</param>
		/// <param name="lsn">LSN to recover to. This value or the LSN are required.</param>
		/// <param name="recovery_fork_guid">Recovery fork GUID of LSN to recover to. Meaningful only when lsn is specified.</param>
		/// <returns>Returns the esimate for a restore or export to the specified recovery point.</returns>
		public async Task<MssqlRestoreEstimateResult> MssqlDb_idRestore_estimateGetByTimeAndLsnAndRecovery_fork_guidAsync(string id, System.DateTimeOffset time, string lsn, string recovery_fork_guid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/restore_estimate&time=" + time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&lsn=" + (lsn==null? "" : System.Uri.EscapeDataString(lsn))+"&recovery_fork_guid=" + (recovery_fork_guid==null? "" : System.Uri.EscapeDataString(recovery_fork_guid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlRestoreEstimateResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list all database files to be restored
		/// Provides a list of database files to be restored for the specified restore or export operation.
		/// MssqlDb_idRestore_filesGetByTimeAndLsnAndRecovery_fork_guid mssql/db/{id}/restore_files
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="time">Time, in ISO8601 date-time format, to recover to. For example, "2016-01-01T01:23:45.678". This value or the LSN are required.</param>
		/// <param name="lsn">LSN to recover to. This value or the time are required.</param>
		/// <param name="recovery_fork_guid">Recovery fork GUID of LSN to recover to. Meaningful only when lsn is specified.</param>
		/// <returns>Database files to be restored.</returns>
		public async Task<MssqlRestoreFile[]> MssqlDb_idRestore_filesGetByTimeAndLsnAndRecovery_fork_guidAsync(string id, System.DateTimeOffset time, string lsn, string recovery_fork_guid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/restore_files&time=" + time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&lsn=" + (lsn==null? "" : System.Uri.EscapeDataString(lsn))+"&recovery_fork_guid=" + (recovery_fork_guid==null? "" : System.Uri.EscapeDataString(recovery_fork_guid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlRestoreFile[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the snappableId for a Microsoft SQL database
		/// Returns the snappableId for a Microsoft SQL database.
		/// MssqlDb_idSnappable_idGet mssql/db/{id}/snappable_id
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <returns>Returns the snappableId.</returns>
		public async Task<MssqlSnappableId> MssqlDb_idSnappable_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snappable_id";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlSnappableId>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all snapshots of a Microsoft SQL database
		/// Deletes all snapshots of a Microsoft SQL database. The database must be unprotected for the operation to succeed.
		/// MssqlDb_idSnapshotDelete mssql/db/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		public async Task MssqlDb_idSnapshotDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary information for snapshots of a Microsoft SQL database
		/// Returns a list of summary information for snapshots of a Microsoft SQL database.
		/// MssqlDb_idSnapshotGetByAfter_timeAndBefore_time mssql/db/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="after_time">Filter snapshots to those taken on or after this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <param name="before_time">Filter snapshots to those taken before or on this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <returns>Returns summary information for snapshots.</returns>
		public async Task<MssqlDbSnapshotSummaryListResponse> MssqlDb_idSnapshotGetByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlDbSnapshotSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Take an on-demand backup of a Microsoft SQL database
		/// Take an on-demand backup of a Microsoft SQL database. The forceFullSnapshot property can be set to true to force a full snapshot. To check the result of the request, poll /mssql/request/{id}.
		/// MssqlDb_idSnapshotPost mssql/db/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL database.</param>
		/// <param name="requestBody">Configuration for the on-demand backup.</param>
		public async Task MssqlDb_idSnapshotPostAsync(string id, MssqlBackupJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary of a SQL Server hierarchy object
		/// Retrieve details for the specified object in the SQL Server hierarchy.
		/// 
		/// MssqlHierarchy_idGet mssql/hierarchy/{id}
		/// </summary>
		/// <param name="id">ID of the SQL Server hierarchy object.</param>
		/// <returns>Details of the hierarchy object.</returns>
		public async Task<MssqlHierarchyObjectSummary> MssqlHierarchy_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlHierarchyObjectSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of immediate descendant objects
		/// Retrieve the list of immediate descendant objects for the specified parent.
		/// MssqlHierarchy_idChildrenGetByEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndNameAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndIs_clusteredAndHas_instancesAndSla_assignmentAndSort_byAndSort_orderAndSnappable_status mssql/hierarchy/{id}/children
		/// </summary>
		/// <param name="id">ID of the parent SQL Server hierarchy object. To get top-level nodes, use **root** as the ID.
		///</param>
		/// <param name="effective_sla_domain_id">Filter by the ID of the effective SLA Domain.</param>
		/// <param name="object_type">Filter by a comma-separated list of node object types.
		///</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">An integer that specifies the number of initial matches to ignore.
		///</param>
		/// <param name="name">Filter children by provided name.</param>
		/// <param name="is_relic">Filter by the value of the `isRelic` field for nodes with object type MssqlDatabase.</param>
		/// <param name="is_live_mount">Filter database by the value of the `isLiveMount` field for nodes with object type MssqlDatabase.</param>
		/// <param name="is_log_shipping_secondary">Filter by the value of the `isLogShippingSecondary` field for nodes with object type MssqlDatabase.</param>
		/// <param name="is_clustered">Filter by the value of the `isClustered` field for nodes with object type MssqlDatabase or MssqlInstance.</param>
		/// <param name="has_instances">Boolean that filters top-level nodes with the Host or WindowsCluster object type by whether or not the nodes have children MssqlInstance nodes. When this value is 'true,' the filter shows only nodes with children MssqlInstance nodes. When this value is 'false,' the filter shows only nodes without children MssqlInstance nodes.</param>
		/// <param name="sla_assignment">Filter by SLA assignment type.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <param name="snappable_status">Determines whether SQL Server instances are fetched with additional privilege checks.</param>
		/// <returns>Summary list of children objects.</returns>
		public async Task<MssqlHierarchyObjectSummaryListResponse> MssqlHierarchy_idChildrenGetByEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndNameAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndIs_clusteredAndHas_instancesAndSla_assignmentAndSort_byAndSort_orderAndSnappable_statusAsync(
					string id, 
					string effective_sla_domain_id, 
					MssqlHierarchyObjectType[] object_type, 
					string primary_cluster_id, 
					int limit, 
					int offset, 
					string name, 
					bool is_relic, 
					bool is_live_mount, 
					bool is_log_shipping_secondary, 
					bool is_clustered, 
					bool has_instances, 
					SlaAssignment sla_assignment, 
					MssqlHierarchy_idChildrenGetByEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndNameAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndIs_clusteredAndHas_instancesAndSla_assignmentAndSort_byAndSort_orderAndSnappable_statusSort_by sort_by, 
					SortOrder sort_order, 
					SnappablePrivilegeStatus snappable_status, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/children&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&"+string.Join("&", object_type.Select(z => $"object_type={z}"))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&limit="+limit+"&offset="+offset+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&is_relic="+is_relic+"&is_live_mount="+is_live_mount+"&is_log_shipping_secondary="+is_log_shipping_secondary+"&is_clustered="+is_clustered+"&has_instances="+has_instances+"&sla_assignment=" + sla_assignment+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlHierarchyObjectSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of descendant objects
		/// Retrieve the list of descendant objects for the specified parent.
		/// MssqlHierarchy_idDescendantsGetByEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndNameAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndIs_clusteredAndHas_instancesAndSla_assignmentAndSort_byAndSort_orderAndSnappable_status mssql/hierarchy/{id}/descendants
		/// </summary>
		/// <param name="id">ID of the parent SQL server hierarchy object. To get top-level nodes, use **root** as the ID.
		///</param>
		/// <param name="effective_sla_domain_id">Filter by the ID of the effective SLA Domain.</param>
		/// <param name="object_type">Filter by a comma-separated list of node object types.
		///</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">An integer that specifies the number of initial matches to ignore.
		///</param>
		/// <param name="name">Filter descendants by provided name.</param>
		/// <param name="is_relic">Filter by the value of the `isRelic` field for nodes with MssqlDatabase as the value of the object type field.</param>
		/// <param name="is_live_mount">Filter database by the value of the `isLiveMount` field for nodes with MssqlDatabase as the value of the object type field.</param>
		/// <param name="is_log_shipping_secondary">Filter by the value of the `isLogShippingSecondary` field for nodes with MssqlDatabase as the value of the object type field.</param>
		/// <param name="is_clustered">Filter by the value of the `isClustered` field for nodes with object type MssqlDatabase or MssqlInstance.</param>
		/// <param name="has_instances">Boolean that filters top-level nodes with the Host or WindowsCluster object type by whether or not the nodes have children MssqlInstance nodes. When this value is 'true,' the filter shows only nodes with children MssqlInstance nodes. When this value is 'false,' the filter shows only nodes without children MssqlInstance nodes.</param>
		/// <param name="sla_assignment">Filter by SLA Domain assignment type.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <param name="snappable_status">Determines whether SQL Server instances are fetched with additional privilege checks.</param>
		/// <returns>Summary list of descendant objects.</returns>
		public async Task<MssqlHierarchyObjectSummaryListResponse> MssqlHierarchy_idDescendantsGetByEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndNameAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndIs_clusteredAndHas_instancesAndSla_assignmentAndSort_byAndSort_orderAndSnappable_statusAsync(
					string id, 
					string effective_sla_domain_id, 
					MssqlHierarchyObjectType[] object_type, 
					string primary_cluster_id, 
					int limit, 
					int offset, 
					string name, 
					bool is_relic, 
					bool is_live_mount, 
					bool is_log_shipping_secondary, 
					bool is_clustered, 
					bool has_instances, 
					SlaAssignment sla_assignment, 
					MssqlHierarchy_idDescendantsGetByEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndNameAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndIs_clusteredAndHas_instancesAndSla_assignmentAndSort_byAndSort_orderAndSnappable_statusSort_by sort_by, 
					SortOrder sort_order, 
					SnappablePrivilegeStatus snappable_status, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/descendants&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&"+string.Join("&", object_type.Select(z => $"object_type={z}"))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&limit="+limit+"&offset="+offset+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&is_relic="+is_relic+"&is_live_mount="+is_live_mount+"&is_log_shipping_secondary="+is_log_shipping_secondary+"&is_clustered="+is_clustered+"&has_instances="+has_instances+"&sla_assignment=" + sla_assignment+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlHierarchyObjectSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the summary of SQL Server host configurations
		/// Returns a list of customized SQL Server host configurations.
		/// MssqlHostConfigurationGetByHost_id mssql/host/configuration
		/// </summary>
		/// <param name="host_id">IDs of the hosts.</param>
		/// <returns>Summary of SQL Server host configurations.</returns>
		public async Task<MssqlHostConfigurationWithHostIdListResponse> MssqlHostConfigurationGetByHost_idAsync(string[] host_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/host/configuration?"+string.Join("&", host_id.Select(z => $"host_id={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlHostConfigurationWithHostIdListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a SQL Server host configuration
		/// Creates a SQL Server host configuration.
		/// MssqlHostConfigurationPost mssql/host/configuration
		/// </summary>
		/// <param name="requestBody">Parameters for creating a SQL Server host configuration.</param>
		public async Task MssqlHostConfigurationPostAsync(MssqlHostConfigurationWithHostId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/host/configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete the SQL Server host configuration
		/// Deletes the SQL Server host configuration. The host falls back to use values from the global configuration.
		/// MssqlHostConfiguration_host_idDelete mssql/host/configuration/{host_id}
		/// </summary>
		/// <param name="host_id">ID of the host.</param>
		public async Task MssqlHostConfiguration_host_idDeleteAsync(string host_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/host/configuration/"+ (host_id==null? "" : System.Uri.EscapeDataString(host_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the configuration for a specific host
		/// Returns the configuration for the specified SQL Server host.
		/// MssqlHostConfiguration_host_idGet mssql/host/configuration/{host_id}
		/// </summary>
		/// <param name="host_id">ID of the host.</param>
		/// <returns>Configuration details of the specified SQL Server host.</returns>
		public async Task<MssqlHostConfiguration> MssqlHostConfiguration_host_idGetAsync(string host_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/host/configuration/"+ (host_id==null? "" : System.Uri.EscapeDataString(host_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlHostConfiguration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update host configuration
		/// Updates the configuration for a specified host.
		/// MssqlHostConfiguration_host_idPatch mssql/host/configuration/{host_id}
		/// </summary>
		/// <param name="host_id">ID of the SQL Server host to update the host configuration.</param>
		/// <param name="requestBody">SQL Server host configuration properties to update.</param>
		/// <returns>Details of the updated SQL Server host configuration.</returns>
		public async Task<MssqlHostConfiguration> MssqlHostConfiguration_host_idPatchAsync(string host_id, MssqlHostConfiguration requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/host/configuration/"+ (host_id==null? "" : System.Uri.EscapeDataString(host_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlHostConfiguration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for Microsoft SQL instances
		/// Returns a list of summary information for Microsoft SQL instances.
		/// MssqlInstanceGetByRoot_idAndPrimary_cluster_idAndSnappable_status mssql/instance
		/// </summary>
		/// <param name="root_id">Include only instances that belong to this root.</param>
		/// <param name="primary_cluster_id">Limits the instances returned within one cluster specified by primary_cluster_id.</param>
		/// <param name="snappable_status">Determines whether SQL Server instances are fetched with additional privilege checks.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<MssqlInstanceSummaryListResponse> MssqlInstanceGetByRoot_idAndPrimary_cluster_idAndSnappable_statusAsync(string root_id, string primary_cluster_id, SnappablePrivilegeStatus snappable_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/instance?root_id=" + (root_id==null? "" : System.Uri.EscapeDataString(root_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlInstanceSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a count of Microsoft SQL instances
		/// Returns a count of all Microsoft SQL instances.
		/// MssqlInstanceCountGet mssql/instance/count
		/// </summary>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<CountResponse> MssqlInstanceCountGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/instance/count";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CountResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detailed information for a Microsoft SQL instance
		/// Returns a detailed view of a Microsoft SQL instance.
		/// MssqlInstance_idGet mssql/instance/{id}
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL instance.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<MssqlInstanceDetail> MssqlInstance_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/instance/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlInstanceDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Microsoft SQL instance
		/// Update a Microsoft SQL instance with specified properties.
		/// MssqlInstance_idPatch mssql/instance/{id}
		/// </summary>
		/// <param name="id">ID of the Microsoft SQL instance.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Returned if the update was successful.</returns>
		public async Task<MssqlInstanceDetail> MssqlInstance_idPatchAsync(string id, MssqlInstanceUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/instance/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MssqlInstanceDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get details for an async request
		/// Returns the task object for an async request related to SQL Server databases.
		/// MssqlRequest_idGet mssql/request/{id}
		/// </summary>
		/// <param name="id">ID of the async request.</param>
		/// <returns>Status of the async request.</returns>
		public async Task<AsyncRequestStatus> MssqlRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Assign SLA properties to SQL Server objects
		/// Assigns SLA Domain properties to SQL Server objects. Hosts and Windows clusters cannot be assigned SLA Domains directly. The SLA Domains are instead applied to the SQL Server child objects within the Host or Windows Cluster object. Newly discovered SQL Server objects within a given Host or Windows Cluster object do not inherit SLA Domain properties from other child SQL Server objects with the same parent object.
		/// 
		/// MssqlSla_domainAssignPost mssql/sla_domain/assign
		/// </summary>
		/// <param name="requestBody">Update information.</param>
		public async Task MssqlSla_domainAssignPostAsync(MssqlSlaDomainAssignInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mssql/sla_domain/assign";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Link to download the Advanced Recovery Options example file
		/// Link to download the Advanced Recovery Options example file which can be used to customize Oracle recoveries.
		/// OracleAco_example_download_linkGet oracle/aco_example_download_link
		/// </summary>
		/// <returns>Link to download the example Advanced Recovery Options file.</returns>
		public async Task<OracleFileDownloadLink> OracleAco_example_download_linkGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/aco_example_download_link";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OracleFileDownloadLink>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List of supported Advanced Cloning Options
		/// Get the list of supported Advanced Cloning Options (ACO) parameters.
		/// OracleAco_parameter_listGet oracle/aco_parameter_list
		/// </summary>
		/// <returns>List of supported Advanced Cloning Options (ACO) parameters.</returns>
		public async Task<OracleAcoParameterList> OracleAco_parameter_listGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/aco_parameter_list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OracleAcoParameterList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an Oracle Data Guard group
		/// Update properties of an Oracle Data Guard group object.
		/// OracleData_guard_group_idPatch oracle/data_guard_group/{id}
		/// </summary>
		/// <param name="id">ID assigned to an Oracle Data Guard group object.</param>
		/// <param name="requestBody">Properties to use for the update of an Oracle Data Guard group object.</param>
		/// <returns>Successfully updated the Oracle Data Guard group object.</returns>
		public async Task<OracleDbDetail> OracleData_guard_group_idPatchAsync(string id, OracleDataGuardGroupUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/data_guard_group/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OracleDbDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for Oracle databases
		/// Retrieves an array containing summary information about the Oracle database objects in the Rubrik cluster.
		/// OracleDbGetByNameAndSla_assignmentAndEffective_sla_domain_idAndPrimary_cluster_idAndIs_relicAndIs_live_mountAndLimitAndOffsetAndSort_byAndSort_orderAndInclude_backup_task_infoAndIs_data_guard_group oracle/db
		/// </summary>
		/// <param name="name">Filters a response by making an infix comparison of the database name, SID, and tablespaces in the response with the specified value.</param>
		/// <param name="sla_assignment">Limits the response to Oracle databases that are protected by the specified type of SLA Domain assignment.</param>
		/// <param name="effective_sla_domain_id">Filters by effective SLA Domain ID.</param>
		/// <param name="primary_cluster_id">Limits the response to Oracle databases that have the specified primary cluster value.</param>
		/// <param name="is_relic">Limits the response to Oracle databases that have the specified isRelic value.</param>
		/// <param name="is_live_mount">Limits the response to Oracle databases that have the specified isLiveMount value.</param>
		/// <param name="limit">Limits the summary information to the specified number of matches. Optionally, it can be used with offset to begin the count of matches at the number specified in the offset parameter, and with sort_by to sort the results by the specified attribute.</param>
		/// <param name="offset">Determines the elements to include in the response starting with the element at the index number specified here. Optionally used with limit to enable paging of the results by retrieving a smaller number of elements in the response.</param>
		/// <param name="sort_by">Specifies a comma-separated list of attributes to use in sorting the matches. Performs an ASCII sort of the values in the response using each specified attribute, in the order specified.</param>
		/// <param name="sort_order">Specifies the ascending or descending order to sort the elements in the response by the attributes specified in the sort_by parameter.</param>
		/// <param name="include_backup_task_info">Specifies whether to include the backup task information in the response.</param>
		/// <param name="is_data_guard_group">Limits the response to Oracle databases that have the specified value for the isDataGuardGroup flag.</param>
		/// <returns>Summary of Oracle databases.</returns>
		public async Task<OracleDbSummaryListResponse> OracleDbGetByNameAndSla_assignmentAndEffective_sla_domain_idAndPrimary_cluster_idAndIs_relicAndIs_live_mountAndLimitAndOffsetAndSort_byAndSort_orderAndInclude_backup_task_infoAndIs_data_guard_groupAsync(string name, SlaAssignment sla_assignment, string effective_sla_domain_id, string primary_cluster_id, bool is_relic, bool is_live_mount, int limit, int offset, OracleDbGetByNameAndSla_assignmentAndEffective_sla_domain_idAndPrimary_cluster_idAndIs_relicAndIs_live_mountAndLimitAndOffsetAndSort_byAndSort_orderAndInclude_backup_task_infoAndIs_data_guard_groupSort_by sort_by, SortOrder sort_order, bool include_backup_task_info, bool is_data_guard_group, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/db?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sla_assignment=" + sla_assignment+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&is_relic="+is_relic+"&is_live_mount="+is_live_mount+"&limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&include_backup_task_info="+include_backup_task_info+"&is_data_guard_group="+is_data_guard_group;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OracleDbSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update Oracle Databases
		/// Update the properties of the objects that represent the specified Oracle Databases.
		/// OracleDbBulkPatch oracle/db/bulk
		/// </summary>
		/// <param name="requestBody">Properties to use for the update of Oracle Database objects.</param>
		/// <returns>Successfully updated Oracle Database objects.</returns>
		public async Task<BulkOracleDbDetails> OracleDbBulkPatchAsync(OracleBulkUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/db/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BulkOracleDbDetails>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Oracle database information
		/// Retrieves detailed information for a specified Oracle database object.
		/// OracleDb_idGet oracle/db/{id}
		/// </summary>
		/// <param name="id">ID of an Oracle database object.</param>
		/// <returns>Detailed information for the specified Oracle database.</returns>
		public async Task<OracleDbDetail> OracleDb_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/db/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OracleDbDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an Oracle database
		/// Updates the properties of a specified Oracle database object.
		/// OracleDb_idPatch oracle/db/{id}
		/// </summary>
		/// <param name="id">ID of an Oracle database object.</param>
		/// <param name="requestBody">Properties of the Oracle database object to be updated. object.</param>
		/// <returns>Detailed information for the updated Oracle database.</returns>
		public async Task<OracleDbDetail> OracleDb_idPatchAsync(string id, OracleUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/db/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OracleDbDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete downloaded Oracle database snapshots and log snapshots
		/// Requests an asynchronous job to expire downloaded database snapshots taken during a specified time period as well as log snapshots that contain any logs with timestamps within that time period.
		/// OracleDb_idDownloaded_snapshotsDeleteByAfter_timeAndBefore_time oracle/db/{id}/downloaded_snapshots
		/// </summary>
		/// <param name="id">ID of the Oracle database.</param>
		/// <param name="after_time">Uses the ISO 8601 format to specify the start of the time period used by the asynchronous snapshot expiration job, as in the example "2016-01-01T01:23:45.678".</param>
		/// <param name="before_time">Uses the ISO 8601 format to specify the end of the time period used by the asynchronous snapshot expiration job, as in the example "2016-01-01T01:23:45.678".</param>
		public async Task OracleDb_idDownloaded_snapshotsDeleteByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/downloaded_snapshots&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a size estimate for a restore or export
		/// The estimated size of the data to download from an archival location in order to perform a specified restore or export operation.
		/// OracleDb_idRestore_estimateGetBySnapshot_idAndRecovery_time oracle/db/{id}/restore_estimate
		/// </summary>
		/// <param name="id">ID of the Oracle database.</param>
		/// <param name="snapshot_id">ID of the snapshot to recover to.</param>
		/// <param name="recovery_time">The date and time for the recovery restore point, specified in the ISO 8601 format, as in the example "2016-01-01T01:23:45.678".</param>
		/// <returns>Returns the estimate for a restore or export to the specified recovery point.</returns>
		public async Task<OracleRestoreEstimateResult> OracleDb_idRestore_estimateGetBySnapshot_idAndRecovery_timeAsync(string id, string snapshot_id, System.DateTimeOffset recovery_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/restore_estimate&snapshot_id=" + (snapshot_id==null? "" : System.Uri.EscapeDataString(snapshot_id))+"&recovery_time=" + recovery_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OracleRestoreEstimateResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Validate Oracle database backups
		/// Queue a job to validate Oracle backups for a database snapshot or a specified timestamp.
		/// OracleDb_idValidatePost oracle/db/{id}/validate
		/// </summary>
		/// <param name="id">ID of the database to be validated.</param>
		/// <param name="requestBody">Configuration parameters for a job to validate an Oracle backups.</param>
		public async Task OracleDb_idValidatePostAsync(string id, OracleValidateConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/validate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update Oracle Hosts
		/// Update properties to Oracle Host objects.
		/// OracleHostBulkPatch oracle/host/bulk
		/// </summary>
		/// <param name="requestBody">Properties to use for the update of Oracle Host objects.</param>
		/// <returns>Successfully updated Oracle Host objects.</returns>
		public async Task<BulkOracleHostDetails> OracleHostBulkPatchAsync(OracleBulkUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/host/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BulkOracleHostDetails>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update Oracle RACs
		/// Update the properties of the objects that represent the specified Oracle RAC.
		/// OracleRacBulkPatch oracle/rac/bulk
		/// </summary>
		/// <param name="requestBody">Properties to use for the update of Oracle RAC objects.</param>
		/// <returns>Successfully updated Oracle RAC objects.</returns>
		public async Task<BulkOracleRacDetails> OracleRacBulkPatchAsync(OracleBulkUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/rac/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BulkOracleRacDetails>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Validate Oracle ACO file
		/// Validate the provided Oracle ACO (Advanced Cloning Options) file.
		/// OracleValidate_aco_filePostByIs_live_mount oracle/validate_aco_file
		/// </summary>
		/// <param name="is_live_mount">Boolean that determines whether the ACO file is being used for a Live Mount.</param>
		/// <param name="requestBody">Contents of the Advanced Cloning Options file in base64 encoded format.</param>
		/// <returns>Validation result of the provided ACO file.</returns>
		public async Task<OracleAcoValidationResult> OracleValidate_aco_filePostByIs_live_mountAsync(bool is_live_mount, string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oracle/validate_aco_file?is_live_mount="+is_live_mount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OracleAcoValidationResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a list of Rubrik Envoy objects
		/// Remove a list of Rubrik Envoy objects from an organization and delete the objects from the Rubrik cluster.
		/// Organization_idEnvoyBulkDelete organization/{id}/envoy/bulk
		/// </summary>
		/// <param name="id">ID assigned to an organization object.</param>
		public async Task Organization_idEnvoyBulkDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organization/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/envoy/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a list of Rubrik Envoy objects
		/// Change one or more of the properties of a list of Rubrik Envoy objects.
		/// Organization_idEnvoyBulkPatch organization/{id}/envoy/bulk
		/// </summary>
		/// <param name="id">ID assigned to an organization object.</param>
		/// <param name="requestBody">Properties to assign to the Rubrik Envoy objects.</param>
		/// <returns>Returns a detailed view of all updated Rubrik Envoy objects.</returns>
		public async Task<EnvoyDetailList> Organization_idEnvoyBulkPatchAsync(string id, EnvoyBulkUpdate[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organization/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/envoy/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EnvoyDetailList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a list of Rubrik Envoy objects
		/// Create a list of Rubrik Envoy objects for a specified organization and specify the properties to assign to the Rubrik Envoy objects.
		/// Organization_idEnvoyBulkPost organization/{id}/envoy/bulk
		/// </summary>
		/// <param name="id">ID assigned to an organization object.</param>
		/// <param name="requestBody">Properties to assign to the Rubrik Envoy objects.</param>
		/// <returns>Returns a detailed view of all created Rubrik Envoy objects.</returns>
		public async Task<EnvoyDetailList> Organization_idEnvoyBulkPostAsync(string id, EnvoyCreate[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organization/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/envoy/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EnvoyDetailList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Search for principals
		/// Search for principals based on the specified parameters.
		/// PrincipalGetByLimitAndOffsetAndSort_byAndSort_orderAndAuth_domain_idAndOrganization_idAndIs_assigned_roles_or_is_localAndRole_idAndNameAndPrincipal_typeAndIs_totp_enabled principal
		/// </summary>
		/// <param name="limit">Maximum number of results to return.</param>
		/// <param name="offset">Starting offset of the results to return.</param>
		/// <param name="sort_by">Attribute by which to sort. Default is "name".</param>
		/// <param name="sort_order">Sort order. Default order is ascending.</param>
		/// <param name="auth_domain_id">ID of the authentication domain that contains the principal.</param>
		/// <param name="organization_id">ID of the organization of which the principal is a member.</param>
		/// <param name="is_assigned_roles_or_is_local">A Boolean that specifies whether the principal has any roles assigned or is a local user. When a principal is a local user, or when the principal has any roles assigned, this value is 'true'.
		///</param>
		/// <param name="role_id">ID of a role assigned to the principal.</param>
		/// <param name="name">The name of the principal.</param>
		/// <param name="principal_type">The type of principal.</param>
		/// <param name="is_totp_enabled">Indicates if the principal has TOTP authentication enabled. Returns the users with TOTP authentication enabled when the value is true.
		///</param>
		/// <returns>The list of matching principals.</returns>
		public async Task<PrincipalSummaryV1ListResponse> PrincipalGetByLimitAndOffsetAndSort_byAndSort_orderAndAuth_domain_idAndOrganization_idAndIs_assigned_roles_or_is_localAndRole_idAndNameAndPrincipal_typeAndIs_totp_enabledAsync(int limit, int offset, PrincipalSearchSortAttribute sort_by, SortOrder sort_order, string auth_domain_id, string organization_id, bool is_assigned_roles_or_is_local, string role_id, string name, PrincipalSummaryV1PrincipalType principal_type, bool is_totp_enabled, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "principal?limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&auth_domain_id=" + (auth_domain_id==null? "" : System.Uri.EscapeDataString(auth_domain_id))+"&organization_id=" + (organization_id==null? "" : System.Uri.EscapeDataString(organization_id))+"&is_assigned_roles_or_is_local="+is_assigned_roles_or_is_local+"&role_id=" + (role_id==null? "" : System.Uri.EscapeDataString(role_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&principal_type=" + principal_type+"&is_totp_enabled="+is_totp_enabled;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PrincipalSummaryV1ListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get roles assigned to principals
		/// Get a list of role information for all roles assigned to the principals.
		/// 
		/// PrincipalRoleGetByPrincipals principal/role
		/// </summary>
		/// <param name="principals">IDs of the principals.</param>
		/// <returns>List of roles assigned to the principal.</returns>
		public async Task<PrincipalWithRoleInfo[]> PrincipalRoleGetByPrincipalsAsync(string[] principals, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "principal/role?"+string.Join("&", principals.Select(z => $"principals={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PrincipalWithRoleInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Assign roles to principals
		/// Assign a set of roles to the specified principals.
		/// PrincipalRolePost principal/role
		/// </summary>
		/// <param name="requestBody">A set of roles and a set of principals to which the roles should be granted.
		///</param>
		/// <returns>Role information for roles assigned to the principal.
		///</returns>
		public async Task<RoleInfo[]> PrincipalRolePostAsync(RoleAssignmentRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "principal/role";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RoleInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Revoke roles from principals
		/// Revoke a set of roles from the specified principals.
		/// 
		/// PrincipalRoleBulk_revokePost principal/role/bulk_revoke
		/// </summary>
		/// <param name="requestBody">A set of roles to revoke from a set of principals.</param>
		public async Task PrincipalRoleBulk_revokePostAsync(RoleAssignmentRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "principal/role/bulk_revoke";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Resume replication from specified source clusters
		/// A single Rubrik cluster can be the replication target for multiple source Rubrik clusters. For each source cluster specified, this resumes replication from that source cluster to the target cluster. This call must be made on the target cluster.
		/// 
		/// ReplicationLocation_pauseDisablePost replication/location_pause/disable
		/// </summary>
		/// <param name="requestBody">A configuration value that specifies which source clusters resume replication. Snapshots taken before or during the replication pause can be skipped.
		///</param>
		public async Task ReplicationLocation_pauseDisablePostAsync(DisablePerLocationPause requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "replication/location_pause/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Pause replication from specified source clusters
		/// A single Rubrik cluster can be the replication target for multiple source Rubrik clusters. For each source cluster specified, this pauses replication from that source cluster to the target cluster. This call must be made on the target cluster.
		/// 
		/// ReplicationLocation_pauseEnablePost replication/location_pause/enable
		/// </summary>
		/// <param name="requestBody">A configuration value that specifies which source clusters pause replication. Replication jobs can be canceled immediately or be allowed to finish.
		///</param>
		public async Task ReplicationLocation_pauseEnablePostAsync(EnablePerLocationPause requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "replication/location_pause/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get compliance summary information
		/// Returns the compliance summary information for all protected objects based on a time-based requirement of at least one snapshot in each 24 hour report period. This view ignores the policies assigned to protected objects through SLA Domains.
		/// ReportCompliance_summaryGet report/compliance_summary
		/// </summary>
		/// <returns>Data from the report data source.</returns>
		public async Task<ComplianceSummaryV1> ReportCompliance_summaryGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "report/compliance_summary";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ComplianceSummaryV1>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get compliance summary information
		/// Returns the compliance summary information for all protected objects based on whether the last expected snapshot was successful. This requirement is based on the SLA Domain assigned to the objects.
		/// ReportCompliance_summary_slaGetBySnapshot_range report/compliance_summary_sla
		/// </summary>
		/// <param name="snapshot_range">An SLA Domain-based range of snapshots. Compliance is calculated for snapshots in the range.</param>
		/// <returns>Data from the report data source.</returns>
		public async Task<ComplianceSummarySLAV1> ReportCompliance_summary_slaGetBySnapshot_rangeAsync(ComplianceRangeFilter snapshot_range, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "report/compliance_summary_sla?snapshot_range=" + snapshot_range;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ComplianceSummarySLAV1>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify the report config
		/// Set the different report config parameters.
		/// ReportConfigPatch report/config
		/// </summary>
		/// <param name="requestBody">Specifies the new report config parameters.</param>
		/// <returns>The new duration, in days, of the retention period for report job instances for log jobs.</returns>
		public async Task<ReportConfigResponse> ReportConfigPatchAsync(ReportConfigPatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "report/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReportConfigResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all roles in an organization
		/// Get a list of role information for all roles in the specified organization.
		/// 
		/// RoleGetByLimitAndOffsetAndSort_byAndSort_orderAndOrganization_idAndNameAndRole_template role
		/// </summary>
		/// <param name="limit">Maximum number of results to return.</param>
		/// <param name="offset">Starting offset of the results to return.</param>
		/// <param name="sort_by">Attribute used to sort the role list.</param>
		/// <param name="sort_order">Sort order used, ascending or descending.</param>
		/// <param name="organization_id">The ID of the organization the roles are a part of. When empty, the Rubrik cluster infers the organization from the session.
		///</param>
		/// <param name="name">The name of the role.</param>
		/// <param name="role_template">List of comma-separated role templates by which to filter the roles.
		///</param>
		/// <returns>Information about the requested roles.</returns>
		public async Task<RoleInfoListResponse> RoleGetByLimitAndOffsetAndSort_byAndSort_orderAndOrganization_idAndNameAndRole_templateAsync(int limit, int offset, RoleListSortAttributes sort_by, SortOrder sort_order, string organization_id, string name, string[] role_template, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role?limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&organization_id=" + (organization_id==null? "" : System.Uri.EscapeDataString(organization_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&"+string.Join("&", role_template.Select(z => $"role_template={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RoleInfoListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new role
		/// Create a new role in the current organization.
		/// RolePost role
		/// </summary>
		/// <param name="requestBody">Information about the role.</param>
		/// <returns>Information about the newly created role.</returns>
		public async Task<RoleInfo> RolePostAsync(RoleInfoCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RoleInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a role
		/// Delete the role with the specified ID.
		/// Role_idDelete role/{id}
		/// </summary>
		/// <param name="id">ID of the role.</param>
		public async Task Role_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get role information for the specified role
		/// Get role information for the role with the specified ID.
		/// Role_idGet role/{id}
		/// </summary>
		/// <param name="id">ID of the role.</param>
		/// <returns>Information about the role.</returns>
		public async Task<RoleInfo> Role_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RoleInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update role information
		/// Update the role information for the specified role.
		/// Role_idPatch role/{id}
		/// </summary>
		/// <param name="id">ID of the role.</param>
		/// <param name="requestBody">Information about the role.</param>
		/// <returns>Information about the updated role.</returns>
		public async Task<RoleInfo> Role_idPatchAsync(string id, RoleInfoUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "role/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RoleInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Make SAML authentication request
		/// Make a SAML authentication request for a specified IdP Authentication Domain.
		/// SamlAuthn_request_idp_namePost saml/authn_request/{idp_name}
		/// </summary>
		/// <param name="idp_name">Name of the IdP Authentication Domain to authenticate with.</param>
		/// <param name="requestBody">Additional information associated with a single sign-on (SSO) authentication request.</param>
		/// <returns>Return the necessary data for constructing SAML authentication request.</returns>
		public async Task<SamlSsoAuthnRequestDetail> SamlAuthn_request_idp_namePostAsync(string idp_name, SamlSsoAuthnRequestInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "saml/authn_request/"+ (idp_name==null? "" : System.Uri.EscapeDataString(idp_name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SamlSsoAuthnRequestDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Configure and generate Rubrik SAML metadata
		/// Configure and generate the SAML metadata for this Rubrik cluster. The call returns the download URL for the metadata.
		/// SamlRubrik_metadataPost saml/rubrik_metadata
		/// </summary>
		/// <param name="requestBody">Information for generating Rubrik SAML metadata file.</param>
		/// <returns>Returns the URL for downloading the Rubrik SAML metadata.</returns>
		public async Task<RubrikSamlMetadataSummary> SamlRubrik_metadataPostAsync(RubrikSamlMetadataInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "saml/rubrik_metadata";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RubrikSamlMetadataSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Check SAML SSO Status
		/// An object that contains two values. A Boolean value that determines whether or not SSO is enabled and an optional String value that indicates the name of the default IdP authentication domain for SSO login. When the boolean value is 'true,' SAML SSO is enabled. When the Boolean value is 'false,' SAML SSO is disabled.
		/// SamlSso_statusGet saml/sso_status
		/// </summary>
		/// <returns>Return an object containing SAML SSO status.</returns>
		public async Task<SamlSsoStatus> SamlSso_statusGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "saml/sso_status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SamlSsoStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary information for discovered SAP HANA databases
		/// Returns summary information for SAP HANA databases connected to the CDM cluster.
		/// Sap_hanaDbGetByEffective_sla_domain_idAndPrimary_cluster_idAndNameAndSla_assignmentAndLimitAndOffsetAndIs_relicAndSort_byAndSort_order sap_hana/db
		/// </summary>
		/// <param name="effective_sla_domain_id">The ID of the SLA Domain that controls the protection of the host.</param>
		/// <param name="primary_cluster_id">The ID of the Rubrik cluster that provides primary protection for the SAP HANA databases.</param>
		/// <param name="name">The name of the SAP HANA database.</param>
		/// <param name="sla_assignment">The name of the SLA Domain that controls the protection of the SAP HANA database.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">An integer that specifies a number of initial matches to ignore.</param>
		/// <param name="is_relic">Specify whether the SAP HANA database is accessible on the Rubrik cluster.</param>
		/// <param name="sort_by">Specifies the SAP HANA Database attribute to use in sorting the summary information.</param>
		/// <param name="sort_order">The order to sort the responses by. Valid choices are asc (ascending) and desc (descending).</param>
		/// <returns>If the query is successful, returns summary information for SAP HANA databases connected to the cluster.</returns>
		public async Task<SapHanaDatabaseSummaryListResponse> Sap_hanaDbGetByEffective_sla_domain_idAndPrimary_cluster_idAndNameAndSla_assignmentAndLimitAndOffsetAndIs_relicAndSort_byAndSort_orderAsync(string effective_sla_domain_id, string primary_cluster_id, string name, string sla_assignment, int limit, int offset, bool is_relic, SapHanaDatabaseListSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db?effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sla_assignment=" + (sla_assignment==null? "" : System.Uri.EscapeDataString(sla_assignment))+"&limit="+limit+"&offset="+offset+"&is_relic="+is_relic+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SapHanaDatabaseSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the status of a SAP HANA database request
		/// Get details about a SAP HANA database related request which includes the status of data backup job.
		/// Sap_hanaDbRequest_idGet sap_hana/db/request/{id}
		/// </summary>
		/// <param name="id">ID of the request.</param>
		/// <returns>Status for the async request.</returns>
		public async Task<AsyncRequestStatus> Sap_hanaDbRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a particular full snapshot of a SAP HANA database
		/// Initiates a request to delete a particular full snapshot of a SAP HANA database. If the log retention period for the database is still in effect, the snapshot will be deleted when the log retention period ends.
		/// Sap_hanaDbSnapshot_idDelete sap_hana/db/snapshot/{id}
		/// </summary>
		/// <param name="id">ID assigned to a SAP HANA database full snapshot.</param>
		public async Task Sap_hanaDbSnapshot_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get SAP HANA database snapshot details
		/// Retrieve detailed information about a full or an incremental snapshot of a SAP HANA database.
		/// Sap_hanaDbSnapshot_idGet sap_hana/db/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <returns>Returns details about a snapshot.</returns>
		public async Task<SapHanaDatabaseSnapshotDetail> Sap_hanaDbSnapshot_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SapHanaDatabaseSnapshotDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detailed information for an SAP HANA database
		/// Returns a detailed view of the SAP HANA database.
		/// Sap_hanaDb_idGet sap_hana/db/{id}
		/// </summary>
		/// <param name="id">The ID of the SAP HANA database.</param>
		/// <returns>If the query is successful, returns a detailed view of the SAP HANA database.</returns>
		public async Task<SapHanaDatabaseDetail> Sap_hanaDb_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SapHanaDatabaseDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the SLA Domain for an SAP HANA database
		/// Update the SLA Domain that is configured for an SAP HANA database.
		/// Sap_hanaDb_idPatch sap_hana/db/{id}
		/// </summary>
		/// <param name="id">The ID of the SAP HANA database.</param>
		/// <param name="requestBody">Object containing updated SAP HANA database SLA Domain ID.</param>
		/// <returns>If the API call is successful, the SAP HANA database object is updated and summary of the object is returned.</returns>
		public async Task<SapHanaDatabaseDetail> Sap_hanaDb_idPatchAsync(string id, SapHanaDatabasePatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SapHanaDatabaseDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Configure the target database for system copy restore
		/// Initiates a job to configure the specified target database for a system copy restore by sending metadata about the source database. System copy restore in SAP HANA is done across different databases.
		/// Sap_hanaDb_idConfigure_restorePost sap_hana/db/{id}/configure_restore
		/// </summary>
		/// <param name="id">ID of the target SAP HANA database to be configured.</param>
		/// <param name="requestBody">The object containing configuration related metadata for the source SAP HANA database.</param>
		public async Task Sap_hanaDb_idConfigure_restorePostAsync(string id, SapHanaRestoreSourceConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/configure_restore";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve summary information for missed snapshots of a SAP HANA database
		/// Returns a summary of information for the missed snapshots of a SAP HANA database. Retrieve only the missed snapshots that occur between the beginning and ending timestamps.
		/// Sap_hanaDb_idMissed_snapshotGetByAfter_timeAndBefore_time sap_hana/db/{id}/missed_snapshot
		/// </summary>
		/// <param name="id">ID of the SAP HANA database.</param>
		/// <param name="after_time">Filter for snapshots that are missed on or after this time. The date-time string must be in ISO8601 format, for example, "2016-01-01T01:23:45.678".</param>
		/// <param name="before_time">Filter for snapshots that are missed on or before this time. The date-time string must be in ISO8601 format, for example, "2016-01-01T01:23:45.678".</param>
		/// <returns>Returns details about missed snapshots.</returns>
		public async Task<MissedSnapshotListResponse> Sap_hanaDb_idMissed_snapshotGetByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/missed_snapshot&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MissedSnapshotListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get recoverable ranges of a SAP HANA database
		/// Retrieve the recoverable ranges for a specified SAP HANA database. Provide a beginning and/or ending timestamp to retrieve only the recoverable ranges that fall within this period of time.
		/// Sap_hanaDb_idRecoverable_rangeGetByAfter_timeAndBefore_time sap_hana/db/{id}/recoverable_range
		/// </summary>
		/// <param name="id">ID of the SAP HANA database.</param>
		/// <param name="after_time">Filter ranges to end after this time. The date-time string should be in an ISO8601 format. For example, "2016-01-01T01:23:45.678Z".</param>
		/// <param name="before_time">Filter ranges to start before this time. The date-time string should be in an ISO8601 format. For example, "2016-01-01T01:23:45.678Z".</param>
		/// <returns>Returns the recoverable ranges for the SAP HANA database.</returns>
		public async Task<SapHanaRecoverableRangeListResponse> Sap_hanaDb_idRecoverable_rangeGetByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/recoverable_range&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SapHanaRecoverableRangeListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a summary list of snapshots for a SAP HANA database
		/// Retrieve summary information about the full and incremental snapshots of a specified SAP HANA database.
		/// Sap_hanaDb_idSnapshotGetByBackup_typeAndAfter_timeAndBefore_time sap_hana/db/{id}/snapshot
		/// </summary>
		/// <param name="id">ID assigned to a SAP HANA database object.</param>
		/// <param name="backup_type">Filter snapshots to those of a particular backup type.</param>
		/// <param name="after_time">Filter snapshots to those taken on or after this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <param name="before_time">Filter snapshots to those taken before or on this time. The date-time string should be in ISO8601 format, such as "2016-01-01T01:23:45.678".</param>
		/// <returns>Returns summary information for all snapshots.</returns>
		public async Task<SapHanaDatabaseSnapshotSummaryListResponse> Sap_hanaDb_idSnapshotGetByBackup_typeAndAfter_timeAndBefore_timeAsync(string id, SapHanaDatabaseSnapshotSummaryBackupType backup_type, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot&backup_type=" + backup_type+"&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SapHanaDatabaseSnapshotSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create on demand database snapshot
		/// Initiates a job to take an on demand full snapshot of a specified SAP HANA database object. The GET /sap_hana/db/request/{id} endpoint can be used to monitor the progress of the job.
		/// Sap_hanaDb_idSnapshotPost sap_hana/db/{id}/snapshot
		/// </summary>
		/// <param name="id">ID assigned to a SAP HANA database object.</param>
		/// <param name="requestBody">Configuration for the on demand backup.</param>
		public async Task Sap_hanaDb_idSnapshotPostAsync(string id, BaseOnDemandSnapshotConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reset the configuration for system copy restore on target database
		/// Initiates a job to reset the configuration for the system copy restore on the specified target database. System copy restore in SAP HANA is done across different databases.
		/// Sap_hanaDb_idUnconfigure_restorePost sap_hana/db/{id}/unconfigure_restore
		/// </summary>
		/// <param name="id">ID assigned to target SAP HANA database object.</param>
		public async Task Sap_hanaDb_idUnconfigure_restorePostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/db/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/unconfigure_restore";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary information for added SAP HANA systems
		/// Returns summary information for SAP HANA systems.
		/// Sap_hanaSystemGetByPrimary_cluster_idAndSidAndLimitAndOffsetAndSort_byAndSort_order sap_hana/system
		/// </summary>
		/// <param name="primary_cluster_id">The ID of the Rubrik cluster that provides primary protection for the SAP HANA databases.</param>
		/// <param name="sid">The SAP System Identification (SID) code for the SAP HANA system.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">An integer that specifies a number of initial matches to ignore.</param>
		/// <param name="sort_by">The SAP HANA system attribute to use in sorting the responses.</param>
		/// <param name="sort_order">The order to sort the responses by. Valid choices are asc (ascending) and desc (descending).</param>
		/// <returns>If query is successful, returns summary information for SAP HANA systems.</returns>
		public async Task<SapHanaSystemSummaryListResponse> Sap_hanaSystemGetByPrimary_cluster_idAndSidAndLimitAndOffsetAndSort_byAndSort_orderAsync(string primary_cluster_id, string sid, int limit, int offset, SapHanaSystemListSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/system?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&sid=" + (sid==null? "" : System.Uri.EscapeDataString(sid))+"&limit="+limit+"&offset="+offset+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SapHanaSystemSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a SAP HANA system
		/// Add a SAP HANA system to the Rubrik cluster.
		/// Sap_hanaSystemPost sap_hana/system
		/// </summary>
		/// <param name="requestBody">Add a SAP HANA system to the Rubrik cluster. Contains parameters like username, list of hosts, password required while adding a SAP HANA system.</param>
		public async Task Sap_hanaSystemPostAsync(SapHanaSystemConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/system";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the status of a SAP HANA system request
		/// Get details about a SAP HANA system related request which includes the status of delete or refresh system job.
		/// Sap_hanaSystemRequest_idGet sap_hana/system/request/{id}
		/// </summary>
		/// <param name="id">The ID of the request object used to poll the status.</param>
		/// <returns>Status for the request.</returns>
		public async Task<AsyncRequestStatus> Sap_hanaSystemRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/system/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a SAP HANA system
		/// Initiates a job to delete a SAP HANA system object. GET /sap_hana/system/request/{id} endpoint can be used to monitor the progress of the job.
		/// Sap_hanaSystem_idDelete sap_hana/system/{id}
		/// </summary>
		/// <param name="id">The ID of the SAP HANA system.</param>
		public async Task Sap_hanaSystem_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/system/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary information for a SAP HANA system
		/// Returns a summary view of a SAP HANA system.
		/// Sap_hanaSystem_idGet sap_hana/system/{id}
		/// </summary>
		/// <param name="id">The ID of the SAP HANA system.</param>
		/// <returns>Returns summary information.</returns>
		public async Task<SapHanaSystemSummary> Sap_hanaSystem_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/system/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SapHanaSystemSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the SLA Domain for a SAP HANA system
		/// Update the SLA Domain that is configured for a SAP HANA system.
		/// Sap_hanaSystem_idPatch sap_hana/system/{id}
		/// </summary>
		/// <param name="id">The ID of the SAP HANA system.</param>
		/// <param name="requestBody">An object that contains the updated SLA Domain ID for the SAP HANA system.</param>
		public async Task Sap_hanaSystem_idPatchAsync(string id, SapHanaSystemPatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/system/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Refresh SAP HANA system metadata
		/// Initiates a job to refresh metadata of a SAP HANA system object. The GET /sap_hana/system/request/{id} endpoint can be used to monitor the progress of the job.
		/// Sap_hanaSystem_idRefreshPost sap_hana/system/{id}/refresh
		/// </summary>
		/// <param name="id">The ID of the SAP HANA system.</param>
		public async Task Sap_hanaSystem_idRefreshPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sap_hana/system/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/refresh";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create user session
		/// Open a user session.
		/// SessionPostByOrganization_idAndRealm session
		/// </summary>
		/// <param name="organization_id">Bind the new session to the specified organization. When this parameter is not specified, the session will be bound to an organization chosen according to the user's preferences and authorizations.</param>
		/// <param name="realm">Bind the new session to the specified directory. When this parameter is unspecified, the session will be bound to local domain.</param>
		/// <returns>Session creation successful.</returns>
		public async Task<SessionSummary> SessionPostByOrganization_idAndRealmAsync(string organization_id, string realm, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "session?organization_id=" + (organization_id==null? "" : System.Uri.EscapeDataString(organization_id))+"&realm=" + (realm==null? "" : System.Uri.EscapeDataString(realm));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SessionSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete user session
		/// Close a user session and invalidate the session token.
		/// Session_idDelete session/{id}
		/// </summary>
		/// <param name="id">Session ID or  *me* for session of bearer token.</param>
		public async Task Session_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "session/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of SLA Domains
		/// Retrieve summary information for all SLA Domains.
		/// Sla_domainGetByPrimary_cluster_idAndNameAndSort_byAndSort_orderAndData_sourcesAndSnapshot_ids sla_domain
		/// </summary>
		/// <param name="primary_cluster_id">Limits the information retrieved to those SLA Domains that are associated with the Rubrik cluster ID that is specified by primary_cluster_id. Use **local** for the Rubrik cluster that is hosting the current REST API session.</param>
		/// <param name="name">Limit the list information to those SLA Domains which match the specified SLA Domain 'name' value.</param>
		/// <param name="sort_by">Attribute to use to sort the SLA Domains summary information. Optionally use **_sort_order_** to specify whether to sort in ascending or descending order.</param>
		/// <param name="sort_order">Sort order, either ascending or descending. If not specified, SLA Domain summary results will be sorted in ascending order.</param>
		/// <param name="data_sources">Limit the list information to SLA Domains that can be assigned to specified data sources.</param>
		/// <param name="snapshot_ids">Limit the list information to SLA Domains that can be assigned to specified snapshots.</param>
		/// <returns>Summary information for SLA Domains.</returns>
		public async Task<SlaDomainSummaryListResponse> Sla_domainGetByPrimary_cluster_idAndNameAndSort_byAndSort_orderAndData_sourcesAndSnapshot_idsAsync(string primary_cluster_id, string name, Failover_clusterGetByNameAndOperating_system_typeAndSla_assignmentAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, string[] data_sources, string[] snapshot_ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sla_domain?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&"+string.Join("&", data_sources.Select(z => $"data_sources={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", snapshot_ids.Select(z => $"snapshot_ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SlaDomainSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create SLA Domain
		/// Create a new SLA Domain on a Rubrik cluster by specifying Domain Rules and policies. Only Managed Volume objects support minute frequency to take transaction log backup. SLA assignment on other objects will be disallowed.
		/// Sla_domainPost sla_domain
		/// </summary>
		/// <param name="requestBody">SLA Domain definition. The SLA domain accepts two backup windows, one for a regular backup or snapshot and one for the first full backup or snapshot. Specify times using Rubrik cluster timezone.</param>
		public async Task Sla_domainPostAsync(SlaDomainDefinition requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sla_domain";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Assign retention SLA Domain to the downloaded snapshots of a single object
		/// Assigns an SLA Domain to a list of downloaded snapshots. The SLA Domain manages retention for the snapshots in the downloaded location. The assignment does not affect the retention of the snapshots in other locations.
		/// Sla_domainAssign_to_downloaded_snapshotsPost sla_domain/assign_to_downloaded_snapshots
		/// </summary>
		/// <param name="requestBody">An object ID and a list of IDs for the downloaded snapshots. The specified SLA Domain manages retention for the downloaded copy of snapshots assigned to the specified IDs.</param>
		public async Task Sla_domainAssign_to_downloaded_snapshotsPostAsync(DownloadedSnapshotSlaAssignmentInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sla_domain/assign_to_downloaded_snapshots";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove SLA Domain
		/// Delete an SLA Domain from a Rubrik cluster. The SLA Domain must not be assigned to any VMs, filesets or databases.
		/// Sla_domain_idDelete sla_domain/{id}
		/// </summary>
		/// <param name="id">ID of the SLA Domain.</param>
		public async Task Sla_domain_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sla_domain/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get SLA Domain details
		/// Retrieve summary information for a specified SLA Domain.
		/// Sla_domain_idGet sla_domain/{id}
		/// </summary>
		/// <param name="id">ID of the SLA Domain.</param>
		/// <returns>Object containing information about the SLA Domain.</returns>
		public async Task<SlaDomainSummary> Sla_domain_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sla_domain/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SlaDomainSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patch SLA Domain
		/// (DEPRECATED) Patch the properties of an SLA Domain. The recommended endpoint is v3/sla_domain/{id}.
		/// Sla_domain_idPatchByShould_apply_to_existing_snapshots sla_domain/{id}
		/// </summary>
		/// <param name="id">ID of the SLA Domain.</param>
		/// <param name="should_apply_to_existing_snapshots">A Boolean that determines whether the new configuration retains existing snapshots of data sources that are currently retained by this SLA Domain. The value is 'true' by default.</param>
		/// <param name="requestBody">Object containing the fields to be edited for SLA Domain. The SLA Domain accepts two backup windows, one for a regular backup or snapshot and one for the first full backup or snapshot. Specify times using the Rubrik cluster timezone. Remote SLA Domain only supports edit to the archival specification.</param>
		/// <returns>Object containing the patched SLA Domain.</returns>
		public async Task<SlaDomainSummary> Sla_domain_idPatchByShould_apply_to_existing_snapshotsAsync(string id, bool should_apply_to_existing_snapshots, SlaDomainPatchDefinition requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sla_domain/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&should_apply_to_existing_snapshots="+should_apply_to_existing_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SlaDomainSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update SLA Domain
		/// Update the properties of an SLA Domain.
		/// Sla_domain_idPutByShould_apply_to_existing_snapshots sla_domain/{id}
		/// </summary>
		/// <param name="id">ID of the SLA Domain.</param>
		/// <param name="should_apply_to_existing_snapshots">A Boolean that determines whether the new configuration retains existing snapshots of data sources that are currently retained by this SLA Domain. The value is 'true' by default.</param>
		/// <param name="requestBody">Object containing the updated SLA Domain. The SLA domain accepts two backup windows, one for a regular backup or snapshot and one for the first full backup or snpashot. Specify times using the Rubrik cluster time zone.</param>
		/// <returns>Object containing updated SLA Domain.</returns>
		public async Task<SlaDomainSummary> Sla_domain_idPutByShould_apply_to_existing_snapshotsAsync(string id, bool should_apply_to_existing_snapshots, SlaDomainDefinition requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sla_domain/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&should_apply_to_existing_snapshots="+should_apply_to_existing_snapshots;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SlaDomainSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns storage stats for a snapshot
		/// Returns the storage statistics for a snapshot.
		/// Snapshot_idStorageStatsGet snapshot/{id}/storage/stats
		/// </summary>
		/// <param name="id">ID assigned to a snapshot object.</param>
		/// <returns>Returns storage stats for a snapshot.</returns>
		public async Task<SnapshotStorageStats> Snapshot_idStorageStatsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/storage/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SnapshotStorageStats>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the configured syslog export rules
		/// Return the list of all configured syslog export rules.
		/// SyslogExportGet syslog/export
		/// </summary>
		/// <returns>List of all configured syslog export rules.</returns>
		public async Task<SyslogExportRuleSummaryListResponse> SyslogExportGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "syslog/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SyslogExportRuleSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a new syslog export rule
		/// Adds a new rule specifying where to export the specified syslog information.
		/// 
		/// SyslogExportPost syslog/export
		/// </summary>
		/// <param name="requestBody">Syslog export rule.</param>
		/// <returns>Summary of the newly added syslog export rule.</returns>
		public async Task<SyslogExportRuleSummary> SyslogExportPostAsync(SyslogExportRuleFull requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "syslog/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SyslogExportRuleSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Test the specified syslog export rule
		/// Send a test message using the syslog export rule specified by the given id.
		/// 
		/// SyslogExportTestPost syslog/export/test
		/// </summary>
		/// <param name="requestBody">Syslog export rule.</param>
		/// <returns>Syslog export rule was tested successfully.</returns>
		public async Task<SyslogServerTestResult> SyslogExportTestPostAsync(SyslogExportRuleFull requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "syslog/export/test";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SyslogServerTestResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete the specified syslog export rule
		/// Delete the syslog export rule specified by the given id.
		/// SyslogExport_idDelete syslog/export/{id}
		/// </summary>
		/// <param name="id">The ID of the syslog export rule.</param>
		public async Task SyslogExport_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "syslog/export/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the specified syslog export rule
		/// Get the summary of the syslog export rule specified by the given id.
		/// 
		/// SyslogExport_idGet syslog/export/{id}
		/// </summary>
		/// <param name="id">The ID of syslog export rule.</param>
		/// <returns>Summary of the syslog export rule.</returns>
		public async Task<SyslogExportRuleSummary> SyslogExport_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "syslog/export/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SyslogExportRuleSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the specified syslog export rule
		/// Update the syslog export rule specified by the given id.
		/// SyslogExport_idPatch syslog/export/{id}
		/// </summary>
		/// <param name="id">The ID of syslog export rule.</param>
		/// <param name="requestBody">Syslog export rule.</param>
		/// <returns>Updated syslog export rule.</returns>
		public async Task<SyslogExportRuleSummary> SyslogExport_idPatchAsync(string id, SyslogExportRulePartial requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "syslog/export/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SyslogExportRuleSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary of all the objects with unmanaged snapshots
		/// Get summary of all the objects with unmanaged snapshots.
		/// Unmanaged_objectGetByLimitAndAfter_idAndSearch_valueAndUnmanaged_statusAndObject_typeAndSort_byAndSort_order unmanaged_object
		/// </summary>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="after_id">First unmanaged object after which objects should be retrieved.</param>
		/// <param name="search_value">Filters by the object name using infix search.</param>
		/// <param name="unmanaged_status">Filters by object status. Valid status are Protected, Unprotected, and Relic.</param>
		/// <param name="object_type">Filter by the type of the unmanaged object.</param>
		/// <param name="sort_by">Sort the result by given attribute.</param>
		/// <param name="sort_order">The sort order. The default sort order is ascending.</param>
		/// <returns>Get page summary about objects with unmanaged snapshots.</returns>
		public async Task<UnmanagedObjectDetailsListResponse> Unmanaged_objectGetByLimitAndAfter_idAndSearch_valueAndUnmanaged_statusAndObject_typeAndSort_byAndSort_orderAsync(int limit, string after_id, string search_value, UnmanagedObjectDetailsUnmanagedStatus unmanaged_status, UnmanagedObjectDetailsObjectType object_type, UnmanagedObjectSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "unmanaged_object?limit="+limit+"&after_id=" + (after_id==null? "" : System.Uri.EscapeDataString(after_id))+"&search_value=" + (search_value==null? "" : System.Uri.EscapeDataString(search_value))+"&unmanaged_status=" + unmanaged_status+"&object_type=" + object_type+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UnmanagedObjectDetailsListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Assign relic/unmanaged entities to an SLA Domain for managing retention asynchronously
		/// Assign relic/unmanaged entities to the specified SLA Domain for managing retention. The assignment event runs asynchronously.
		/// Unmanaged_objectAssign_retention_slaPost unmanaged_object/assign_retention_sla
		/// </summary>
		/// <param name="requestBody">Object with SLA Domain ID and a comma-separated list of the IDs of the relic/unmanaged entities being assigned to the SLA Domain.</param>
		/// <returns>Pending SLA Domains resulting from this assignment.</returns>
		public async Task<ManagedObjectPendingSlaInfo[]> Unmanaged_objectAssign_retention_slaPostAsync(UnmanagedObjectSlaAssignmentInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "unmanaged_object/assign_retention_sla";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManagedObjectPendingSlaInfo[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary of all unmanaged reader objects
		/// A summary of all unmanaged objects recovered from reader archival locations.
		/// Unmanaged_objectReader_objectGetByLimitAndAfter_idAndObject_nameAndUnmanaged_statusAndObject_typeAndSort_byAndSort_order unmanaged_object/reader_object
		/// </summary>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="after_id">Retrieve objects after the unmanaged object with the specified ID.</param>
		/// <param name="object_name">Search object by object name.</param>
		/// <param name="unmanaged_status">Filters by object status. Valid status are Protected, Unprotected, and Relic.</param>
		/// <param name="object_type">Filter by the type of the unmanaged object.</param>
		/// <param name="sort_by">Sort the result by given attribute.</param>
		/// <param name="sort_order">The sort order. The default sort order is ascending.</param>
		/// <returns>Returns a page summary of the unmanaged objects recovered from reader archival locations.</returns>
		public async Task<UnmanagedObjectSummaryListResponse> Unmanaged_objectReader_objectGetByLimitAndAfter_idAndObject_nameAndUnmanaged_statusAndObject_typeAndSort_byAndSort_orderAsync(int limit, string after_id, string object_name, UnmanagedObjectDetailsUnmanagedStatus unmanaged_status, UnmanagedObjectDetailsObjectType object_type, UnmanagedObjectSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "unmanaged_object/reader_object?limit="+limit+"&after_id=" + (after_id==null? "" : System.Uri.EscapeDataString(after_id))+"&object_name=" + (object_name==null? "" : System.Uri.EscapeDataString(object_name))+"&unmanaged_status=" + unmanaged_status+"&object_type=" + object_type+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UnmanagedObjectSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Bulk tier existing snapshots to cold storage
		/// Schedules a job to tier existing snapshots of the specified objects to cold storage.
		/// Unmanaged_objectSnapshotBulk_archive_tierPost unmanaged_object/snapshot/bulk_archive_tier
		/// </summary>
		/// <param name="requestBody">A list of object IDs to tier. Optionally specifies a location ID.</param>
		public async Task Unmanaged_objectSnapshotBulk_archive_tierPostAsync(BulkTierSnapshotsConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "unmanaged_object/snapshot/bulk_archive_tier";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary of all the snapshots for a given object
		/// Gets summary information for all snapshots of the object with the specified object ID.
		/// Unmanaged_object_idSnapshotGetByLimitAndOffsetAndSearch_valueAndSnapshot_typeAndBefore_dateAndAfter_dateAndSort_byAndSort_order unmanaged_object/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of a object.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Ignore these many matches in the beginning.</param>
		/// <param name="search_value">Search snapshot by date and time.</param>
		/// <param name="snapshot_type">Filter by snapshot type. Valid types are OnDemand, PolicyBased, Retrieved.</param>
		/// <param name="before_date">Filter all the snapshots before a date.</param>
		/// <param name="after_date">Filter all the snapshots after a date.</param>
		/// <param name="sort_by">Sort by given attribute.</param>
		/// <param name="sort_order">The sort order. The default sort order is ascending.</param>
		/// <returns>Get page summary about snapshots for a given object.</returns>
		public async Task<SnapshotSummaryListResponse> Unmanaged_object_idSnapshotGetByLimitAndOffsetAndSearch_valueAndSnapshot_typeAndBefore_dateAndAfter_dateAndSort_byAndSort_orderAsync(string id, int limit, int offset, string search_value, SnapshotSummarySnapshotType snapshot_type, System.DateTimeOffset before_date, System.DateTimeOffset after_date, SnapshotSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "unmanaged_object/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot&limit="+limit+"&offset="+offset+"&search_value=" + (search_value==null? "" : System.Uri.EscapeDataString(search_value))+"&snapshot_type=" + snapshot_type+"&before_date=" + before_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&after_date=" + after_date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SnapshotSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the local user account lockout settings
		/// Get the local user account lockout settings which are used to configure whether user accounts will be locked on failed logins, when they will be locked and the duration for which they will stay locked.
		/// 
		/// UserLockoutGet user/lockout
		/// </summary>
		/// <returns>Get the local user account lockout settings which are used to configure whether user accounts will be locked on failed logins, when they will be locked and the duration for which they will stay locked.
		///</returns>
		public async Task<LocalUserAccountLockoutStatus> UserLockoutGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/lockout";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LocalUserAccountLockoutStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the local user account lockout settings
		/// Update the local user account lockout settings which are used to configure whether user accounts will be locked on failed logins, when they will be locked and the duration for which they will stay locked.
		/// 
		/// UserLockoutPatch user/lockout
		/// </summary>
		/// <param name="requestBody">Update the local user account lockout settings.</param>
		/// <returns>Current configuration for local user account lockout feature.
		///</returns>
		public async Task<LocalUserAccountLockoutStatus> UserLockoutPatchAsync(LocalUserAccountLockoutConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/lockout";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LocalUserAccountLockoutStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reset the TOTP for the given user
		/// Reset the TOTP settings to the default disabled state for the specified user account.
		/// 
		/// User_idTotpConfigDelete user/{id}/totp/config
		/// </summary>
		/// <param name="id">The user account object ID.</param>
		public async Task User_idTotpConfigDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/totp/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Configure the TOTP secret for the given user
		/// Use this endpoint to configure the time-based one time password (TOTP) secret for a specified user account. The endpoint replaces an existing secret with the new one. The Rubrik cluster checks the secret against a one time password (OTP) to ensure validity.
		/// 
		/// User_idTotpConfigPut user/{id}/totp/config
		/// </summary>
		/// <param name="id">The user account object ID.</param>
		/// <param name="requestBody">The time-based one time password (TOTP) configuration.</param>
		public async Task User_idTotpConfigPutAsync(string id, TotpConfigUpdateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/totp/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Generate a TOTP secret key for the given user
		/// Use this endpoint to generate the time-based one time password (TOTP) secret key for a specified user account. The secret is a key value encoded in Base32 and includes a URI for generating a scannable QR code.
		/// 
		/// User_idTotpNew_secretPost user/{id}/totp/new_secret
		/// </summary>
		/// <param name="id">The user account object ID.</param>
		/// <returns>Successfully generated TOTP secret.</returns>
		public async Task<TotpSecret> User_idTotpNew_secretPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/totp/new_secret";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TotpSecret>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the TOTP status for the given user
		/// Get the time-based one time password (TOTP) status for a specified user account. The TOTP status specifies whether that account has TOTP enabled and whether TOTP is being enforced for that account.
		/// 
		/// User_idTotpStatusGet user/{id}/totp/status
		/// </summary>
		/// <param name="id">The user account object ID.</param>
		/// <returns>The TOTP status of the user.
		///</returns>
		public async Task<TotpStatus> User_idTotpStatusGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/totp/status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TotpStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unlock a user account
		/// Unlock a user account that has been locked because of too many failed login attempts.
		/// User_idUnlockPost user/{id}/unlock
		/// </summary>
		/// <param name="id">The ID of the user account that has been locked.</param>
		public async Task User_idUnlockPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/unlock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a list of user-defined resource tags
		/// Delete a list of user-defined resource tags in one delete operation.
		/// 
		/// User_defined_tagDeleteByIds user_defined_tag
		/// </summary>
		/// <param name="ids">An array of IDs of the user-defined resource tags to be deleted. Any non-existent ID in the array will be ignored.
		///</param>
		/// <returns>Return a list of IDs that were deleted successfully.</returns>
		public async Task<ResourceTagDeleteResponse> User_defined_tagDeleteByIdsAsync(string[] ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user_defined_tag?"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceTagDeleteResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get user-defined resource tags
		/// Get user-defined resource tags for the cloud compute resources created by CloudOn and CloudOut.
		/// 
		/// User_defined_tagGetByKeyAndScope_ref_id user_defined_tag
		/// </summary>
		/// <param name="key">Filter results by resource tag.</param>
		/// <param name="scope_ref_id">Filter results by archival location id.</param>
		/// <returns>List of user-defined resource tags.</returns>
		public async Task<ResourceTagGetResponse> User_defined_tagGetByKeyAndScope_ref_idAsync(string key, string scope_ref_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user_defined_tag?key=" + (key==null? "" : System.Uri.EscapeDataString(key))+"&scope_ref_id=" + (scope_ref_id==null? "" : System.Uri.EscapeDataString(scope_ref_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceTagGetResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a user-defined resource tag for tagging cloud compute resources
		/// Create a user-defined resource tag for tagging cloud compute resources created by CloudOn and CloutOut.
		/// 
		/// User_defined_tagPost user_defined_tag
		/// </summary>
		/// <param name="requestBody">The definition of a new user-defined resource tag to be created.
		///</param>
		/// <returns>Return the successfully created ResourceTag details.</returns>
		public async Task<ResourceTagDetail> User_defined_tagPostAsync(ResourceTagDefinition requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user_defined_tag";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceTagDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a user-defined resource tag
		/// Delete a user-defined resource tag.
		/// User_defined_tag_idDelete user_defined_tag/{id}
		/// </summary>
		/// <param name="id">ID of the user-defined resource tag.</param>
		public async Task User_defined_tag_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user_defined_tag/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get user-defined tag
		/// Retrieve details of a user-defined resource tag.
		/// User_defined_tag_idGet user_defined_tag/{id}
		/// </summary>
		/// <param name="id">ID of the user-defined resource tag.</param>
		/// <returns>resource tag detail.</returns>
		public async Task<ResourceTagDetail> User_defined_tag_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user_defined_tag/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceTagDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the value of a user-defined resource tag
		/// Update the value of a user-defined resource tag.
		/// 
		/// User_defined_tag_idPatch user_defined_tag/{id}
		/// </summary>
		/// <param name="id">ID of the user-defined resource tag.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Updated resource tag detail.</returns>
		public async Task<ResourceTagDetail> User_defined_tag_idPatchAsync(string id, ResourceTagUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user_defined_tag/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceTagDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary for all vCD Clusters
		/// Retrieve summary information for all vCD cluster objects.
		/// VcdClusterGetByNameAndStatusAndSort_byAndSort_order vcd/cluster
		/// </summary>
		/// <param name="name">Search for a vCD Cluster object by name.</param>
		/// <param name="status">Filter the results using the status value of the vCD Cluster objects.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Order for sorting the results, either ascending or descending.</param>
		/// <returns>Summary information for vCD clusters.</returns>
		public async Task<VcdClusterSummaryListResponse> VcdClusterGetByNameAndStatusAndSort_byAndSort_orderAsync(string name, RefreshableObjectConnectionStatusStatus status, VcdClusterListSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/cluster?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&status=" + status+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdClusterSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a vCD Cluster
		/// Create a vCD Cluster object by providing the address of the vCD Cluster and the credentials for an account on the vCD Cluster that has administrator privileges. This request initiates an asynchronous job to connect with the vCD Cluster and retrieve the required metadata.
		/// VcdClusterPost vcd/cluster
		/// </summary>
		/// <param name="requestBody">IP address and account credentials of the vCD Cluster, and ID of the managing Rubrik cluster.</param>
		public async Task VcdClusterPostAsync(VcdClusterConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/cluster";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get vCD Cluster job status
		/// Retrieve the details of a specified asynchronous job for a vCD Cluster.
		/// VcdClusterRequest_idGet vcd/cluster/request/{id}
		/// </summary>
		/// <param name="id">ID assigned to an asynchronous job.</param>
		public async Task VcdClusterRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/cluster/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove vCD Cluster
		/// Start an asynchronous job to remove a vCD Cluster object.
		/// VcdCluster_idDelete vcd/cluster/{id}
		/// </summary>
		/// <param name="id">ID assigned to a vCD Cluster object.</param>
		public async Task VcdCluster_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vCD Cluster details
		/// Retrieve detailed information for a vCD Cluster object.
		/// VcdCluster_idGet vcd/cluster/{id}
		/// </summary>
		/// <param name="id">ID assigned to a vCD Cluster object.</param>
		/// <returns>Details for a vCD Cluster object.</returns>
		public async Task<VcdClusterDetail> VcdCluster_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdClusterDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Change vCD Cluster object
		/// Modify the hostname and credentials of a specified vCD Cluster object.
		/// VcdCluster_idPatch vcd/cluster/{id}
		/// </summary>
		/// <param name="id">ID assigned to a vCD Cluster object.</param>
		/// <param name="requestBody">Updated hostname and credentials for a specified vCD Cluster object.</param>
		/// <returns>Details of an updated vCD Cluster object.</returns>
		public async Task<VcdClusterDetail> VcdCluster_idPatchAsync(string id, VcdClusterPatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdClusterDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Refresh a vCD Cluster
		/// Start an asynchronous job to refresh the metadata for a specified vCD Cluster object.
		/// VcdCluster_idRefreshPost vcd/cluster/{id}/refresh
		/// </summary>
		/// <param name="id">ID assigned to a vCD Cluster object.</param>
		public async Task VcdCluster_idRefreshPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/refresh";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get VimServers of a vCD Cluster
		/// Retrieves the VimServer representation of the vCenter Servers that are attached to a specified vCD Cluster object.
		/// VcdCluster_idVimserverGetBySort_byAndSort_order vcd/cluster/{id}/vimserver
		/// </summary>
		/// <param name="id">ID assigned to a vCD Cluster object.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Order for sorting the results, either ascending or descending.</param>
		/// <returns>Summary information for VimServer objects.</returns>
		public async Task<VimserverSummaryListResponse> VcdCluster_idVimserverGetBySort_byAndSort_orderAsync(string id, VcdClusterListSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/vimserver&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VimserverSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary of a vCD hierarchy object
		/// Retrieve details for the specified object in the vCD hierarchy.
		/// VcdHierarchy_idGet vcd/hierarchy/{id}
		/// </summary>
		/// <param name="id">ID of the vCD hierarchy object.</param>
		/// <returns>Details of the hierarchy object.</returns>
		public async Task<VcdHierarchyObjectSummary> VcdHierarchy_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdHierarchyObjectSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get immediate descendant objects
		/// Retrieve the list of immediate descendant objects for the specified parent.
		/// VcdHierarchy_idChildrenGetBySort_byAndSort_orderAndLimitAndOffsetAndNameAndIs_relicAndEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndSla_assignmentAndSnappable_status vcd/hierarchy/{id}/children
		/// </summary>
		/// <param name="id">ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Order for sorting the results, either ascending or descending.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Number of matches to ignore from the beginning of the results.</param>
		/// <param name="name">Search object by object name.</param>
		/// <param name="is_relic">Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic children when this value is not specified.</param>
		/// <param name="effective_sla_domain_id">Filter by ID of effective SLA domain.</param>
		/// <param name="object_type">Filter by node object type.</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="sla_assignment">Filter by SLA assignment type.</param>
		/// <param name="snappable_status">Filters vCD hierarchy objects based on the specified query value.</param>
		/// <returns>Summary list of immediate descendant objects.</returns>
		public async Task<VcdHierarchyObjectSummaryListResponse> VcdHierarchy_idChildrenGetBySort_byAndSort_orderAndLimitAndOffsetAndNameAndIs_relicAndEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndSla_assignmentAndSnappable_statusAsync(string id, VcdHierarchyObjectSortAttribute sort_by, SortOrder sort_order, int limit, int offset, string name, bool is_relic, string effective_sla_domain_id, VcdHierarchyObjectSummaryObjectType object_type, string primary_cluster_id, SlaAssignment sla_assignment, SnappablePrivilegeStatus snappable_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/children&sort_by=" + sort_by+"&sort_order=" + sort_order+"&limit="+limit+"&offset="+offset+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&is_relic="+is_relic+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&object_type=" + object_type+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&sla_assignment=" + sla_assignment+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdHierarchyObjectSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of descendant objects
		/// Retrieve the list of descendant objects for the specified parent.
		/// VcdHierarchy_idDescendantsGetBySort_byAndSort_orderAndLimitAndOffsetAndNameAndIs_relicAndEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndSla_assignmentAndSnappable_status vcd/hierarchy/{id}/descendants
		/// </summary>
		/// <param name="id">ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.</param>
		/// <param name="sort_by">Attribute to sort the results on.</param>
		/// <param name="sort_order">Order for sorting the results, either ascending or descending.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Ignore these many matches in the beginning.</param>
		/// <param name="name">Search object by object name.</param>
		/// <param name="is_relic">Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic descendants if this query is not set.</param>
		/// <param name="effective_sla_domain_id">Filter by ID of effective SLA domain.</param>
		/// <param name="object_type">Filter by node object type.</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="sla_assignment">Filter by SLA assignment type.</param>
		/// <param name="snappable_status">Filters vCD hierarchy objects based on the specified query value.</param>
		/// <returns>Summary list of descendant objects.</returns>
		public async Task<VcdHierarchyObjectSummaryListResponse> VcdHierarchy_idDescendantsGetBySort_byAndSort_orderAndLimitAndOffsetAndNameAndIs_relicAndEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndSla_assignmentAndSnappable_statusAsync(string id, VcdHierarchyObjectSortAttribute sort_by, SortOrder sort_order, int limit, int offset, string name, bool is_relic, string effective_sla_domain_id, VcdHierarchyObjectSummaryObjectType object_type, string primary_cluster_id, SlaAssignment sla_assignment, SnappablePrivilegeStatus snappable_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/descendants&sort_by=" + sort_by+"&sort_order=" + sort_order+"&limit="+limit+"&offset="+offset+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&is_relic="+is_relic+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&object_type=" + object_type+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&sla_assignment=" + sla_assignment+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdHierarchyObjectSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary for vApps
		/// Retrieve summary information for all vCD vApp objects.
		/// VcdVappGetBySort_byAndSort_orderAndLimitAndOffsetAndNameAndIs_relicAndEffective_sla_domain_idAndPrimary_cluster_idAndSla_assignmentAndInclude_backup_task_info vcd/vapp
		/// </summary>
		/// <param name="sort_by">Attribute to sort the vCD vApp list on.</param>
		/// <param name="sort_order">Order for sorting the results, either ascending or descending.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Number of matches to ignore from the beginning of the results.</param>
		/// <param name="name">Search for a vCD vApp object by name.</param>
		/// <param name="is_relic">Filter by isRelic field of vCD vApp object. Return both relic and non-relic vApps when this value is not specified.</param>
		/// <param name="effective_sla_domain_id">Filter by ID of the effective SLA domain.</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="sla_assignment">Filter by SLA assignment type.</param>
		/// <param name="include_backup_task_info">Include backup task information in response.</param>
		/// <returns>Summary information for vCD vApps.</returns>
		public async Task<VcdVappSummaryListResponse> VcdVappGetBySort_byAndSort_orderAndLimitAndOffsetAndNameAndIs_relicAndEffective_sla_domain_idAndPrimary_cluster_idAndSla_assignmentAndInclude_backup_task_infoAsync(VcdVappObjectSortAttribute sort_by, SortOrder sort_order, int limit, int offset, string name, bool is_relic, string effective_sla_domain_id, string primary_cluster_id, SlaAssignment sla_assignment, bool include_backup_task_info, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp?sort_by=" + sort_by+"&sort_order=" + sort_order+"&limit="+limit+"&offset="+offset+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&is_relic="+is_relic+"&effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&sla_assignment=" + sla_assignment+"&include_backup_task_info="+include_backup_task_info;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdVappSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vApp job status
		/// Retrieve the details of a specified asynchronous job for a vApp.
		/// VcdVappRequest_idGet vcd/vapp/request/{id}
		/// </summary>
		/// <param name="id">ID assigned to an asynchronous job.</param>
		public async Task VcdVappRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a vApp snapshot
		/// Designate a vApp snapshot as expired and available for garbage collection. The snapshot must be an on-demand snapshot or a snapshot from a vApp that is not assigned to an SLA Domain.
		/// VcdVappSnapshot_idDeleteByLocation vcd/vapp/snapshot/{id}
		/// </summary>
		/// <param name="id">ID assigned to a snapshot object.</param>
		/// <param name="location">Location of the snapshot to delete. Use _local_ to delete only the local copy of the snapshot. Use _all_ to delete the snapshot locally, on a replication target, and at an archival location.</param>
		public async Task VcdVappSnapshot_idDeleteByLocationAsync(string id, FilesetSnapshot_idDeleteByLocationLocation location, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&location=" + location;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vApp snapshot details
		/// Retrieve detailed information about a specified snapshot for a vApp object.
		/// VcdVappSnapshot_idGet vcd/vapp/snapshot/{id}
		/// </summary>
		/// <param name="id">ID assigned to a snapshot object.</param>
		/// <returns>Details for a vApp snapshot.</returns>
		public async Task<VcdVappSnapshotDetail> VcdVappSnapshot_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdVappSnapshotDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download snapshot from archive
		/// Provides a method for retrieving a snapshot that is not available locally, from an archival location.
		/// VcdVappSnapshot_idDownloadPost vcd/vapp/snapshot/{id}/download
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		public async Task VcdVappSnapshot_idDownloadPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Export vApp snapshot
		/// Export the specified vApp snapshot into a new vApp or an existing vApp.
		/// VcdVappSnapshot_snapshot_idExportPost vcd/vapp/snapshot/{snapshot_id}/export
		/// </summary>
		/// <param name="snapshot_id">ID assigned to the vApp snapshot object.</param>
		/// <param name="requestBody">Configuration for the request to export the specified vApp snapshot.</param>
		public async Task VcdVappSnapshot_snapshot_idExportPostAsync(string snapshot_id, VappExportSnapshotJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/snapshot/"+ (snapshot_id==null? "" : System.Uri.EscapeDataString(snapshot_id))+"/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get exportable network configurations
		/// Retrieve summary information for the vApp networks that are available for network connections from the virtual machines in the exported vApp snapshot. The summary also specifies the default vApp network for each virtual machine network connection.
		/// VcdVappSnapshot_snapshot_idExportOptionsGetByExport_modeAndTarget_vapp_idAndTarget_org_vdc_id vcd/vapp/snapshot/{snapshot_id}/export/options
		/// </summary>
		/// <param name="snapshot_id">ID assigned to the vApp snapshot object to export.</param>
		/// <param name="export_mode">Target type for the specified vApp export.</param>
		/// <param name="target_vapp_id">ID assigned to the target vApp object, when the export is into an existing vApp. When the export is not into a target vApp, remove the 'target_vapp_id' member.</param>
		/// <param name="target_org_vdc_id">ID assigned to a target organization VDC object. Use the ID when exporting a vApp snapshot to create a new vApp on the specified target organization VDC. When the exported vApp snapshot is not used to create a new vApp on a target organization VDC, remove the 'target_org_vdc_id' member.</param>
		/// <returns>vApp snapshot export options.</returns>
		public async Task<VappExportOptions> VcdVappSnapshot_snapshot_idExportOptionsGetByExport_modeAndTarget_vapp_idAndTarget_org_vdc_idAsync(string snapshot_id, VappExportMode export_mode, string target_vapp_id, string target_org_vdc_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/snapshot/"+ (snapshot_id==null? "" : System.Uri.EscapeDataString(snapshot_id))+"/export/options&export_mode=" + export_mode+"&target_vapp_id=" + (target_vapp_id==null? "" : System.Uri.EscapeDataString(target_vapp_id))+"&target_org_vdc_id=" + (target_org_vdc_id==null? "" : System.Uri.EscapeDataString(target_org_vdc_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VappExportOptions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Instant Recovery of vApp virtual machines
		/// Use Instant Recovery to recover specified vApp virtual machines.
		/// VcdVappSnapshot_snapshot_idInstant_recoverPost vcd/vapp/snapshot/{snapshot_id}/instant_recover
		/// </summary>
		/// <param name="snapshot_id">ID assigned to the vApp snapshot object.</param>
		/// <param name="requestBody">Configuration for a request to recover specified virtual machines from a vApp snapshot.</param>
		public async Task VcdVappSnapshot_snapshot_idInstant_recoverPostAsync(string snapshot_id, VappInstantRecoveryJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/snapshot/"+ (snapshot_id==null? "" : System.Uri.EscapeDataString(snapshot_id))+"/instant_recover";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Instant Recovery information
		/// Retrieve the available vApp network connections and the default vApp network connection for the virtual machines in a vApp snapshot. Use this information to configure an Instant Recovery of specified virtual machines in the vApp snapshot.
		/// VcdVappSnapshot_snapshot_idInstant_recoverOptionsGet vcd/vapp/snapshot/{snapshot_id}/instant_recover/options
		/// </summary>
		/// <param name="snapshot_id">ID assigned to a vApp snapshot object.</param>
		/// <returns>vApp Instant Recovery options.</returns>
		public async Task<VappInstantRecoveryOptions> VcdVappSnapshot_snapshot_idInstant_recoverOptionsGetAsync(string snapshot_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/snapshot/"+ (snapshot_id==null? "" : System.Uri.EscapeDataString(snapshot_id))+"/instant_recover/options";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VappInstantRecoveryOptions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Export of a vApp template snapshot
		/// Export a vApp template snapashot to a catalog. Use the options endpoint to confirm that exporting to the catalog defaults or the original organization vDC storage profile is possible.
		/// VcdVappTemplateSnapshot_snapshot_idExportPost vcd/vapp/template/snapshot/{snapshot_id}/export
		/// </summary>
		/// <param name="snapshot_id">ID assigned to a vApp snapshot object.</param>
		/// <param name="requestBody">Configuration for a request to export a vApp template snapshot to a specific catalog.</param>
		public async Task VcdVappTemplateSnapshot_snapshot_idExportPostAsync(string snapshot_id, VappTemplateExportJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/template/snapshot/"+ (snapshot_id==null? "" : System.Uri.EscapeDataString(snapshot_id))+"/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Export information for a vApp template snapshot
		/// Retrieve the available choices vApp template storage profile and organization vDC choices in case of exporting to either original organization vDC defaults of the target catalog. In case advanced option of manually deciding org vdc is preferred, this also provides available storage profile choices.
		/// VcdVappTemplateSnapshot_snapshot_idExportOptionsGetByCatalog_idAndNameAndOrg_vdc_id vcd/vapp/template/snapshot/{snapshot_id}/export/options
		/// </summary>
		/// <param name="snapshot_id">ID assigned to a vApp snapshot object.</param>
		/// <param name="catalog_id">ID of the target catalog object.</param>
		/// <param name="name">Name of template object to create. This is used to verify the existence of a template with the given name. Templates must have unique names.</param>
		/// <param name="org_vdc_id">ID assigned to a target organization vDC object. Use the ID when exporting a vApp template snapshot to a specified organization VDC. This ID is used to fetch the avaiable choices to pick the storage profile of the template. Leave this field empty to use the options from the original organization vDC or the target catalog defaults.</param>
		/// <returns>vApp template snapshot export options.</returns>
		public async Task<VappTemplateExportOptionsUnion> VcdVappTemplateSnapshot_snapshot_idExportOptionsGetByCatalog_idAndNameAndOrg_vdc_idAsync(string snapshot_id, string catalog_id, string name, string org_vdc_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/template/snapshot/"+ (snapshot_id==null? "" : System.Uri.EscapeDataString(snapshot_id))+"/export/options&catalog_id=" + (catalog_id==null? "" : System.Uri.EscapeDataString(catalog_id))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&org_vdc_id=" + (org_vdc_id==null? "" : System.Uri.EscapeDataString(org_vdc_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VappTemplateExportOptionsUnion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get details of a specific vApp
		/// Retrieve detailed information for a specified vApp.
		/// VcdVapp_idGet vcd/vapp/{id}
		/// </summary>
		/// <param name="id">ID assigned to a vApp object.</param>
		/// <returns>Detailed information about a vApp object.</returns>
		public async Task<VcdVappDetail> VcdVapp_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdVappDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update vApp
		/// Make changes to the parameters of a specified vApp object.
		/// VcdVapp_idPatch vcd/vapp/{id}
		/// </summary>
		/// <param name="id">ID assigned to a vApp object.</param>
		/// <param name="requestBody">Parameters to use to update the specified vApp object.</param>
		/// <returns>Details of an updated vApp object.</returns>
		public async Task<VcdVappDetail> VcdVapp_idPatchAsync(string id, VcdVappPatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdVappDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get details about missed snapshots for a vApp
		/// Retrieve the timestamp for each missed snapshot for a specified vApp.
		/// VcdVapp_idMissed_snapshotGet vcd/vapp/{id}/missed_snapshot
		/// </summary>
		/// <param name="id">ID of the vApp.</param>
		/// <returns>Details for missed snapshots for a vApp.</returns>
		public async Task<MissedSnapshotListResponse> VcdVapp_idMissed_snapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/missed_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MissedSnapshotListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for a file in a vApp
		/// Aggregated search for a file through snapshots of all virtual machines that are presently part of the vApp. Specify the file using a full path prefix or a filename prefix.
		/// VcdVapp_idSearchGetByPath vcd/vapp/{id}/search
		/// </summary>
		/// <param name="id">ID of the vApp.</param>
		/// <param name="path">The path query. Use either a path prefix or a filename prefix.</param>
		/// <returns>File search results.</returns>
		public async Task<AppSearchResponseListResponse> VcdVapp_idSearchGetByPathAsync(string id, string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/search&path=" + (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AppSearchResponseListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all snapshots of vApp
		/// Delete all snapshots for a specified vApp object.
		/// VcdVapp_idSnapshotDelete vcd/vapp/{id}/snapshot
		/// </summary>
		/// <param name="id">ID assigned to a vApp object.</param>
		public async Task VcdVapp_idSnapshotDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of snapshots of vApp
		/// Retrieve summary information for each of the snapshot objects of a specified vApp object.
		/// VcdVapp_idSnapshotGet vcd/vapp/{id}/snapshot
		/// </summary>
		/// <param name="id">ID assigned to a vApp object.</param>
		/// <returns>Summary information for all snapshots for a vApp object.</returns>
		public async Task<VcdVappSnapshotSummaryListResponse> VcdVapp_idSnapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcdVappSnapshotSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an on-demand snapshot for a vApp
		/// Start an asynchronous job to create an on-demand snapshot for a specified vApp object.
		/// VcdVapp_idSnapshotPost vcd/vapp/{id}/snapshot
		/// </summary>
		/// <param name="id">ID assigned to a vApp object.</param>
		/// <param name="requestBody">Configuration for the on-demand backup of a specified vApp object.</param>
		public async Task VcdVapp_idSnapshotPostAsync(string id, BaseOnDemandSnapshotConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vcd/vapp/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all the clusters belonging to this datacenter
		/// Get all the clusters belonging to this datacenter.
		/// VmwareCompute_clusterGetByDatacenter_idAndPrimary_cluster_idAndSnappable_status vmware/compute_cluster
		/// </summary>
		/// <param name="datacenter_id">Filter clusters on data center ID.</param>
		/// <param name="primary_cluster_id">Filter on a primary cluster ID. Also accepts value 'local'.</param>
		/// <param name="snappable_status">Determines whether to fetch Compute Clusters with additional privilege checks.</param>
		/// <returns>Returns list of compute clusters subject to provided filters.</returns>
		public async Task<ComputeClusterSummaryListResponse> VmwareCompute_clusterGetByDatacenter_idAndPrimary_cluster_idAndSnappable_statusAsync(string datacenter_id, string primary_cluster_id, SnappablePrivilegeStatus snappable_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/compute_cluster?datacenter_id=" + (datacenter_id==null? "" : System.Uri.EscapeDataString(datacenter_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ComputeClusterSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get asynchronous request details for VMware cluster
		/// Get the details of an asynchronous request that involves a VMware compute cluster.
		/// VmwareCompute_clusterRequest_idGet vmware/compute_cluster/request/{id}
		/// </summary>
		/// <param name="id">ID of an asynchronous request.</param>
		/// <returns>Status of an asynchronous request.</returns>
		public async Task<AsyncRequestStatus> VmwareCompute_clusterRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/compute_cluster/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get details for the compute cluster
		/// Get details for the compute cluster.
		/// VmwareCompute_cluster_idGet vmware/compute_cluster/{id}
		/// </summary>
		/// <param name="id">ID of the compute cluster.</param>
		/// <returns>Details of the requested compute cluster.</returns>
		public async Task<ComputeClusterDetail> VmwareCompute_cluster_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/compute_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ComputeClusterDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify information for a VMware compute cluster
		/// Update the configuredSlaDomainId for a VMware compute cluster with a specific ID.
		/// VmwareCompute_cluster_idPatch vmware/compute_cluster/{id}
		/// </summary>
		/// <param name="id">ID of the compute cluster.</param>
		/// <param name="requestBody">Object with changes for the Compute Cluster information.</param>
		/// <returns>Details of the updated compute cluster.</returns>
		public async Task<ComputeClusterDetail> VmwareCompute_cluster_idPatchAsync(string id, ComputeClusterUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/compute_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ComputeClusterDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Install the Rubrik ioFilter to the VMware cluster with a specific ID
		/// Install the latest version of Rubrik ioFilter to the VMware cluster with a specific ID. The cluster must be in maintenance mode to install the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above.
		/// VmwareCompute_cluster_idInstall_io_filterPost vmware/compute_cluster/{id}/install_io_filter
		/// </summary>
		/// <param name="id">ID of the VMware compute cluster.</param>
		public async Task VmwareCompute_cluster_idInstall_io_filterPostAsync(string id, FullyQualifiedDomainNameInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/compute_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/install_io_filter";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the ioFilters on the VMware compute cluster with a specific ID
		/// Get the summary of the ioFilters on the VMware compute cluster with a specific ID.
		/// VmwareCompute_cluster_idIo_filterGet vmware/compute_cluster/{id}/io_filter
		/// </summary>
		/// <param name="id">ID of the VMware compute cluster.</param>
		/// <returns>List of the ioFilters on the VMware compute cluster.</returns>
		public async Task<IoFilterSummaryListResponse> VmwareCompute_cluster_idIo_filterGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/compute_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/io_filter";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IoFilterSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Uninstall the Rubrik ioFilter from the VMware cluster with a specific ID
		/// Uninstall the Rubrik ioFilter from the VMware cluster with a specific ID. The cluster must be in maintenance mode to uninstall the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above.
		/// VmwareCompute_cluster_idUninstall_io_filterPost vmware/compute_cluster/{id}/uninstall_io_filter
		/// </summary>
		/// <param name="id">ID of the VMware compute cluster.</param>
		public async Task VmwareCompute_cluster_idUninstall_io_filterPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/compute_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/uninstall_io_filter";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Upgrade the Rubrik ioFilter for the VMware cluster with a specific ID
		/// Upgrade the Rubrik ioFilter for a VMware cluster with a specific ID. The cluster must be in maintenance mode to upgrade the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above.
		/// VmwareCompute_cluster_idUpgrade_io_filterPost vmware/compute_cluster/{id}/upgrade_io_filter
		/// </summary>
		/// <param name="id">ID of the VMware compute cluster.</param>
		public async Task VmwareCompute_cluster_idUpgrade_io_filterPostAsync(string id, FullyQualifiedDomainNameInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/compute_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/upgrade_io_filter";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the current preference of CDM between IPv4 and IPv6 for CDP data transfer
		/// Returns the current preference of CDM between IPv4 and IPv6 for CDP data transfer.
		/// VmwareConfigCdpGet_preferred_cdp_network_protocolGet vmware/config/cdp/get_preferred_cdp_network_protocol
		/// </summary>
		/// <returns>The preferred network protocol to use for transferring CDP data.</returns>
		public async Task<PreferredCdpNetworkProtocolObject> VmwareConfigCdpGet_preferred_cdp_network_protocolGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/config/cdp/get_preferred_cdp_network_protocol";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PreferredCdpNetworkProtocolObject>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the current preference of CDM between IPv4 and IPv6 for CDP data transfer
		/// Set the current preference of CDM between IPv4 and IPv6 for CDP data transfer.
		/// VmwareConfigCdpSet_preferred_cdp_network_protocolPatch vmware/config/cdp/set_preferred_cdp_network_protocol
		/// </summary>
		/// <param name="requestBody">The preferred network protocol to use for transferring CDP data.</param>
		/// <returns>The updated preferred network protocol to transfer CDP data over.</returns>
		public async Task<PreferredCdpNetworkProtocolObject> VmwareConfigCdpSet_preferred_cdp_network_protocolPatchAsync(PreferredCdpNetworkProtocol requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/config/cdp/set_preferred_cdp_network_protocol";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PreferredCdpNetworkProtocolObject>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all the VMware recovery networks for a compute resource ID
		/// Get all the networks for snapshot recovery for the specified compute resource.
		/// VmwareConfigRecoveryNetworksGetByCompute_resource_idAndCompute_resource_type vmware/config/recovery/networks
		/// </summary>
		/// <param name="compute_resource_id">Get VMware recovery networks for the compute resource ID.</param>
		/// <param name="compute_resource_type">The type of the compute resource.</param>
		/// <returns>All the VMware networks for the compute resource.</returns>
		public async Task<VmwareNetworkCollection> VmwareConfigRecoveryNetworksGetByCompute_resource_idAndCompute_resource_typeAsync(string compute_resource_id, VmwareHierarchyInfoObjectType compute_resource_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/config/recovery/networks?compute_resource_id=" + (compute_resource_id==null? "" : System.Uri.EscapeDataString(compute_resource_id))+"&compute_resource_type=" + compute_resource_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareNetworkCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Available VMware Hierarchy Objects for Export Operations
		/// Get VMware Clusters, Hosts, and Resource Pool hierarchy objects that are available as the target for Virtual Machine Export operations.
		/// VmwareHierarchyExportGetByRoot_id vmware/hierarchy/export
		/// </summary>
		/// <param name="root_id">Get child objects of given root ID.</param>
		/// <returns>Information about Child Hierarchy Objects of Root.</returns>
		public async Task<VmwareHierarchyInfoListResponse> VmwareHierarchyExportGetByRoot_idAsync(string root_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/hierarchy/export?root_id=" + (root_id==null? "" : System.Uri.EscapeDataString(root_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareHierarchyInfoListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get VMware Hierarchy Object Information
		/// Get VMware Clusters, Hosts, and Resource Pool hierarchy object detail information by object ID.
		/// VmwareHierarchy_idExportGet vmware/hierarchy/{id}/export
		/// </summary>
		/// <param name="id">Get VMware hierarchy objects of given ID.</param>
		/// <returns>VMware hierarchy object details.</returns>
		public async Task<VmwareHierarchyInfo> VmwareHierarchy_idExportGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/hierarchy/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareHierarchyInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary of all the ESXi hypervisor
		/// Get summary of all the ESXi hypervisor.
		/// VmwareHostGetByPrimary_cluster_idAndCompute_cluster_idAndSnappable_status vmware/host
		/// </summary>
		/// <param name="primary_cluster_id">ID of the Primary cluster.</param>
		/// <param name="compute_cluster_id">Filter by ID of Compute Cluster.</param>
		/// <param name="snappable_status">Requests additional data about VMware Hosts based on the specified query value.</param>
		/// <returns>List of VMware host summaries.</returns>
		public async Task<VmwareHostSummaryListResponse> VmwareHostGetByPrimary_cluster_idAndCompute_cluster_idAndSnappable_statusAsync(string primary_cluster_id, string compute_cluster_id, SnappablePrivilegeStatus snappable_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/host?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&compute_cluster_id=" + (compute_cluster_id==null? "" : System.Uri.EscapeDataString(compute_cluster_id))+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareHostSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get details of a ESXi hypervisor
		/// Get details of a ESXi hypervisor.
		/// VmwareHost_idGet vmware/host/{id}
		/// </summary>
		/// <param name="id">ID of the VMWare host.</param>
		/// <returns>Details about the vmware host.</returns>
		public async Task<VmwareHostDetail> VmwareHost_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/host/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareHostDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the SLA Domain for an ESXi hypervisor
		/// Update the SLA Domain that is configured for an ESXi hypervisor.
		/// VmwareHost_idPatch vmware/host/{id}
		/// </summary>
		/// <param name="id">ID of the ESXi hypervisor.</param>
		/// <param name="requestBody">Object with changes for the ESXi hypervisor information.</param>
		/// <returns>Details for the ESXi hypervisor.</returns>
		public async Task<VmwareHostDetail> VmwareHost_idPatchAsync(string id, VmwareHostUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/host/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareHostDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get details of datastores in a ESXi hypervisor
		/// Get details of datastores in a ESXi hypervisor.
		/// VmwareHost_idDatastoreGet vmware/host/{id}/datastore
		/// </summary>
		/// <param name="id">ID of the VMWare host.</param>
		/// <returns>Details about the vmware host.</returns>
		public async Task<VmwareHostDatastoreDetail> VmwareHost_idDatastoreGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/host/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/datastore";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareHostDatastoreDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of vCenters
		/// Retrieve information for each managed vCenter, including: ID, managed ID, address, username, SLA ID, and primary cluster ID.
		/// VmwareVcenterGetByPrimary_cluster_idAndSnappable_statusAndIgnore_connection_status vmware/vcenter
		/// </summary>
		/// <param name="primary_cluster_id">Limits the information to the Rubrik cluster specified by the value of primary_cluster_id. Use 'local' for the Rubrik cluster that is hosting the current REST API session.</param>
		/// <param name="snappable_status">Determines whether to fetch vCenters with additional privilege checks.</param>
		/// <param name="ignore_connection_status">Don't ping vCenters for connection status. The connection_status field in the response is unusable.</param>
		/// <returns>Summary information for managed vCenters.</returns>
		public async Task<VcenterSummaryListResponse> VmwareVcenterGetByPrimary_cluster_idAndSnappable_statusAndIgnore_connection_statusAsync(string primary_cluster_id, SnappablePrivilegeStatus snappable_status, bool ignore_connection_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&snappable_status=" + snappable_status+"&ignore_connection_status="+ignore_connection_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcenterSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add vCenter Server
		/// (DEPRECATED) Create a vCenter Server object by providing the address and account credentials of the vCenter Server. Initiates an asynchronous job to establish a connection with the vCenter Server and retrieve all metadata. Use GET /vcenter/{id}/status to check status. The recommended endpoint is /v2/vmware/vcenter. This endpoint will remain available in future releases despite deprecation.
		/// VmwareVcenterPost vmware/vcenter
		/// </summary>
		/// <param name="requestBody">IP address and account credentials of the vCenter Server server, and ID of the managing Rubrik cluster.</param>
		public async Task VmwareVcenterPostAsync(VcenterConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a list of HotAdd proxy virtual machines
		/// Retrieve summary information for all HotAdd proxy virtual machines.
		/// VmwareVcenterHotaddVmGetByNameAndSort_byAndSort_order vmware/vcenter/hotadd/vm
		/// </summary>
		/// <param name="name">Limit the list information to HotAdd proxy virtual machines that match the specified HotAdd proxy virtual machine 'name' value.</param>
		/// <param name="sort_by">Attribute to use to sort the HotAdd proxy virtual machines summary information. Optionally use **_sort_order_** to specify whether to sort in ascending or descending order.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Summary information for HotAdd proxy virtual machines.</returns>
		public async Task<HotAddProxyVmInfoListResponse> VmwareVcenterHotaddVmGetByNameAndSort_byAndSort_orderAsync(string name, Failover_clusterGetByNameAndOperating_system_typeAndSla_assignmentAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/hotadd/vm?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HotAddProxyVmInfoListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vCenter Server async request
		/// Get details about a vcenter related async request.
		/// VmwareVcenterRequest_idGet vmware/vcenter/request/{id}
		/// </summary>
		/// <param name="id">ID of the request.</param>
		/// <returns>Status for the async request.</returns>
		public async Task<AsyncRequestStatus> VmwareVcenterRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove vCenter Server
		/// Initiates an asynchronous job to remove a vCenter Server object. The vCenter Server cannot have VMs mounted through the Rubrik cluster.
		/// VmwareVcenter_idDelete vmware/vcenter/{id}
		/// </summary>
		/// <param name="id">ID of the vCenter Server. to remove.</param>
		public async Task VmwareVcenter_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the details of a vCenter Server
		/// Retrieve detailed information for a vCenter Server object.
		/// VmwareVcenter_idGet vmware/vcenter/{id}
		/// </summary>
		/// <param name="id">ID of the vCenter Server.</param>
		/// <returns>Details for a vCenter Server object.</returns>
		public async Task<VcenterDetail> VmwareVcenter_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcenterDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the SLA Domain for a vCenter Server
		/// Update the SLA Domain that is configured for a vCenter Server.
		/// VmwareVcenter_idPatch vmware/vcenter/{id}
		/// </summary>
		/// <param name="id">ID of the vCenter Server.</param>
		/// <param name="requestBody">Object containing updated vCenter Server information.</param>
		/// <returns>Summary of the updated vCenter Server object.</returns>
		public async Task<VcenterSummary> VmwareVcenter_idPatchAsync(string id, VcenterPatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcenterSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update vCenter Server
		/// Update the address, username and password of the specified vCenter Server object.
		/// VmwareVcenter_idPut vmware/vcenter/{id}
		/// </summary>
		/// <param name="id">ID of the vCenter Server.</param>
		/// <param name="requestBody">Object containing updated vCenter Server information.</param>
		/// <returns>Summary of the updated vCenter Server object.</returns>
		public async Task<VcenterSummary> VmwareVcenter_idPutAsync(string id, VcenterConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VcenterSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the ingest and export bandwidth limits for HotAdd with the vCenter
		/// Get the ingest and export bandwidth limits in Mbps when using HotAdd with the vCenter. These limits are shared across all HotAdd proxies for the Center.
		/// VmwareVcenter_idHotaddBandwidthGet vmware/vcenter/{id}/hotadd/bandwidth
		/// </summary>
		/// <param name="id">The ID of the vCenter server from which to derive the number of proxies needed.</param>
		/// <returns>Ingest and export bandwidth limits for the vCenter.</returns>
		public async Task<HotAddBandwidthInfo> VmwareVcenter_idHotaddBandwidthGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/hotadd/bandwidth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HotAddBandwidthInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the ingest and export bandwidth limits for HotAdd with the vCenter
		/// Set the ingest and export bandwidth limits in Mbps when using HotAdd with the vCenter. These limits are shared across all HotAdd proxies for the Center.
		/// VmwareVcenter_idHotaddBandwidthPost vmware/vcenter/{id}/hotadd/bandwidth
		/// </summary>
		/// <param name="id">ID of the vCenter server upon which the Rubrik cluster is setting the HotAdd bandwidth limits.</param>
		/// <param name="requestBody">The ingest and export bandwidth limits for the vCenter.</param>
		public async Task VmwareVcenter_idHotaddBandwidthPostAsync(string id, HotAddBandwidthInfo requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/hotadd/bandwidth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the number of HotAdd proxies needed for the vCenter
		/// Get the number of HotAdd proxies that need to be deployed to the vCenter to support the maximum number of ingest jobs.
		/// VmwareVcenter_idHotaddNeededGet vmware/vcenter/{id}/hotadd/needed
		/// </summary>
		/// <param name="id">The ID of the vCenter server for which to get the number of proxies needed.</param>
		/// <returns>Number of HotAdd proxies needed for the vCenter.</returns>
		public async Task<HotAddProxiesNeededInfo> VmwareVcenter_idHotaddNeededGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/hotadd/needed";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HotAddProxiesNeededInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the user-configured network for HotAdd operations
		/// Retrieve the user-configured network for HotAdd backup and recovery operations on VMware on AWS.
		/// VmwareVcenter_idHotaddNetworkGet vmware/vcenter/{id}/hotadd/network
		/// </summary>
		/// <param name="id">ID of the vCenter server for which the Rubrik cluster is retrieving the configured HotAdd network information.</param>
		/// <returns>Configured network information for the HotAdd proxy virtual machines.</returns>
		public async Task<HotAddNetworkConfigWithName> VmwareVcenter_idHotaddNetworkGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/hotadd/network";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HotAddNetworkConfigWithName>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the user-configured network for HotAdd backup and recovery
		/// Set the user-configured network for HotAdd backup and recovery operations on VMware on AWS.
		/// VmwareVcenter_idHotaddNetworkPost vmware/vcenter/{id}/hotadd/network
		/// </summary>
		/// <param name="id">ID of the vCenter server for which the Rubrik cluster is setting the HotAdd network information.</param>
		/// <param name="requestBody">The information about a static IP address and user-configured vCenter network selected for HotAdd backup and recovery.</param>
		public async Task VmwareVcenter_idHotaddNetworkPostAsync(string id, HotAddNetworkConfigWithId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/hotadd/network";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the user-configured networks in the vCenter
		/// Get the names and IDs of the user configured networks in the vCenter. This information enables users to choose a desired network for backups to go through for VMware Cloud on AWS setups.
		/// VmwareVcenter_idNetworksGet vmware/vcenter/{id}/networks
		/// </summary>
		/// <param name="id">The ID of the vCenter server for which to retrieve user-configured networks.</param>
		/// <returns>List of network IDs and Names.</returns>
		public async Task<NetworkInfoListResponse> VmwareVcenter_idNetworksGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/networks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkInfoListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Refresh vCenter Server metadata
		/// Create a job to refresh the metadata for the specified vCenter Server.
		/// VmwareVcenter_idRefreshPost vmware/vcenter/{id}/refresh
		/// </summary>
		/// <param name="id">ID of the vCenter Server.</param>
		public async Task VmwareVcenter_idRefreshPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/refresh";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Refresh single virtual machine metadata in a vcenter
		/// Refresh the metadata for a single virtual machine controlled by vCenter.
		/// VmwareVcenter_idRefresh_vmPost vmware/vcenter/{id}/refresh_vm
		/// </summary>
		/// <param name="id">The ID of the vCenter server that controls the management of the virtual machine whose metadata will be refreshed.</param>
		/// <param name="requestBody">The vCenter managed object ID (MOID) of the virtual machine whose metadata will be refreshed.</param>
		public async Task VmwareVcenter_idRefresh_vmPostAsync(string id, string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vcenter/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/refresh_vm";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get list of VMs
		/// Get summary of all the VMs.
		/// VmwareVmGetByEffective_sla_domain_idAndPrimary_cluster_idAndLimitAndOffsetAndIs_relicAndNameAndMoidAndSla_assignmentAndGuest_os_nameAndSort_byAndSort_order vmware/vm
		/// </summary>
		/// <param name="effective_sla_domain_id">Filter by ID of effective SLA Domain.</param>
		/// <param name="primary_cluster_id">Filter by primary cluster ID, or **local**.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Ignore these many matches in the beginning.</param>
		/// <param name="is_relic">Filter by the isRelic field of the virtual machine. When this parameter is not set, return both relic and non-relic virtual machines.</param>
		/// <param name="name">Search by using a virtual machine name.</param>
		/// <param name="moid">Search by using a virtual machine managed object ID.</param>
		/// <param name="sla_assignment">Filter by SLA Domain assignment type.</param>
		/// <param name="guest_os_name">Filters by the name of operating system using infix search.</param>
		/// <param name="sort_by">Sort results based on the specified attribute.</param>
		/// <param name="sort_order">Sort order, either ascending or descending.</param>
		/// <returns>Virtual machine summary.</returns>
		public async Task<VirtualMachineSummaryListResponse> VmwareVmGetByEffective_sla_domain_idAndPrimary_cluster_idAndLimitAndOffsetAndIs_relicAndNameAndMoidAndSla_assignmentAndGuest_os_nameAndSort_byAndSort_orderAsync(string effective_sla_domain_id, string primary_cluster_id, int limit, int offset, bool is_relic, string name, string moid, SlaAssignment sla_assignment, string guest_os_name, VmwareVmGetByEffective_sla_domain_idAndPrimary_cluster_idAndLimitAndOffsetAndIs_relicAndNameAndMoidAndSla_assignmentAndGuest_os_nameAndSort_byAndSort_orderSort_by sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm?effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&limit="+limit+"&offset="+offset+"&is_relic="+is_relic+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&moid=" + (moid==null? "" : System.Uri.EscapeDataString(moid))+"&sla_assignment=" + sla_assignment+"&guest_os_name=" + (guest_os_name==null? "" : System.Uri.EscapeDataString(guest_os_name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Live mount a snapshot each from a set of virtual machines
		/// VmwareVmBatch_mountPost vmware/vm/batch_mount
		/// </summary>
		/// <param name="requestBody">Configuration object containing an array of virtual machine IDs, a way to indicate the snapshot to be chosen and mount configs.</param>
		public async Task VmwareVmBatch_mountPostAsync(BatchMountSnapshotJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/batch_mount";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the live CDP info for a set of CDP-enabled virtual machines
		/// VmwareVmCdpPost vmware/vm/cdp
		/// </summary>
		/// <param name="requestBody">The ID of each CDP-enabled virtual machine for which live info is being retrieved.</param>
		/// <returns>Returns the live CDP info for the CDP-enabled virtual machines.</returns>
		public async Task<BatchVmwareCdpLiveInfo> VmwareVmCdpPostAsync(string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/cdp";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchVmwareCdpLiveInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns CDP state info for a set of virtual machines
		/// VmwareVmCdp_statePost vmware/vm/cdp_state
		/// </summary>
		/// <param name="requestBody">The ID of each virtual machine for which CDP state info is being retrieved.</param>
		/// <returns>Returns CDP state info for the virtual machines.</returns>
		public async Task<BatchVmwareCdpStateInfo> VmwareVmCdp_statePostAsync(string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/cdp_state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchVmwareCdpStateInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Make this cluster the primary for agents on a set of VMs
		/// Migrate the primary cluster with which the agent is able to communicate. For disaster recovery when migrating everything over from another cluster, the /host/make_primary endpoint can be used with the oldPrimaryClusterUuid parameter.
		/// VmwareVmMake_primaryPost vmware/vm/make_primary
		/// </summary>
		/// <param name="requestBody">IDs of hosts to migrate.</param>
		public async Task VmwareVmMake_primaryPostAsync(string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/make_primary";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the recoverable ranges that were missed for a set of CDP-enabled virtual machines
		/// VmwareVmMissed_recoverable_rangePost vmware/vm/missed_recoverable_range
		/// </summary>
		/// <param name="requestBody">The batch request and the date ranges (optional) as a filter. The batch request includes the ID of each CDP-enabled virtual machine for which missed recoverable ranges are being retrieved.</param>
		/// <returns>Returns the missed recoverable ranges for a set of CDP-enabled virtual machines.</returns>
		public async Task<BatchVmwareVmMissedRecoverableRanges> VmwareVmMissed_recoverable_rangePostAsync(BatchVmwareVmMissedRecoverableRangesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/missed_recoverable_range";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchVmwareVmMissedRecoverableRanges>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the recoverable ranges for a set of CDP-enabled virtual machines
		/// VmwareVmRecoverable_rangePost vmware/vm/recoverable_range
		/// </summary>
		/// <param name="requestBody">The batch request, which includes the ID of each CDP-enabled virtual machine for which recoverable ranges are being retrieved, and optionally the date ranges as a filter.</param>
		/// <returns>Returns the recoverable ranges for a set of CDP-enabled virtual machines.</returns>
		public async Task<BatchVmwareVmRecoverableRanges> VmwareVmRecoverable_rangePostAsync(BatchVmwareVmRecoverableRangesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/recoverable_range";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchVmwareVmRecoverableRanges>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get asynchronous request details for VM
		/// Get the details of an asynchronous request that involves a VMware virtual machine.
		/// VmwareVmRequest_idGet vmware/vm/request/{id}
		/// </summary>
		/// <param name="id">ID of an asynchronous request.</param>
		/// <returns>Status of an asynchronous request.</returns>
		public async Task<AsyncRequestStatus> VmwareVmRequest_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/request/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AsyncRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Take an on-demand snapshot of multiple virtual machines
		/// Bulk operation of taking on-demand snapshot for given virtual machines.
		/// VmwareVmSnapshotBulkPost vmware/vm/snapshot/bulk
		/// </summary>
		/// <param name="requestBody">The IDs of the virtual machines for which to take an on-demand snapshot and the ID of the SLA Domain to assign to the resulting snapshot.</param>
		public async Task VmwareVmSnapshotBulkPostAsync(BulkOnDemandSnapshotJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Live Mount information
		/// Retrieve summary information about Live Mount activity.
		/// VmwareVmSnapshotMountGetByVm_idAndOffsetAndLimit vmware/vm/snapshot/mount
		/// </summary>
		/// <param name="vm_id">Filters information by virtual machine ID.</param>
		/// <param name="offset">Starting position in the list of Live Mount entries contained in the response. The summary information includes the specified numbered entry and all higher numbered entries. Use with **_limit_** to retrieve the summary information as smaller groups of entries, e.g. for paging of the results.</param>
		/// <param name="limit">Limit the summary information to a specified maximum number of entries. Optionally, use with **_offset_** to start the count at a specified point. Default is 25.</param>
		/// <returns>Summary information for all Live Mounts.</returns>
		public async Task<VmwareVmMountSummaryV1ListResponse> VmwareVmSnapshotMountGetByVm_idAndOffsetAndLimitAsync(string vm_id, int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/mount?vm_id=" + (vm_id==null? "" : System.Uri.EscapeDataString(vm_id))+"&offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareVmMountSummaryV1ListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a Live Mount VM
		/// Create a request to delete a Live Mount virtual machine.
		/// VmwareVmSnapshotMount_idDeleteByForce vmware/vm/snapshot/mount/{id}
		/// </summary>
		/// <param name="id">ID of a Live Mount.</param>
		/// <param name="force">Force unmount to remove metadata when the datastore of the Live Mount virtual machine was moved off of the Rubrik cluster.</param>
		public async Task VmwareVmSnapshotMount_idDeleteByForceAsync(string id, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/mount/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&force="+force;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information for a Live Mount
		/// Retrieve detailed information for a specified Live Mount.
		/// VmwareVmSnapshotMount_idGet vmware/vm/snapshot/mount/{id}
		/// </summary>
		/// <param name="id">ID of a Live Mount.</param>
		/// <returns>Detailed information for the specified Live Mount.</returns>
		public async Task<VmwareVmMountDetailV1> VmwareVmSnapshotMount_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/mount/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareVmMountDetailV1>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Power a Live Mount on and off
		/// Power a specified Live Mount virtual machine on or off. Pass **_true_** to power the virtual machine on and pass **_false_** to power the virtual machine off.
		/// VmwareVmSnapshotMount_idPatch vmware/vm/snapshot/mount/{id}
		/// </summary>
		/// <param name="id">ID of a Live Mount.</param>
		/// <param name="requestBody">Power state configuration.</param>
		/// <returns>Details of the Live Mount.</returns>
		public async Task<VmwareVmMountDetailV1> VmwareVmSnapshotMount_idPatchAsync(string id, UpdateMountConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/mount/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareVmMountDetailV1>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Relocate a virtual machine to another datastore
		/// Run storage VMotion to relocate a specified Live Mount into another data store.
		/// VmwareVmSnapshotMount_idRelocatePost vmware/vm/snapshot/mount/{id}/relocate
		/// </summary>
		/// <param name="id">ID of the live mount.</param>
		/// <param name="requestBody">Configuration for the RelocateMount request to another data store.</param>
		public async Task VmwareVmSnapshotMount_idRelocatePostAsync(string id, RelocateMountConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/mount/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/relocate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete VM snapshot
		/// Designate a snapshot as expired and available for garbage collection. The snapshot must be an on-demand snapshot or a snapshot from a virtual machine that is not assigned to an SLA Domain.
		/// VmwareVmSnapshot_idDeleteByLocation vmware/vm/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="location">Location of the snapshot. Use **_local_** to delete only the local copy of the snapshot. Or use **_all_** to delete the snapshot locally, on a replication target, and at an archival location.</param>
		public async Task VmwareVmSnapshot_idDeleteByLocationAsync(string id, FilesetSnapshot_idDeleteByLocationLocation location, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&location=" + location;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get VM snapshot details
		/// Retrieve detailed information about a virtual machine snapshot.
		/// VmwareVmSnapshot_idGet vmware/vm/snapshot/{id}
		/// </summary>
		/// <param name="id">ID of a snapshot.</param>
		/// <returns>Snapshot details.</returns>
		public async Task<VmSnapshotDetail> VmwareVmSnapshot_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmSnapshotDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List files in VM snapshot
		/// For a virtual machine snapshot, list the directories and files that are beneath a specified file system path.
		/// VmwareVmSnapshot_idBrowseGetByPathAndOffsetAndLimit vmware/vm/snapshot/{id}/browse
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		/// <param name="path">The absolute path of the starting point for the directory listing.</param>
		/// <param name="offset">Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries.</param>
		/// <param name="limit">Maximum number of entries in the response.</param>
		/// <returns>List of files and directories at the specified path.</returns>
		public async Task<BrowseResponseListResponse> VmwareVmSnapshot_idBrowseGetByPathAndOffsetAndLimitAsync(string id, string path, int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/browse&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BrowseResponseListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download snapshot from archive
		/// Provides a method for retrieving a snapshot, that is not available locally, from an archival location.
		/// VmwareVmSnapshot_idDownloadPost vmware/vm/snapshot/{id}/download
		/// </summary>
		/// <param name="id">ID of snapshot.</param>
		public async Task VmwareVmSnapshot_idDownloadPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download file from VM snapshot
		/// Create a request to download a file from a virtual machine snapshot.
		/// VmwareVmSnapshot_idDownload_filePost vmware/vm/snapshot/{id}/download_file
		/// </summary>
		/// <param name="id">ID of a snapshot.</param>
		/// <param name="requestBody">Configuration for the file download request.</param>
		public async Task VmwareVmSnapshot_idDownload_filePostAsync(string id, DownloadFileJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download_file";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Export VM snapshot
		/// Export a virtual machine from a snapshot, using a specified hypervisor host as the datastore.
		/// VmwareVmSnapshot_idExportPost vmware/vm/snapshot/{id}/export
		/// </summary>
		/// <param name="id">ID of a snapshot.</param>
		/// <param name="requestBody">Configuration for the export request.</param>
		public async Task VmwareVmSnapshot_idExportPostAsync(string id, ExportSnapshotJobConfigV1 requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Download a snapshot from an archival location, then export a virtual machine using the downloaded snapshot
		/// Download a snapshot from an archival location and then export a virtual machine using the downloaded snapshot.
		/// VmwareVmSnapshot_idExport_with_downloadPost vmware/vm/snapshot/{id}/export_with_download
		/// </summary>
		/// <param name="id">ID of a snapshot.</param>
		/// <param name="requestBody">Configuration for the export request.</param>
		public async Task VmwareVmSnapshot_idExport_with_downloadPostAsync(string id, ExportSnapshotJobConfigV1 requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/export_with_download";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Instantly recover a VM
		/// Instantly recovery a virtual machine from a snapshot. The Instant Recovery request starts the virtual machine with networking enabled and renames and powers off the source virtual machine, if it still exists.
		/// VmwareVmSnapshot_idInstant_recoverPost vmware/vm/snapshot/{id}/instant_recover
		/// </summary>
		/// <param name="id">ID of Snapshot.</param>
		/// <param name="requestBody">Configuration for the Instant Recovery request.</param>
		public async Task VmwareVmSnapshot_idInstant_recoverPostAsync(string id, InstantRecoveryJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instant_recover";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Live mount a VM from a snapshot
		/// Create a request to Live Mount a virtual machine from a snapshot using a specified configuration.
		/// VmwareVmSnapshot_idMountPost vmware/vm/snapshot/{id}/mount
		/// </summary>
		/// <param name="id">ID of a snapshot.</param>
		/// <param name="requestBody">Configuration for the Live Mount request.</param>
		public async Task VmwareVmSnapshot_idMountPostAsync(string id, MountSnapshotJobConfigV1 requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/mount";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Restore file from VM snapshot
		/// Create a request to restore a file or folder to the source virtual machine.
		/// VmwareVmSnapshot_idRestore_filePost vmware/vm/snapshot/{id}/restore_file
		/// </summary>
		/// <param name="id">ID of a snapshot.</param>
		/// <param name="requestBody">Configuration for the restore request.</param>
		public async Task VmwareVmSnapshot_idRestore_filePostAsync(string id, RestoreFileJobConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/restore_file";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get snapshot information for a list of virtual machines
		/// Retrieve snapshot summaries for a list of virtual machines.
		/// VmwareVmSnapshotsPost vmware/vm/snapshots
		/// </summary>
		/// <param name="requestBody">IDs of the virtual machines.</param>
		/// <returns>Snapshot summaries for a list of virtual machines.</returns>
		public async Task<BatchVmSnapshotSummaries> VmwareVmSnapshotsPostAsync(string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/snapshots";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchVmSnapshotSummaries>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Details about the specific Virtual Disk
		/// Detailed about the specific Virtual Disk.
		/// VmwareVmVirtual_disk_idGet vmware/vm/virtual_disk/{id}
		/// </summary>
		/// <param name="id">ID of the Virtual Disk.</param>
		/// <returns>Return details about the virtual disk.</returns>
		public async Task<VirtualDiskDetail> VmwareVmVirtual_disk_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/virtual_disk/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualDiskDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a specific Virtual Disk
		/// Update a specific Virtual Disk.
		/// VmwareVmVirtual_disk_idPatch vmware/vm/virtual_disk/{id}
		/// </summary>
		/// <param name="id">ID of the Virtual Disk.</param>
		/// <param name="requestBody">Virtual Disk update information.</param>
		/// <returns>The updated Virtual Disk.</returns>
		public async Task<VirtualDiskDetail> VmwareVmVirtual_disk_idPatchAsync(string id, VirtualDiskUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/virtual_disk/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualDiskDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get VM details
		/// Retrieve details for a virtual machine.
		/// VmwareVm_idGet vmware/vm/{id}
		/// </summary>
		/// <param name="id">ID of the virtual machine.</param>
		/// <returns>Virtual machine details.</returns>
		public async Task<VirtualMachineDetail> VmwareVm_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update VM
		/// Update a virtual machine with specified properties. Use the guestCredential field to update the guest credential for a specified virtual machine.
		/// VmwareVm_idPatch vmware/vm/{id}
		/// </summary>
		/// <param name="id">ID of virtual machine.</param>
		/// <param name="requestBody">Properties to update.</param>
		/// <returns>Virtual machine details.</returns>
		public async Task<VirtualMachineDetail> VmwareVm_idPatchAsync(string id, VirtualMachineUpdateWithSecret requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Run guest OS script
		/// Run the specified preBackup, postSnap, or postBackup script in the guest OS of a virtual machine. The script must exist and meet requirements.
		/// VmwareVm_idGuest_scriptRunPost vmware/vm/{id}/guest_script/run
		/// </summary>
		/// <param name="id">ID of the virtual machine.</param>
		/// <param name="requestBody">Configuration used to run the specified preBackup, postSnap, or postBackup guest OS script.</param>
		public async Task VmwareVm_idGuest_scriptRunPostAsync(string id, VmGuestScriptRunConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/guest_script/run";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get missed time ranges for point in time recovery
		/// Gets a list of time ranges to which a CDP-enabled virtual machine cannot perform a point-in-time recovery. The time ranges are indicated by start and end timestamps listed as date-time strings.
		/// VmwareVm_idMissed_recoverable_rangeGetByAfter_timeAndBefore_time vmware/vm/{id}/missed_recoverable_range
		/// </summary>
		/// <param name="id">The virtual machine ID.</param>
		/// <param name="after_time">Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.</param>
		/// <param name="before_time">Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.</param>
		/// <returns>Returns the missed recoverable ranges for the virtual machine.</returns>
		public async Task<VmwareRecoverableRangeListResponse> VmwareVm_idMissed_recoverable_rangeGetByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/missed_recoverable_range&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareRecoverableRangeListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get details about missed snapshots for a VM
		/// Retrieve details about the missed snapshots for a virtual machine.
		/// VmwareVm_idMissed_snapshotGet vmware/vm/{id}/missed_snapshot
		/// </summary>
		/// <param name="id">ID of a virtual machine.</param>
		/// <returns>Missed snapshot details for a virtual machine.</returns>
		public async Task<MissedSnapshotListResponse> VmwareVm_idMissed_snapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/missed_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MissedSnapshotListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get available time ranges for point in time recovery
		/// Gets time ranges available for point-in-time recovery. The time ranges are indicated by start and end date-time strings.
		/// VmwareVm_idRecoverable_rangeGetByAfter_timeAndBefore_time vmware/vm/{id}/recoverable_range
		/// </summary>
		/// <param name="id">The virtual machine ID.</param>
		/// <param name="after_time">Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.</param>
		/// <param name="before_time">Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.</param>
		/// <returns>Returns the recoverable ranges for the virtual machine.</returns>
		public async Task<VmwareRecoverableRangeListResponse> VmwareVm_idRecoverable_rangeGetByAfter_timeAndBefore_timeAsync(string id, System.DateTimeOffset after_time, System.DateTimeOffset before_time, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/recoverable_range&after_time=" + after_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&before_time=" + before_time.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmwareRecoverableRangeListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Register Rubrik Backup Service
		/// Register the Rubrik Backup Service that is running on a specified host with the specified Rubrik cluster.
		/// VmwareVm_idRegister_agentPost vmware/vm/{id}/register_agent
		/// </summary>
		/// <param name="id">ID assigned to a virtual machine object.</param>
		public async Task VmwareVm_idRegister_agentPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/register_agent";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the configuration for forcing a full snapshot of a VMware virtual machine
		/// Retrieve the configuration that has been set for forcing a full snapshot for a VMware virtual machine.
		/// VmwareVm_idRequestForce_full_snapshotGet vmware/vm/{id}/request/force_full_snapshot
		/// </summary>
		/// <param name="id">ID of the VMware virtual machine.</param>
		/// <returns>Return the configuration for forcing a full snapshot for the VMware virtual machine.</returns>
		public async Task<VmForceFullResponse> VmwareVm_idRequestForce_full_snapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/request/force_full_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmForceFullResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request a full snapshot for the next backup job of a VMware virtual machine
		/// Request a full snapshot to be taken for the next backup job of a VMware virtual machine.
		/// VmwareVm_idRequestForce_full_snapshotPost vmware/vm/{id}/request/force_full_snapshot
		/// </summary>
		/// <param name="id">ID of the VMware virtual machine.</param>
		/// <param name="requestBody">Configuration for forcing a full snapshot on the VMware virtual machine.</param>
		/// <returns>Returns the response to the request for a forced full snapshot.</returns>
		public async Task<VmForceFullResponse> VmwareVm_idRequestForce_full_snapshotPostAsync(string id, VmForceFullRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/request/force_full_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmForceFullResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Search for a file from a VM
		/// Search for a file in the snapshots of a a virtual machine. Specify the file by full path prefix or filename prefix.
		/// VmwareVm_idSearchGetByPathAndLimitAndCursor vmware/vm/{id}/search
		/// </summary>
		/// <param name="id">ID of the virtual machine.</param>
		/// <param name="path">The path query. Use either a path prefix or a filename prefix.</param>
		/// <param name="limit">Maximum number of entries in the response.</param>
		/// <param name="cursor">Pagination cursor returned by the previous request.</param>
		/// <returns>File search results.</returns>
		public async Task<SearchResponseListResponse> VmwareVm_idSearchGetByPathAndLimitAndCursorAsync(string id, string path, int limit, string cursor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/search&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&limit="+limit+"&cursor=" + (cursor==null? "" : System.Uri.EscapeDataString(cursor));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchResponseListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all snapshots of VM
		/// Delete all of the snapshots from a virtual machine.
		/// VmwareVm_idSnapshotDelete vmware/vm/{id}/snapshot
		/// </summary>
		/// <param name="id">Virtual machine ID.</param>
		public async Task VmwareVm_idSnapshotDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list of snapshots of VM
		/// Retrieve summary information for the snapshots of a virtual machine.
		/// VmwareVm_idSnapshotGet vmware/vm/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the virtual machine.</param>
		/// <returns>Summary snapshot information for a virtual machine.</returns>
		public async Task<VmSnapshotSummaryListResponse> VmwareVm_idSnapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmSnapshotSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an on-demand snapshot for a VM
		/// Use the ID of a virtual machine to create an on-demand snapshot.
		/// VmwareVm_idSnapshotPost vmware/vm/{id}/snapshot
		/// </summary>
		/// <param name="id">ID of the virtual machine.</param>
		/// <param name="requestBody">Configuration for the on-demand snapshot.</param>
		public async Task VmwareVm_idSnapshotPostAsync(string id, BaseOnDemandSnapshotConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vmware/vm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get list of Volume Groups
		/// Get summary of all Volume Groups.
		/// Volume_groupGetByEffective_sla_domain_idAndPrimary_cluster_idAndLimitAndOffsetAndIs_relicAndNameAndSla_assignmentAndSort_byAndSort_order volume_group
		/// </summary>
		/// <param name="effective_sla_domain_id">The ID of the SLA Domain that controls the protection of the Volume Group.</param>
		/// <param name="primary_cluster_id">The ID of the Rubrik cluster that provides primary protection for the Volume Group.</param>
		/// <param name="limit">Limit the number of matches returned.</param>
		/// <param name="offset">Ignore these many matches in the beginning.</param>
		/// <param name="is_relic">Specifies whether the results should contain only Volume Groups that are accessible on the Rubrik cluster.</param>
		/// <param name="name">The name of the Volume Group.</param>
		/// <param name="sla_assignment">The type of SLA assigned to the Volume Group.</param>
		/// <param name="sort_by">The Volume Group attribute to use in storing the responses. Valid attributes are `name` and `effectiveSlaDomainName`.</param>
		/// <param name="sort_order">The order to sort the responses. Valid choices are asc (ascending) or desc (descending).</param>
		/// <returns>Get Volume Groups summary list.</returns>
		public async Task<VolumeGroupSummaryListResponse> Volume_groupGetByEffective_sla_domain_idAndPrimary_cluster_idAndLimitAndOffsetAndIs_relicAndNameAndSla_assignmentAndSort_byAndSort_orderAsync(string effective_sla_domain_id, string primary_cluster_id, int limit, int offset, bool is_relic, string name, SlaAssignment sla_assignment, FailoverClusterHierarchyObjectSortAttribute sort_by, SortOrder sort_order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group?effective_sla_domain_id=" + (effective_sla_domain_id==null? "" : System.Uri.EscapeDataString(effective_sla_domain_id))+"&primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&limit="+limit+"&offset="+offset+"&is_relic="+is_relic+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&sla_assignment=" + sla_assignment+"&sort_by=" + sort_by+"&sort_order=" + sort_order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary information for all mounts
		/// Retrieves information for each Volume Group mount. The information returned includes the following items, when available. id (the unique ID of the mount), name (the name of the Volume Group), snapshotDate (the snapshot date), sourceVolumeGroupId (the ID of the Volume Group from which this snapshot was created), sourceHostId (the ID of the source host), sourceHostName (the name of the source host), mountedDate (the date when the mount was created), mountedVolumes (information on the mounted volumes), targetHostId (the ID of the mounted volumes host), targetHostName (the name of the mounted volumes host), mountRequestId (the ID of the job instance that initiated the mount), unmountRequestId (the ID of the job instance that initiated the request to remove the mount), isReady (whether the Volume Group mount is ready to use), and restoreScriptSmbPath (the link to the script that can perform bare-metal recovery).
		/// Volume_groupSnapshotMountGetBySource_volume_group_idAndSource_host_nameAndSort_byAndSort_orderAndOffsetAndLimit volume_group/snapshot/mount
		/// </summary>
		/// <param name="source_volume_group_id">The ID of the source Volume Group.</param>
		/// <param name="source_host_name">A prefix of the source host name. The prefix is used as a response filter when available.</param>
		/// <param name="sort_by">The Volume Group mount attribute used in sorting the responses. Valid choices are name, sourceHostName, snapshotDate, and mountedDate.</param>
		/// <param name="sort_order">The order to sort the responses. Valid choices are asc (ascending) or desc (descending).</param>
		/// <param name="offset">Ignore these many matches in the beginning.</param>
		/// <param name="limit">Limit the number of matches returned. The default value is 25.</param>
		/// <returns>Returns summary information for all mounts.</returns>
		public async Task<VolumeGroupMountSummaryListResponse> Volume_groupSnapshotMountGetBySource_volume_group_idAndSource_host_nameAndSort_byAndSort_orderAndOffsetAndLimitAsync(string source_volume_group_id, string source_host_name, VolumeGroupMountListSortAttribute sort_by, SortOrder sort_order, int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/snapshot/mount?source_volume_group_id=" + (source_volume_group_id==null? "" : System.Uri.EscapeDataString(source_volume_group_id))+"&source_host_name=" + (source_host_name==null? "" : System.Uri.EscapeDataString(source_host_name))+"&sort_by=" + sort_by+"&sort_order=" + sort_order+"&offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupMountSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get summary information for a mount
		/// Retrieve information on a Volume Group mount. The information returned includes the following items, when available. id (the unique ID of the mount), name (the name of the Volume Group), snapshotDate (the snapshot date), sourceVolumeGroupId (The ID of the Volume Group from which this snapshot was created), sourceHostId (the ID of the source host), sourceHostName (the name of the source host), mountedDate (the date when the mount was created), mountedVolumes (the mounted volumes information), targetHostId (the ID of the mounted volumes host), targetHostName (the name of the mounted volumes host), mountRequestId (the ID of the job instance that initiated the mount), unmountRequestId (the ID of the job instance that intiated the request to remove the mount), isReady (whether the Volume Group mount is ready to use), and restoreScriptSmbPath (the link to the script that can perform bare-metal recovery).
		/// Volume_groupSnapshotMount_idGet volume_group/snapshot/mount/{id}
		/// </summary>
		/// <param name="id">The ID of the Volume Group mount.</param>
		/// <returns>Returns detail information for a specified live mount.</returns>
		public async Task<VolumeGroupMountSummary> Volume_groupSnapshotMount_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/snapshot/mount/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupMountSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Volume Group snapshot details
		/// Retrieve detailed information about a snapshot.
		/// Volume_groupSnapshot_idGet volume_group/snapshot/{id}
		/// </summary>
		/// <param name="id">The ID of the Volume Group snapshot.</param>
		/// <returns>Returns details about a snapshot.</returns>
		public async Task<VolumeGroupSnapshotDetail> Volume_groupSnapshot_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/snapshot/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupSnapshotDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Volume Group details
		/// Detailed view of a Volume Group.
		/// Volume_group_idGet volume_group/{id}
		/// </summary>
		/// <param name="id">The ID of the Volume Group.</param>
		/// <returns>Return details about the Volume Group.</returns>
		public async Task<VolumeGroupDetail> Volume_group_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update Volume Group properties
		/// Patch Volume Group with specified properties.
		/// Volume_group_idPatch volume_group/{id}
		/// </summary>
		/// <param name="id">The ID of Volume Group.</param>
		/// <param name="requestBody">Properties to update for this Volume Group.</param>
		/// <returns>Return details about the Volume Group.</returns>
		public async Task<VolumeGroupDetail> Volume_group_idPatchAsync(string id, VolumeGroupPatch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the latest snapshot of the Volume Group
		/// Retrieve the latest snapshot summary of a Volume Group.
		/// Volume_group_idLatest_snapshotGet volume_group/{id}/latest_snapshot
		/// </summary>
		/// <param name="id">ID of the Volume Group.</param>
		/// <returns>Returns a summary of a Volume Group's latest snapshot. Returns an empty array if there is no snapshot summary.
		///</returns>
		public async Task<VolumeGroupSnapshotSummary[]> Volume_group_idLatest_snapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/latest_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupSnapshotSummary[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the configuration for forcing a full snapshot
		/// Retrieve the configuration for forcing a full snapshot for a Volume Group.
		/// Volume_group_idRequestForce_full_snapshotGet volume_group/{id}/request/force_full_snapshot
		/// </summary>
		/// <param name="id">The ID of the Volume Group.</param>
		/// <returns>Return the configuration for forcing a full snapshot on the Volume Group.</returns>
		public async Task<VolumeGroupForceFullResponse> Volume_group_idRequestForce_full_snapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/request/force_full_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupForceFullResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request a full snapshot on the next backup job of a Volume Group
		/// Request a full snapshot to be taken during the next backup job of a Volume Group.
		/// Volume_group_idRequestForce_full_snapshotPost volume_group/{id}/request/force_full_snapshot
		/// </summary>
		/// <param name="id">The ID of the Volume Group.</param>
		/// <param name="requestBody">Configuration for forcing a full snapshot on the Volume Group.</param>
		/// <returns>Return the configuration for forcing a full snapshot on the Volume Group.</returns>
		public async Task<VolumeGroupForceFullResponse> Volume_group_idRequestForce_full_snapshotPostAsync(string id, VolumeGroupForceFullRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/request/force_full_snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupForceFullResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get list of snapshots of the Volume Group
		/// Retrieve snapshot details for a Volume Group.
		/// Volume_group_idSnapshotGet volume_group/{id}/snapshot
		/// </summary>
		/// <param name="id">The ID of the Volume Group.</param>
		/// <returns>Returns summary information for all snapshots.</returns>
		public async Task<VolumeGroupSnapshotSummaryListResponse> Volume_group_idSnapshotGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumeGroupSnapshotSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create on-demand snapshot for the Volume Group
		/// Create an on-demand snapshot for the given Volume Group ID.
		/// Volume_group_idSnapshotPost volume_group/{id}/snapshot
		/// </summary>
		/// <param name="id">The ID of the Volume Group.</param>
		/// <param name="requestBody">Configuration for the on-demand backup. Configuration values are `volumeIdsIncludedInSnapshot`, which specifies the unique ID of each volume that is part of this snapshot of the Volume Group, and `slaID`, the ID of the SLA Domain for the snapshot.</param>
		public async Task Volume_group_idSnapshotPostAsync(string id, VolumeGroupOnDemandSnapshotConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volume_group/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get summary information for Windows clusters
		/// Returns a list of summary information for Windows server failover clusters.
		/// Windows_clusterGetByPrimary_cluster_idAndIs_agentlessAndSnappable_status windows_cluster
		/// </summary>
		/// <param name="primary_cluster_id">Filter by primary_cluster_id. Use **local** for the local cluster.</param>
		/// <param name="is_agentless">Filter by is_agentless flag.</param>
		/// <param name="snappable_status">Determines whether Windows clusters are fetched with additional privilege checks.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<WindowsClusterSummaryListResponse> Windows_clusterGetByPrimary_cluster_idAndIs_agentlessAndSnappable_statusAsync(string primary_cluster_id, bool is_agentless, SnappablePrivilegeStatus snappable_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "windows_cluster?primary_cluster_id=" + (primary_cluster_id==null? "" : System.Uri.EscapeDataString(primary_cluster_id))+"&is_agentless="+is_agentless+"&snappable_status=" + snappable_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WindowsClusterSummaryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detailed information for a Windows cluster
		/// Returns a detailed view of a Windows server failover cluster.
		/// Windows_cluster_idGet windows_cluster/{id}
		/// </summary>
		/// <param name="id">ID of the Windows cluster.</param>
		/// <returns>Returned if the query was successful.</returns>
		public async Task<WindowsClusterDetail> Windows_cluster_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "windows_cluster/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WindowsClusterDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum EventCsv_download_linkGetByLimitAndEvent_series_statusAndEvent_statusAndEvent_typeAndEvent_severityAndObject_idsAndObject_typeAndObject_nameAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeEvent_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Archive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Audit = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthDomain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsEvent = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Backup = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Classification = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeSource = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeVm = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Configuration = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connection = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Conversion = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Diagnostic = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Discovery = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failover = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fileset = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hardware = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HostEvent = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervScvmm = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervServer = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Index = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Instantiate = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LegalHold = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Maintenance = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixCluster = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Recovery = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replication = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResourceOperations = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Storage = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArray = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StormResource = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Support = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TestFailover = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrade = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VCenter = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcd = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnknownEventType = 37,
	}
	
	public enum EventLatestGetByLimitAndEvent_series_statusAndEvent_statusAndEvent_typeAndEvent_severityAndObject_idsAndObject_typeAndObject_nameAndAfter_idAndBefore_dateAndAfter_dateAndOrder_by_timeAndShould_include_event_seriesEvent_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Archive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Audit = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthDomain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AwsEvent = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Backup = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Classification = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeSource = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CloudNativeVm = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Configuration = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connection = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Conversion = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Diagnostic = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Discovery = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failover = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Fileset = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hardware = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HostEvent = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervScvmm = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HypervServer = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Index = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Instantiate = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LegalHold = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Maintenance = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NutanixCluster = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Recovery = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Replication = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResourceOperations = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Storage = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StorageArray = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StormResource = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Support = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="System")]
		_System = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TestFailover = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrade = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VCenter = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Vcd = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VolumeGroup = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnknownEventType = 37,
	}
	
	public enum Exclusion_patternGetByPatternAndIs_mutableAndSource_idAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pattern = 0,
	}
	
	public enum Failover_clusterGetByNameAndOperating_system_typeAndSla_assignmentAndPrimary_cluster_idAndLimitAndOffsetAndSort_byAndSort_orderSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
	}
	
	public enum FilesetGetByPrimary_cluster_idAndHost_idAndShare_idAndIs_relicAndEffective_sla_domain_idAndTemplate_idAndLimitAndOffsetAndNameAndHost_nameAndSort_byAndSort_orderSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hostName = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		templateId = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		includes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		excludes = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		exceptions = 6,
	}
	
	public enum FilesetSnapshot_idDeleteByLocationLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		local = 1,
	}
	
	public enum Fileset_templateGetByPrimary_cluster_idAndOperating_system_typeAndShare_typeAndNameAndSort_byAndSort_orderOperating_system_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnixLike = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
	}
	
	public enum Fileset_templateGetByPrimary_cluster_idAndOperating_system_typeAndShare_typeAndNameAndSort_byAndSort_orderShare_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NFS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SMB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
	}
	
	public enum Fileset_templateGetByPrimary_cluster_idAndOperating_system_typeAndShare_typeAndNameAndSort_byAndSort_orderSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hostCount = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		includes = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		excludes = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		exceptions = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shareType = 5,
	}
	
	public enum Hdfs_templateGetByPrimary_cluster_idAndNameAndSort_byAndSort_orderSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hostCount = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		includes = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		excludes = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		exceptions = 4,
	}
	
	public enum HostGetByOperating_system_typeAndOperating_systemAndPrimary_cluster_idAndNameAndHostnameAndSort_byAndSort_orderAndSnappable_statusSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hostname = 0,
	}
	
	public enum MssqlDbMountGetBySource_database_idAndSource_database_nameAndTarget_instance_idAndMounted_database_nameAndSort_byAndSort_orderAndOffsetAndLimitSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sourceDatabaseName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sourceRecoveryPoint = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mountedDatabaseName = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		creationDate = 3,
	}
	
	public enum MssqlDb_idCompatible_instanceGetByRecovery_timeAndRecovery_typeRecovery_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Mount = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Export = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Restore = 2,
	}
	
	public enum MssqlHierarchy_idChildrenGetByEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndNameAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndIs_clusteredAndHas_instancesAndSla_assignmentAndSort_byAndSort_orderAndSnappable_statusSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="descendantCount.MssqlInstance")]
		descendantCount_MssqlInstance = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="descendantCount.MssqlDatabase")]
		descendantCount_MssqlDatabase = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		logBackupRetentionHours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		copyOnly = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 5,
	}
	
	public enum MssqlHierarchy_idDescendantsGetByEffective_sla_domain_idAndObject_typeAndPrimary_cluster_idAndLimitAndOffsetAndNameAndIs_relicAndIs_live_mountAndIs_log_shipping_secondaryAndIs_clusteredAndHas_instancesAndSla_assignmentAndSort_byAndSort_orderAndSnappable_statusSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="descendantCount.MssqlInstance")]
		descendantCount_MssqlInstance = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="descendantCount.MssqlDatabase")]
		descendantCount_MssqlDatabase = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		logBackupRetentionHours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		copyOnly = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 5,
	}
	
	public enum OracleDbGetByNameAndSla_assignmentAndEffective_sla_domain_idAndPrimary_cluster_idAndIs_relicAndIs_live_mountAndLimitAndOffsetAndSort_byAndSort_orderAndInclude_backup_task_infoAndIs_data_guard_groupSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 1,
	}
	
	public enum VmwareVmGetByEffective_sla_domain_idAndPrimary_cluster_idAndLimitAndOffsetAndIs_relicAndNameAndMoidAndSla_assignmentAndGuest_os_nameAndSort_byAndSort_orderSort_by
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		effectiveSlaDomainName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		moid = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		folderPath = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		infraPath = 4,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
