//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BaseIndexResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BaseIndexResponse_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Pagination _meta { get; set; }
	}
	
	public class BaseIndexResponse_links
	{
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Link Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Link
	{
		
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Pagination
	{
		
		[System.Runtime.Serialization.DataMember(Name="currentPage")]
		public System.Nullable<System.Int32> CurrentPage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pageCount")]
		public System.Nullable<System.Int32> PageCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="perPage")]
		public System.Nullable<System.Int32> PerPage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalCount")]
		public System.Nullable<System.Int32> TotalCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Error
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// The `Persona` object describes a radio DJ/host. One person can have multiple personas
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Persona
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Persona_links _links { get; set; }
		
		/// <summary>
		/// HTML-formatted biography
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bio")]
		public string Bio { get; set; }
		
		/// <summary>
		/// DJ/host's email address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="image")]
		public string Image { get; set; }
		
		/// <summary>
		/// On-air DJ/host name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Since what year has the DJ/host been at the station?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="since")]
		public string Since { get; set; }
		
		/// <summary>
		/// URL to web site for the DJ/host
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website")]
		public string Website { get; set; }
	}
	
	public class Persona_links
	{
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Link Self { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public Link[] Shows { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Playlist
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Playlist_links _links { get; set; }
		
		/// <summary>
		/// Was the playlist created playlists created by a radio station automation system?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automation")]
		public System.Nullable<System.Boolean> Automation { get; set; }
		
		/// <summary>
		/// Program/show category
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// HTML-formatted description of the playlist or program/show
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Duration in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// UTC datetime ISO-8601
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public System.Nullable<System.DateTimeOffset> End { get; set; }
		
		/// <summary>
		/// HTML-formatted description of the episode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="episode_description")]
		public string Episode_description { get; set; }
		
		/// <summary>
		/// Title of this episode of the program/show
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="episode_name")]
		public string Episode_name { get; set; }
		
		/// <summary>
		/// Should the client application hide information about the playlist's DJ/host?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hide_dj")]
		public System.Nullable<System.Boolean> Hide_dj { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="image")]
		public string Image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="persona_id")]
		public System.Nullable<System.Int32> Persona_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="show_id")]
		public System.Nullable<System.Int32> Show_id { get; set; }
		
		/// <summary>
		/// Since what year has the program/show existed?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="since")]
		public string Since { get; set; }
		
		/// <summary>
		/// UTC datetime ISO-8601
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public System.Nullable<System.DateTimeOffset> Start { get; set; }
		
		/// <summary>
		/// Station's time zone
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
		
		/// <summary>
		/// Program/show title
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// URL to web site for the playlist or program/show
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Playlist_links
	{
		
		[System.Runtime.Serialization.DataMember(Name="persona")]
		public Link Persona { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Link Self { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="show")]
		public Link Show { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="spins")]
		public Link Spins { get; set; }
	}
	
	/// <summary>
	/// A `Show` object describes one occurrence of a radio program. A result set may contain multiple occurrences of the same show with difference `start` and `end` values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Show
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Show_links _links { get; set; }
		
		/// <summary>
		/// Program/show category
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// HTML-formatted description of the playlist or program/show
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Duration in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// UTC datetime ISO-8601
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public System.Nullable<System.DateTimeOffset> End { get; set; }
		
		/// <summary>
		/// Should the client application hide information about the show's DJs/hosts?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hide_dj")]
		public System.Nullable<System.Boolean> Hide_dj { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="image")]
		public string Image { get; set; }
		
		/// <summary>
		/// Is the show a one-off in the schedule instead of repeating?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="one_off")]
		public System.Nullable<System.Boolean> One_off { get; set; }
		
		/// <summary>
		/// Since what year has the program/show existed?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="since")]
		public string Since { get; set; }
		
		/// <summary>
		/// UTC datetime ISO-8601
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public System.Nullable<System.DateTimeOffset> Start { get; set; }
		
		/// <summary>
		/// Station's time zone
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
		
		/// <summary>
		/// Program/show title
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// URL to web site for the program/show
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Show_links
	{
		
		[System.Runtime.Serialization.DataMember(Name="personas")]
		public Link[] Personas { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="playlists")]
		public Link Playlists { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Link Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Spin
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Spin_links _links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="artist")]
		public string Artist { get; set; }
		
		/// <summary>
		/// Station-specific custom field relating to the song's artist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artist-custom")]
		public string Artist_custom { get; set; }
		
		/// <summary>
		/// Reference number in the record label's catalog
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="catalog-number")]
		public string Catalog_number { get; set; }
		
		/// <summary>
		/// Is the track's metadata schema "classical" rather than "popular"?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classical")]
		public System.Nullable<System.Boolean> Classical { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="composer")]
		public string Composer { get; set; }
		
		/// <summary>
		/// For classical music, conducor of the ensemble
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conductor")]
		public string Conductor { get; set; }
		
		/// <summary>
		/// Duration in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// UTC datetime ISO-8601
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public System.Nullable<System.DateTimeOffset> End { get; set; }
		
		/// <summary>
		/// For classical music, orchestra, performing ensemble, choir, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ensemble")]
		public string Ensemble { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="genre")]
		public string Genre { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Cover art
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public string Image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isrc")]
		public string Isrc { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="iswc")]
		public string Iswc { get; set; }
		
		/// <summary>
		/// Record label, i.e. publisher of the sound recording
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Station-specific custom field relating to the record label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label-custom")]
		public string Label_custom { get; set; }
		
		/// <summary>
		/// Is the artist local to the station?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="local")]
		public System.Nullable<System.Boolean> Local { get; set; }
		
		/// <summary>
		/// Media format in which the sound recording was reased
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="medium")]
		public string Medium { get; set; }
		
		/// <summary>
		/// Is this a recent release?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="new")]
		public System.Nullable<System.Boolean> New { get; set; }
		
		/// <summary>
		/// HTML-formatted DJ annotation of the spin, can include images etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// For classical music, featured performing artists, e.g. soloists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performers")]
		public string Performers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="playlist_id")]
		public System.Nullable<System.Int32> Playlist_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="release")]
		public string Release { get; set; }
		
		/// <summary>
		/// Station-specific custom field relating to the release
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release-custom")]
		public string Release_custom { get; set; }
		
		/// <summary>
		/// Year of initial release
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="released")]
		public System.Nullable<System.Int32> Released { get; set; }
		
		/// <summary>
		/// Was the spin requested by a listener?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="request")]
		public System.Nullable<System.Boolean> Request { get; set; }
		
		/// <summary>
		/// Title of the song or track
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="song")]
		public string Song { get; set; }
		
		/// <summary>
		/// UTC datetime ISO-8601
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public System.Nullable<System.DateTimeOffset> Start { get; set; }
		
		/// <summary>
		/// Station's time zone
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
		
		/// <summary>
		/// Universal Product Code of the release
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upc")]
		public string Upc { get; set; }
		
		/// <summary>
		/// Is it a "Various Artists" release?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="va")]
		public System.Nullable<System.Boolean> Va { get; set; }
		
		/// <summary>
		/// For classical music, the main compositional work the track (see `song` field) belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="work")]
		public string Work { get; set; }
	}
	
	public class Spin_links
	{
		
		[System.Runtime.Serialization.DataMember(Name="playlist")]
		public Link Playlist { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="self")]
		public Link Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ValidationError
	{
		
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get Personas
		/// PersonaGetByNameAndCountAndPageAndFieldsAndExpand personas
		/// </summary>
		/// <param name="name">Filter by Persona name</param>
		/// <param name="count">Amount of items to return
		/// Minimum: 1
		// </param>
		/// <param name="page">Offset, used together with count
		/// Minimum: 1
		// </param>
		/// <param name="fields">Allows to select only needed fields</param>
		/// <param name="expand">Allows to select extra fields</param>
		/// <returns>The personas</returns>
		public async Task<BaseIndexResponse> PersonaGetByNameAndCountAndPageAndFieldsAndExpandAsync(string name, int count, int page, string[] fields, string[] expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "personas?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&count="+count+"&page="+page+"&"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", expand.Select(z => $"expand={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BaseIndexResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Persona by id
		/// PersonaGetByIdAndFieldsAndExpand personas/{id}
		/// </summary>
		/// <param name="fields">Allows to select only needed fields</param>
		/// <param name="expand">Allows to select extra fields</param>
		/// <returns>The Persona</returns>
		public async Task<Persona> PersonaGetByIdAndFieldsAndExpandAsync(int id, string[] fields, string[] expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "personas/"+id+"?"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", expand.Select(z => $"expand={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Persona>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns playlists optionally filtered by {start} and/or {end} datetimes
		/// Get Playlists optionally filtered by a datetime range.
		/// Only past Playlists will be returned (with allowed tolerance equals 1 hour in future).
		/// 
		/// Ordered chronologically from newest to oldest.
		/// 
		/// PlaylistGetByStartAndEndAndShow_idAndPersona_idAndCountAndPageAndFieldsAndExpand playlists
		/// </summary>
		/// <param name="start">The datetime starting from items must be returned. Maximum 1 hour in future.
		///</param>
		/// <param name="end">The ending datetime. Maximum 1 hour in future.
		///</param>
		/// <param name="show_id">Filter by show</param>
		/// <param name="persona_id">Filter by persona</param>
		/// <param name="count">Amount of items to return
		/// Minimum: 1
		// </param>
		/// <param name="page">Offset, used together with count
		/// Minimum: 1
		// </param>
		/// <param name="fields">Allows to select only needed fields</param>
		/// <param name="expand">Allows to select extra fields</param>
		/// <returns>The playlists</returns>
		public async Task<BaseIndexResponse> PlaylistGetByStartAndEndAndShow_idAndPersona_idAndCountAndPageAndFieldsAndExpandAsync(System.DateTimeOffset start, System.DateTimeOffset end, int show_id, int persona_id, int count, int page, string[] fields, string[] expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists?start=" + start.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&end=" + end.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&show_id="+show_id+"&persona_id="+persona_id+"&count="+count+"&page="+page+"&"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", expand.Select(z => $"expand={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BaseIndexResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Playlist by id
		/// The response object represents the playlist specified by {id}.
		/// 
		/// Status 404 is returned if a playlist with {id} does not exist or if it does but starts in the future (with allowed tolerance equals 1 hour in future).
		/// 
		/// PlaylistGetByIdAndFieldsAndExpand playlists/{id}
		/// </summary>
		/// <param name="fields">Allows to select only needed fields</param>
		/// <param name="expand">Allows to select extra fields</param>
		/// <returns>The playlist</returns>
		public async Task<Playlist> PlaylistGetByIdAndFieldsAndExpandAsync(int id, string[] fields, string[] expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists/"+id+"?"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", expand.Select(z => $"expand={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Playlist>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns scheduled shows optionally filtered by {start} and/or {end} datetimes
		/// **Terminology**: Spinitron defines a *show* as a radio program. A show can have one or more *schedules*,
		/// each of which may specify either an *occurence* or a *repetition*, which represents a set of occurences.
		/// Thus scheduled shows have occurences that, for example, may be displayed in a calendar.
		/// 
		/// In the response, `items` is an array of objects representing occurences of scheduled shows.
		/// 
		/// You may optionally filter `items` to a datetime *range* by including in the request {start} and/or {end}
		/// parameters, both of which must be no more than one hour in the past. An occurence starting at {end} is
		/// included in the reponse.
		/// 
		/// `itmes` can include occurences that begin *or* end within the filter range. A show that goes on air before
		/// {start} appears in `items` if it ends *after* but not *at* {start}. An occurence starting at or before {end}
		/// is included.
		/// 
		/// If the request omits the {start} parameter, the server sets its value to the current time so that the filter
		/// range's start is always defined. If the request specifies {end} then the requested range is *bounded*,
		/// otherwise it is *unbounded*.
		/// 
		/// For a bounded request, `items` includes *every* occurence of all shows occuring in the range. The only
		/// difference between objects in `items` representing a given show will be the `start` field value.
		/// 
		/// For an unbounded request, `items` includes *only one* occurence per show, specifically, the
		/// next occurrence after {start} of all shows occuring after {start}.
		/// 
		/// Use an unbounded request to get a straight list all shows. Use a bounded request to get a calendar/agenda
		/// of shows expanded into occurrences by thir shedules and repetitions.
		/// 
		/// Objects in `items` are ordered first by `datetime` and then by `id`.
		/// 
		/// ShowGetByStartAndEndAndCountAndPageAndFieldsAndExpand shows
		/// </summary>
		/// <param name="start">The datetime starting from items must be returned. Maximum 1 hour in past.
		///</param>
		/// <param name="end">The ending datetime. Maximum 1 hour in past.
		///</param>
		/// <param name="count">Amount of items to return
		/// Minimum: 1
		// </param>
		/// <param name="page">Offset, used together with count
		/// Minimum: 1
		// </param>
		/// <param name="fields">Allows to select only needed fields</param>
		/// <param name="expand">Allows to select extra fields</param>
		/// <returns>The shows</returns>
		public async Task<BaseIndexResponse> ShowGetByStartAndEndAndCountAndPageAndFieldsAndExpandAsync(System.DateTimeOffset start, System.DateTimeOffset end, int count, int page, string[] fields, string[] expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows?start=" + start.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&end=" + end.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&count="+count+"&page="+page+"&"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", expand.Select(z => $"expand={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BaseIndexResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Show by id
		/// The response object represents the next occurence of the show specified by {id}.
		/// 
		/// Status 404 is returned if a show with {id} does not exist or if it does but all its scheduled occurences elapsed in the past.
		/// 
		/// ShowGetByIdAndFieldsAndExpand shows/{id}
		/// </summary>
		/// <param name="fields">Allows to select only needed fields</param>
		/// <param name="expand">Allows to select extra fields</param>
		/// <returns>The Show</returns>
		public async Task<Show> ShowGetByIdAndFieldsAndExpandAsync(int id, string[] fields, string[] expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+id+"?"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", expand.Select(z => $"expand={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Show>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns spins optionally filtered by {start} and/or {end} datetimes
		/// Get Spins optionally filtered by a datetime range. Only past Spins will be returned.
		/// 
		/// SpinGetByStartAndEndAndPlaylist_idAndShow_idAndCountAndPageAndFieldsAndExpand spins
		/// </summary>
		/// <param name="start">The datetime starting from items must be returned.
		///</param>
		/// <param name="end">The ending datetime.
		///</param>
		/// <param name="playlist_id">Filter by playlist</param>
		/// <param name="show_id">Filter by show</param>
		/// <param name="count">Amount of items to return
		/// Minimum: 1
		// </param>
		/// <param name="page">Offset, used together with count
		/// Minimum: 1
		// </param>
		/// <param name="fields">Allows to select only needed fields</param>
		/// <param name="expand">Allows to select extra fields</param>
		/// <returns>The spins</returns>
		public async Task<BaseIndexResponse> SpinGetByStartAndEndAndPlaylist_idAndShow_idAndCountAndPageAndFieldsAndExpandAsync(System.DateTimeOffset start, System.DateTimeOffset end, int playlist_id, int show_id, int count, int page, string[] fields, string[] expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "spins?start=" + start.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&end=" + end.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&playlist_id="+playlist_id+"&show_id="+show_id+"&count="+count+"&page="+page+"&"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", expand.Select(z => $"expand={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BaseIndexResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Spin by id
		/// SpinGetByIdAndFieldsAndExpand spins/{id}
		/// </summary>
		/// <param name="fields">Allows to select only needed fields</param>
		/// <param name="expand">Allows to select extra fields</param>
		/// <returns>The spin</returns>
		public async Task<Spin> SpinGetByIdAndFieldsAndExpandAsync(int id, string[] fields, string[] expand, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "spins/"+id+"?"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", expand.Select(z => $"expand={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Spin>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
