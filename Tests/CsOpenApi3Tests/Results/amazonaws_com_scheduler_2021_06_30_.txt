//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateScheduleOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FlexibleTimeWindowMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFF = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FLEXIBLE = 1,
	}
	
	/// <summary>
	/// An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeadLetterConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
	}
	
	/// <summary>
	/// The templated target type for the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> API operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EcsParameters
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CapacityProviderStrategyItem[] CapacityProviderStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableECSManagedTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableExecuteCommand { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Group { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LaunchType LaunchType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NetworkConfiguration NetworkConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PlacementConstraint[] PlacementConstraints { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PlacementStrategy[] PlacementStrategy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlatformVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PropagateTags PropagateTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ReferenceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TagMap[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TaskCount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TaskDefinitionArn { get; set; }
	}
	
	/// <summary>
	/// The details of a capacity provider strategy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CapacityProviderStrategyItem
	{
		
		[System.Runtime.Serialization.DataMember(Name="base")]
		public System.Nullable<System.Int32> Base { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="capacityProvider")]
		public string CapacityProvider { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public System.Nullable<System.Int32> Weight { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LaunchType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EC2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FARGATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL = 2,
	}
	
	/// <summary>
	/// Specifies the network configuration for an ECS task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NetworkConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="awsvpcConfiguration")]
		public AwsVpcConfiguration AwsvpcConfiguration { get; set; }
	}
	
	/// <summary>
	/// This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AwsVpcConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AssignPublicIp AssignPublicIp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityGroups { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] Subnets { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AssignPublicIp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	/// <summary>
	/// An object representing a constraint on task placement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PlacementConstraint
	{
		
		[System.Runtime.Serialization.DataMember(Name="expression")]
		public string Expression { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public PlacementConstraintType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PlacementConstraintType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		distinctInstance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		memberOf = 1,
	}
	
	/// <summary>
	/// The task placement strategy for a task or service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PlacementStrategy
	{
		
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public PlacementStrategyType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PlacementStrategyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		random = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		spread = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		binpack = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PropagateTags
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TASK_DEFINITION = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TagMap
	{
	}
	
	/// <summary>
	/// The templated target type for the EventBridge <a href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html"> <code>PutEvents</code> </a> API operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EventBridgeParameters
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DetailType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Source { get; set; }
	}
	
	/// <summary>
	/// The templated target type for the Amazon Kinesis <a href="kinesis/latest/APIReference/API_PutRecord.html"> <code>PutRecord</code> </a> API operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class KinesisParameters
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PartitionKey { get; set; }
	}
	
	/// <summary>
	/// A <code>RetryPolicy</code> object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RetryPolicy
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaximumEventAgeInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaximumRetryAttempts { get; set; }
	}
	
	/// <summary>
	/// The templated target type for the Amazon SageMaker <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html"> <code>StartPipelineExecution</code> </a> API operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SageMakerPipelineParameters
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SageMakerPipelineParameter[] PipelineParameterList { get; set; }
	}
	
	/// <summary>
	/// The name and value pair of a parameter to use to start execution of a SageMaker Model Building Pipeline.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SageMakerPipelineParameter
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// The templated target type for the Amazon SQS <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html"> <code>SendMessage</code> </a> API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html">Using the Amazon SQS message deduplication ID</a> in the <i>Amazon SQS Developer Guide</i>. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SqsParameters
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageGroupId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceQuotaExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ValidationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InternalServerException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourceNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ThrottlingException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateScheduleGroupOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleGroupArn { get; set; }
	}
	
	/// <summary>
	/// Tag to associate with a schedule group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Tag
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteScheduleOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteScheduleGroupOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetScheduleOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ActionAfterCompletion ActionAfterCompletion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FlexibleTimeWindow FlexibleTimeWindow { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KmsKeyArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModificationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleExpressionTimezone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AssignPublicIp State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Target Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ActionAfterCompletion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE = 1,
	}
	
	/// <summary>
	/// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FlexibleTimeWindow
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaximumWindowInMinutes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FlexibleTimeWindowMode Mode { get; set; }
	}
	
	/// <summary>
	/// The schedule's target. EventBridge Scheduler supports templated target that invoke common API operations, as well as universal targets that you can customize to invoke over 6,000 API operations across more than 270 services. You can only specify one templated or universal target for a schedule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Target
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeadLetterConfig DeadLetterConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EcsParameters EcsParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EventBridgeParameters EventBridgeParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KinesisParameters KinesisParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RetryPolicy RetryPolicy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SageMakerPipelineParameters SageMakerPipelineParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SqsParameters SqsParameters { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetScheduleGroupOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModificationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ScheduleGroupState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScheduleGroupState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListScheduleGroupsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ScheduleGroupSummary[] ScheduleGroups { get; set; }
	}
	
	/// <summary>
	/// The details of a schedule group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScheduleGroupSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModificationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ScheduleGroupState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListSchedulesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ScheduleSummary[] Schedules { get; set; }
	}
	
	/// <summary>
	/// The details of a schedule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScheduleSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModificationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AssignPublicIp State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TargetSummary Target { get; set; }
	}
	
	/// <summary>
	/// The details of a target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TargetSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListTagsForResourceOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TagResourceOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UntagResourceOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateScheduleOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateScheduleGroupInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScheduleState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateScheduleInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ActionAfterCompletion ActionAfterCompletion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FlexibleTimeWindow FlexibleTimeWindow { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KmsKeyArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleExpressionTimezone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AssignPublicIp State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Target Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteScheduleGroupInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteScheduleInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetScheduleGroupInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetScheduleInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListScheduleGroupsInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListSchedulesInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListTagsForResourceInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TagResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UntagResourceInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateScheduleInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ActionAfterCompletion ActionAfterCompletion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FlexibleTimeWindow FlexibleTimeWindow { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KmsKeyArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ScheduleExpressionTimezone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AssignPublicIp State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Target Target { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Creates the specified schedule.
		/// CreateSchedule schedules/{Name}
		/// </summary>
		/// <param name="Name">The name of the schedule that you are creating.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateScheduleOutput> CreateScheduleAsync(string Name, CreateSchedulePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedules/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateScheduleOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified schedule.
		/// DeleteSchedule schedules/{Name}
		/// </summary>
		/// <param name="clientToken"> Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. 
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="groupName">The name of the schedule group associated with this schedule. If you omit this, the default schedule group is used.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="Name">The name of the schedule to delete.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteScheduleOutput> DeleteScheduleAsync(string clientToken, string groupName, string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedules/"+ (Name==null? "" : System.Uri.EscapeDataString(Name))+"?clientToken=" + (clientToken==null? "" : System.Uri.EscapeDataString(clientToken))+"&groupName=" + (groupName==null? "" : System.Uri.EscapeDataString(groupName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DeleteScheduleOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the specified schedule.
		/// GetSchedule schedules/{Name}
		/// </summary>
		/// <param name="groupName">The name of the schedule group associated with this schedule. If you omit this, EventBridge Scheduler assumes that the schedule is associated with the default group.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="Name">The name of the schedule to retrieve.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <returns>Success</returns>
		public async Task<GetScheduleOutput> GetScheduleAsync(string groupName, string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedules/"+ (Name==null? "" : System.Uri.EscapeDataString(Name))+"?groupName=" + (groupName==null? "" : System.Uri.EscapeDataString(groupName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetScheduleOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p> Updates the specified schedule. When you call <code>UpdateSchedule</code>, EventBridge Scheduler uses all values, including empty values, specified in the request and overrides the existing schedule. This is by design. This means that if you do not set an optional field in your request, that field will be set to its system-default value after the update. </p> <p> Before calling this operation, we recommend that you call the <code>GetSchedule</code> API operation and make a note of all optional parameters for your <code>UpdateSchedule</code> call. </p>
		/// UpdateSchedule schedules/{Name}
		/// </summary>
		/// <param name="Name">The name of the schedule that you are updating.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateScheduleOutput> UpdateScheduleAsync(string Name, UpdateSchedulePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedules/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateScheduleOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates the specified schedule group.
		/// CreateScheduleGroup schedule-groups/{Name}
		/// </summary>
		/// <param name="Name">The name of the schedule group that you are creating.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateScheduleGroupOutput> CreateScheduleGroupAsync(string Name, CreateScheduleGroupPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedule-groups/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateScheduleGroupOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes the specified schedule group. Deleting a schedule group results in EventBridge Scheduler deleting all schedules associated with the group. When you delete a group, it remains in a <code>DELETING</code> state until all of its associated schedules are deleted. Schedules associated with the group that are set to run while the schedule group is in the process of being deleted might continue to invoke their targets until the schedule group and its associated schedules are deleted.</p> <note> <p> This operation is eventually consistent. </p> </note>
		/// DeleteScheduleGroup schedule-groups/{Name}
		/// </summary>
		/// <param name="clientToken"> Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. 
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="Name">The name of the schedule group to delete.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteScheduleGroupOutput> DeleteScheduleGroupAsync(string clientToken, string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedule-groups/"+ (Name==null? "" : System.Uri.EscapeDataString(Name))+"?clientToken=" + (clientToken==null? "" : System.Uri.EscapeDataString(clientToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DeleteScheduleGroupOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the specified schedule group.
		/// GetScheduleGroup schedule-groups/{Name}
		/// </summary>
		/// <param name="Name">The name of the schedule group to retrieve.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <returns>Success</returns>
		public async Task<GetScheduleGroupOutput> GetScheduleGroupAsync(string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedule-groups/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetScheduleGroupOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated list of your schedule groups.
		/// ListScheduleGroups schedule-groups
		/// </summary>
		/// <param name="MaxResults">If specified, limits the number of results returned by this operation. The operation also returns a <code>NextToken</code> which you can use in a subsequent operation to retrieve the next set of results.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="NamePrefix">The name prefix that you can use to return a filtered list of your schedule groups.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="NextToken">The token returned by a previous call to retrieve the next set of results.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <returns>Success</returns>
		public async Task<ListScheduleGroupsOutput> ListScheduleGroupsAsync(int MaxResults, string NamePrefix, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedule-groups?MaxResults="+MaxResults+"&NamePrefix=" + (NamePrefix==null? "" : System.Uri.EscapeDataString(NamePrefix))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListScheduleGroupsOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated list of your EventBridge Scheduler schedules.
		/// ListSchedules schedules
		/// </summary>
		/// <param name="ScheduleGroup">If specified, only lists the schedules whose associated schedule group matches the given filter.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="MaxResults">If specified, limits the number of results returned by this operation. The operation also returns a <code>NextToken</code> which you can use in a subsequent operation to retrieve the next set of results.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="NamePrefix">Schedule name prefix to return the filtered list of resources.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="NextToken">The token returned by a previous call to retrieve the next set of results.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="State">If specified, only lists the schedules whose current state matches the given filter.</param>
		/// <returns>Success</returns>
		public async Task<ListSchedulesOutput> ListSchedulesAsync(string ScheduleGroup, int MaxResults, string NamePrefix, string NextToken, AssignPublicIp State, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "schedules?ScheduleGroup=" + (ScheduleGroup==null? "" : System.Uri.EscapeDataString(ScheduleGroup))+"&MaxResults="+MaxResults+"&NamePrefix=" + (NamePrefix==null? "" : System.Uri.EscapeDataString(NamePrefix))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken))+"&State=" + State;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListSchedulesOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the tags associated with the Scheduler resource.
		/// ListTagsForResource tags/{ResourceArn}
		/// </summary>
		/// <param name="ResourceArn">The ARN of the EventBridge Scheduler resource for which you want to view tags.
		/// Min length: 1
		/// Max length: 1011
		// </param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceOutput> ListTagsForResourceAsync(string ResourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (ResourceArn==null? "" : System.Uri.EscapeDataString(ResourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListTagsForResourceOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Assigns one or more tags (key-value pairs) to the specified EventBridge Scheduler resource. You can only assign tags to schedule groups.
		/// TagResource tags/{ResourceArn}
		/// </summary>
		/// <param name="ResourceArn">The Amazon Resource Name (ARN) of the schedule group that you are adding tags to.
		/// Min length: 1
		/// Max length: 1011
		// </param>
		/// <returns>Success</returns>
		public async Task<TagResourceOutput> TagResourceAsync(string ResourceArn, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (ResourceArn==null? "" : System.Uri.EscapeDataString(ResourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TagResourceOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes one or more tags from the specified EventBridge Scheduler schedule group.
		/// UntagResource tags/{ResourceArn}#TagKeys
		/// </summary>
		/// <param name="ResourceArn">The Amazon Resource Name (ARN) of the schedule group from which you are removing tags.
		/// Min length: 1
		/// Max length: 1011
		// </param>
		/// <param name="TagKeys">The list of tag keys to remove from the resource.
		/// Minimum items: 0
		/// Maximum items: 200
		// </param>
		/// <returns>Success</returns>
		public async Task<UntagResourceOutput> UntagResourceAsync(string ResourceArn, string[] TagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (ResourceArn==null? "" : System.Uri.EscapeDataString(ResourceArn))+"#TagKeys&"+string.Join("&", TagKeys.Select(z => $"TagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UntagResourceOutput>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class CreateSchedulePostBody
	{
		
		/// <summary>
		/// Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ActionAfterCompletion ActionAfterCompletion { get; set; }
		
		/// <summary>
		///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. 
		/// Min length: 1
		/// Max length: 64
		/// Pattern: ^[a-zA-Z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_]+$")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The description you specify for the schedule.
		/// Min length: 0
		/// Max length: 512
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(512)]
		public string Description { get; set; }
		
		/// <summary>
		/// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the <code>EndDate</code> you specify. EventBridge Scheduler ignores <code>EndDate</code> for one-time schedules.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateSchedulePostBodyFlexibleTimeWindow FlexibleTimeWindow { get; set; }
		
		/// <summary>
		/// The name of the schedule group to associate with this schedule. If you omit this, the default schedule group is used.
		/// Min length: 1
		/// Max length: 64
		/// Pattern: ^[0-9a-zA-Z-_.]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[0-9a-zA-Z-_.]+$")]
		public string GroupName { get; set; }
		
		/// <summary>
		/// The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
		/// Min length: 1
		/// Max length: 2048
		/// Pattern: ^arn:aws(-[a-z]+)?:kms:[a-z0-9\-]+:\d{12}:(key|alias)\/[0-9a-zA-Z-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2048)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws(-[a-z]+)?:kms:[a-z0-9\-]+:\d{12}:(key|alias)\/[0-9a-zA-Z-_]*$")]
		public string KmsKeyArn { get; set; }
		
		/// <summary>
		/// <p> The expression that defines when the schedule runs. The following formats are supported. </p> <ul> <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li> <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li> <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li> </ul> <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p> <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p> <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p> <p> For more information and examples, see <a href="https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
		/// Required
		/// Min length: 1
		/// Max length: 256
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string ScheduleExpression { get; set; }
		
		/// <summary>
		/// The timezone in which the scheduling expression is evaluated.
		/// Min length: 1
		/// Max length: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string ScheduleExpressionTimezone { get; set; }
		
		/// <summary>
		/// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the <code>StartDate</code> you specify. EventBridge Scheduler ignores <code>StartDate</code> for one-time schedules.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
		
		/// <summary>
		/// Specifies whether the schedule is enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AssignPublicIp State { get; set; }
		
		/// <summary>
		/// The schedule's target. EventBridge Scheduler supports templated target that invoke common API operations, as well as universal targets that you can customize to invoke over 6,000 API operations across more than 270 services. You can only specify one templated or universal target for a schedule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateSchedulePostBodyTarget Target { get; set; }
	}
	
	public class CreateSchedulePostBodyFlexibleTimeWindow
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaximumWindowInMinutes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FlexibleTimeWindowMode Mode { get; set; }
	}
	
	public class CreateSchedulePostBodyTarget
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeadLetterConfig DeadLetterConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EcsParameters EcsParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EventBridgeParameters EventBridgeParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KinesisParameters KinesisParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RetryPolicy RetryPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SageMakerPipelineParameters SageMakerPipelineParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SqsParameters SqsParameters { get; set; }
	}
	
	public class UpdateSchedulePutBody
	{
		
		/// <summary>
		/// Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ActionAfterCompletion ActionAfterCompletion { get; set; }
		
		/// <summary>
		///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. 
		/// Min length: 1
		/// Max length: 64
		/// Pattern: ^[a-zA-Z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_]+$")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The description you specify for the schedule.
		/// Min length: 0
		/// Max length: 512
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(512)]
		public string Description { get; set; }
		
		/// <summary>
		/// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the <code>EndDate</code> you specify. EventBridge Scheduler ignores <code>EndDate</code> for one-time schedules.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateSchedulePutBodyFlexibleTimeWindow FlexibleTimeWindow { get; set; }
		
		/// <summary>
		/// The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.
		/// Min length: 1
		/// Max length: 64
		/// Pattern: ^[0-9a-zA-Z-_.]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[0-9a-zA-Z-_.]+$")]
		public string GroupName { get; set; }
		
		/// <summary>
		/// The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.
		/// Min length: 1
		/// Max length: 2048
		/// Pattern: ^arn:aws(-[a-z]+)?:kms:[a-z0-9\-]+:\d{12}:(key|alias)\/[0-9a-zA-Z-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2048)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws(-[a-z]+)?:kms:[a-z0-9\-]+:\d{12}:(key|alias)\/[0-9a-zA-Z-_]*$")]
		public string KmsKeyArn { get; set; }
		
		/// <summary>
		/// <p> The expression that defines when the schedule runs. The following formats are supported. </p> <ul> <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li> <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li> <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li> </ul> <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p> <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p> <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p> <p> For more information and examples, see <a href="https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
		/// Required
		/// Min length: 1
		/// Max length: 256
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string ScheduleExpression { get; set; }
		
		/// <summary>
		/// The timezone in which the scheduling expression is evaluated.
		/// Min length: 1
		/// Max length: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string ScheduleExpressionTimezone { get; set; }
		
		/// <summary>
		/// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the <code>StartDate</code> you specify. EventBridge Scheduler ignores <code>StartDate</code> for one-time schedules.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
		
		/// <summary>
		/// Specifies whether the schedule is enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AssignPublicIp State { get; set; }
		
		/// <summary>
		/// The schedule's target. EventBridge Scheduler supports templated target that invoke common API operations, as well as universal targets that you can customize to invoke over 6,000 API operations across more than 270 services. You can only specify one templated or universal target for a schedule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateSchedulePutBodyTarget Target { get; set; }
	}
	
	public class UpdateSchedulePutBodyFlexibleTimeWindow
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaximumWindowInMinutes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FlexibleTimeWindowMode Mode { get; set; }
	}
	
	public class UpdateSchedulePutBodyTarget
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeadLetterConfig DeadLetterConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EcsParameters EcsParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EventBridgeParameters EventBridgeParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KinesisParameters KinesisParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RetryPolicy RetryPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SageMakerPipelineParameters SageMakerPipelineParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SqsParameters SqsParameters { get; set; }
	}
	
	public class CreateScheduleGroupPostBody
	{
		
		/// <summary>
		///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. 
		/// Min length: 1
		/// Max length: 64
		/// Pattern: ^[a-zA-Z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_]+$")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The list of tags to associate with the schedule group.
		/// Minimum items: 0
		/// Maximum items: 200
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(200)]
		public Tag[] Tags { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// The list of tags to associate with the schedule group.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 200
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(200)]
		public Tag[] Tags { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
