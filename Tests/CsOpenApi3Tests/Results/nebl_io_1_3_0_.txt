//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Error
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public string Fields { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BroadcastTxRequest
	{
		
		/// <summary>
		/// Signed raw tx hex to broadcast
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="txHex")]
		public string TxHex { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BroadcastTxResponse
	{
		
		/// <summary>
		/// Txid of successfully broadcasted transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BurnTokenRequest
	{
		
		/// <summary>
		/// Array of objects representing tokens to be burned
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="burn")]
		public BurnTokenRequestBurn[] BurnTokenRequestBurn { get; set; }
		
		/// <summary>
		/// Fee in satoshi to include in the issuance transaction min 10000 (0.0001 NEBL)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fee")]
		public double Fee { get; set; }
		
		/// <summary>
		/// Array of addresses to send the token from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string[] From { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transfer")]
		public BurnTokenRequestTransfer[] BurnTokenRequestTransfer { get; set; }
	}
	
	public class BurnTokenRequestBurn
	{
		
		/// <summary>
		/// Amount of tokens to burn
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// Unique token id we are burning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
	}
	
	public class BurnTokenRequestTransfer
	{
		
		/// <summary>
		/// Address to transfer tokens to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Number of tokens to send
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// ID of token we are sending
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BurnTokenResponse
	{
		
		/// <summary>
		/// Array of indexes of multisig outputs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multisigOutputs")]
		public double[] MultisigOutputs { get; set; }
		
		/// <summary>
		/// Array of indexes transfering NTP1 tokens
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ntp1OutputIndexes")]
		public double[] Ntp1OutputIndexes { get; set; }
		
		/// <summary>
		/// Unsigned, raw transaction hex of the transaction to burn the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txHex")]
		public string TxHex { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetAddressInfoResponse
	{
		
		/// <summary>
		/// The Neblio Address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Array of UTXOs held at this address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utxos")]
		public GetAddressInfoResponseUtxos[] GetAddressInfoResponseUtxos { get; set; }
	}
	
	public class GetAddressInfoResponseUtxos
	{
		
		/// <summary>
		/// Blockheight of the UTXO
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockheight")]
		public System.Nullable<System.Double> Blockheight { get; set; }
		
		/// <summary>
		/// Blocktime of the UTXO
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blocktime")]
		public System.Nullable<System.Double> Blocktime { get; set; }
		
		/// <summary>
		/// Index of the UTXO at this address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Double> Index { get; set; }
		
		/// <summary>
		/// Object representing the scruptPubKey of the UTXO
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scriptPubKey")]
		public string ScriptPubKey { get; set; }
		
		/// <summary>
		/// Array of NTP1 tokens in this UTXO.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokens")]
		public GetAddressInfoResponseUtxosTokens[] GetAddressInfoResponseUtxosTokens { get; set; }
		
		/// <summary>
		/// Txid of this UTXO
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// Whether the UTXO has been used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="used")]
		public System.Nullable<System.Boolean> Used { get; set; }
		
		/// <summary>
		/// Value of the UTXO in NEBL satoshi
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	public class GetAddressInfoResponseUtxosTokens
	{
		
		/// <summary>
		/// Whether the tokens can be aggregated together
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationPolicy")]
		public string AggregationPolicy { get; set; }
		
		/// <summary>
		/// Number of Tokens
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// Decimal places the token is divisible to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="divisibility")]
		public System.Nullable<System.Double> Divisibility { get; set; }
		
		/// <summary>
		/// TXID the token originally was issued in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issueTxid")]
		public string IssueTxid { get; set; }
		
		/// <summary>
		/// Whether the token is locked, preventing more from being issued
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lockStatus")]
		public System.Nullable<System.Boolean> LockStatus { get; set; }
		
		/// <summary>
		/// Unique NTP1 identifier for this token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetAddressResponse
	{
		
		/// <summary>
		/// Address in string form
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addrStr")]
		public string AddrStr { get; set; }
		
		/// <summary>
		/// NEBL balance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="balance")]
		public System.Nullable<System.Double> Balance { get; set; }
		
		/// <summary>
		/// NEBL balance in satoshis
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="balanceSat")]
		public System.Nullable<System.Double> BalanceSat { get; set; }
		
		/// <summary>
		/// Total NEBL received
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalReceived")]
		public System.Nullable<System.Double> TotalReceived { get; set; }
		
		/// <summary>
		/// Total NEBL received in satoshis
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalReceivedSat")]
		public System.Nullable<System.Double> TotalReceivedSat { get; set; }
		
		/// <summary>
		/// Total NEBL sent
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalSent")]
		public System.Nullable<System.Double> TotalSent { get; set; }
		
		/// <summary>
		/// Total NEBL sent satoshis
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalSentSat")]
		public System.Nullable<System.Double> TotalSentSat { get; set; }
		
		/// <summary>
		/// Array of transaction ids for this address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transactions")]
		public string[] Transactions { get; set; }
		
		/// <summary>
		/// Number of transactions for this address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txAppearances")]
		public System.Nullable<System.Double> TxAppearances { get; set; }
		
		/// <summary>
		/// Unconfirmed NEBL balance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unconfirmedBalance")]
		public System.Nullable<System.Double> UnconfirmedBalance { get; set; }
		
		/// <summary>
		/// Unconfirmed NEBL balance in satoshis
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unconfirmedBalanceSat")]
		public System.Nullable<System.Double> UnconfirmedBalanceSat { get; set; }
		
		/// <summary>
		/// Number of unconfirmed transactions for this address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unconfirmedTxAppearances")]
		public System.Nullable<System.Double> UnconfirmedTxAppearances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetAddressUtxosResponseElement
	{
		
		/// <summary>
		/// Address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// NEBL amount
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// Number of confirmations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Double> Confirmations { get; set; }
		
		/// <summary>
		/// scriptPubKey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scriptPubKey")]
		public string ScriptPubKey { get; set; }
		
		/// <summary>
		/// Timestamp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.Double> Ts { get; set; }
		
		/// <summary>
		/// Transaction ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// vout
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public System.Nullable<System.Double> Vout { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetBlockIndexResponse
	{
		
		/// <summary>
		/// Hash of the requested block
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockHash")]
		public string BlockHash { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetBlockResponse
	{
		
		/// <summary>
		/// Block bits
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bits")]
		public string Bits { get; set; }
		
		/// <summary>
		/// Number of confirmations block has
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Double> Confirmations { get; set; }
		
		/// <summary>
		/// Block difficulty
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="difficulty")]
		public System.Nullable<System.Double> Difficulty { get; set; }
		
		/// <summary>
		/// Block hash
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hash")]
		public string Hash { get; set; }
		
		/// <summary>
		/// Block height
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Double> Height { get; set; }
		
		/// <summary>
		/// Merkleroot of block
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="merkleroot")]
		public string Merkleroot { get; set; }
		
		/// <summary>
		/// Hash of the next block on the chain
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextblockhash")]
		public string Nextblockhash { get; set; }
		
		/// <summary>
		/// Block nonce
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nonce")]
		public System.Nullable<System.Double> Nonce { get; set; }
		
		/// <summary>
		/// Hash of the previous block on the chain
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previousblockhash")]
		public string Previousblockhash { get; set; }
		
		/// <summary>
		/// Number of NEBL awarded in this block
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reward")]
		public System.Nullable<System.Double> Reward { get; set; }
		
		/// <summary>
		/// Block size in bytes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Double> Size { get; set; }
		
		/// <summary>
		/// Block time relative to epoch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Double> Time { get; set; }
		
		/// <summary>
		/// Array of tx ids in the block
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tx")]
		public string[] Tx { get; set; }
		
		/// <summary>
		/// Block version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Double> Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetFaucetResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public GetFaucetResponseData Data { get; set; }
		
		/// <summary>
		/// Whether the withdrawal was successful
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class GetFaucetResponseData
	{
		
		/// <summary>
		/// TXID of a successful withdrawal
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txId")]
		public string TxId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetRawTxResponse
	{
		
		/// <summary>
		/// Raw hex representing the transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawtx")]
		public string Rawtx { get; set; }
	}
	
	/// <summary>
	/// Depending on the function called, the structure and information contained in this object will vary
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStatusResponse
	{
	}
	
	/// <summary>
	/// Object containing node sync status
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetSyncResponse
	{
		
		/// <summary>
		/// Current blockchain height
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockChainHeight")]
		public System.Nullable<System.Double> BlockChainHeight { get; set; }
		
		/// <summary>
		/// Recent sync error messages
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		/// <summary>
		/// Height node is synced to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Double> Height { get; set; }
		
		/// <summary>
		/// Current sync status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Current sync percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncPercentage")]
		public System.Nullable<System.Double> SyncPercentage { get; set; }
		
		/// <summary>
		/// Node type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetTokenHoldersResponse
	{
		
		/// <summary>
		/// Whether the tokesn are aggregatable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationPolicy")]
		public string AggregationPolicy { get; set; }
		
		/// <summary>
		/// How many decimal points the token is divisble to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="divibility")]
		public System.Nullable<System.Double> Divibility { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="holders")]
		public GetTokenHoldersResponseHolders[] GetTokenHoldersResponseHolders { get; set; }
		
		/// <summary>
		/// Whether new issuances of this token are locked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lockStatus")]
		public System.Nullable<System.Boolean> LockStatus { get; set; }
		
		/// <summary>
		/// A UTXO of this token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="someUtxo")]
		public string SomeUtxo { get; set; }
		
		/// <summary>
		/// TokenId of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
	}
	
	public class GetTokenHoldersResponseHolders
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetTokenIdResponse
	{
		
		/// <summary>
		/// Unique ID of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
		
		/// <summary>
		/// String representing the token Symbol
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenName")]
		public string TokenName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetTokenMetadataResponse
	{
		
		/// <summary>
		/// Whether the tokens are aggregatable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationPolicy")]
		public string AggregationPolicy { get; set; }
		
		/// <summary>
		/// Decimal places the token is divisible to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="divisibility")]
		public System.Nullable<System.Double> Divisibility { get; set; }
		
		/// <summary>
		/// Block number token was issued in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstBlock")]
		public System.Nullable<System.Double> FirstBlock { get; set; }
		
		/// <summary>
		/// Total tokens issued in initial issuance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initialIssuanceAmount")]
		public System.Nullable<System.Double> InitialIssuanceAmount { get; set; }
		
		/// <summary>
		/// TXID the token was issued with
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuanceTxid")]
		public string IssuanceTxid { get; set; }
		
		/// <summary>
		/// Address that issued the tokens
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issueAddress")]
		public string IssueAddress { get; set; }
		
		/// <summary>
		/// Whether issuance of more tokens is locked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lockStatus")]
		public System.Nullable<System.Boolean> LockStatus { get; set; }
		
		/// <summary>
		/// Metadata set at issuance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadataOfIssuance")]
		public GetTokenMetadataResponseMetadataOfIssuance MetadataOfIssuance { get; set; }
		
		/// <summary>
		/// Metadata set for UTXO
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadataOfUtxo")]
		public GetTokenMetadataResponseMetadataOfUtxo MetadataOfUtxo { get; set; }
		
		/// <summary>
		/// Number of times tokens have been burned
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numOfBurns")]
		public System.Nullable<System.Double> NumOfBurns { get; set; }
		
		/// <summary>
		/// Total number of addresses this token is held at
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numOfHolders")]
		public System.Nullable<System.Double> NumOfHolders { get; set; }
		
		/// <summary>
		/// Total number of times this token has been issued
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numOfIssuance")]
		public System.Nullable<System.Double> NumOfIssuance { get; set; }
		
		/// <summary>
		/// Total number of transactions of this token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numOfTransfers")]
		public System.Nullable<System.Double> NumOfTransfers { get; set; }
		
		/// <summary>
		/// Example UTXO containing this token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="someUtxo")]
		public string SomeUtxo { get; set; }
		
		/// <summary>
		/// ID of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
		
		/// <summary>
		/// Total number of tokens in supply
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalSupply")]
		public System.Nullable<System.Double> TotalSupply { get; set; }
	}
	
	public class GetTokenMetadataResponseMetadataOfIssuance
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public GetTokenMetadataResponseMetadataOfIssuanceData Data { get; set; }
	}
	
	public class GetTokenMetadataResponseMetadataOfIssuanceData
	{
		
		/// <summary>
		/// Token description
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Name of token issuer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		/// <summary>
		/// Token symbol
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenName")]
		public string TokenName { get; set; }
		
		/// <summary>
		/// Metadata set by user on token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		public GetTokenMetadataResponseMetadataOfIssuanceDataUserData UserData { get; set; }
	}
	
	public class GetTokenMetadataResponseMetadataOfIssuanceDataUserData
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public GetTokenMetadataResponseMetadataOfIssuanceDataUserDataMeta[] GetTokenMetadataResponseMetadataOfIssuanceDataUserDataMeta { get; set; }
	}
	
	public class GetTokenMetadataResponseMetadataOfIssuanceDataUserDataMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class GetTokenMetadataResponseMetadataOfUtxo
	{
		
		/// <summary>
		/// Metadata set by user on token for UTXO
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		public GetTokenMetadataResponseMetadataOfUtxoUserData UserData { get; set; }
	}
	
	public class GetTokenMetadataResponseMetadataOfUtxoUserData
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public string[] Meta { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetTransactionInfoResponse
	{
		
		/// <summary>
		/// Hash of the block this transaction is in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockhash")]
		public string Blockhash { get; set; }
		
		/// <summary>
		/// Block height of this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockheight")]
		public System.Nullable<System.Double> Blockheight { get; set; }
		
		/// <summary>
		/// Block time of this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blocktime")]
		public System.Nullable<System.Double> Blocktime { get; set; }
		
		/// <summary>
		/// Number of transaction confirmations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Double> Confirmations { get; set; }
		
		/// <summary>
		/// Total NEBL used as fee for this transcation in satoshis
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fee")]
		public System.Nullable<System.Double> Fee { get; set; }
		
		/// <summary>
		/// Transaction in raw hex
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
		
		/// <summary>
		/// Transaction locktime
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locktime")]
		public System.Nullable<System.Double> Locktime { get; set; }
		
		/// <summary>
		/// Transaction time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Double> Time { get; set; }
		
		/// <summary>
		/// Total NEBL sent in this transaction in satoshis
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalsent")]
		public System.Nullable<System.Double> Totalsent { get; set; }
		
		/// <summary>
		/// TXID of transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// Transaction version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Double> Version { get; set; }
		
		/// <summary>
		/// Array of transaction inputs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vin")]
		public GetTransactionInfoResponseVin[] GetTransactionInfoResponseVin { get; set; }
		
		/// <summary>
		/// Array of transaction outputs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public GetTransactionInfoResponseVout[] GetTransactionInfoResponseVout { get; set; }
	}
	
	public class GetTransactionInfoResponseVin
	{
		
		[System.Runtime.Serialization.DataMember(Name="previousOutput")]
		public GetTransactionInfoResponseVinPreviousOutput PreviousOutput { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scriptSig")]
		public GetTransactionInfoResponseVinScriptSig ScriptSig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sequence")]
		public System.Nullable<System.Double> Sequence { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tokens")]
		public GetTransactionInfoResponseVinTokens[] GetTransactionInfoResponseVinTokens { get; set; }
		
		/// <summary>
		/// TXID of the input
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// Value of input in NEBL satoshi
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
		
		/// <summary>
		/// output index
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public System.Nullable<System.Double> Vout { get; set; }
	}
	
	public class GetTransactionInfoResponseVinPreviousOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="asm")]
		public string Asm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reqSigs")]
		public System.Nullable<System.Double> ReqSigs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetTransactionInfoResponseVinScriptSig
	{
		
		[System.Runtime.Serialization.DataMember(Name="asm")]
		public string Asm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
	}
	
	public class GetTransactionInfoResponseVinTokens
	{
		
		/// <summary>
		/// Whether the tokens are aggregatable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationPolicy")]
		public string AggregationPolicy { get; set; }
		
		/// <summary>
		/// Number of tokens
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// Decimal places the token is divisible to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="divisibility")]
		public System.Nullable<System.Double> Divisibility { get; set; }
		
		/// <summary>
		/// TXID the token was issued in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issueTxid")]
		public string IssueTxid { get; set; }
		
		/// <summary>
		/// Whether issuance of more tokens is locked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lockStatus")]
		public System.Nullable<System.Boolean> LockStatus { get; set; }
		
		/// <summary>
		/// ID of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
	}
	
	public class GetTransactionInfoResponseVout
	{
		
		/// <summary>
		/// Blockheight of this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockheight")]
		public System.Nullable<System.Double> Blockheight { get; set; }
		
		/// <summary>
		/// Output index
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="n")]
		public System.Nullable<System.Double> N { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scriptPubKey")]
		public GetTransactionInfoResponseVoutScriptPubKey ScriptPubKey { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tokens")]
		public GetTransactionInfoResponseVoutTokens[] GetTransactionInfoResponseVoutTokens { get; set; }
		
		/// <summary>
		/// Whether this output has now been used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="used")]
		public System.Nullable<System.Boolean> Used { get; set; }
		
		/// <summary>
		/// Blockheight this output was used in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usedBlockheight")]
		public System.Nullable<System.Double> UsedBlockheight { get; set; }
		
		/// <summary>
		/// TXID this output was used in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usedTxid")]
		public string UsedTxid { get; set; }
		
		/// <summary>
		/// Value of the output in NEBL satoshi
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	public class GetTransactionInfoResponseVoutScriptPubKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="asm")]
		public string Asm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reqSigs")]
		public System.Nullable<System.Double> ReqSigs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetTransactionInfoResponseVoutTokens
	{
		
		/// <summary>
		/// Whether the tokens are aggregatable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationPolicy")]
		public string AggregationPolicy { get; set; }
		
		/// <summary>
		/// Number of tokens
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// Decimal places the token is divisible to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="divisibility")]
		public System.Nullable<System.Double> Divisibility { get; set; }
		
		/// <summary>
		/// TXID the token was issued in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issueTxid")]
		public string IssueTxid { get; set; }
		
		/// <summary>
		/// Whether issuance of more tokens is locked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lockStatus")]
		public System.Nullable<System.Boolean> LockStatus { get; set; }
		
		/// <summary>
		/// ID of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetTxResponse
	{
		
		/// <summary>
		/// Hash of the block this transaction is in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockhash")]
		public string Blockhash { get; set; }
		
		/// <summary>
		/// Block height of this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockheight")]
		public System.Nullable<System.Double> Blockheight { get; set; }
		
		/// <summary>
		/// Block time of this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blocktime")]
		public System.Nullable<System.Double> Blocktime { get; set; }
		
		/// <summary>
		/// Number of transaction confirmations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Double> Confirmations { get; set; }
		
		/// <summary>
		/// Total NEBL used as fee for this transcation in satoshis
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fee")]
		public System.Nullable<System.Double> Fee { get; set; }
		
		/// <summary>
		/// Total NEBL used in fees for this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fees")]
		public System.Nullable<System.Double> Fees { get; set; }
		
		/// <summary>
		/// Transaction locktime
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locktime")]
		public System.Nullable<System.Double> Locktime { get; set; }
		
		/// <summary>
		/// Transcation size in bytes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Double> Size { get; set; }
		
		/// <summary>
		/// Transaction time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Double> Time { get; set; }
		
		/// <summary>
		/// Total NEBL sent in this transaction in satoshis
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalsent")]
		public System.Nullable<System.Double> Totalsent { get; set; }
		
		/// <summary>
		/// TXID of transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// Total NEBL input in this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="valueIn")]
		public System.Nullable<System.Double> ValueIn { get; set; }
		
		/// <summary>
		/// Total NEBL output in this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="valueOut")]
		public System.Nullable<System.Double> ValueOut { get; set; }
		
		/// <summary>
		/// Transaction version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Double> Version { get; set; }
		
		/// <summary>
		/// Array of transaction inputs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vin")]
		public GetTxResponseVin[] GetTxResponseVin { get; set; }
		
		/// <summary>
		/// Array of transaction outputs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public GetTxResponseVout[] GetTxResponseVout { get; set; }
	}
	
	public class GetTxResponseVin
	{
		
		/// <summary>
		/// input index
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="n")]
		public System.Nullable<System.Double> N { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scriptSig")]
		public GetTxResponseVinScriptSig ScriptSig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sequence")]
		public System.Nullable<System.Double> Sequence { get; set; }
		
		/// <summary>
		/// TXID of the input
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// Value of input in NEBL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
		
		/// <summary>
		/// Value of input in NEBL satoshi
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="valueSat")]
		public System.Nullable<System.Double> ValueSat { get; set; }
		
		/// <summary>
		/// output index
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public System.Nullable<System.Double> Vout { get; set; }
	}
	
	public class GetTxResponseVinScriptSig
	{
		
		[System.Runtime.Serialization.DataMember(Name="asm")]
		public string Asm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
	}
	
	public class GetTxResponseVout
	{
		
		/// <summary>
		/// Blockheight of this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockheight")]
		public System.Nullable<System.Double> Blockheight { get; set; }
		
		/// <summary>
		/// Output index
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="n")]
		public System.Nullable<System.Double> N { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scriptPubKey")]
		public GetTxResponseVoutScriptPubKey ScriptPubKey { get; set; }
		
		/// <summary>
		/// Whether this output has now been used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="used")]
		public System.Nullable<System.Boolean> Used { get; set; }
		
		/// <summary>
		/// Blockheight this output was used in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usedBlockheight")]
		public System.Nullable<System.Double> UsedBlockheight { get; set; }
		
		/// <summary>
		/// TXID this output was used in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usedTxid")]
		public string UsedTxid { get; set; }
		
		/// <summary>
		/// Value of the output in NEBL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	public class GetTxResponseVoutScriptPubKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="asm")]
		public string Asm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reqSigs")]
		public System.Nullable<System.Double> ReqSigs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Object containing an array of transaction objects
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetTxsResponse
	{
		
		/// <summary>
		/// Number of pages of transactions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pagesTotal")]
		public System.Nullable<System.Double> PagesTotal { get; set; }
		
		/// <summary>
		/// Array of transaction objects
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txs")]
		public GetTxResponse[] Txs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IssueTokenRequest
	{
		
		/// <summary>
		/// Number of tokens to issue
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public double Amount { get; set; }
		
		/// <summary>
		/// Number of decimal places the token should be divisble by (0-7)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="divisibility")]
		public double Divisibility { get; set; }
		
		/// <summary>
		/// Fee in satoshi to include in the issuance transaction min 1000000000 (10 NEBL)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fee")]
		public double Fee { get; set; }
		
		/// <summary>
		/// Object representing flags that potentialy modify this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flags")]
		public IssueTokenRequestFlags Flags { get; set; }
		
		/// <summary>
		/// Address issuing the token
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issueAddress")]
		public string IssueAddress { get; set; }
		
		/// <summary>
		/// Object representing all metadata at token issuance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public IssueTokenRequestMetadata Metadata { get; set; }
		
		/// <summary>
		/// whether the token should be reissuable
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reissuable")]
		public bool Reissuable { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transfer")]
		public IssueTokenRequestTransfer[] IssueTokenRequestTransfer { get; set; }
	}
	
	public class IssueTokenRequestFlags
	{
		
		/// <summary>
		/// If true change will be split into 2 outputs, one for NEBL change and one for NTP1 change (recommended)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splitChange")]
		public System.Nullable<System.Boolean> SplitChange { get; set; }
	}
	
	public class IssueTokenRequestMetadata
	{
		
		/// <summary>
		/// Long name or description of token (ex. Nibble)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Array of encryption instruction objects for encrypting userData
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptions")]
		public IssueTokenRequestMetadataEncryptions[] IssueTokenRequestMetadataEncryptions { get; set; }
		
		/// <summary>
		/// Name of token issuer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		/// <summary>
		/// Object describing token rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public IssueTokenRequestMetadataRules Rules { get; set; }
		
		/// <summary>
		/// Token Symbol it will be identified by (ex. NIBBL)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenName")]
		public string TokenName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="urls")]
		public IssueTokenRequestMetadataUrls[] IssueTokenRequestMetadataUrls { get; set; }
		
		/// <summary>
		/// Metadata set by user on token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		public IssueTokenRequestMetadataUserData UserData { get; set; }
	}
	
	public class IssueTokenRequestMetadataEncryptions
	{
		
		/// <summary>
		/// key format (pem or der)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// userData key to encrypt
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// RSA public key used for encryption
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pubkey")]
		public string Pubkey { get; set; }
		
		/// <summary>
		/// pkcs1 or pkcs8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class IssueTokenRequestMetadataRules
	{
		
		/// <summary>
		/// Object describing expiration rules of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiration")]
		public IssueTokenRequestMetadataRulesExpiration Expiration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fees")]
		public IssueTokenRequestMetadataRulesFees Fees { get; set; }
		
		/// <summary>
		/// Array of objects describing what addresses can hold the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="holders")]
		public IssueTokenRequestMetadataRulesHolders[] IssueTokenRequestMetadataRulesHolders { get; set; }
	}
	
	public class IssueTokenRequestMetadataRulesExpiration
	{
		
		/// <summary>
		/// Whether this rule can be modified in future transactions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public System.Nullable<System.Boolean> Locked { get; set; }
		
		/// <summary>
		/// Blockheight at wh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validUntil")]
		public System.Nullable<System.Double> ValidUntil { get; set; }
	}
	
	public class IssueTokenRequestMetadataRulesFees
	{
		
		/// <summary>
		/// Array of objects describing fee rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public IssueTokenRequestMetadataRulesFeesItems[] IssueTokenRequestMetadataRulesFeesItems { get; set; }
		
		/// <summary>
		/// Whether this rule can be modified in future transactions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public System.Nullable<System.Boolean> Locked { get; set; }
	}
	
	public class IssueTokenRequestMetadataRulesFeesItems
	{
		
		/// <summary>
		/// Address fee is auto sent to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// How fee should be paid, either with a tokenId, or with NEBL if null
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
		
		/// <summary>
		/// Amount of NTP1 token, or NEBL (in satoshi) to pay as fee
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class IssueTokenRequestMetadataRulesHolders
	{
		
		/// <summary>
		/// Address that can hold the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Whether this rule can be modified in future transactions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public System.Nullable<System.Boolean> Locked { get; set; }
	}
	
	public class IssueTokenRequestMetadataUrls
	{
		
		/// <summary>
		/// Hash of data at the URL, used for verification
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataHash")]
		public string DataHash { get; set; }
		
		/// <summary>
		/// mimeType of URL content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mimeType")]
		public string MimeType { get; set; }
		
		/// <summary>
		/// Name of the URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Actual URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class IssueTokenRequestMetadataUserData
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public IssueTokenRequestMetadataUserDataMeta[] IssueTokenRequestMetadataUserDataMeta { get; set; }
	}
	
	public class IssueTokenRequestMetadataUserDataMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class IssueTokenRequestTransfer
	{
		
		/// <summary>
		/// Address to send the amount of issued tokens to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IssueTokenResponse
	{
		
		/// <summary>
		/// TokenId of the to be issued token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
		
		/// <summary>
		/// Unsigned, raw transaction hex of the transaction to issue the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txHex")]
		public string TxHex { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RpcRequest
	{
		
		/// <summary>
		/// Identifier of RCP caller
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue("neblio-apis")]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; } = "neblio-apis";
		
		/// <summary>
		/// JSON-RPC version
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue("1.0")]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jsonrpc")]
		public string Jsonrpc { get; set; } = "1.0";
		
		/// <summary>
		/// Name of the Neblio RPC method to call
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// Array of string params that should be passed to the RPC method.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="params")]
		public string[] Params { get; set; }
	}
	
	/// <summary>
	/// Object containing the JSON response from the Neblio node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RpcResponse
	{
		
		/// <summary>
		/// Object containing any error information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		/// <summary>
		/// Identifier of RCP caller
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Object containing the response output.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public string Result { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SendTokenRequest
	{
		
		/// <summary>
		/// Fee in satoshi to include in the issuance transaction min 10000 (0.0001 NEBL)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fee")]
		public double Fee { get; set; }
		
		/// <summary>
		/// Object representing flags that potentialy modify this transaction
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flags")]
		public SendTokenRequestFlags Flags { get; set; }
		
		/// <summary>
		/// Array of addresses to send the token from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string[] From { get; set; }
		
		/// <summary>
		/// Object representing all metadata at token issuance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public SendTokenRequestMetadata Metadata { get; set; }
		
		/// <summary>
		/// Array of UTXOs to send the token from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sendutxo")]
		public string[] Sendutxo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public SendTokenRequestTo[] SendTokenRequestTo { get; set; }
	}
	
	public class SendTokenRequestFlags
	{
		
		/// <summary>
		/// If true change will be split into 2 outputs, one for NEBL change and one for NTP1 change (recommended)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splitChange")]
		public System.Nullable<System.Boolean> SplitChange { get; set; }
	}
	
	public class SendTokenRequestMetadata
	{
		
		/// <summary>
		/// Long name or description of token (ex. Nibble)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Array of encryption instruction objects for encrypting userData
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptions")]
		public SendTokenRequestMetadataEncryptions[] SendTokenRequestMetadataEncryptions { get; set; }
		
		/// <summary>
		/// Name of token issuer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		/// <summary>
		/// Object describing token rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public SendTokenRequestMetadataRules Rules { get; set; }
		
		/// <summary>
		/// Token Symbol it will be identified by (ex. NIBBL)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenName")]
		public string TokenName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="urls")]
		public SendTokenRequestMetadataUrls[] SendTokenRequestMetadataUrls { get; set; }
		
		/// <summary>
		/// Metadata set by user on token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		public SendTokenRequestMetadataUserData UserData { get; set; }
	}
	
	public class SendTokenRequestMetadataEncryptions
	{
		
		/// <summary>
		/// key format (pem or der)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// userData key to encrypt
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// RSA public key used for encryption
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pubkey")]
		public string Pubkey { get; set; }
		
		/// <summary>
		/// pkcs1 or pkcs8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class SendTokenRequestMetadataRules
	{
		
		/// <summary>
		/// Object describing expiration rules of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiration")]
		public SendTokenRequestMetadataRulesExpiration Expiration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fees")]
		public SendTokenRequestMetadataRulesFees Fees { get; set; }
		
		/// <summary>
		/// Array of objects describing what addresses can hold the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="holders")]
		public SendTokenRequestMetadataRulesHolders[] SendTokenRequestMetadataRulesHolders { get; set; }
	}
	
	public class SendTokenRequestMetadataRulesExpiration
	{
		
		/// <summary>
		/// Whether this rule can be modified in future transactions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public System.Nullable<System.Boolean> Locked { get; set; }
		
		/// <summary>
		/// Blockheight at wh
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validUntil")]
		public System.Nullable<System.Double> ValidUntil { get; set; }
	}
	
	public class SendTokenRequestMetadataRulesFees
	{
		
		/// <summary>
		/// Array of objects describing fee rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public SendTokenRequestMetadataRulesFeesItems[] SendTokenRequestMetadataRulesFeesItems { get; set; }
		
		/// <summary>
		/// Whether this rule can be modified in future transactions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public System.Nullable<System.Boolean> Locked { get; set; }
	}
	
	public class SendTokenRequestMetadataRulesFeesItems
	{
		
		/// <summary>
		/// Address fee is auto sent to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// How fee should be paid, either with a tokenId, or with NEBL if null
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
		
		/// <summary>
		/// Amount of NTP1 token, or NEBL (in satoshi) to pay as fee
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class SendTokenRequestMetadataRulesHolders
	{
		
		/// <summary>
		/// Address that can hold the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Whether this rule can be modified in future transactions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public System.Nullable<System.Boolean> Locked { get; set; }
	}
	
	public class SendTokenRequestMetadataUrls
	{
		
		/// <summary>
		/// Hash of data at the URL, used for verification
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataHash")]
		public string DataHash { get; set; }
		
		/// <summary>
		/// mimeType of URL content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mimeType")]
		public string MimeType { get; set; }
		
		/// <summary>
		/// Name of the URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Actual URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class SendTokenRequestMetadataUserData
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public SendTokenRequestMetadataUserDataMeta[] SendTokenRequestMetadataUserDataMeta { get; set; }
	}
	
	public class SendTokenRequestMetadataUserDataMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class SendTokenRequestTo
	{
		
		/// <summary>
		/// Address to transfer tokens to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Number of tokens to send
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// ID of token we are sending
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SendTokenResponse
	{
		
		/// <summary>
		/// Array of indexes of multisig outputs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multisigOutputs")]
		public double[] MultisigOutputs { get; set; }
		
		/// <summary>
		/// Array of indexes transfering NTP1 tokens
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ntp1OutputIndexes")]
		public double[] Ntp1OutputIndexes { get; set; }
		
		/// <summary>
		/// Unsigned, raw transaction hex of the transaction to send the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txHex")]
		public string TxHex { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SendTxRequest
	{
		
		/// <summary>
		/// Signed raw tx hex to broadcast
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rawtx")]
		public string Rawtx { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Send a JSON-RPC call to a localhost neblio-Qt or nebliod node
		/// Call any Neblio RPC command from the Neblio API libraries. Useful for signing transactions with a local node and other functions. Will not work from a browser due to CORS restrictions. Requires a node to be running locally at 127.0.0.1
		/// Json_rpc 
		/// </summary>
		/// <returns>Object containing the JSON response from the Neblio node.</returns>
		public async Task<RpcResponse> Json_rpcAsync(RpcRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RpcResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns address object
		/// Returns NEBL address object containing information on a specific address
		/// GetAddress ins/addr/{address}
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Object containing address info</returns>
		public async Task<GetAddressResponse> GetAddressAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetAddressResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns address balance in sats
		/// Returns NEBL address balance in satoshis
		/// GetAddressBalance ins/addr/{address}/balance
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Address balance</returns>
		public async Task<double> GetAddressBalanceAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/balance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<double>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns total received by address in sats
		/// Returns total NEBL received by address in satoshis
		/// GetAddressTotalReceived ins/addr/{address}/totalReceived
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Total received by address</returns>
		public async Task<double> GetAddressTotalReceivedAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/totalReceived";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<double>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns total sent by address in sats
		/// Returns total NEBL sent by address in satoshis
		/// GetAddressTotalSent ins/addr/{address}/totalSent
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Total sent by address</returns>
		public async Task<double> GetAddressTotalSentAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/totalSent";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<double>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns address unconfirmed balance in sats
		/// Returns NEBL address unconfirmed balance in satoshis
		/// GetAddressUnconfirmedBalance ins/addr/{address}/unconfirmedBalance
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Address unconfirmed balance</returns>
		public async Task<double> GetAddressUnconfirmedBalanceAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/unconfirmedBalance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<double>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all UTXOs at a given address
		/// Returns information on each Unspent Transaction Output contained at an address
		/// GetAddressUtxos ins/addr/{address}/utxo
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>UTXOs at an address</returns>
		public async Task<GetAddressUtxosReturn[]> GetAddressUtxosAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/utxo";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetAddressUtxosReturn[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns block hash of block
		/// Returns the block hash of a block at a given block index
		/// GetBlockIndex ins/block-index/{blockindex}
		/// </summary>
		/// <param name="blockindex">Block Index</param>
		/// <returns>Object containing block hash</returns>
		public async Task<GetBlockIndexResponse> GetBlockIndexAsync(double blockindex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/block-index/"+blockindex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetBlockIndexResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns information regarding a Neblio block
		/// Returns blockchain data for a given block based upon the block hash
		/// GetBlock ins/block/{blockhash}
		/// </summary>
		/// <param name="blockhash">Block Hash</param>
		/// <returns>Object containing all information on a blockchain block</returns>
		public async Task<GetBlockResponse> GetBlockAsync(string blockhash, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/block/"+ (blockhash==null? "" : System.Uri.EscapeDataString(blockhash));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetBlockResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns raw transaction hex
		/// Returns raw transaction hex representing a NEBL transaction
		/// GetRawTx ins/rawtx/{txid}
		/// </summary>
		/// <param name="txid">Transaction ID</param>
		/// <returns>Object containing raw hex of transaction</returns>
		public async Task<GetRawTxResponse> GetRawTxAsync(string txid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/rawtx/"+ (txid==null? "" : System.Uri.EscapeDataString(txid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetRawTxResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Utility API for calling several blockchain node functions
		/// Utility API for calling several blockchain node functions - getInfo, getDifficulty, getBestBlockHash, getLastBlockHash
		/// GetStatus ins/status
		/// </summary>
		/// <param name="q">Function to call, getInfo, getDifficulty, getBestBlockHash, or getLastBlockHash</param>
		/// <returns>Function Response</returns>
		public async Task<GetStatusResponse> GetStatusAsync(string q, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/status?q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetStatusResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get node sync status
		/// Returns information on the node's sync progress
		/// GetSync ins/sync
		/// </summary>
		/// <returns>Sync Info</returns>
		public async Task<GetSyncResponse> GetSyncAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/sync";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetSyncResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Broadcasts a signed raw transaction to the network (not NTP1 specific)
		/// Broadcasts a signed raw transaction to the network. If successful returns the txid of the broadcast trasnaction.
		/// 
		/// SendTx ins/tx/send
		/// </summary>
		/// <param name="requestBody">Object representing a transaction to broadcast</param>
		/// <returns>An object containing the TXID if the broadcast was successful</returns>
		public async Task<BroadcastTxResponse> SendTxAsync(SendTxRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/tx/send";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BroadcastTxResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns transaction object
		/// Returns NEBL transaction object representing a NEBL transaction
		/// GetTx ins/tx/{txid}
		/// </summary>
		/// <param name="txid">Transaction ID</param>
		/// <returns>Object containing transaction info</returns>
		public async Task<GetTxResponse> GetTxAsync(string txid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/tx/"+ (txid==null? "" : System.Uri.EscapeDataString(txid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTxResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get transactions by block or address
		/// Returns all transactions by block or address
		/// GetTxs ins/txs
		/// </summary>
		/// <param name="address">Address</param>
		/// <param name="block">Block Hash</param>
		/// <param name="pageNum">Page number to display</param>
		/// <returns>List of transactions</returns>
		public async Task<GetTxsResponse> GetTxsAsync(string address, string block, double pageNum, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ins/txs?address=" + (address==null? "" : System.Uri.EscapeDataString(address))+"&block=" + (block==null? "" : System.Uri.EscapeDataString(block))+"&pageNum="+pageNum;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTxsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Information On a Neblio Address
		/// Returns both NEBL and NTP1 token UTXOs held at the given address.
		/// 
		/// GetAddressInfo ntp1/addressinfo/{address}
		/// </summary>
		/// <param name="address">Neblio Address to get information on.</param>
		/// <returns>An object with an array of UTXOs for this address</returns>
		public async Task<GetAddressInfoResponse> GetAddressInfoAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/addressinfo/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetAddressInfoResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Broadcasts a signed raw transaction to the network
		/// Broadcasts a signed raw transaction to the network. If successful returns the txid of the broadcast trasnaction.
		/// 
		/// BroadcastTx ntp1/broadcast
		/// </summary>
		/// <param name="requestBody">Object representing a transaction to broadcast</param>
		/// <returns>An object containing the TXID if the broadcast was successful</returns>
		public async Task<BroadcastTxResponse> BroadcastTxAsync(BroadcastTxRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/broadcast";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BroadcastTxResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Builds a transaction that burns an NTP1 Token
		/// Builds an unsigned raw transaction that burns an NTP1 token on the Neblio blockchain.
		/// 
		/// BurnToken ntp1/burntoken
		/// </summary>
		/// <param name="requestBody">Object representing the token to be burned</param>
		/// <returns>An object representing the tx to burn the token</returns>
		public async Task<BurnTokenResponse> BurnTokenAsync(BurnTokenRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/burntoken";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BurnTokenResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Builds a transaction that issues a new NTP1 Token
		/// Builds an unsigned raw transaction that issues a new NTP1 token on the Neblio blockchain.
		/// 
		/// IssueToken ntp1/issue
		/// </summary>
		/// <param name="requestBody">Object representing the token to be created</param>
		/// <returns>An object representing the token created</returns>
		public async Task<IssueTokenResponse> IssueTokenAsync(IssueTokenRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/issue";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IssueTokenResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Builds a transaction that sends an NTP1 Token
		/// Builds an unsigned raw transaction that sends an NTP1 token on the Neblio blockchain.
		/// 
		/// SendToken ntp1/sendtoken
		/// </summary>
		/// <param name="requestBody">Object representing the token to be sent</param>
		/// <returns>An object representing the tx to send the token</returns>
		public async Task<SendTokenResponse> SendTokenAsync(SendTokenRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/sendtoken";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SendTokenResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Addresses Holding a Token
		/// Returns the the the addresses holding a token and how many tokens are held
		/// 
		/// GetTokenHolders ntp1/stakeholders/{tokenid}
		/// </summary>
		/// <param name="tokenid">TokenId to request metadata for</param>
		/// <returns>An object containing all of the addresses holding a token</returns>
		public async Task<GetTokenHoldersResponse> GetTokenHoldersAsync(string tokenid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/stakeholders/"+ (tokenid==null? "" : System.Uri.EscapeDataString(tokenid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTokenHoldersResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the tokenId representing a token
		/// Translates a token symbol to a tokenId if a token exists with that symbol on the network
		/// 
		/// GetTokenId ntp1/tokenid/{tokensymbol}
		/// </summary>
		/// <param name="tokensymbol">Token symbol</param>
		/// <returns>Object containing the token symbol and ID, if token symbol does not exist on network, empty object is returned.</returns>
		public async Task<GetTokenIdResponse> GetTokenIdAsync(string tokensymbol, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/tokenid/"+ (tokensymbol==null? "" : System.Uri.EscapeDataString(tokensymbol));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTokenIdResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Metadata of Token
		/// Returns the metadata associated with a token.
		/// 
		/// GetTokenMetadata ntp1/tokenmetadata/{tokenid}
		/// </summary>
		/// <param name="tokenid">TokenId to request metadata for</param>
		/// <param name="verbosity">0 (Default) is fastest, 1 contains token stats, 2 contains token holding addresses</param>
		/// <returns>An object containing the metadata of a token</returns>
		public async Task<GetTokenMetadataResponse> GetTokenMetadataAsync(string tokenid, double verbosity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/tokenmetadata/"+ (tokenid==null? "" : System.Uri.EscapeDataString(tokenid))+"&verbosity="+verbosity;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTokenMetadataResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get UTXO Metadata of Token
		/// Returns the metadata associated with a token for that specific utxo instead of the issuance transaction.
		/// 
		/// GetTokenMetadataOfUtxo ntp1/tokenmetadata/{tokenid}/{utxo}
		/// </summary>
		/// <param name="tokenid">TokenId to request metadata for</param>
		/// <param name="utxo">Specific UTXO to request metadata for</param>
		/// <param name="verbosity">0 (Default) is fastest, 1 contains token stats, 2 contains token holding addresses</param>
		/// <returns>An object containing the metadata of a token for a UTXO</returns>
		public async Task<GetTokenMetadataResponse> GetTokenMetadataOfUtxoAsync(string tokenid, string utxo, double verbosity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/tokenmetadata/"+ (tokenid==null? "" : System.Uri.EscapeDataString(tokenid))+"/"+ (utxo==null? "" : System.Uri.EscapeDataString(utxo))+"&verbosity="+verbosity;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTokenMetadataResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Information On an NTP1 Transaction
		/// Returns detailed information regarding an NTP1 transaction.
		/// 
		/// GetTransactionInfo ntp1/transactioninfo/{txid}
		/// </summary>
		/// <param name="txid">Neblio txid to get information on.</param>
		/// <returns>An object represending this transaction</returns>
		public async Task<GetTransactionInfoResponse> GetTransactionInfoAsync(string txid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ntp1/transactioninfo/"+ (txid==null? "" : System.Uri.EscapeDataString(txid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTransactionInfoResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Withdraws testnet NEBL to the specified address
		/// Withdraw testnet NEBL to your Neblio Testnet address. By default amount is 1500000000 or 15 NEBL and has a max of 50 NEBL. Only 2 withdrawals allowed per 24 hour period.
		/// 
		/// Testnet_getFaucet testnet/faucet
		/// </summary>
		/// <param name="address">Your Neblio Testnet Address</param>
		/// <param name="amount">Amount of NEBL to withdrawal in satoshis</param>
		/// <returns>Object containing the transaction ID of the withdrawal.</returns>
		public async Task<GetFaucetResponse> Testnet_getFaucetAsync(string address, double amount, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/faucet?address=" + (address==null? "" : System.Uri.EscapeDataString(address))+"&amount="+amount;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetFaucetResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns address object
		/// Returns NEBL address object containing information on a specific address
		/// Testnet_getAddress testnet/ins/addr/{address}
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Object containing address info</returns>
		public async Task<GetAddressResponse> Testnet_getAddressAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetAddressResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns address balance in sats
		/// Returns NEBL address balance in satoshis
		/// Testnet_getAddressBalance testnet/ins/addr/{address}/balance
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Address balance</returns>
		public async Task<double> Testnet_getAddressBalanceAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/balance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<double>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns total received by address in sats
		/// Returns total NEBL received by address in satoshis
		/// Testnet_getAddressTotalReceived testnet/ins/addr/{address}/totalReceived
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Total received by address</returns>
		public async Task<double> Testnet_getAddressTotalReceivedAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/totalReceived";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<double>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns total sent by address in sats
		/// Returns total NEBL sent by address in satoshis
		/// Testnet_getAddressTotalSent testnet/ins/addr/{address}/totalSent
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Total sent by address</returns>
		public async Task<double> Testnet_getAddressTotalSentAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/totalSent";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<double>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns address unconfirmed balance in sats
		/// Returns NEBL address unconfirmed balance in satoshis
		/// Testnet_getAddressUnconfirmedBalance testnet/ins/addr/{address}/unconfirmedBalance
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>Address unconfirmed balance</returns>
		public async Task<double> Testnet_getAddressUnconfirmedBalanceAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/unconfirmedBalance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<double>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all UTXOs at a given address
		/// Returns information on each Unspent Transaction Output contained at an address
		/// Testnet_getAddressUtxos testnet/ins/addr/{address}/utxo
		/// </summary>
		/// <param name="address">Address</param>
		/// <returns>UTXOs at an address</returns>
		public async Task<Testnet_getAddressUtxosReturn[]> Testnet_getAddressUtxosAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/addr/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/utxo";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Testnet_getAddressUtxosReturn[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns block hash of block
		/// Returns the block hash of a block at a given block index
		/// Testnet_getBlockIndex testnet/ins/block-index/{blockindex}
		/// </summary>
		/// <param name="blockindex">Block Index</param>
		/// <returns>Object containing block hash</returns>
		public async Task<GetBlockIndexResponse> Testnet_getBlockIndexAsync(double blockindex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/block-index/"+blockindex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetBlockIndexResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns information regarding a Neblio block
		/// Returns blockchain data for a given block based upon the block hash
		/// Testnet_getBlock testnet/ins/block/{blockhash}
		/// </summary>
		/// <param name="blockhash">Block Hash</param>
		/// <returns>Object containing all information on a blockchain block</returns>
		public async Task<GetBlockResponse> Testnet_getBlockAsync(string blockhash, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/block/"+ (blockhash==null? "" : System.Uri.EscapeDataString(blockhash));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetBlockResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns raw transaction hex
		/// Returns raw transaction hex representing a NEBL transaction
		/// Testnet_getRawTx testnet/ins/rawtx/{txid}
		/// </summary>
		/// <param name="txid">Transaction ID</param>
		/// <returns>Object containing raw hex of transaction</returns>
		public async Task<GetRawTxResponse> Testnet_getRawTxAsync(string txid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/rawtx/"+ (txid==null? "" : System.Uri.EscapeDataString(txid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetRawTxResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Utility API for calling several blockchain node functions
		/// Utility API for calling several blockchain node functions - getInfo, getDifficulty, getBestBlockHash, getLastBlockHash
		/// Testnet_getStatus testnet/ins/status
		/// </summary>
		/// <param name="q">Function to call, getInfo, getDifficulty, getBestBlockHash, or getLastBlockHash</param>
		/// <returns>Function Response</returns>
		public async Task<GetStatusResponse> Testnet_getStatusAsync(string q, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/status?q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetStatusResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get node sync status
		/// Returns information on the node's sync progress
		/// Testnet_getSync testnet/ins/sync
		/// </summary>
		/// <returns>Sync Info</returns>
		public async Task<GetSyncResponse> Testnet_getSyncAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/sync";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetSyncResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Broadcasts a signed raw transaction to the network (not NTP1 specific)
		/// Broadcasts a signed raw transaction to the network. If successful returns the txid of the broadcast trasnaction.
		/// 
		/// Testnet_sendTx testnet/ins/tx/send
		/// </summary>
		/// <param name="requestBody">Object representing a transaction to broadcast</param>
		/// <returns>An object containing the TXID if the broadcast was successful</returns>
		public async Task<BroadcastTxResponse> Testnet_sendTxAsync(SendTxRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/tx/send";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BroadcastTxResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns transaction object
		/// Returns NEBL transaction object representing a NEBL transaction
		/// Testnet_getTx testnet/ins/tx/{txid}
		/// </summary>
		/// <param name="txid">Transaction ID</param>
		/// <returns>Object containing transaction info</returns>
		public async Task<GetTxResponse> Testnet_getTxAsync(string txid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/tx/"+ (txid==null? "" : System.Uri.EscapeDataString(txid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTxResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get transactions by block or address
		/// Returns all transactions by block or address
		/// Testnet_getTxs testnet/ins/txs
		/// </summary>
		/// <param name="address">Address</param>
		/// <param name="block">Block Hash</param>
		/// <param name="pageNum">Page number to display</param>
		/// <returns>List of transactions</returns>
		public async Task<GetTxsResponse> Testnet_getTxsAsync(string address, string block, double pageNum, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ins/txs?address=" + (address==null? "" : System.Uri.EscapeDataString(address))+"&block=" + (block==null? "" : System.Uri.EscapeDataString(block))+"&pageNum="+pageNum;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTxsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Information On a Neblio Address
		/// Returns both NEBL and NTP1 token UTXOs held at the given address.
		/// 
		/// Testnet_getAddressInfo testnet/ntp1/addressinfo/{address}
		/// </summary>
		/// <param name="address">Neblio Address to get information on.</param>
		/// <returns>An object with an array of UTXOs for this address</returns>
		public async Task<GetAddressInfoResponse> Testnet_getAddressInfoAsync(string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/addressinfo/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetAddressInfoResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Broadcasts a signed raw transaction to the network
		/// Broadcasts a signed raw transaction to the network. If successful returns the txid of the broadcast trasnaction.
		/// 
		/// Testnet_broadcastTx testnet/ntp1/broadcast
		/// </summary>
		/// <param name="requestBody">Object representing a transaction to broadcast</param>
		/// <returns>An object containing the TXID if the broadcast was successful</returns>
		public async Task<BroadcastTxResponse> Testnet_broadcastTxAsync(BroadcastTxRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/broadcast";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BroadcastTxResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Builds a transaction that burns an NTP1 Token
		/// Builds an unsigned raw transaction that burns an NTP1 token on the Neblio blockchain.
		/// 
		/// Testnet_burnToken testnet/ntp1/burntoken
		/// </summary>
		/// <param name="requestBody">Object representing the token to be burned</param>
		/// <returns>An object representing the tx to burn the token</returns>
		public async Task<BurnTokenResponse> Testnet_burnTokenAsync(BurnTokenRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/burntoken";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<BurnTokenResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Builds a transaction that issues a new NTP1 Token
		/// Builds an unsigned raw transaction that issues a new NTP1 token on the Neblio blockchain.
		/// 
		/// Testnet_issueToken testnet/ntp1/issue
		/// </summary>
		/// <param name="requestBody">Object representing the token to be created</param>
		/// <returns>An object representing the token created</returns>
		public async Task<IssueTokenResponse> Testnet_issueTokenAsync(IssueTokenRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/issue";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IssueTokenResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Builds a transaction that sends an NTP1 Token
		/// Builds an unsigned raw transaction that sends an NTP1 token on the Neblio blockchain.
		/// 
		/// Testnet_sendToken testnet/ntp1/sendtoken
		/// </summary>
		/// <param name="requestBody">Object representing the token to be sent</param>
		/// <returns>An object representing the tx to send the token</returns>
		public async Task<SendTokenResponse> Testnet_sendTokenAsync(SendTokenRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/sendtoken";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SendTokenResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Addresses Holding a Token
		/// Returns the the the addresses holding a token and how many tokens are held
		/// 
		/// Testnet_getTokenHolders testnet/ntp1/stakeholders/{tokenid}
		/// </summary>
		/// <param name="tokenid">TokenId to request metadata for</param>
		/// <returns>An object containing all of the addresses holding a token</returns>
		public async Task<GetTokenHoldersResponse> Testnet_getTokenHoldersAsync(string tokenid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/stakeholders/"+ (tokenid==null? "" : System.Uri.EscapeDataString(tokenid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTokenHoldersResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the tokenId representing a token
		/// Translates a token symbol to a tokenId if a token exists with that symbol on the network
		/// 
		/// Testnet_getTokenId testnet/ntp1/tokenid/{tokensymbol}
		/// </summary>
		/// <param name="tokensymbol">Token symbol</param>
		/// <returns>Object containing the token symbol and ID, if token symbol does not exist on network, empty object is returned.</returns>
		public async Task<GetTokenIdResponse> Testnet_getTokenIdAsync(string tokensymbol, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/tokenid/"+ (tokensymbol==null? "" : System.Uri.EscapeDataString(tokensymbol));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTokenIdResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Metadata of Token
		/// Returns the metadata associated with a token.
		/// 
		/// Testnet_getTokenMetadata testnet/ntp1/tokenmetadata/{tokenid}
		/// </summary>
		/// <param name="tokenid">TokenId to request metadata for</param>
		/// <param name="verbosity">0 (Default) is fastest, 1 contains token stats, 2 contains token holding addresses</param>
		/// <returns>An object containing the metadata of a token</returns>
		public async Task<GetTokenMetadataResponse> Testnet_getTokenMetadataAsync(string tokenid, double verbosity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/tokenmetadata/"+ (tokenid==null? "" : System.Uri.EscapeDataString(tokenid))+"&verbosity="+verbosity;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTokenMetadataResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get UTXO Metadata of Token
		/// Returns the metadata associated with a token for that specific utxo instead of the issuance transaction.
		/// 
		/// Testnet_getTokenMetadataOfUtxo testnet/ntp1/tokenmetadata/{tokenid}/{utxo}
		/// </summary>
		/// <param name="tokenid">TokenId to request metadata for</param>
		/// <param name="utxo">Specific UTXO to request metadata for</param>
		/// <param name="verbosity">0 (Default) is fastest, 1 contains token stats, 2 contains token holding addresses</param>
		/// <returns>An object containing the metadata of a token for a UTXO</returns>
		public async Task<GetTokenMetadataResponse> Testnet_getTokenMetadataOfUtxoAsync(string tokenid, string utxo, double verbosity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/tokenmetadata/"+ (tokenid==null? "" : System.Uri.EscapeDataString(tokenid))+"/"+ (utxo==null? "" : System.Uri.EscapeDataString(utxo))+"&verbosity="+verbosity;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTokenMetadataResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Information On an NTP1 Transaction
		/// Returns detailed information regarding an NTP1 transaction.
		/// 
		/// Testnet_getTransactionInfo testnet/ntp1/transactioninfo/{txid}
		/// </summary>
		/// <param name="txid">Neblio txid to get information on.</param>
		/// <returns>An object represending this transaction</returns>
		public async Task<GetTransactionInfoResponse> Testnet_getTransactionInfoAsync(string txid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "testnet/ntp1/transactioninfo/"+ (txid==null? "" : System.Uri.EscapeDataString(txid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetTransactionInfoResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class GetAddressUtxosReturn
	{
		
		/// <summary>
		/// Address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// NEBL amount
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// Number of confirmations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Double> Confirmations { get; set; }
		
		/// <summary>
		/// scriptPubKey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scriptPubKey")]
		public string ScriptPubKey { get; set; }
		
		/// <summary>
		/// Timestamp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.Double> Ts { get; set; }
		
		/// <summary>
		/// Transaction ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// vout
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public System.Nullable<System.Double> Vout { get; set; }
	}
	
	public class Testnet_getAddressUtxosReturn
	{
		
		/// <summary>
		/// Address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// NEBL amount
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// Number of confirmations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Double> Confirmations { get; set; }
		
		/// <summary>
		/// scriptPubKey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scriptPubKey")]
		public string ScriptPubKey { get; set; }
		
		/// <summary>
		/// Timestamp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.Double> Ts { get; set; }
		
		/// <summary>
		/// Transaction ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		/// <summary>
		/// vout
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public System.Nullable<System.Double> Vout { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
