//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Representation of an Article to be created/updated
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Article
	{
		
		[System.Runtime.Serialization.DataMember(Name="article")]
		public ArticleArticle1 Article1 { get; set; }
	}
	
	public class ArticleArticle1
	{
		
		[System.Runtime.Serialization.DataMember(Name="body_markdown")]
		public string Body_markdown { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="canonical_url")]
		public string Canonical_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="main_image")]
		public string Main_image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organization_id")]
		public System.Nullable<System.Int32> Organization_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="published")]
		public System.Nullable<System.Boolean> Published { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="series")]
		public string Series { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// Flare tag of the article
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArticleFlareTag
	{
		
		/// <summary>
		/// Background color (hexadecimal)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bg_color_hex")]
		public string Bg_color_hex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Text color (hexadecimal)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text_color_hex")]
		public string Text_color_hex { get; set; }
	}
	
	/// <summary>
	/// Representation of an article or post returned in a list
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArticleIndex
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="canonical_url")]
		public string Canonical_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cover_image")]
		public string Cover_image { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="crossposted_at")]
		public System.Nullable<System.DateTimeOffset> Crossposted_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="edited_at")]
		public System.Nullable<System.DateTimeOffset> Edited_at { get; set; }
		
		/// <summary>
		/// Flare tag of the article
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flare_tag")]
		public ArticleFlareTag Flare_tag { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_comment_at")]
		public System.DateTimeOffset Last_comment_at { get; set; }
		
		/// <summary>
		/// The organization the resource belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public SharedOrganization Organization { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="positive_reactions_count")]
		public int Positive_reactions_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_reactions_count")]
		public int Public_reactions_count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="published_at")]
		public System.DateTimeOffset Published_at { get; set; }
		
		/// <summary>
		/// Crossposting or published date time
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="published_timestamp")]
		public System.DateTimeOffset Published_timestamp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="readable_publish_date")]
		public string Readable_publish_date { get; set; }
		
		/// <summary>
		/// Reading time, in minutes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reading_time_minutes")]
		public int Reading_time_minutes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="social_image")]
		public string Social_image { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag_list")]
		public string[] Tag_list { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public string Type_of { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The resource creator
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public SharedUser User { get; set; }
	}
	
	/// <summary>
	/// The organization the resource belongs to
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SharedOrganization
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Profile image (640x640)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_image")]
		public string Profile_image { get; set; }
		
		/// <summary>
		/// Profile image (90x90)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_image_90")]
		public string Profile_image_90 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// The resource creator
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SharedUser
	{
		
		[System.Runtime.Serialization.DataMember(Name="github_username")]
		public string Github_username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Profile image (640x640)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_image")]
		public string Profile_image { get; set; }
		
		/// <summary>
		/// Profile image (90x90)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_image_90")]
		public string Profile_image_90 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="website_url")]
		public string Website_url { get; set; }
	}
	
	/// <summary>
	/// A Comment on an Article or Podcast Episode
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Comment
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id_code")]
		public string Id_code { get; set; }
		
		/// <summary>
		/// Podcast image url
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public string Type_of { get; set; }
	}
	
	/// <summary>
	/// A Display Ad, aka Billboard, aka Widget
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisplayAd
	{
		
		/// <summary>
		/// Ad must be both published and approved to be in rotation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="approved")]
		public System.Nullable<System.Boolean> Approved { get; set; }
		
		/// <summary>
		/// Articles this ad should *not* appear on (blank means no articles are disallowed, and this ad can appear next to any/all articles). Comma-separated list of integer Article IDs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="article_exclude_ids")]
		public string Article_exclude_ids { get; set; }
		
		/// <summary>
		/// The text (in markdown) of the ad (required)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body_markdown")]
		public string Body_markdown { get; set; }
		
		/// <summary>
		/// Identifies the user who created the ad.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creator_id")]
		public System.Nullable<System.Int32> Creator_id { get; set; }
		
		/// <summary>
		/// Potentially limits visitors to whom the ad is visible
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display_to")]
		public System.Nullable<DisplayAdDisplay_to> Display_to { get; set; }
		
		/// <summary>
		/// The ID of the Display Ad
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// For internal use, helps distinguish ads from one another
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Identifies the organization to which the ad belongs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization_id")]
		public System.Nullable<System.Int32> Organization_id { get; set; }
		
		/// <summary>
		/// Identifies which area of site layout the ad can appear in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="placement_area")]
		public DisplayAdPlacement_area Placement_area { get; set; }
		
		/// <summary>
		/// Ad must be both published and approved to be in rotation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="published")]
		public System.Nullable<System.Boolean> Published { get; set; }
		
		/// <summary>
		/// Tags on which this ad can be displayed (blank is all/any tags)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag_list")]
		public string Tag_list { get; set; }
		
		/// <summary>
		/// Types of the billboards:
		///in_house (created by admins),
		///community (created by an entity, appears on entity's content),
		///external ( created by an entity, or a non-entity, can appear everywhere)
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public System.Nullable<DisplayAdType_of> Type_of { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DisplayAdDisplay_to
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="all")]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="logged_in")]
		logged_in = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="logged_out")]
		logged_out = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DisplayAdPlacement_area
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sidebar_left")]
		sidebar_left = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sidebar_left_2")]
		sidebar_left_2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sidebar_right")]
		sidebar_right = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="feed_first")]
		feed_first = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="feed_second")]
		feed_second = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="feed_third")]
		feed_third = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="post_sidebar")]
		post_sidebar = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="post_comments")]
		post_comments = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DisplayAdType_of
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="in_house")]
		in_house = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="community")]
		community = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="external")]
		external = 2,
	}
	
	/// <summary>
	/// Representation of a followed tag
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FollowedTag
	{
		
		/// <summary>
		/// Tag id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public long Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="points")]
		public float Points { get; set; }
	}
	
	/// <summary>
	/// Representation of an Organization
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Organization
	{
		
		[System.Runtime.Serialization.DataMember(Name="github_username")]
		public string Github_username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="joined_at")]
		public string Joined_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="story")]
		public string Story { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="summary")]
		public string Summary { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tag_line")]
		public string Tag_line { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tech_stack")]
		public string Tech_stack { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public string Type_of { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Representation of a page object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Page
	{
		
		/// <summary>
		/// For JSON pages, the JSON body
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body_json")]
		public string Body_json { get; set; }
		
		/// <summary>
		/// The text (in markdown) of the ad (required)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body_markdown")]
		public string Body_markdown { get; set; }
		
		/// <summary>
		/// For internal use, helps similar pages from one another
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// If true, the page is available at '/{slug}' instead of '/page/{slug}', use with caution
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_top_level_path")]
		public System.Nullable<System.Boolean> Is_top_level_path { get; set; }
		
		/// <summary>
		/// Used to link to this page in URLs, must be unique and URL-safe
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="social_image")]
		public string Social_image { get; set; }
		
		/// <summary>
		/// Controls what kind of layout the page is rendered in
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(PageTemplate.contained)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="template")]
		public PageTemplate Template { get; set; } = PageTemplate.contained;
		
		/// <summary>
		/// Title of the page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PageTemplate
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="contained")]
		contained = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="full_within_layout")]
		full_within_layout = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nav_bar_included")]
		nav_bar_included = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="json")]
		json = 3,
	}
	
	/// <summary>
	/// Representation of a podcast episode returned in a list
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PodcastEpisodeIndex
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="class_name")]
		public string Class_name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Podcast episode image url or podcast image url
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The podcast that the resource belongs to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="podcast")]
		public SharedPodcast Podcast { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public string Type_of { get; set; }
	}
	
	/// <summary>
	/// The podcast that the resource belongs to
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SharedPodcast
	{
		
		/// <summary>
		/// Podcast image url
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// A profile image object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProfileImage
	{
		
		/// <summary>
		/// Determines the type of the profile image owner (user or organization)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_of")]
		public string Image_of { get; set; }
		
		/// <summary>
		/// Profile image (640x640)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_image")]
		public string Profile_image { get; set; }
		
		/// <summary>
		/// Profile image (90x90)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_image_90")]
		public string Profile_image_90 { get; set; }
		
		/// <summary>
		/// Return profile_image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public string Type_of { get; set; }
	}
	
	/// <summary>
	/// Representation of a tag
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		[System.Runtime.Serialization.DataMember(Name="bg_color_hex")]
		public string Bg_color_hex { get; set; }
		
		/// <summary>
		/// Tag id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int64> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text_color_hex")]
		public string Text_color_hex { get; set; }
	}
	
	/// <summary>
	/// The representation of a user
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User
	{
		
		[System.Runtime.Serialization.DataMember(Name="github_username")]
		public string Github_username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int64> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="joined_at")]
		public string Joined_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profile_image")]
		public string Profile_image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="summary")]
		public string Summary { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter_username")]
		public string Twitter_username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public string Type_of { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="website_url")]
		public string Website_url { get; set; }
	}
	
	/// <summary>
	/// User invite parameters
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserInviteParam
	{
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Representation of an Article with video
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VideoArticle
	{
		
		[System.Runtime.Serialization.DataMember(Name="cloudinary_video_url")]
		public string Cloudinary_video_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int64> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public string Type_of { get; set; }
		
		/// <summary>
		/// Author of the article
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public VideoArticleUser User { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_id")]
		public System.Nullable<System.Int64> User_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="video_duration_in_minutes")]
		public string Video_duration_in_minutes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="video_source_url")]
		public string Video_source_url { get; set; }
	}
	
	public class VideoArticleUser
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Invite a User
		/// This endpoint allows the client to trigger an invitation to the provided email address.
		/// 
		/// It requires a token from a user with `super_admin` privileges.
		/// ApiAdminUsersPost api/admin/users
		/// </summary>
		/// <returns>Successful</returns>
		public async Task ApiAdminUsersPostAsync(UserInviteParam requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/admin/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Published articles
		/// This endpoint allows the client to retrieve a list of articles.
		/// 
		/// "Articles" are all the posts that users create on DEV that typically
		/// show up in the feed. They can be a blog post, a discussion question,
		/// a help thread etc. but is referred to as article within the code.
		/// 
		/// By default it will return featured, published articles ordered
		/// by descending popularity.
		/// 
		/// It supports pagination, each page will contain `30` articles by default.
		/// ApiArticlesGetByPageAndPer_pageAndTagAndTagsAndTags_excludeAndUsernameAndStateAndTopAndCollection_id api/articles
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="tag">Using this parameter will retrieve articles that contain the requested tag. Articles
		///will be ordered by descending popularity.This parameter can be used in conjuction with `top`.</param>
		/// <param name="tags">Using this parameter will retrieve articles with any of the comma-separated tags.
		///Articles will be ordered by descending popularity.</param>
		/// <param name="tags_exclude">Using this parameter will retrieve articles that do _not_ contain _any_
		///of comma-separated tags. Articles will be ordered by descending popularity.</param>
		/// <param name="username">Using this parameter will retrieve articles belonging
		///            to a User or Organization ordered by descending publication date.
		///            If `state=all` the number of items returned will be `1000` instead of the default `30`.
		///            This parameter can be used in conjuction with `state`.</param>
		/// <param name="state">Using this parameter will allow the client to check which articles are fresh or rising.
		///            If `state=fresh` the server will return fresh articles.
		///            If `state=rising` the server will return rising articles.
		///            This param can be used in conjuction with `username`, only if set to `all`.</param>
		/// <param name="top">Using this parameter will allow the client to return the most popular articles
		///in the last `N` days.
		///`top` indicates the number of days since publication of the articles returned.
		///This param can be used in conjuction with `tag`.
		/// Minimum: 1
		// </param>
		/// <param name="collection_id">Adding this will allow the client to return the list of articles
		///belonging to the requested collection, ordered by ascending publication date.</param>
		/// <returns>A List of Articles</returns>
		public async Task<ArticleIndex[]> ApiArticlesGetByPageAndPer_pageAndTagAndTagsAndTags_excludeAndUsernameAndStateAndTopAndCollection_idAsync(int page, int per_page, string tag, string tags, string tags_exclude, string username, ApiArticlesGetByPageAndPer_pageAndTagAndTagsAndTags_excludeAndUsernameAndStateAndTopAndCollection_idState state, int top, int collection_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles?page="+page+"&per_page="+per_page+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&tags=" + (tags==null? "" : System.Uri.EscapeDataString(tags))+"&tags_exclude=" + (tags_exclude==null? "" : System.Uri.EscapeDataString(tags_exclude))+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&state=" + state+"&top="+top+"&collection_id="+collection_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArticleIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Publish article
		/// This endpoint allows the client to create a new article.
		/// 
		/// "Articles" are all the posts that users create on DEV that typically show up in the feed. They can be a blog post, a discussion question, a help thread etc. but is referred to as article within the code.
		/// ApiArticlesPost api/articles
		/// </summary>
		public async Task ApiArticlesPostAsync(Article requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Published articles sorted by published date
		/// This endpoint allows the client to retrieve a list of articles. ordered by descending publish date.
		/// 
		/// It supports pagination, each page will contain 30 articles by default.
		/// ApiArticlesLatestGetByPageAndPer_page api/articles/latest
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>A List of Articles</returns>
		public async Task<ArticleIndex[]> ApiArticlesLatestGetByPageAndPer_pageAsync(int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/latest?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArticleIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// User's articles
		/// This endpoint allows the client to retrieve a list of published articles on behalf of an authenticated user.
		/// 
		/// "Articles" are all the posts that users create on DEV that typically show up in the feed. They can be a blog post, a discussion question, a help thread etc. but is referred to as article within the code.
		/// 
		/// Published articles will be in reverse chronological publication order.
		/// 
		/// It will return published articles with pagination. By default a page will contain 30 articles.
		/// ApiArticlesMeGetByPageAndPer_page api/articles/me
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>A List of the authenticated user's Articles</returns>
		public async Task<ArticleIndex[]> ApiArticlesMeGetByPageAndPer_pageAsync(int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/me?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArticleIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// User's all articles
		/// This endpoint allows the client to retrieve a list of all articles on behalf of an authenticated user.
		/// 
		/// "Articles" are all the posts that users create on DEV that typically show up in the feed. They can be a blog post, a discussion question, a help thread etc. but is referred to as article within the code.
		/// 
		/// It will return both published and unpublished articles with pagination.
		/// 
		/// Unpublished articles will be at the top of the list in reverse chronological creation order. Published articles will follow in reverse chronological publication order.
		/// 
		/// By default a page will contain 30 articles.
		/// ApiArticlesMeAllGetByPageAndPer_page api/articles/me/all
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>A List of the authenticated user's Articles</returns>
		public async Task<ArticleIndex[]> ApiArticlesMeAllGetByPageAndPer_pageAsync(int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/me/all?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArticleIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// User's published articles
		/// This endpoint allows the client to retrieve a list of published articles on behalf of an authenticated user.
		/// 
		/// "Articles" are all the posts that users create on DEV that typically show up in the feed. They can be a blog post, a discussion question, a help thread etc. but is referred to as article within the code.
		/// 
		/// Published articles will be in reverse chronological publication order.
		/// 
		/// It will return published articles with pagination. By default a page will contain 30 articles.
		/// ApiArticlesMePublishedGetByPageAndPer_page api/articles/me/published
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>A List of the authenticated user's Articles</returns>
		public async Task<ArticleIndex[]> ApiArticlesMePublishedGetByPageAndPer_pageAsync(int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/me/published?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArticleIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// User's unpublished articles
		/// This endpoint allows the client to retrieve a list of unpublished articles on behalf of an authenticated user.
		/// 
		/// "Articles" are all the posts that users create on DEV that typically show up in the feed. They can be a blog post, a discussion question, a help thread etc. but is referred to as article within the code.
		/// 
		/// Unpublished articles will be in reverse chronological creation order.
		/// 
		/// It will return unpublished articles with pagination. By default a page will contain 30 articles.
		/// ApiArticlesMeUnpublishedGetByPageAndPer_page api/articles/me/unpublished
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>A List of the authenticated user's Articles</returns>
		public async Task<ArticleIndex[]> ApiArticlesMeUnpublishedGetByPageAndPer_pageAsync(int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/me/unpublished?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArticleIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Published article by id
		/// This endpoint allows the client to retrieve a single published article given its `id`.
		/// ApiArticles_idGet api/articles/{id}
		/// </summary>
		/// <returns>An Article</returns>
		public async Task<string> ApiArticles_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an article by id
		/// This endpoint allows the client to update an existing article.
		/// 
		/// "Articles" are all the posts that users create on DEV that typically show up in the feed. They can be a blog post, a discussion question, a help thread etc. but is referred to as article within the code.
		/// ApiArticles_idPut api/articles/{id}
		/// </summary>
		/// <param name="id">The ID of the user to unpublish.
		/// Minimum: 1
		// </param>
		/// <returns>An Article</returns>
		public async Task ApiArticles_idPutAsync(int id, Article requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Unpublish an article
		/// This endpoint allows the client to unpublish an article.
		/// 
		/// The user associated with the API key must have any 'admin' or 'moderator' role.
		/// 
		/// The article will be unpublished and will no longer be visible to the public. It will remain
		/// in the database and will set back to draft status on the author's posts dashboard. Any
		/// notifications associated with the article will be deleted. Any comments on the article
		/// will remain.
		/// ApiArticles_idUnpublishPutByNote api/articles/{id}/unpublish
		/// </summary>
		/// <param name="id">The ID of the article to unpublish.
		/// Minimum: 1
		// </param>
		/// <param name="note">Content for the note that's created along with unpublishing</param>
		public async Task ApiArticles_idUnpublishPutByNoteAsync(int id, string note, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/"+id+"/unpublish?note=" + (note==null? "" : System.Uri.EscapeDataString(note));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Published article by path
		/// This endpoint allows the client to retrieve a single published article given its `path`.
		/// ApiArticles_username_slugGet api/articles/{username}/{slug}
		/// </summary>
		/// <returns>An Article</returns>
		public async Task<string> ApiArticles_username_slugGetAsync(string username, string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/articles/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Comments
		/// This endpoint allows the client to retrieve all comments belonging to an article or podcast episode as threaded conversations.
		/// 
		/// It will return the all top level comments with their nested comments as threads. See the format specification for further details.
		/// ApiCommentsGetByA_idAndP_id api/comments
		/// </summary>
		/// <param name="a_id">Article identifier.</param>
		/// <param name="p_id">Podcast Episode identifier.</param>
		/// <returns>A List of Comments</returns>
		public async Task<Comment[]> ApiCommentsGetByA_idAndP_idAsync(string a_id, string p_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/comments?a_id=" + (a_id==null? "" : System.Uri.EscapeDataString(a_id))+"&p_id=" + (p_id==null? "" : System.Uri.EscapeDataString(p_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Comment by id
		/// This endpoint allows the client to retrieve a comment as well as his descendants comments.
		/// 
		/// It will return the required comment (the root) with its nested descendants as a thread.
		/// 
		/// See the format specification for further details.
		/// ApiComments_idGet api/comments/{id}
		/// </summary>
		/// <param name="id">Comment identifier.</param>
		/// <returns>A List of the Comments</returns>
		public async Task ApiComments_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/comments/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// display ads
		/// This endpoint allows the client to retrieve a list of all display ads.
		/// ApiDisplay_adsGet api/display_ads
		/// </summary>
		/// <returns>successful</returns>
		public async Task<DisplayAd[]> ApiDisplay_adsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/display_ads";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DisplayAd[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// display ads
		/// This endpoint allows the client to create a new display ad.
		/// ApiDisplay_adsPost api/display_ads
		/// </summary>
		/// <returns>successful</returns>
		public async Task<string> ApiDisplay_adsPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/display_ads";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// display ad
		/// This endpoint allows the client to retrieve a single display ad, via its id.
		/// ApiDisplay_ads_idGet api/display_ads/{id}
		/// </summary>
		/// <param name="id">The ID of the display ad.
		/// Minimum: 1
		// </param>
		/// <returns>successful</returns>
		public async Task ApiDisplay_ads_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/display_ads/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// display ads
		/// This endpoint allows the client to update the attributes of a single display ad, via its id.
		/// ApiDisplay_ads_idPut api/display_ads/{id}
		/// </summary>
		/// <param name="id">The ID of the display ad.
		/// Minimum: 1
		// </param>
		/// <returns>successful</returns>
		public async Task<string> ApiDisplay_ads_idPutAsync(int id, string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/display_ads/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// unpublish
		/// This endpoint allows the client to remove a display ad from rotation by un-publishing it.
		/// ApiDisplay_ads_idUnpublishPut api/display_ads/{id}/unpublish
		/// </summary>
		/// <param name="id">The ID of the display ad to unpublish.
		/// Minimum: 1
		// </param>
		public async Task ApiDisplay_ads_idUnpublishPutAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/display_ads/"+id+"/unpublish";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Followers
		/// This endpoint allows the client to retrieve a list of the followers they have.
		/// "Followers" are users that are following other users on the website.
		/// It supports pagination, each page will contain 80 followers by default.
		/// ApiFollowersUsersGetByPageAndPer_pageAndSort api/followers/users
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="sort">Default is 'created_at'. Specifies the sort order for the created_at param of the follow
		///                                relationship. To sort by newest followers first (descending order) specify
		///                                ?sort=-created_at.</param>
		/// <returns>A List of followers</returns>
		public async Task<ApiFollowersUsersGetByPageAndPer_pageAndSortReturn[]> ApiFollowersUsersGetByPageAndPer_pageAndSortAsync(int page, int per_page, string sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/followers/users?page="+page+"&per_page="+per_page+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ApiFollowersUsersGetByPageAndPer_pageAndSortReturn[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Followed Tags
		/// This endpoint allows the client to retrieve a list of the tags they follow.
		/// ApiFollowsTagsGet api/follows/tags
		/// </summary>
		/// <returns>A List of followed tags</returns>
		public async Task<FollowedTag[]> ApiFollowsTagsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/follows/tags";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FollowedTag[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// An organization
		/// This endpoint allows the client to retrieve a single organization by their username
		/// ApiOrganizations_usernameGet api/organizations/{username}
		/// </summary>
		/// <returns>An Organization</returns>
		public async Task<string> ApiOrganizations_usernameGetAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/organizations/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Organization's Articles
		/// This endpoint allows the client to retrieve a list of Articles belonging to the organization
		/// 
		/// It supports pagination, each page will contain `30` users by default.
		/// ApiOrganizations_usernameArticlesGetByPageAndPer_page api/organizations/{username}/articles
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>An Organization's Articles</returns>
		public async Task<ArticleIndex[]> ApiOrganizations_usernameArticlesGetByPageAndPer_pageAsync(string username, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/organizations/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/articles&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArticleIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Organization's users
		/// This endpoint allows the client to retrieve a list of users belonging to the organization
		/// 
		/// It supports pagination, each page will contain `30` users by default.
		/// ApiOrganizations_usernameUsersGetByPageAndPer_page api/organizations/{username}/users
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>An Organization's users</returns>
		public async Task<User[]> ApiOrganizations_usernameUsersGetByPageAndPer_pageAsync(string username, int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/organizations/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/users&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<User[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// show details for all pages
		/// This endpoint allows the client to retrieve details for all Page objects.
		/// ApiPagesGet api/pages
		/// </summary>
		/// <returns>successful</returns>
		public async Task<Page[]> ApiPagesGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/pages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Page[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// pages
		/// This endpoint allows the client to create a new page.
		/// ApiPagesPost api/pages
		/// </summary>
		/// <returns>successful</returns>
		public async Task ApiPagesPostAsync(ApiPagesPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/pages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// remove a page
		/// This endpoint allows the client to delete a single Page object, specified by ID.
		/// ApiPages_idDelete api/pages/{id}
		/// </summary>
		/// <param name="id">The ID of the page.
		/// Minimum: 1
		// </param>
		/// <returns>successful</returns>
		public async Task<Page> ApiPages_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/pages/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Page>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// show details for a page
		/// This endpoint allows the client to retrieve details for a single Page object, specified by ID.
		/// ApiPages_idGet api/pages/{id}
		/// </summary>
		/// <param name="id">The ID of the page.
		/// Minimum: 1
		// </param>
		/// <returns>successful</returns>
		public async Task<Page> ApiPages_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/pages/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Page>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// update details for a page
		/// This endpoint allows the client to retrieve details for a single Page object, specified by ID.
		/// ApiPages_idPut api/pages/{id}
		/// </summary>
		/// <param name="id">The ID of the page.
		/// Minimum: 1
		// </param>
		/// <returns>successful</returns>
		public async Task<Page> ApiPages_idPutAsync(int id, Page requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/pages/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Page>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Podcast Episodes
		/// This endpoint allows the client to retrieve a list of podcast episodes.
		/// "Podcast episodes" are episodes belonging to podcasts.
		/// It will only return active (reachable) podcast episodes that belong to published podcasts available on the platform, ordered by descending publication date.
		/// It supports pagination, each page will contain 30 articles by default.
		/// ApiPodcast_episodesGetByPageAndPer_pageAndUsername api/podcast_episodes
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="username">Using this parameter will retrieve episodes belonging to a specific podcast.</param>
		/// <returns>A List of Podcast episodes filtered by username</returns>
		public async Task<PodcastEpisodeIndex[]> ApiPodcast_episodesGetByPageAndPer_pageAndUsernameAsync(int page, int per_page, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/podcast_episodes?page="+page+"&per_page="+per_page+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PodcastEpisodeIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// A Users or organizations profile image
		/// This endpoint allows the client to retrieve a user or organization profile image information by its
		/// corresponding username.
		/// ApiProfile_images_usernameGet api/profile_images/{username}
		/// </summary>
		/// <param name="username">The parameter is the username of the user or the username of the organization.</param>
		/// <returns>An object containing profile image details</returns>
		public async Task<string> ApiProfile_images_usernameGetAsync(string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/profile_images/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// create reaction
		/// This endpoint allows the client to create a reaction to a specified reactable (eg, Article, Comment, or User). For examples:
		/// * "Like"ing an Article will create a new "like" Reaction from the user for that Articles
		/// * "Like"ing that Article a second time will return the previous "like"
		/// ApiReactionsPostByCategoryAndReactable_idAndReactable_type api/reactions
		/// </summary>
		/// <returns>successful</returns>
		public async Task ApiReactionsPostByCategoryAndReactable_idAndReactable_typeAsync(ApiReactionsPostByCategoryAndReactable_idAndReactable_typeCategory category, int reactable_id, ApiReactionsPostByCategoryAndReactable_idAndReactable_typeReactable_type reactable_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/reactions?category=" + category+"&reactable_id="+reactable_id+"&reactable_type=" + reactable_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// toggle reaction
		/// This endpoint allows the client to toggle the user's reaction to a specified reactable (eg, Article, Comment, or User). For examples:
		/// * "Like"ing an Article will create a new "like" Reaction from the user for that Articles
		/// * "Like"ing that Article a second time will remove the "like" from the user
		/// ApiReactionsTogglePostByCategoryAndReactable_idAndReactable_type api/reactions/toggle
		/// </summary>
		/// <returns>successful</returns>
		public async Task ApiReactionsTogglePostByCategoryAndReactable_idAndReactable_typeAsync(ApiReactionsPostByCategoryAndReactable_idAndReactable_typeCategory category, int reactable_id, ApiReactionsPostByCategoryAndReactable_idAndReactable_typeReactable_type reactable_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/reactions/toggle?category=" + category+"&reactable_id="+reactable_id+"&reactable_type=" + reactable_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Readinglist
		/// This endpoint allows the client to retrieve a list of articles that were saved to a Users readinglist.
		/// It supports pagination, each page will contain `30` articles by default
		/// ApiReadinglistGetByPageAndPer_page api/readinglist
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>A list of articles in the users readinglist</returns>
		public async Task<ArticleIndex[]> ApiReadinglistGetByPageAndPer_pageAsync(int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/readinglist?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArticleIndex[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Tags
		/// This endpoint allows the client to retrieve a list of tags that can be used to tag articles.
		/// 
		/// It will return tags ordered by popularity.
		/// 
		/// It supports pagination, each page will contain 10 tags by default.
		/// ApiTagsGetByPageAndPer_page api/tags
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>A List of all tags</returns>
		public async Task<Tag[]> ApiTagsGetByPageAndPer_pageAsync(int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/tags?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Tag[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The authenticated user
		/// This endpoint allows the client to retrieve information about the authenticated user
		/// ApiUsersMeGet api/users/me
		/// </summary>
		/// <returns>successful</returns>
		public async Task<string> ApiUsersMeGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/users/me";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// A User
		/// This endpoint allows the client to retrieve a single user, either by id
		/// or by the user's username.
		/// 
		/// For complete documentation, see the v0 API docs: https://developers.forem.com/api/v0#tag/users/operation/getUser
		/// ApiUsers_idGet api/users/{id}
		/// </summary>
		/// <returns>successful</returns>
		public async Task<string> ApiUsers_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/users/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Suspend a User
		/// This endpoint allows the client to suspend a user.
		/// 
		/// The user associated with the API key must have any 'admin' or 'moderator' role.
		/// 
		/// This specified user will be assigned the 'suspended' role. Suspending a user will stop the
		/// user from posting new posts and comments. It doesn't delete any of the user's content, just
		/// prevents them from creating new content while suspended. Users are not notified of their suspension
		/// in the UI, so if you want them to know about this, you must notify them.
		/// ApiUsers_idSuspendPut api/users/{id}/suspend
		/// </summary>
		/// <param name="id">The ID of the user to suspend.
		/// Minimum: 1
		// </param>
		public async Task ApiUsers_idSuspendPutAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/users/"+id+"/suspend";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unpublish a User's Articles and Comments
		/// This endpoint allows the client to unpublish all of the articles and
		/// comments created by a user.
		/// 
		/// The user associated with the API key must have any 'admin' or 'moderator' role.
		/// 
		/// This specified user's articles and comments will be unpublished and will no longer be
		/// visible to the public. They will remain in the database and will set back to draft status
		/// on the specified user's  dashboard. Any notifications associated with the specified user's
		/// articles and comments will be deleted.
		/// 
		/// Note this endpoint unpublishes articles and comments asychronously: it will return a 204 NO CONTENT
		/// status code immediately, but the articles and comments will not be unpublished until the
		/// request is completed on the server.
		/// ApiUsers_idUnpublishPut api/users/{id}/unpublish
		/// </summary>
		/// <param name="id">The ID of the user to unpublish.
		/// Minimum: 1
		// </param>
		public async Task ApiUsers_idUnpublishPutAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/users/"+id+"/unpublish";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Articles with a video
		/// This endpoint allows the client to retrieve a list of articles that are uploaded with a video.
		/// 
		/// It will only return published video articles ordered by descending popularity.
		/// 
		/// It supports pagination, each page will contain 24 articles by default.
		/// ApiVideosGetByPageAndPer_page api/videos
		/// </summary>
		/// <param name="page">Pagination page
		/// Minimum: 1
		// </param>
		/// <param name="per_page">Page size (the number of items to return per page). The default maximum value can be overridden by "API_PER_PAGE_MAX" environment variable.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <returns>A List of all articles with videos</returns>
		public async Task<VideoArticle[]> ApiVideosGetByPageAndPer_pageAsync(int page, int per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/videos?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VideoArticle[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum ApiArticlesGetByPageAndPer_pageAndTagAndTagsAndTags_excludeAndUsernameAndStateAndTopAndCollection_idState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fresh")]
		fresh = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="rising")]
		rising = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="all")]
		all = 2,
	}
	
	public class ApiFollowersUsersGetByPageAndPer_pageAndSortReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The follower's name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A path to the follower's profile
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Profile image (640x640)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_image")]
		public string Profile_image { get; set; }
		
		/// <summary>
		/// user_follower by default
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type_of")]
		public string Type_of { get; set; }
		
		/// <summary>
		/// The follower's user id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_id")]
		public System.Nullable<System.Int32> User_id { get; set; }
	}
	
	public class ApiPagesPostPostBody
	{
		
		/// <summary>
		/// For JSON pages, the JSON body
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body_json")]
		public string Body_json { get; set; }
		
		/// <summary>
		/// The text (in markdown) of the ad (required)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body_markdown")]
		public string Body_markdown { get; set; }
		
		/// <summary>
		/// For internal use, helps similar pages from one another
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// If true, the page is available at '/{slug}' instead of '/page/{slug}', use with caution
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_top_level_path")]
		public System.Nullable<System.Boolean> Is_top_level_path { get; set; }
		
		/// <summary>
		/// Used to link to this page in URLs, must be unique and URL-safe
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// Controls what kind of layout the page is rendered in
		/// </summary>
		[System.ComponentModel.DefaultValue(PageTemplate.contained)]
		[System.Runtime.Serialization.DataMember(Name="template")]
		public PageTemplate Template { get; set; } = PageTemplate.contained;
		
		/// <summary>
		/// Title of the page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public enum ApiReactionsPostByCategoryAndReactable_idAndReactable_typeCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="like")]
		like = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unicorn")]
		unicorn = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="exploding_head")]
		exploding_head = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="raised_hands")]
		raised_hands = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fire")]
		fire = 4,
	}
	
	public enum ApiReactionsPostByCategoryAndReactable_idAndReactable_typeReactable_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Comment")]
		Comment = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Article")]
		Article = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="User")]
		User = 2,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
