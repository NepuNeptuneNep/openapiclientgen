//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A bucket.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Bucket
	{
		
		/// <summary>
		/// Access controls on the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acl")]
		public BucketAccessControl[] Acl { get; set; }
		
		/// <summary>
		/// The bucket's Cross-Origin Resource Sharing (CORS) configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cors")]
		public BucketCors[] BucketCors { get; set; }
		
		/// <summary>
		/// Default access controls to apply to new objects when no ACL is provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultObjectAcl")]
		public ObjectAccessControl[] DefaultObjectAcl { get; set; }
		
		/// <summary>
		/// HTTP 1.1 Entity tag for the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// The ID of the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The kind of item this is. For buckets, this is always storage#bucket.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#bucket")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#bucket";
		
		/// <summary>
		/// The bucket's lifecycle configuration. See object lifecycle management for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lifecycle")]
		public BucketLifecycle Lifecycle { get; set; }
		
		/// <summary>
		/// The location of the bucket. Object data for objects in the bucket resides in physical storage within this region. Typical values are US and EU. Defaults to US. See the developer's guide for the authoritative list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// The bucket's logging configuration, which defines the destination bucket and optional name prefix for the current bucket's logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logging")]
		public BucketLogging Logging { get; set; }
		
		/// <summary>
		/// The metadata generation of this bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metageneration")]
		public string Metageneration { get; set; }
		
		/// <summary>
		/// The name of the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The owner of the bucket. This is always the project team's owner group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public BucketOwner Owner { get; set; }
		
		/// <summary>
		/// The URI of this bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The bucket's storage class. This defines how objects in the bucket are stored and determines the SLA and the cost of storage. Typical values are STANDARD and DURABLE_REDUCED_AVAILABILITY. Defaults to STANDARD. See the developer's guide for the authoritative list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageClass")]
		public string StorageClass { get; set; }
		
		/// <summary>
		/// Creation time of the bucket in RFC 3339 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeCreated")]
		public System.Nullable<System.DateTimeOffset> TimeCreated { get; set; }
		
		/// <summary>
		/// The bucket's versioning configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="versioning")]
		public BucketVersioning Versioning { get; set; }
		
		/// <summary>
		/// The bucket's website configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website")]
		public BucketWebsite Website { get; set; }
	}
	
	/// <summary>
	/// An access-control entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BucketAccessControl
	{
		
		/// <summary>
		/// The name of the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket")]
		public string Bucket { get; set; }
		
		/// <summary>
		/// The domain associated with the entity, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// The email address associated with the entity, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The entity holding the permission, in one of the following forms: 
		///- user-userId 
		///- user-email 
		///- group-groupId 
		///- group-email 
		///- domain-domain 
		///- allUsers 
		///- allAuthenticatedUsers Examples: 
		///- The user liz@example.com would be user-liz@example.com. 
		///- The group example@googlegroups.com would be group-example@googlegroups.com. 
		///- To refer to all members of the Google Apps for Business domain example.com, the entity would be domain-example.com.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public string Entity { get; set; }
		
		/// <summary>
		/// The ID for the entity, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entityId")]
		public string EntityId { get; set; }
		
		/// <summary>
		/// HTTP 1.1 Entity tag for the access-control entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// The ID of the access-control entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The kind of item this is. For bucket access control entries, this is always storage#bucketAccessControl.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#bucketAccessControl")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#bucketAccessControl";
		
		/// <summary>
		/// The access permission for the entity. Can be READER, WRITER, or OWNER.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// The link to this access-control entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	public class BucketCors
	{
		
		/// <summary>
		/// The value, in seconds, to return in the  Access-Control-Max-Age header used in preflight responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxAgeSeconds")]
		public System.Nullable<System.Int32> MaxAgeSeconds { get; set; }
		
		/// <summary>
		/// The list of HTTP methods on which to include CORS response headers: GET, OPTIONS, POST, etc. Note, "*" is permitted in the list of methods, and means "any method".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string[] Method { get; set; }
		
		/// <summary>
		/// The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string[] Origin { get; set; }
		
		/// <summary>
		/// The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseHeader")]
		public string[] ResponseHeader { get; set; }
	}
	
	/// <summary>
	/// An access-control entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ObjectAccessControl
	{
		
		/// <summary>
		/// The name of the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket")]
		public string Bucket { get; set; }
		
		/// <summary>
		/// The domain associated with the entity, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// The email address associated with the entity, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The entity holding the permission, in one of the following forms: 
		///- user-userId 
		///- user-email 
		///- group-groupId 
		///- group-email 
		///- domain-domain 
		///- allUsers 
		///- allAuthenticatedUsers Examples: 
		///- The user liz@example.com would be user-liz@example.com. 
		///- The group example@googlegroups.com would be group-example@googlegroups.com. 
		///- To refer to all members of the Google Apps for Business domain example.com, the entity would be domain-example.com.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public string Entity { get; set; }
		
		/// <summary>
		/// The ID for the entity, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entityId")]
		public string EntityId { get; set; }
		
		/// <summary>
		/// HTTP 1.1 Entity tag for the access-control entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// The content generation of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="generation")]
		public string Generation { get; set; }
		
		/// <summary>
		/// The ID of the access-control entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The kind of item this is. For object access control entries, this is always storage#objectAccessControl.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#objectAccessControl")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#objectAccessControl";
		
		/// <summary>
		/// The name of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="object")]
		public string Object { get; set; }
		
		/// <summary>
		/// The access permission for the entity. Can be READER or OWNER.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// The link to this access-control entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	public class BucketLifecycle
	{
		
		/// <summary>
		/// A lifecycle management rule, which is made of an action to take and the condition(s) under which the action will be taken.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rule")]
		public BucketLifecycleRule[] BucketLifecycleRule { get; set; }
	}
	
	public class BucketLifecycleRule
	{
		
		/// <summary>
		/// The action to take.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public BucketLifecycleRuleAction Action { get; set; }
		
		/// <summary>
		/// The condition(s) under which the action will be taken.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="condition")]
		public BucketLifecycleRuleCondition Condition { get; set; }
	}
	
	public class BucketLifecycleRuleAction
	{
		
		/// <summary>
		/// Type of the action. Currently only Delete is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class BucketLifecycleRuleCondition
	{
		
		/// <summary>
		/// Age of an object (in days). This condition is satisfied when an object reaches the specified age.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="age")]
		public System.Nullable<System.Int32> Age { get; set; }
		
		/// <summary>
		/// A date in RFC 3339 format with only the date part, e.g. "2013-01-15". This condition is satisfied when an object is created before midnight of the specified date in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdBefore")]
		public System.Nullable<System.DateOnly> CreatedBefore { get; set; }
		
		/// <summary>
		/// Relevant only for versioned objects. If the value is true, this condition matches live objects; if the value is false, it matches archived objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isLive")]
		public System.Nullable<System.Boolean> IsLive { get; set; }
		
		/// <summary>
		/// Relevant only for versioned objects. If the value is N, this condition is satisfied when there are at least N versions (including the live version) newer than this version of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numNewerVersions")]
		public System.Nullable<System.Int32> NumNewerVersions { get; set; }
	}
	
	public class BucketLogging
	{
		
		/// <summary>
		/// The destination bucket where the current bucket's logs should be placed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logBucket")]
		public string LogBucket { get; set; }
		
		/// <summary>
		/// A prefix for log object names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logObjectPrefix")]
		public string LogObjectPrefix { get; set; }
	}
	
	public class BucketOwner
	{
		
		/// <summary>
		/// The entity, in the form group-groupId.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public string Entity { get; set; }
		
		/// <summary>
		/// The ID for the entity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entityId")]
		public string EntityId { get; set; }
	}
	
	public class BucketVersioning
	{
		
		/// <summary>
		/// While set to true, versioning is fully enabled for this bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class BucketWebsite
	{
		
		/// <summary>
		/// Behaves as the bucket's directory index where missing objects are treated as potential directories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mainPageSuffix")]
		public string MainPageSuffix { get; set; }
		
		/// <summary>
		/// The custom object to return when a requested resource is not found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notFoundPage")]
		public string NotFoundPage { get; set; }
	}
	
	/// <summary>
	/// An access-control list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BucketAccessControls
	{
		
		/// <summary>
		/// The list of items.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public BucketAccessControl[] Items { get; set; }
		
		/// <summary>
		/// The kind of item this is. For lists of bucket access control entries, this is always storage#bucketAccessControls.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#bucketAccessControls")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#bucketAccessControls";
	}
	
	/// <summary>
	/// A list of buckets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Buckets
	{
		
		/// <summary>
		/// The list of items.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Bucket[] Items { get; set; }
		
		/// <summary>
		/// The kind of item this is. For lists of buckets, this is always storage#buckets.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#buckets")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#buckets";
		
		/// <summary>
		/// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// An notification channel used to watch for resource changes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Channel
	{
		
		/// <summary>
		/// The address where notifications are delivered for this channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiration")]
		public string Expiration { get; set; }
		
		/// <summary>
		/// A UUID or similar unique string that identifies this channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Identifies this as a notification channel used to watch for changes to a resource, which is "api#channel".
		/// </summary>
		[System.ComponentModel.DefaultValue("api#channel")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "api#channel";
		
		/// <summary>
		/// Additional parameters controlling delivery channel behavior. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="params")]
		public System.Collections.Generic.Dictionary<string, string> Params { get; set; }
		
		/// <summary>
		/// A Boolean value to indicate whether payload is wanted. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public System.Nullable<System.Boolean> Payload { get; set; }
		
		/// <summary>
		/// An opaque ID that identifies the resource being watched on this channel. Stable across different API versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceId")]
		public string ResourceId { get; set; }
		
		/// <summary>
		/// A version-specific identifier for the watched resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceUri")]
		public string ResourceUri { get; set; }
		
		/// <summary>
		/// An arbitrary string delivered to the target address with each notification delivered over this channel. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// The type of delivery mechanism used for this channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A Compose request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComposeRequest
	{
		
		/// <summary>
		/// An object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public Object Destination { get; set; }
		
		/// <summary>
		/// The kind of item this is.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#composeRequest")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#composeRequest";
		
		/// <summary>
		/// The list of source objects that will be concatenated into a single object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceObjects")]
		public ComposeRequestSourceObjects[] ComposeRequestSourceObjects { get; set; }
	}
	
	/// <summary>
	/// An object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Object
	{
		
		/// <summary>
		/// Access controls on the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acl")]
		public ObjectAccessControl[] Acl { get; set; }
		
		/// <summary>
		/// The bucket containing this object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket")]
		public string Bucket { get; set; }
		
		/// <summary>
		/// Cache-Control directive for the object data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheControl")]
		public string CacheControl { get; set; }
		
		/// <summary>
		/// Number of underlying components that make up this object. Components are accumulated by compose operations and are limited to a count of 32.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="componentCount")]
		public System.Nullable<System.Int32> ComponentCount { get; set; }
		
		/// <summary>
		/// Content-Disposition of the object data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentDisposition")]
		public string ContentDisposition { get; set; }
		
		/// <summary>
		/// Content-Encoding of the object data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentEncoding")]
		public string ContentEncoding { get; set; }
		
		/// <summary>
		/// Content-Language of the object data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentLanguage")]
		public string ContentLanguage { get; set; }
		
		/// <summary>
		/// Content-Type of the object data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
		
		/// <summary>
		/// CRC32c checksum, as described in RFC 4960, Appendix B; encoded using base64.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="crc32c")]
		public string Crc32c { get; set; }
		
		/// <summary>
		/// HTTP 1.1 Entity tag for the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// The content generation of this object. Used for object versioning.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="generation")]
		public string Generation { get; set; }
		
		/// <summary>
		/// The ID of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The kind of item this is. For objects, this is always storage#object.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#object")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#object";
		
		/// <summary>
		/// MD5 hash of the data; encoded using base64.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5Hash")]
		public string Md5Hash { get; set; }
		
		/// <summary>
		/// Media download link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mediaLink")]
		public string MediaLink { get; set; }
		
		/// <summary>
		/// User-provided metadata, in key/value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// The generation of the metadata for this object at this generation. Used for metadata versioning. Has no meaning outside of the context of this generation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metageneration")]
		public string Metageneration { get; set; }
		
		/// <summary>
		/// The name of this object. Required if not specified by URL parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The owner of the object. This will always be the uploader of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public ObjectOwner Owner { get; set; }
		
		/// <summary>
		/// The link to this object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Content-Length of the data in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public string Size { get; set; }
		
		/// <summary>
		/// Storage class of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageClass")]
		public string StorageClass { get; set; }
		
		/// <summary>
		/// Deletion time of the object in RFC 3339 format. Will be returned if and only if this version of the object has been deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeDeleted")]
		public System.Nullable<System.DateTimeOffset> TimeDeleted { get; set; }
		
		/// <summary>
		/// Modification time of the object metadata in RFC 3339 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class ObjectOwner
	{
		
		/// <summary>
		/// The entity, in the form user-userId.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public string Entity { get; set; }
		
		/// <summary>
		/// The ID for the entity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entityId")]
		public string EntityId { get; set; }
	}
	
	public class ComposeRequestSourceObjects
	{
		
		/// <summary>
		/// The generation of this object to use as the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="generation")]
		public string Generation { get; set; }
		
		/// <summary>
		/// The source object's name. All source objects must reside in the same bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Conditions that must be met for this operation to execute.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectPreconditions")]
		public ComposeRequestSourceObjectsObjectPreconditions ObjectPreconditions { get; set; }
	}
	
	public class ComposeRequestSourceObjectsObjectPreconditions
	{
		
		/// <summary>
		/// Only perform the composition if the generation of the source object that would be used matches this value. If this value and a generation are both specified, they must be the same value or the call will fail.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ifGenerationMatch")]
		public string IfGenerationMatch { get; set; }
	}
	
	/// <summary>
	/// An access-control list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ObjectAccessControls
	{
		
		/// <summary>
		/// The list of items.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public string[] Items { get; set; }
		
		/// <summary>
		/// The kind of item this is. For lists of object access control entries, this is always storage#objectAccessControls.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#objectAccessControls")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#objectAccessControls";
	}
	
	/// <summary>
	/// A list of objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Objects
	{
		
		/// <summary>
		/// The list of items.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Object[] Items { get; set; }
		
		/// <summary>
		/// The kind of item this is. For lists of objects, this is always storage#objects.
		/// </summary>
		[System.ComponentModel.DefaultValue("storage#objects")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "storage#objects";
		
		/// <summary>
		/// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of prefixes of objects matching-but-not-listed up to and including the requested delimiter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixes")]
		public string[] Prefixes { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Retrieves a list of buckets for a given project.
		/// Storage_buckets_list b
		/// </summary>
		/// <param name="project">A valid API project identifier.</param>
		/// <param name="maxResults">Maximum number of buckets to return.</param>
		/// <param name="pageToken">A previously-returned page token representing part of the larger set of results to view.</param>
		/// <param name="projection">Set of properties to return. Defaults to noAcl.</param>
		/// <returns>Successful response</returns>
		public async Task<Buckets> Storage_buckets_listAsync(string project, int maxResults, string pageToken, Storage_buckets_listProjection projection, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b?project=" + (project==null? "" : System.Uri.EscapeDataString(project))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&projection=" + projection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Buckets>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new bucket.
		/// Storage_buckets_insert b
		/// </summary>
		/// <param name="project">A valid API project identifier.</param>
		/// <param name="projection">Set of properties to return. Defaults to noAcl, unless the bucket resource specifies acl or defaultObjectAcl properties, when it defaults to full.</param>
		/// <returns>Successful response</returns>
		public async Task<Bucket> Storage_buckets_insertAsync(string project, Storage_buckets_listProjection projection, Bucket requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b?project=" + (project==null? "" : System.Uri.EscapeDataString(project))+"&projection=" + projection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Bucket>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Permanently deletes an empty bucket.
		/// Storage_buckets_delete b/{bucket}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="ifMetagenerationMatch">Makes the return of the bucket metadata conditional on whether the bucket's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the return of the bucket metadata conditional on whether the bucket's current metageneration does not match the given value.</param>
		/// <returns>Successful response</returns>
		public async Task Storage_buckets_deleteAsync(string bucket, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns metadata for the specified bucket.
		/// Storage_buckets_get b/{bucket}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="ifMetagenerationMatch">Makes the return of the bucket metadata conditional on whether the bucket's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the return of the bucket metadata conditional on whether the bucket's current metageneration does not match the given value.</param>
		/// <param name="projection">Set of properties to return. Defaults to noAcl.</param>
		/// <returns>Successful response</returns>
		public async Task<Bucket> Storage_buckets_getAsync(string bucket, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Storage_buckets_listProjection projection, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch))+"&projection=" + projection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Bucket>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a bucket. This method supports patch semantics.
		/// Storage_buckets_patch b/{bucket}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="ifMetagenerationMatch">Makes the return of the bucket metadata conditional on whether the bucket's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the return of the bucket metadata conditional on whether the bucket's current metageneration does not match the given value.</param>
		/// <param name="projection">Set of properties to return. Defaults to full.</param>
		/// <returns>Successful response</returns>
		public async Task<Bucket> Storage_buckets_patchAsync(string bucket, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Storage_buckets_listProjection projection, Bucket requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch))+"&projection=" + projection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Bucket>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a bucket.
		/// Storage_buckets_update b/{bucket}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="ifMetagenerationMatch">Makes the return of the bucket metadata conditional on whether the bucket's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the return of the bucket metadata conditional on whether the bucket's current metageneration does not match the given value.</param>
		/// <param name="projection">Set of properties to return. Defaults to full.</param>
		/// <returns>Successful response</returns>
		public async Task<Bucket> Storage_buckets_updateAsync(string bucket, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Storage_buckets_listProjection projection, Bucket requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch))+"&projection=" + projection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Bucket>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves ACL entries on the specified bucket.
		/// Storage_bucketAccessControls_list b/{bucket}/acl
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <returns>Successful response</returns>
		public async Task<BucketAccessControls> Storage_bucketAccessControls_listAsync(string bucket, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/acl";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BucketAccessControls>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new ACL entry on the specified bucket.
		/// Storage_bucketAccessControls_insert b/{bucket}/acl
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <returns>Successful response</returns>
		public async Task<BucketAccessControl> Storage_bucketAccessControls_insertAsync(string bucket, BucketAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/acl";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BucketAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Permanently deletes the ACL entry for the specified entity on the specified bucket.
		/// Storage_bucketAccessControls_delete b/{bucket}/acl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <returns>Successful response</returns>
		public async Task Storage_bucketAccessControls_deleteAsync(string bucket, string entity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/acl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the ACL entry for the specified entity on the specified bucket.
		/// Storage_bucketAccessControls_get b/{bucket}/acl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <returns>Successful response</returns>
		public async Task<BucketAccessControl> Storage_bucketAccessControls_getAsync(string bucket, string entity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/acl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BucketAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an ACL entry on the specified bucket. This method supports patch semantics.
		/// Storage_bucketAccessControls_patch b/{bucket}/acl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <returns>Successful response</returns>
		public async Task<BucketAccessControl> Storage_bucketAccessControls_patchAsync(string bucket, string entity, BucketAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/acl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BucketAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an ACL entry on the specified bucket.
		/// Storage_bucketAccessControls_update b/{bucket}/acl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <returns>Successful response</returns>
		public async Task<BucketAccessControl> Storage_bucketAccessControls_updateAsync(string bucket, string entity, BucketAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/acl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BucketAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves default object ACL entries on the specified bucket.
		/// Storage_defaultObjectAccessControls_list b/{bucket}/defaultObjectAcl
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="ifMetagenerationMatch">If present, only return default ACL listing if the bucket's current metageneration matches this value.</param>
		/// <param name="ifMetagenerationNotMatch">If present, only return default ACL listing if the bucket's current metageneration does not match the given value.</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControls> Storage_defaultObjectAccessControls_listAsync(string bucket, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/defaultObjectAcl&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControls>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new default object ACL entry on the specified bucket.
		/// Storage_defaultObjectAccessControls_insert b/{bucket}/defaultObjectAcl
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControl> Storage_defaultObjectAccessControls_insertAsync(string bucket, ObjectAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/defaultObjectAcl";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Permanently deletes the default object ACL entry for the specified entity on the specified bucket.
		/// Storage_defaultObjectAccessControls_delete b/{bucket}/defaultObjectAcl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <returns>Successful response</returns>
		public async Task Storage_defaultObjectAccessControls_deleteAsync(string bucket, string entity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/defaultObjectAcl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the default object ACL entry for the specified entity on the specified bucket.
		/// Storage_defaultObjectAccessControls_get b/{bucket}/defaultObjectAcl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControl> Storage_defaultObjectAccessControls_getAsync(string bucket, string entity, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/defaultObjectAcl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a default object ACL entry on the specified bucket. This method supports patch semantics.
		/// Storage_defaultObjectAccessControls_patch b/{bucket}/defaultObjectAcl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControl> Storage_defaultObjectAccessControls_patchAsync(string bucket, string entity, ObjectAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/defaultObjectAcl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a default object ACL entry on the specified bucket.
		/// Storage_defaultObjectAccessControls_update b/{bucket}/defaultObjectAcl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControl> Storage_defaultObjectAccessControls_updateAsync(string bucket, string entity, ObjectAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/defaultObjectAcl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of objects matching the criteria.
		/// Storage_objects_list b/{bucket}/o
		/// </summary>
		/// <param name="bucket">Name of the bucket in which to look for objects.</param>
		/// <param name="delimiter">Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.</param>
		/// <param name="maxResults">Maximum number of items plus prefixes to return. As duplicate prefixes are omitted, fewer total results may be returned than requested.</param>
		/// <param name="pageToken">A previously-returned page token representing part of the larger set of results to view.</param>
		/// <param name="prefix">Filter results to objects whose names begin with this prefix.</param>
		/// <param name="projection">Set of properties to return. Defaults to noAcl.</param>
		/// <param name="versions">If true, lists all versions of a file as distinct results.</param>
		/// <returns>Successful response</returns>
		public async Task<Objects> Storage_objects_listAsync(string bucket, string delimiter, int maxResults, string pageToken, string prefix, Storage_buckets_listProjection projection, bool versions, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o&delimiter=" + (delimiter==null? "" : System.Uri.EscapeDataString(delimiter))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&prefix=" + (prefix==null? "" : System.Uri.EscapeDataString(prefix))+"&projection=" + projection+"&versions="+versions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Objects>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Watch for changes on all objects in a bucket.
		/// Storage_objects_watchAll b/{bucket}/o/watch
		/// </summary>
		/// <param name="bucket">Name of the bucket in which to look for objects.</param>
		/// <param name="delimiter">Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.</param>
		/// <param name="maxResults">Maximum number of items plus prefixes to return. As duplicate prefixes are omitted, fewer total results may be returned than requested.</param>
		/// <param name="pageToken">A previously-returned page token representing part of the larger set of results to view.</param>
		/// <param name="prefix">Filter results to objects whose names begin with this prefix.</param>
		/// <param name="projection">Set of properties to return. Defaults to noAcl.</param>
		/// <param name="versions">If true, lists all versions of a file as distinct results.</param>
		/// <returns>Successful response</returns>
		public async Task<Channel> Storage_objects_watchAllAsync(string bucket, string delimiter, int maxResults, string pageToken, string prefix, Storage_buckets_listProjection projection, bool versions, Channel requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/watch&delimiter=" + (delimiter==null? "" : System.Uri.EscapeDataString(delimiter))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&prefix=" + (prefix==null? "" : System.Uri.EscapeDataString(prefix))+"&projection=" + projection+"&versions="+versions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Channel>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes data blobs and associated metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.
		/// Storage_objects_delete b/{bucket}/o/{object}
		/// </summary>
		/// <param name="bucket">Name of the bucket in which the object resides.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="generation">If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <param name="ifGenerationMatch">Makes the operation conditional on whether the object's current generation matches the given value.</param>
		/// <param name="ifGenerationNotMatch">Makes the operation conditional on whether the object's current generation does not match the given value.</param>
		/// <param name="ifMetagenerationMatch">Makes the operation conditional on whether the object's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the operation conditional on whether the object's current metageneration does not match the given value.</param>
		/// <returns>Successful response</returns>
		public async Task Storage_objects_deleteAsync(string bucket, string _object, string generation, string ifGenerationMatch, string ifGenerationNotMatch, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation))+"&ifGenerationMatch=" + (ifGenerationMatch==null? "" : System.Uri.EscapeDataString(ifGenerationMatch))+"&ifGenerationNotMatch=" + (ifGenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifGenerationNotMatch))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves objects or their associated metadata.
		/// Storage_objects_get b/{bucket}/o/{object}
		/// </summary>
		/// <param name="bucket">Name of the bucket in which the object resides.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <param name="ifGenerationMatch">Makes the operation conditional on whether the object's generation matches the given value.</param>
		/// <param name="ifGenerationNotMatch">Makes the operation conditional on whether the object's generation does not match the given value.</param>
		/// <param name="ifMetagenerationMatch">Makes the operation conditional on whether the object's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the operation conditional on whether the object's current metageneration does not match the given value.</param>
		/// <param name="projection">Set of properties to return. Defaults to noAcl.</param>
		/// <returns>Successful response</returns>
		public async Task<Object> Storage_objects_getAsync(string bucket, string _object, string generation, string ifGenerationMatch, string ifGenerationNotMatch, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Storage_buckets_listProjection projection, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation))+"&ifGenerationMatch=" + (ifGenerationMatch==null? "" : System.Uri.EscapeDataString(ifGenerationMatch))+"&ifGenerationNotMatch=" + (ifGenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifGenerationNotMatch))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch))+"&projection=" + projection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Object>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a data blob's associated metadata. This method supports patch semantics.
		/// Storage_objects_patch b/{bucket}/o/{object}
		/// </summary>
		/// <param name="bucket">Name of the bucket in which the object resides.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <param name="ifGenerationMatch">Makes the operation conditional on whether the object's current generation matches the given value.</param>
		/// <param name="ifGenerationNotMatch">Makes the operation conditional on whether the object's current generation does not match the given value.</param>
		/// <param name="ifMetagenerationMatch">Makes the operation conditional on whether the object's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the operation conditional on whether the object's current metageneration does not match the given value.</param>
		/// <param name="projection">Set of properties to return. Defaults to full.</param>
		/// <returns>Successful response</returns>
		public async Task<Object> Storage_objects_patchAsync(string bucket, string _object, string generation, string ifGenerationMatch, string ifGenerationNotMatch, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Storage_buckets_listProjection projection, Object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation))+"&ifGenerationMatch=" + (ifGenerationMatch==null? "" : System.Uri.EscapeDataString(ifGenerationMatch))+"&ifGenerationNotMatch=" + (ifGenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifGenerationNotMatch))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch))+"&projection=" + projection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Object>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a data blob's associated metadata.
		/// Storage_objects_update b/{bucket}/o/{object}
		/// </summary>
		/// <param name="bucket">Name of the bucket in which the object resides.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <param name="ifGenerationMatch">Makes the operation conditional on whether the object's current generation matches the given value.</param>
		/// <param name="ifGenerationNotMatch">Makes the operation conditional on whether the object's current generation does not match the given value.</param>
		/// <param name="ifMetagenerationMatch">Makes the operation conditional on whether the object's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the operation conditional on whether the object's current metageneration does not match the given value.</param>
		/// <param name="projection">Set of properties to return. Defaults to full.</param>
		/// <returns>Successful response</returns>
		public async Task<Object> Storage_objects_updateAsync(string bucket, string _object, string generation, string ifGenerationMatch, string ifGenerationNotMatch, string ifMetagenerationMatch, string ifMetagenerationNotMatch, Storage_buckets_listProjection projection, Object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation))+"&ifGenerationMatch=" + (ifGenerationMatch==null? "" : System.Uri.EscapeDataString(ifGenerationMatch))+"&ifGenerationNotMatch=" + (ifGenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifGenerationNotMatch))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch))+"&projection=" + projection;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Object>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves ACL entries on the specified object.
		/// Storage_objectAccessControls_list b/{bucket}/o/{object}/acl
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControls> Storage_objectAccessControls_listAsync(string bucket, string _object, string generation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"/acl&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControls>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new ACL entry on the specified object.
		/// Storage_objectAccessControls_insert b/{bucket}/o/{object}/acl
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControl> Storage_objectAccessControls_insertAsync(string bucket, string _object, string generation, ObjectAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"/acl&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Permanently deletes the ACL entry for the specified entity on the specified object.
		/// Storage_objectAccessControls_delete b/{bucket}/o/{object}/acl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <returns>Successful response</returns>
		public async Task Storage_objectAccessControls_deleteAsync(string bucket, string _object, string entity, string generation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"/acl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity))+"&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the ACL entry for the specified entity on the specified object.
		/// Storage_objectAccessControls_get b/{bucket}/o/{object}/acl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControl> Storage_objectAccessControls_getAsync(string bucket, string _object, string entity, string generation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"/acl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity))+"&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an ACL entry on the specified object. This method supports patch semantics.
		/// Storage_objectAccessControls_patch b/{bucket}/o/{object}/acl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControl> Storage_objectAccessControls_patchAsync(string bucket, string _object, string entity, string generation, ObjectAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"/acl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity))+"&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an ACL entry on the specified object.
		/// Storage_objectAccessControls_update b/{bucket}/o/{object}/acl/{entity}
		/// </summary>
		/// <param name="bucket">Name of a bucket.</param>
		/// <param name="_object">Name of the object.</param>
		/// <param name="entity">The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.</param>
		/// <param name="generation">If present, selects a specific revision of this object (as opposed to the latest version, the default).</param>
		/// <returns>Successful response</returns>
		public async Task<ObjectAccessControl> Storage_objectAccessControls_updateAsync(string bucket, string _object, string entity, string generation, ObjectAccessControl requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (bucket==null? "" : System.Uri.EscapeDataString(bucket))+"/o/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+"/acl/"+ (entity==null? "" : System.Uri.EscapeDataString(entity))+"&generation=" + (generation==null? "" : System.Uri.EscapeDataString(generation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ObjectAccessControl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Concatenates a list of existing objects into a new object in the same bucket.
		/// Storage_objects_compose b/{destinationBucket}/o/{destinationObject}/compose
		/// </summary>
		/// <param name="destinationBucket">Name of the bucket containing the source objects. The destination object is stored in this bucket.</param>
		/// <param name="destinationObject">Name of the new object.</param>
		/// <param name="ifGenerationMatch">Makes the operation conditional on whether the object's current generation matches the given value.</param>
		/// <param name="ifMetagenerationMatch">Makes the operation conditional on whether the object's current metageneration matches the given value.</param>
		/// <returns>Successful response</returns>
		public async Task<Object> Storage_objects_composeAsync(string destinationBucket, string destinationObject, string ifGenerationMatch, string ifMetagenerationMatch, ComposeRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (destinationBucket==null? "" : System.Uri.EscapeDataString(destinationBucket))+"/o/"+ (destinationObject==null? "" : System.Uri.EscapeDataString(destinationObject))+"/compose&ifGenerationMatch=" + (ifGenerationMatch==null? "" : System.Uri.EscapeDataString(ifGenerationMatch))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Object>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Copies an object to a destination in the same location. Optionally overrides metadata.
		/// Storage_objects_copy b/{sourceBucket}/o/{sourceObject}/copyTo/b/{destinationBucket}/o/{destinationObject}
		/// </summary>
		/// <param name="sourceBucket">Name of the bucket in which to find the source object.</param>
		/// <param name="sourceObject">Name of the source object.</param>
		/// <param name="destinationBucket">Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.</param>
		/// <param name="destinationObject">Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.</param>
		/// <param name="ifGenerationMatch">Makes the operation conditional on whether the destination object's current generation matches the given value.</param>
		/// <param name="ifGenerationNotMatch">Makes the operation conditional on whether the destination object's current generation does not match the given value.</param>
		/// <param name="ifMetagenerationMatch">Makes the operation conditional on whether the destination object's current metageneration matches the given value.</param>
		/// <param name="ifMetagenerationNotMatch">Makes the operation conditional on whether the destination object's current metageneration does not match the given value.</param>
		/// <param name="ifSourceGenerationMatch">Makes the operation conditional on whether the source object's generation matches the given value.</param>
		/// <param name="ifSourceGenerationNotMatch">Makes the operation conditional on whether the source object's generation does not match the given value.</param>
		/// <param name="ifSourceMetagenerationMatch">Makes the operation conditional on whether the source object's current metageneration matches the given value.</param>
		/// <param name="ifSourceMetagenerationNotMatch">Makes the operation conditional on whether the source object's current metageneration does not match the given value.</param>
		/// <param name="projection">Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.</param>
		/// <param name="sourceGeneration">If present, selects a specific revision of the source object (as opposed to the latest version, the default).</param>
		/// <returns>Successful response</returns>
		public async Task<Object> Storage_objects_copyAsync(
					string sourceBucket, 
					string sourceObject, 
					string destinationBucket, 
					string destinationObject, 
					string ifGenerationMatch, 
					string ifGenerationNotMatch, 
					string ifMetagenerationMatch, 
					string ifMetagenerationNotMatch, 
					string ifSourceGenerationMatch, 
					string ifSourceGenerationNotMatch, 
					string ifSourceMetagenerationMatch, 
					string ifSourceMetagenerationNotMatch, 
					Storage_buckets_listProjection projection, 
					string sourceGeneration, 
					Object requestBody, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "b/"+ (sourceBucket==null? "" : System.Uri.EscapeDataString(sourceBucket))+"/o/"+ (sourceObject==null? "" : System.Uri.EscapeDataString(sourceObject))+"/copyTo/b/"+ (destinationBucket==null? "" : System.Uri.EscapeDataString(destinationBucket))+"/o/"+ (destinationObject==null? "" : System.Uri.EscapeDataString(destinationObject))+"&ifGenerationMatch=" + (ifGenerationMatch==null? "" : System.Uri.EscapeDataString(ifGenerationMatch))+"&ifGenerationNotMatch=" + (ifGenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifGenerationNotMatch))+"&ifMetagenerationMatch=" + (ifMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationMatch))+"&ifMetagenerationNotMatch=" + (ifMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifMetagenerationNotMatch))+"&ifSourceGenerationMatch=" + (ifSourceGenerationMatch==null? "" : System.Uri.EscapeDataString(ifSourceGenerationMatch))+"&ifSourceGenerationNotMatch=" + (ifSourceGenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifSourceGenerationNotMatch))+"&ifSourceMetagenerationMatch=" + (ifSourceMetagenerationMatch==null? "" : System.Uri.EscapeDataString(ifSourceMetagenerationMatch))+"&ifSourceMetagenerationNotMatch=" + (ifSourceMetagenerationNotMatch==null? "" : System.Uri.EscapeDataString(ifSourceMetagenerationNotMatch))+"&projection=" + projection+"&sourceGeneration=" + (sourceGeneration==null? "" : System.Uri.EscapeDataString(sourceGeneration));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Object>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stop watching resources through this channel
		/// Storage_channels_stop channels/stop
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task Storage_channels_stopAsync(Channel requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum Storage_buckets_listProjection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="full")]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="noAcl")]
		noAcl = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
