//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// User's activities.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Activities
	{
		
		[System.Runtime.Serialization.DataMember(Name="collection")]
		public ActivitiesCollection[] ActivitiesCollection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="future_href")]
		public string Future_href { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_href")]
		public string Next_href { get; set; }
	}
	
	public class ActivitiesCollection
	{
		
		/// <summary>
		/// Created timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Origin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
		
		/// <summary>
		/// Type of activity (track).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthorizationCode
	{
		
		/// <summary>
		/// Authorization code
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorization_code")]
		public string Authorization_code { get; set; }
		
		/// <summary>
		/// Client ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		/// <summary>
		/// Client secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="grant_type")]
		public System.Nullable<AuthorizationCodeGrant_type> Grant_type { get; set; }
		
		/// <summary>
		/// Redirect URI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_uri")]
		public string Redirect_uri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AuthorizationCodeGrant_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="authorization_code")]
		authorization_code = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="client_credentials")]
		client_credentials = 1,
	}
	
	/// <summary>
	/// User's Comment
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Comment
	{
		
		/// <summary>
		/// Comment body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Created timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Kind (comment).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public string Timestamp { get; set; }
		
		/// <summary>
		/// Track's identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track_id")]
		public System.Nullable<System.Int32> Track_id { get; set; }
		
		/// <summary>
		/// Comment's URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// SoundCloud User object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public CommentUser User { get; set; }
		
		/// <summary>
		/// User's identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_id")]
		public System.Nullable<System.Int32> User_id { get; set; }
	}
	
	public class CommentUser
	{
		
		/// <summary>
		/// URL to a JPEG image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// number of followers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followers_count")]
		public System.Nullable<System.Int32> Followers_count { get; set; }
		
		/// <summary>
		/// number of followed users.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followings_count")]
		public System.Nullable<System.Int32> Followings_count { get; set; }
		
		/// <summary>
		/// unique identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// kind of resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// last modified timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_modified")]
		public string Last_modified { get; set; }
		
		/// <summary>
		/// permalink of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink")]
		public string Permalink { get; set; }
		
		/// <summary>
		/// URL to the SoundCloud.com page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink_url")]
		public string Permalink_url { get; set; }
		
		/// <summary>
		/// number of reposts from user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reposts_count")]
		public System.Nullable<System.Int32> Reposts_count { get; set; }
		
		/// <summary>
		/// API resource URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// username
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Comments
	{
		
		[System.Runtime.Serialization.DataMember(Name="collection")]
		public Comment[] Collection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_href")]
		public string Next_href { get; set; }
	}
	
	/// <summary>
	/// SoundCloud Complete User object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CompleteUser
	{
		
		/// <summary>
		/// URL to a JPEG image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// city.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// country.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// discogs name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="discogs_name")]
		public string Discogs_name { get; set; }
		
		/// <summary>
		/// first name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first_name")]
		public string First_name { get; set; }
		
		/// <summary>
		/// number of followers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followers_count")]
		public System.Nullable<System.Int32> Followers_count { get; set; }
		
		/// <summary>
		/// number of followed users.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followings_count")]
		public System.Nullable<System.Int32> Followings_count { get; set; }
		
		/// <summary>
		/// first and last name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// unique identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// kind of resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// last modified timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_modified")]
		public string Last_modified { get; set; }
		
		/// <summary>
		/// last name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_name")]
		public string Last_name { get; set; }
		
		/// <summary>
		/// locale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locale")]
		public string Locale { get; set; }
		
		/// <summary>
		/// myspace name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="myspace_name")]
		public string Myspace_name { get; set; }
		
		/// <summary>
		/// permalink of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink")]
		public string Permalink { get; set; }
		
		/// <summary>
		/// URL to the SoundCloud.com page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink_url")]
		public string Permalink_url { get; set; }
		
		/// <summary>
		/// subscription plan of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public string Plan { get; set; }
		
		/// <summary>
		/// number of public playlists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playlist_count")]
		public System.Nullable<System.Int32> Playlist_count { get; set; }
		
		/// <summary>
		/// boolean if email is confirmed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary_email_confirmed")]
		public System.Nullable<System.Boolean> Primary_email_confirmed { get; set; }
		
		/// <summary>
		/// number of private playlists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private_playlists_count")]
		public System.Nullable<System.Int32> Private_playlists_count { get; set; }
		
		/// <summary>
		/// number of private tracks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private_tracks_count")]
		public System.Nullable<System.Int32> Private_tracks_count { get; set; }
		
		/// <summary>
		/// number of favorited public tracks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_favorites_count")]
		public System.Nullable<System.Int32> Public_favorites_count { get; set; }
		
		/// <summary>
		/// user's upload quota
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quota")]
		public CompleteUserQuota Quota { get; set; }
		
		/// <summary>
		/// number of reposts from user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reposts_count")]
		public System.Nullable<System.Int32> Reposts_count { get; set; }
		
		/// <summary>
		/// a list subscriptions associated with the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscriptions")]
		public object Subscriptions { get; set; }
		
		/// <summary>
		/// number of public tracks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track_count")]
		public System.Nullable<System.Int32> Track_count { get; set; }
		
		/// <summary>
		/// API resource URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// username
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// a URL to the website.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website")]
		public string Website { get; set; }
		
		/// <summary>
		/// a custom title for the website.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website_title")]
		public string Website_title { get; set; }
	}
	
	public class CompleteUserQuota
	{
		
		/// <summary>
		/// unlimited upload quota.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unlimited_upload_quota")]
		public System.Nullable<System.Boolean> Unlimited_upload_quota { get; set; }
		
		/// <summary>
		/// upload seconds used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upload_seconds_used")]
		public System.Nullable<System.Int32> Upload_seconds_used { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Connection
	{
		
		/// <summary>
		/// Created timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Full Name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display_name")]
		public string Display_name { get; set; }
		
		/// <summary>
		/// Unique identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Kind of resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="post_favorite")]
		public System.Nullable<System.Boolean> Post_favorite { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="post_publish")]
		public System.Nullable<System.Boolean> Post_publish { get; set; }
		
		/// <summary>
		/// Service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// Type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The external link URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateUpdatePlaylistRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="playlist")]
		public CreateUpdatePlaylistRequestPlaylist Playlist { get; set; }
	}
	
	public class CreateUpdatePlaylistRequestPlaylist
	{
		
		/// <summary>
		/// Description of the playlist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// public or private
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharing")]
		public System.Nullable<CreateUpdatePlaylistRequestPlaylistSharing> Sharing { get; set; }
		
		/// <summary>
		/// Title of the playlist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// List of tracks to add to playlist
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tracks")]
		public CreateUpdatePlaylistRequestPlaylistTracks[] CreateUpdatePlaylistRequestPlaylistTracks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CreateUpdatePlaylistRequestPlaylistSharing
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
	}
	
	public class CreateUpdatePlaylistRequestPlaylistTracks
	{
		
		/// <summary>
		/// SoundCloud track id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error1 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public string[] Errors { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="link")]
		public string Link { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Found
	{
		
		/// <summary>
		/// Location URL of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Status code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	/// <summary>
	/// SoundCloud User object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetaUser
	{
		
		/// <summary>
		/// URL to a JPEG image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// profile creation datetime
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// unique identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// kind of resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// last modified datetime
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_modified")]
		public System.Nullable<System.DateTimeOffset> Last_modified { get; set; }
		
		/// <summary>
		/// permalink of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink")]
		public string Permalink { get; set; }
		
		/// <summary>
		/// URL to the SoundCloud.com page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink_url")]
		public string Permalink_url { get; set; }
		
		/// <summary>
		/// API resource URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// username
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetaUsers
	{
		
		[System.Runtime.Serialization.DataMember(Name="collection")]
		public MetaUser[] Collection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_href")]
		public string Next_href { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Password
	{
		
		/// <summary>
		/// Client ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		/// <summary>
		/// Client secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="grant_type")]
		public System.Nullable<PasswordGrant_type> Grant_type { get; set; }
		
		/// <summary>
		/// User password
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password1 { get; set; }
		
		/// <summary>
		/// Redirect URI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_uri")]
		public string Redirect_uri { get; set; }
		
		/// <summary>
		/// User name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_name")]
		public string User_name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PasswordGrant_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="password")]
		password = 0,
	}
	
	/// <summary>
	/// Soundcloud Playlist Object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Playlist
	{
		
		/// <summary>
		/// URL to a JPEG image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artwork_url")]
		public string Artwork_url { get; set; }
		
		/// <summary>
		/// Created timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Playlist description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// is downloadable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadable")]
		public System.Nullable<System.Boolean> Downloadable { get; set; }
		
		/// <summary>
		/// Playlist duration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// European Article Number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ean")]
		public string Ean { get; set; }
		
		/// <summary>
		/// Embeddable by.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="embeddable_by")]
		public string Embeddable_by { get; set; }
		
		/// <summary>
		/// Playlist genre.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="genre")]
		public string Genre { get; set; }
		
		/// <summary>
		/// Playlist identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Type of Soundcloud object (playlist).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// SoundCloud User object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public MetaUser Label { get; set; }
		
		/// <summary>
		/// Label user identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_id")]
		public System.Nullable<System.Int32> Label_id { get; set; }
		
		/// <summary>
		/// Label name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_name")]
		public string Label_name { get; set; }
		
		/// <summary>
		/// Last modified timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_modified")]
		public string Last_modified { get; set; }
		
		/// <summary>
		/// License.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="license")]
		public string License { get; set; }
		
		/// <summary>
		/// Count of playlist likes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="likes_count")]
		public System.Nullable<System.Int32> Likes_count { get; set; }
		
		/// <summary>
		/// Playlist permalink.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink")]
		public string Permalink { get; set; }
		
		/// <summary>
		/// Playlist permalink URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink_url")]
		public string Permalink_url { get; set; }
		
		/// <summary>
		/// Type of playlist.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playlist_type")]
		public string Playlist_type { get; set; }
		
		/// <summary>
		/// Purchase title.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="purchase_title")]
		public string Purchase_title { get; set; }
		
		/// <summary>
		/// Purchase URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="purchase_url")]
		public string Purchase_url { get; set; }
		
		/// <summary>
		/// Release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release")]
		public string Release { get; set; }
		
		/// <summary>
		/// Day of release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_day")]
		public System.Nullable<System.Int32> Release_day { get; set; }
		
		/// <summary>
		/// Month of release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_month")]
		public System.Nullable<System.Int32> Release_month { get; set; }
		
		/// <summary>
		/// Year of release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_year")]
		public System.Nullable<System.Int32> Release_year { get; set; }
		
		/// <summary>
		/// Type of sharing (private/public).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharing")]
		public string Sharing { get; set; }
		
		/// <summary>
		/// Is streamable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="streamable")]
		public System.Nullable<System.Boolean> Streamable { get; set; }
		
		/// <summary>
		/// Tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag_list")]
		public string Tag_list { get; set; }
		
		/// <summary>
		/// Tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		/// <summary>
		/// Playlist title.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Count of tracks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track_count")]
		public System.Nullable<System.Int32> Track_count { get; set; }
		
		/// <summary>
		/// List of tracks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tracks")]
		public Track[] Tracks { get; set; }
		
		/// <summary>
		/// tracks URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tracks_uri")]
		public string Tracks_uri { get; set; }
		
		/// <summary>
		/// Playlist type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Playlist URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// SoundCloud User object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public MetaUser User { get; set; }
		
		/// <summary>
		/// User identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_id")]
		public System.Nullable<System.Int32> User_id { get; set; }
	}
	
	/// <summary>
	/// Soundcloud Track object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Track
	{
		
		/// <summary>
		/// Level of access the user (logged in or anonymous) has to the track.
		///  * `playable` - user is allowed to listen to a full track.
		///  * `preview` - user is allowed to preview a track, meaning a snippet is available
		///  * `blocked` - user can only see the metadata of a track, no streaming is possible
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access")]
		public System.Nullable<TrackAccess> Access { get; set; }
		
		/// <summary>
		/// URL to a JPEG image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artwork_url")]
		public string Artwork_url { get; set; }
		
		/// <summary>
		/// List of countries where track is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="available_country_codes")]
		public string Available_country_codes { get; set; }
		
		/// <summary>
		/// Tempo.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bpm")]
		public System.Nullable<System.Int32> Bpm { get; set; }
		
		/// <summary>
		/// Number of comments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment_count")]
		public System.Nullable<System.Int32> Comment_count { get; set; }
		
		/// <summary>
		/// Is commentable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commentable")]
		public System.Nullable<System.Boolean> Commentable { get; set; }
		
		/// <summary>
		/// Created timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Track description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// NUmber of downloads.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="download_count")]
		public System.Nullable<System.Int32> Download_count { get; set; }
		
		/// <summary>
		/// URL to download a track.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// Is downloadable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadable")]
		public string Downloadable { get; set; }
		
		/// <summary>
		/// Track duration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// Embeddable by.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="embeddable_by")]
		public string Embeddable_by { get; set; }
		
		/// <summary>
		/// Number of favoritings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="favoritings_count")]
		public System.Nullable<System.Int32> Favoritings_count { get; set; }
		
		/// <summary>
		/// Genre
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="genre")]
		public string Genre { get; set; }
		
		/// <summary>
		/// Track identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// ISRC code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isrc")]
		public string Isrc { get; set; }
		
		/// <summary>
		/// Key signature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key_signature")]
		public string Key_signature { get; set; }
		
		/// <summary>
		/// Type of object (track).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Label user name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_name")]
		public string Label_name { get; set; }
		
		/// <summary>
		/// License
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="license")]
		public string License { get; set; }
		
		/// <summary>
		/// Permalink URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink_url")]
		public string Permalink_url { get; set; }
		
		/// <summary>
		/// Number of plays.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playback_count")]
		public System.Nullable<System.Int32> Playback_count { get; set; }
		
		/// <summary>
		/// Purchase title.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="purchase_title")]
		public string Purchase_title { get; set; }
		
		/// <summary>
		/// Purchase URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="purchase_url")]
		public string Purchase_url { get; set; }
		
		/// <summary>
		/// Release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release")]
		public string Release { get; set; }
		
		/// <summary>
		/// Day of release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_day")]
		public System.Nullable<System.Int32> Release_day { get; set; }
		
		/// <summary>
		/// Month of release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_month")]
		public System.Nullable<System.Int32> Release_month { get; set; }
		
		/// <summary>
		/// Year of release.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_year")]
		public System.Nullable<System.Int32> Release_year { get; set; }
		
		/// <summary>
		/// Number of reposts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reposts_count")]
		public System.Nullable<System.Int32> Reposts_count { get; set; }
		
		/// <summary>
		/// Secret URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret_uri")]
		public string Secret_uri { get; set; }
		
		/// <summary>
		/// Type of sharing (public/private).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharing")]
		public string Sharing { get; set; }
		
		/// <summary>
		/// URL to stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_url")]
		public string Stream_url { get; set; }
		
		/// <summary>
		/// Is streamable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="streamable")]
		public System.Nullable<System.Boolean> Streamable { get; set; }
		
		/// <summary>
		/// Tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag_list")]
		public string Tag_list { get; set; }
		
		/// <summary>
		/// Track title.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Track URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// SoundCloud User object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public MetaUser User { get; set; }
		
		/// <summary>
		/// Is user's favourite.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_favorite")]
		public System.Nullable<System.Boolean> User_favorite { get; set; }
		
		/// <summary>
		/// Number of plays by a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_playback_count")]
		public System.Nullable<System.Int32> User_playback_count { get; set; }
		
		/// <summary>
		/// Waveform URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="waveform_url")]
		public string Waveform_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TrackAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="playable")]
		playable = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="preview")]
		preview = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="blocked")]
		blocked = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_null = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Playlists
	{
		
		[System.Runtime.Serialization.DataMember(Name="collection")]
		public Playlist[] Collection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_href")]
		public string Next_href { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RefreshToken
	{
		
		/// <summary>
		/// Client ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		/// <summary>
		/// Client secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="grant_type")]
		public System.Nullable<RefreshTokenGrant_type> Grant_type { get; set; }
		
		/// <summary>
		/// Redirect URI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_uri")]
		public string Redirect_uri { get; set; }
		
		/// <summary>
		/// Refresh token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="refresh_token")]
		public string Refresh_token { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RefreshTokenGrant_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="refresh_token")]
		refresh_token = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Streams
	{
		
		[System.Runtime.Serialization.DataMember(Name="hls_mp3_128_url")]
		public string Hls_mp3_128_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hls_opus_64_url")]
		public string Hls_opus_64_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http_mp3_128_url")]
		public string Http_mp3_128_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="preview_mp3_128_url")]
		public string Preview_mp3_128_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyRequests : Error
	{
		
		[System.Runtime.Serialization.DataMember(Name="spam_warning_urn")]
		public string Spam_warning_urn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrackDataRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="track[artwork_data]")]
		public string Track_artwork_data_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[asset_data]")]
		public string Track_asset_data_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[commentable]")]
		public System.Nullable<System.Boolean> Track_commentable_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[description]")]
		public string Track_description_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[downloadable]")]
		public System.Nullable<System.Boolean> Track_downloadable_ { get; set; }
		
		/// <summary>
		/// who can embed this track "all", "me", or "none"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track[embeddable_by]")]
		public System.Nullable<TrackDataRequestTrack_embeddable_by_> Track_embeddable_by_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[genre]")]
		public string Track_genre_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[isrc]")]
		public string Track_isrc_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[label_name]")]
		public string Track_label_name_ { get; set; }
		
		/// <summary>
		/// Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track[license]")]
		public System.Nullable<TrackDataRequestTrack_license_> Track_license_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[permalink]")]
		public string Track_permalink_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[purchase_url]")]
		public string Track_purchase_url_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[release]")]
		public string Track_release_ { get; set; }
		
		/// <summary>
		/// string, formatted as yyyy-mm-dd, representing release date
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track[release_date]")]
		public string Track_release_date_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[sharing]")]
		public System.Nullable<TrackDataRequestTrack_sharing_> Track_sharing_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[streamable]")]
		public System.Nullable<System.Boolean> Track_streamable_ { get; set; }
		
		/// <summary>
		/// The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY=VALUE. For example: geo:lat=43.555 camel:size=medium “machine:tag=with space” Machine tags are not revealed to the user on the track pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track[tag_list]")]
		public string Track_tag_list_ { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="track[title]")]
		public string Track_title_ { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TrackDataRequestTrack_embeddable_by_
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="all")]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me")]
		me = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="none")]
		none = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TrackDataRequestTrack_license_
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="no-rights-reserved")]
		noMinusrightsMinusreserved = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="all-rights-reserved")]
		allMinusrightsMinusreserved = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by")]
		ccMinusby = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-nc")]
		ccMinusbyMinusnc = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-nd")]
		ccMinusbyMinusnd = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-sa")]
		ccMinusbyMinussa = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-nc-nd")]
		ccMinusbyMinusncMinusnd = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-nc-sa")]
		ccMinusbyMinusncMinussa = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TrackDataRequestTrack_sharing_
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrackMetadataRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="track")]
		public TrackMetadataRequestTrack Track { get; set; }
	}
	
	public class TrackMetadataRequestTrack
	{
		
		[System.Runtime.Serialization.DataMember(Name="commentable")]
		public System.Nullable<System.Boolean> Commentable { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="downloadable")]
		public System.Nullable<System.Boolean> Downloadable { get; set; }
		
		/// <summary>
		/// who can embed this track "all", "me", or "none"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="embeddable_by")]
		public TrackDataRequestTrack_embeddable_by_ Embeddable_by { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="genre")]
		public string Genre { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isrc")]
		public string Isrc { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label_name")]
		public string Label_name { get; set; }
		
		/// <summary>
		/// Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="license")]
		public System.Nullable<TrackMetadataRequestTrackLicense> License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="permalink")]
		public string Permalink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="purchase_url")]
		public string Purchase_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="release")]
		public string Release { get; set; }
		
		/// <summary>
		/// string, formatted as yyyy-mm-dd, representing release date
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_date")]
		public string Release_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sharing")]
		public System.Nullable<TrackMetadataRequestTrackSharing> Sharing { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamable")]
		public System.Nullable<System.Boolean> Streamable { get; set; }
		
		/// <summary>
		/// The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY=VALUE. For example: geo:lat=43.555 camel:size=medium “machine:tag=with space” Machine tags are not revealed to the user on the track pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag_list")]
		public string Tag_list { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TrackMetadataRequestTrackLicense
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="no-rights-reserved")]
		noMinusrightsMinusreserved = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="all-rights-reserved")]
		allMinusrightsMinusreserved = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by")]
		ccMinusby = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-nc")]
		ccMinusbyMinusnc = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-nd")]
		ccMinusbyMinusnd = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-sa")]
		ccMinusbyMinussa = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-nc-nd")]
		ccMinusbyMinusncMinusnd = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cc-by-nc-sa")]
		ccMinusbyMinusncMinussa = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TrackMetadataRequestTrackSharing
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tracks
	{
		
		[System.Runtime.Serialization.DataMember(Name="collection")]
		public Track[] Collection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_href")]
		public string Next_href { get; set; }
	}
	
	/// <summary>
	/// SoundCloud User object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User
	{
		
		/// <summary>
		/// URL to a JPEG image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// city
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// country
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// profile creation datetime
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// description
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// discogs name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="discogs_name")]
		public string Discogs_name { get; set; }
		
		/// <summary>
		/// first name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first_name")]
		public string First_name { get; set; }
		
		/// <summary>
		/// number of followers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followers_count")]
		public System.Nullable<System.Int32> Followers_count { get; set; }
		
		/// <summary>
		/// number of followed users
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followings_count")]
		public System.Nullable<System.Int32> Followings_count { get; set; }
		
		/// <summary>
		/// first and last name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// unique identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// kind of resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// last modified datetime
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_modified")]
		public System.Nullable<System.DateTimeOffset> Last_modified { get; set; }
		
		/// <summary>
		/// last name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_name")]
		public string Last_name { get; set; }
		
		/// <summary>
		/// myspace name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="myspace_name")]
		public string Myspace_name { get; set; }
		
		/// <summary>
		/// permalink of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink")]
		public string Permalink { get; set; }
		
		/// <summary>
		/// URL to the SoundCloud.com page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink_url")]
		public string Permalink_url { get; set; }
		
		/// <summary>
		/// subscription plan of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public string Plan { get; set; }
		
		/// <summary>
		/// number of public playlists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playlist_count")]
		public System.Nullable<System.Int32> Playlist_count { get; set; }
		
		/// <summary>
		/// number of favorited public tracks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_favorites_count")]
		public System.Nullable<System.Int32> Public_favorites_count { get; set; }
		
		/// <summary>
		/// number of reposts from user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reposts_count")]
		public System.Nullable<System.Int32> Reposts_count { get; set; }
		
		/// <summary>
		/// a list subscriptions associated with the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscriptions")]
		public object Subscriptions { get; set; }
		
		/// <summary>
		/// number of public tracks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track_count")]
		public System.Nullable<System.Int32> Track_count { get; set; }
		
		/// <summary>
		/// API resource URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// username
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// a URL to the website
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website")]
		public string Website { get; set; }
		
		/// <summary>
		/// a custom title for the website
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website_title")]
		public string Website_title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Users
	{
		
		[System.Runtime.Serialization.DataMember(Name="collection")]
		public User[] Collection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_href")]
		public string Next_href { get; set; }
	}
	
	/// <summary>
	/// SoundCloud User object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UsersListElement
	{
		
		/// <summary>
		/// URL to a JPEG image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar_url")]
		public string Avatar_url { get; set; }
		
		/// <summary>
		/// city
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// country
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// description
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// discogs name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="discogs_name")]
		public string Discogs_name { get; set; }
		
		/// <summary>
		/// first name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first_name")]
		public string First_name { get; set; }
		
		/// <summary>
		/// number of followers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followers_count")]
		public System.Nullable<System.Int32> Followers_count { get; set; }
		
		/// <summary>
		/// number of followed users
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followings_count")]
		public System.Nullable<System.Int32> Followings_count { get; set; }
		
		/// <summary>
		/// first and last name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="full_name")]
		public string Full_name { get; set; }
		
		/// <summary>
		/// unique identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// kind of resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// last modified datetime
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_modified")]
		public System.Nullable<System.DateTimeOffset> Last_modified { get; set; }
		
		/// <summary>
		/// last name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_name")]
		public string Last_name { get; set; }
		
		/// <summary>
		/// myspace name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="myspace_name")]
		public string Myspace_name { get; set; }
		
		/// <summary>
		/// permalink of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink")]
		public string Permalink { get; set; }
		
		/// <summary>
		/// URL to the SoundCloud.com page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permalink_url")]
		public string Permalink_url { get; set; }
		
		/// <summary>
		/// subscription plan of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public string Plan { get; set; }
		
		/// <summary>
		/// number of public playlists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playlist_count")]
		public System.Nullable<System.Int32> Playlist_count { get; set; }
		
		/// <summary>
		/// number of favorited public tracks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_favorites_count")]
		public System.Nullable<System.Int32> Public_favorites_count { get; set; }
		
		/// <summary>
		/// number of reposts from user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reposts_count")]
		public System.Nullable<System.Int32> Reposts_count { get; set; }
		
		/// <summary>
		/// a list subscriptions associated with the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscriptions")]
		public object Subscriptions { get; set; }
		
		/// <summary>
		/// number of public tracks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="track_count")]
		public System.Nullable<System.Int32> Track_count { get; set; }
		
		/// <summary>
		/// API resource URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// username
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// a URL to the website
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website")]
		public string Website { get; set; }
		
		/// <summary>
		/// a custom title for the website
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website_title")]
		public string Website_title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WebProfilesElement
	{
		
		/// <summary>
		/// Timestamp of when the link was added to the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Kind
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Service or platform
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// Link's title
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// URL of the external link
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Username extracted from the external link
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// The OAuth2 authorization endpoint. Your app redirects a user to this endpoint, allowing them to delegate access to their account.
		/// <h3>Security Advice</h3>
		/// * Using the [implicit OAuth authorization flow](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-16#section-2.1.2) (`response_type=token`)  is **not recommended**. It can suffer from access token leakage and access token replay attacks. Use `response_type=code` instead.
		/// * Use the `state` parameter for [CSRF protection](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-16#section-4.7). Pass a sufficient  random nonce here and verify this nonce again after retrieving the token.
		/// 
		/// ConnectGetByClient_idAndRedirect_uriAndResponse_typeAndScopeAndState connect
		/// </summary>
		/// <param name="client_id">The client id belonging to your application</param>
		/// <param name="redirect_uri">The redirect uri you have configured for your application</param>
		/// <param name="response_type">It's recommended to use "code" here</param>
		/// <param name="scope">Scope</param>
		/// <param name="state">Any value included here will be appended to the redirect URI. Use this for CSRF protection.</param>
		public async Task ConnectGetByClient_idAndRedirect_uriAndResponse_typeAndScopeAndStateAsync(string client_id, string redirect_uri, ConnectGetByClient_idAndRedirect_uriAndResponse_typeAndScopeAndStateResponse_type response_type, string scope, string state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "connect?client_id=" + (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"&redirect_uri=" + (redirect_uri==null? "" : System.Uri.EscapeDataString(redirect_uri))+"&response_type=" + response_type+"&scope=" + (scope==null? "" : System.Uri.EscapeDataString(scope))+"&state=" + (state==null? "" : System.Uri.EscapeDataString(state));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unlikes a playlist.
		/// LikesPlaylists_playlist_idDelete likes/playlists/{playlist_id}
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <returns>Success</returns>
		public async Task LikesPlaylists_playlist_idDeleteAsync(int playlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "likes/playlists/"+playlist_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Likes a playlist.
		/// LikesPlaylists_playlist_idPost likes/playlists/{playlist_id}
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <returns>Success</returns>
		public async Task LikesPlaylists_playlist_idPostAsync(int playlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "likes/playlists/"+playlist_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unlikes a track.
		/// LikesTracks_track_idDelete likes/tracks/{track_id}
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <returns>Success</returns>
		public async Task LikesTracks_track_idDeleteAsync(int track_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "likes/tracks/"+track_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Likes a track.
		/// LikesTracks_track_idPost likes/tracks/{track_id}
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <returns>Success</returns>
		public async Task LikesTracks_track_idPostAsync(int track_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "likes/tracks/"+track_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the authenticated user’s information.
		/// MeGet me
		/// </summary>
		/// <returns>Success</returns>
		public async Task MeGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the authenticated user's activities.
		/// MeActivitiesGetByAccessAndLimit me/activities
		/// </summary>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task MeActivitiesGetByAccessAndLimitAsync(string[] access, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/activities?"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Recent the authenticated user's activities.
		/// MeActivitiesAllOwnGetByAccessAndLimit me/activities/all/own
		/// </summary>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task MeActivitiesAllOwnGetByAccessAndLimitAsync(string[] access, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/activities/all/own?"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the authenticated user's recent track related activities.
		/// MeActivitiesTracksGetByAccessAndLimit me/activities/tracks
		/// </summary>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task MeActivitiesTracksGetByAccessAndLimitAsync(string[] access, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/activities/tracks?"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of the authenticated user's connected social accounts.
		/// MeConnectionsGetByLimitAndOffset me/connections
		/// </summary>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <returns>Success</returns>
		public async Task MeConnectionsGetByLimitAndOffsetAsync(int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/connections?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the authenticated user's connected social account.
		/// MeConnections_connection_idGet me/connections/{connection_id}
		/// </summary>
		/// <param name="connection_id">SoundCloud connection id</param>
		/// <returns>Success</returns>
		public async Task MeConnections_connection_idGetAsync(int connection_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/connections/"+connection_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns user’s favorites ids. (use /me/likes/tracks instead to fetch the authenticated user's likes)
		/// MeFavoritesIdsGetByLimit me/favorites/ids
		/// </summary>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task MeFavoritesIdsGetByLimitAsync(int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/favorites/ids?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users who are following the authenticated user.
		/// MeFollowersGetByLimit me/followers
		/// </summary>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task MeFollowersGetByLimitAsync(int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/followers?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a user who is following the authenticated user. (use /users/{user_id} instead, to fetch the user details)
		/// MeFollowers_follower_idGet me/followers/{follower_id}
		/// </summary>
		/// <param name="follower_id">SoundCloud User id to denote a Follower</param>
		/// <returns>Success</returns>
		public async Task MeFollowers_follower_idGetAsync(int follower_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/followers/"+follower_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users who are followed by the authenticated user.
		/// MeFollowingsGetByLimitAndOffset me/followings
		/// </summary>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <returns>Success</returns>
		public async Task MeFollowingsGetByLimitAndOffsetAsync(int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/followings?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of recent tracks from users followed by the authenticated user.
		/// MeFollowingsTracksGetByAccessAndLimitAndOffset me/followings/tracks
		/// </summary>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <returns>Success</returns>
		public async Task MeFollowingsTracksGetByAccessAndLimitAndOffsetAsync(string[] access, int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/followings/tracks?"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a user who is followed by the authenticated user.
		/// MeFollowings_user_idDelete me/followings/{user_id}
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <returns>Success</returns>
		public async Task MeFollowings_user_idDeleteAsync(int user_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/followings/"+user_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a user who is followed by the authenticated user. (use /users/{user_id} instead, to fetch the user details)
		/// MeFollowings_user_idGet me/followings/{user_id}
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <returns>Success</returns>
		public async Task MeFollowings_user_idGetAsync(int user_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/followings/"+user_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Follows a user.
		/// MeFollowings_user_idPut me/followings/{user_id}
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <returns>Success</returns>
		public async Task MeFollowings_user_idPutAsync(int user_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/followings/"+user_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of favorited or liked tracks of the authenticated user.
		/// MeLikesTracksGetByLimitAndLinked_partitioning me/likes/tracks
		/// </summary>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task MeLikesTracksGetByLimitAndLinked_partitioningAsync(int limit, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/likes/tracks?limit="+limit+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns user’s playlists (sets).
		/// Returns playlist info, playlist tracks and tracks owner info.
		/// MePlaylistsGetByLimit me/playlists
		/// </summary>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task MePlaylistsGetByLimitAsync(int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/playlists?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns playlist. (use /playlists/{playlist_id} instead, to fetch the playlist details)
		/// MePlaylists_playlist_idGet me/playlists/{playlist_id}
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <returns>Success</returns>
		public async Task MePlaylists_playlist_idGetAsync(int playlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/playlists/"+playlist_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of user's tracks.
		/// MeTracksGetByLimitAndLinked_partitioning me/tracks
		/// </summary>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task MeTracksGetByLimitAndLinked_partitioningAsync(int limit, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/tracks?limit="+limit+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a specified track. (use /tracks/{track_id} instead, to fetch the track details)
		/// MeTracks_track_idGet me/tracks/{track_id}
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <returns>Success</returns>
		public async Task MeTracks_track_idGetAsync(int track_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me/tracks/"+track_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Performs a playlist search based on a query
		/// PlaylistsGetByQAndAccessAndLimitAndOffsetAndLinked_partitioning playlists
		/// </summary>
		/// <param name="q">search</param>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task PlaylistsGetByQAndAccessAndLimitAndOffsetAndLinked_partitioningAsync(string q, string[] access, int limit, int offset, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit+"&offset="+offset+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a playlist.
		/// PlaylistsPost playlists
		/// </summary>
		/// <param name="requestBody">Create Playlist request</param>
		public async Task PlaylistsPostAsync(CreateUpdatePlaylistRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a playlist.
		/// Playlists_playlist_idDelete playlists/{playlist_id}
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <returns>Success</returns>
		public async Task Playlists_playlist_idDeleteAsync(int playlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists/"+playlist_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a playlist.
		/// Playlists_playlist_idGetBySecret_tokenAndAccess playlists/{playlist_id}
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <param name="secret_token">A secret token to fetch private playlists/tracks</param>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <returns>Success</returns>
		public async Task Playlists_playlist_idGetBySecret_tokenAndAccessAsync(int playlist_id, string secret_token, string[] access, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists/"+playlist_id+"?secret_token=" + (secret_token==null? "" : System.Uri.EscapeDataString(secret_token))+"&"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a playlist.
		/// Playlists_playlist_idPut playlists/{playlist_id}
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <param name="requestBody">Playlist payload</param>
		/// <returns>Success</returns>
		public async Task Playlists_playlist_idPutAsync(int playlist_id, CreateUpdatePlaylistRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists/"+playlist_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a collection of playlist's reposters.
		/// Playlists_playlist_idRepostersGetByLimit playlists/{playlist_id}/reposters
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task Playlists_playlist_idRepostersGetByLimitAsync(int playlist_id, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists/"+playlist_id+"/reposters?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns tracks under a playlist.
		/// Playlists_playlist_idTracksGetBySecret_tokenAndAccessAndLinked_partitioning playlists/{playlist_id}/tracks
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <param name="secret_token">A secret token to fetch private playlists/tracks</param>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task Playlists_playlist_idTracksGetBySecret_tokenAndAccessAndLinked_partitioningAsync(int playlist_id, string secret_token, string[] access, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playlists/"+playlist_id+"/tracks?secret_token=" + (secret_token==null? "" : System.Uri.EscapeDataString(secret_token))+"&"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a repost on a playlist as the authenticated user
		/// RepostsPlaylists_playlist_idDelete reposts/playlists/{playlist_id}
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		/// <returns>Success</returns>
		public async Task RepostsPlaylists_playlist_idDeleteAsync(int playlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "reposts/playlists/"+playlist_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reposts a playlist as the authenticated user
		/// RepostsPlaylists_playlist_idPost reposts/playlists/{playlist_id}
		/// </summary>
		/// <param name="playlist_id">SoundCloud playlist id</param>
		public async Task RepostsPlaylists_playlist_idPostAsync(int playlist_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "reposts/playlists/"+playlist_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a repost on a track as the authenticated user
		/// RepostsTracks_track_idDelete reposts/tracks/{track_id}
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <returns>Success</returns>
		public async Task RepostsTracks_track_idDeleteAsync(int track_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "reposts/tracks/"+track_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reposts a track as the authenticated user
		/// RepostsTracks_track_idPost reposts/tracks/{track_id}
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		public async Task RepostsTracks_track_idPostAsync(int track_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "reposts/tracks/"+track_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resolves soundcloud.com URLs to Resource URLs to use with the API.
		/// ResolveGetByUrl resolve
		/// </summary>
		/// <param name="url">SoundCloud URL</param>
		public async Task ResolveGetByUrlAsync(string url, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "resolve?url=" + (url==null? "" : System.Uri.EscapeDataString(url));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Performs a track search based on a query
		/// TracksGetByQAndIdsAndGenresAndTagsAndBpmAndDurationAndCreated_atAndAccessAndLimitAndOffsetAndLinked_partitioning tracks
		/// </summary>
		/// <param name="q">search</param>
		/// <param name="ids">A comma separated list of track ids to filter on</param>
		/// <param name="genres">A comma separated list of genres</param>
		/// <param name="tags">A comma separated list of tags</param>
		/// <param name="bpm">Return tracks with a specified bpm[from], bpm[to]</param>
		/// <param name="duration">Return tracks within a specified duration range</param>
		/// <param name="created_at">(yyyy-mm-dd hh:mm:ss) return tracks created within the specified dates</param>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task TracksGetByQAndIdsAndGenresAndTagsAndBpmAndDurationAndCreated_atAndAccessAndLimitAndOffsetAndLinked_partitioningAsync(string q, string ids, string genres, string tags, TracksGetByQAndIdsAndGenresAndTagsAndBpmAndDurationAndCreated_atAndAccessAndLimitAndOffsetAndLinked_partitioningBpm bpm, TracksGetByQAndIdsAndGenresAndTagsAndBpmAndDurationAndCreated_atAndAccessAndLimitAndOffsetAndLinked_partitioningDuration duration, TracksGetByQAndIdsAndGenresAndTagsAndBpmAndDurationAndCreated_atAndAccessAndLimitAndOffsetAndLinked_partitioningCreated_at created_at, string[] access, int limit, int offset, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&ids=" + (ids==null? "" : System.Uri.EscapeDataString(ids))+"&genres=" + (genres==null? "" : System.Uri.EscapeDataString(genres))+"&tags=" + (tags==null? "" : System.Uri.EscapeDataString(tags))+"&bpm=" + bpm+"&duration=" + duration+"&created_at=" + created_at+"&"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit+"&offset="+offset+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a track.
		/// Tracks_track_idDelete tracks/{track_id}
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <returns>Success</returns>
		public async Task Tracks_track_idDeleteAsync(int track_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks/"+track_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a track.
		/// Tracks_track_idGetBySecret_token tracks/{track_id}
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <param name="secret_token">A secret token to fetch private playlists/tracks</param>
		/// <returns>Success</returns>
		public async Task Tracks_track_idGetBySecret_tokenAsync(int track_id, string secret_token, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks/"+track_id+"?secret_token=" + (secret_token==null? "" : System.Uri.EscapeDataString(secret_token));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a track's information.
		/// Tracks_track_idPut tracks/{track_id}
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <param name="requestBody">Track payload</param>
		/// <returns>Success</returns>
		public async Task Tracks_track_idPutAsync(int track_id, TrackMetadataRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks/"+track_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the comments posted on the track(track_id).
		/// Tracks_track_idCommentsGetByLimitAndOffsetAndLinked_partitioning tracks/{track_id}/comments
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task Tracks_track_idCommentsGetByLimitAndOffsetAndLinked_partitioningAsync(int track_id, int limit, int offset, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks/"+track_id+"/comments?limit="+limit+"&offset="+offset+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of users who have favorited or liked the track.
		/// Tracks_track_idFavoritersGetByLimitAndOffset tracks/{track_id}/favoriters
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <returns>Success</returns>
		public async Task Tracks_track_idFavoritersGetByLimitAndOffsetAsync(int track_id, int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks/"+track_id+"/favoriters?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all related tracks of track on SoundCloud.
		/// Tracks_track_idRelatedGetByAccessAndLimitAndOffsetAndLinked_partitioning tracks/{track_id}/related
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task Tracks_track_idRelatedGetByAccessAndLimitAndOffsetAndLinked_partitioningAsync(int track_id, string[] access, int limit, int offset, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks/"+track_id+"/related?"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit+"&offset="+offset+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a collection of track's reposters.
		/// Tracks_track_idRepostersGetByLimit tracks/{track_id}/reposters
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task Tracks_track_idRepostersGetByLimitAsync(int track_id, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks/"+track_id+"/reposters?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a track's streamable URLs
		/// Tracks_track_idStreamsGetBySecret_token tracks/{track_id}/streams
		/// </summary>
		/// <param name="track_id">SoundCloud Track id</param>
		/// <param name="secret_token">A secret token to fetch private playlists/tracks</param>
		/// <returns>Success</returns>
		public async Task Tracks_track_idStreamsGetBySecret_tokenAsync(int track_id, string secret_token, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tracks/"+track_id+"/streams?secret_token=" + (secret_token==null? "" : System.Uri.EscapeDataString(secret_token));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Performs a user search based on a query
		/// UsersGetByQAndIdsAndLimitAndOffsetAndLinked_partitioning users
		/// </summary>
		/// <param name="q">search</param>
		/// <param name="ids">A comma separated list of track ids to filter on</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task UsersGetByQAndIdsAndLimitAndOffsetAndLinked_partitioningAsync(string q, string ids, int limit, int offset, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&ids=" + (ids==null? "" : System.Uri.EscapeDataString(ids))+"&limit="+limit+"&offset="+offset+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a user.
		/// Users_user_idGet users/{user_id}
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <returns>Success</returns>
		public async Task Users_user_idGetAsync(int user_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of user's comments.
		/// Users_user_idCommentsGetByLimitAndOffset users/{user_id}/comments
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="offset">Offset of first result. Deprecated, use `linked_partitioning` instead.</param>
		/// <returns>Success</returns>
		public async Task Users_user_idCommentsGetByLimitAndOffsetAsync(int user_id, int limit, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/comments?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of user's favorited or liked tracks. (use /users/:userId/likes/tracks instead, to fetch a user's likes)
		/// Users_user_idFavoritesGetByLimitAndLinked_partitioning users/{user_id}/favorites
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task Users_user_idFavoritesGetByLimitAndLinked_partitioningAsync(int user_id, int limit, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/favorites?limit="+limit+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of user’s followers.
		/// Returns a list of users that follows (user_id).
		/// Users_user_idFollowersGetByLimit users/{user_id}/followers
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task Users_user_idFollowersGetByLimitAsync(int user_id, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/followers?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of user’s followings.
		/// Returns list of users that (user_id) follows.
		/// Users_user_idFollowingsGetByLimit users/{user_id}/followings
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task Users_user_idFollowingsGetByLimitAsync(int user_id, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/followings?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a user's following. (use /users/{user_id} instead, to fetch the user details)
		/// Returns (following_id) that is followed by (user_id).
		/// Users_user_idFollowings_following_idGet users/{user_id}/followings/{following_id}
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="following_id">SoundCloud User id to denote a Following of a user</param>
		/// <returns>Success</returns>
		public async Task Users_user_idFollowings_following_idGetAsync(int user_id, int following_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/followings/"+following_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of user's liked tracks.
		/// Users_user_idLikesTracksGetByAccessAndLimitAndLinked_partitioning users/{user_id}/likes/tracks
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task Users_user_idLikesTracksGetByAccessAndLimitAndLinked_partitioningAsync(int user_id, string[] access, int limit, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/likes/tracks?"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of user's playlists.
		/// Users_user_idPlaylistsGetByAccessAndLimitAndLinked_partitioning users/{user_id}/playlists
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task Users_user_idPlaylistsGetByAccessAndLimitAndLinked_partitioningAsync(int user_id, string[] access, int limit, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/playlists?"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of user's tracks.
		/// Users_user_idTracksGetByAccessAndLimitAndLinked_partitioning users/{user_id}/tracks
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="access">Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
		///</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <param name="linked_partitioning">Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)</param>
		/// <returns>Success</returns>
		public async Task Users_user_idTracksGetByAccessAndLimitAndLinked_partitioningAsync(int user_id, string[] access, int limit, bool linked_partitioning, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/tracks?"+string.Join("&", access.Select(z => $"access={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit+"&linked_partitioning="+linked_partitioning;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns list of user's links added to their profile (website, facebook, instagram).
		/// Users_user_idWeb_profilesGetByLimit users/{user_id}/web-profiles
		/// </summary>
		/// <param name="user_id">SoundCloud User id</param>
		/// <param name="limit">Number of results to return in the collection.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>Success</returns>
		public async Task Users_user_idWeb_profilesGetByLimitAsync(int user_id, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+user_id+"/web-profiles?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum ConnectGetByClient_idAndRedirect_uriAndResponse_typeAndScopeAndStateResponse_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="code")]
		code = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="token")]
		token = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="code_and_token")]
		code_and_token = 2,
	}
	
	public class TracksGetByQAndIdsAndGenresAndTagsAndBpmAndDurationAndCreated_atAndAccessAndLimitAndOffsetAndLinked_partitioningBpm
	{
		
		/// <summary>
		/// Return tracks with at least this bpm value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public System.Nullable<System.Int32> From { get; set; }
		
		/// <summary>
		/// Return tracks with at most this bpm value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public System.Nullable<System.Int32> To { get; set; }
	}
	
	public class TracksGetByQAndIdsAndGenresAndTagsAndBpmAndDurationAndCreated_atAndAccessAndLimitAndOffsetAndLinked_partitioningDuration
	{
		
		/// <summary>
		/// Return tracks with at least this duration value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public System.Nullable<System.Int32> From { get; set; }
		
		/// <summary>
		/// Return tracks with at most this duration value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public System.Nullable<System.Int32> To { get; set; }
	}
	
	public class TracksGetByQAndIdsAndGenresAndTagsAndBpmAndDurationAndCreated_atAndAccessAndLimitAndOffsetAndLinked_partitioningCreated_at
	{
		
		/// <summary>
		/// (yyyy-mm-dd hh:mm:ss) return tracks created at this date or later
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// (yyyy-mm-dd hh:mm:ss) return tracks created at this date or earlier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
