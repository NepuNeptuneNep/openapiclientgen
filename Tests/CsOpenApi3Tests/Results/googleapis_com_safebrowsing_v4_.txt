//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleProtobufEmpty
	{
	}
	
	/// <summary>
	/// The expected state of a client's local database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4Checksum
	{
		
		/// <summary>
		/// The SHA256 hash of the client state; that is, of the sorted list of all hashes present in the database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sha256")]
		public string Sha256 { get; set; }
	}
	
	/// <summary>
	/// The client metadata associated with Safe Browsing API requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ClientInfo
	{
		
		/// <summary>
		/// A client ID that (hopefully) uniquely identifies the client implementation of the Safe Browsing API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// The version of the client implementation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientVersion")]
		public string ClientVersion { get; set; }
	}
	
	/// <summary>
	/// Describes a Safe Browsing API update request. Clients can request updates for multiple lists in a single request. The server may not respond to all requests, if the server has no updates for that list. NOTE: Field index 2 is unused. NEXT: 5
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequest
	{
		
		/// <summary>
		/// The client metadata associated with Safe Browsing API requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client")]
		public GoogleSecuritySafebrowsingV4ClientInfo Client { get; set; }
		
		/// <summary>
		/// The requested threat list updates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listUpdateRequests")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequest[] ListUpdateRequests { get; set; }
	}
	
	/// <summary>
	/// A single list update request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequest
	{
		
		/// <summary>
		/// The constraints for this update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestConstraints Constraints { get; set; }
		
		/// <summary>
		/// The type of platform at risk by entries present in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformType")]
		public System.Nullable<GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestPlatformType> PlatformType { get; set; }
		
		/// <summary>
		/// The current state of the client for the requested list (the encrypted client state that was received from the last successful list update).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// The types of entries present in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatEntryType")]
		public System.Nullable<GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatEntryType> ThreatEntryType { get; set; }
		
		/// <summary>
		/// The type of threat posed by entries present in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatType")]
		public System.Nullable<GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatType> ThreatType { get; set; }
	}
	
	/// <summary>
	/// The constraints for this update.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestConstraints
	{
		
		/// <summary>
		/// A client's physical location, expressed as a ISO 31166-1 alpha-2 region code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceLocation")]
		public string DeviceLocation { get; set; }
		
		/// <summary>
		/// Requests the lists for a specific language. Expects ISO 639 alpha-2 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Sets the maximum number of entries that the client is willing to have in the local database for the specified list. This should be a power of 2 between 2**10 and 2**20. If zero, no database size limit is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxDatabaseEntries")]
		public System.Nullable<System.Int32> MaxDatabaseEntries { get; set; }
		
		/// <summary>
		/// The maximum size in number of entries. The update will not contain more entries than this value. This should be a power of 2 between 2**10 and 2**20. If zero, no update size limit is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxUpdateEntries")]
		public System.Nullable<System.Int32> MaxUpdateEntries { get; set; }
		
		/// <summary>
		/// Requests the list for a specific geographic location. If not set the server may pick that value based on the user's IP address. Expects ISO 3166-1 alpha-2 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The compression types supported by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportedCompressions")]
		public string[] SupportedCompressions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestPlatformType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLATFORM_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WINDOWS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINUX = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANDROID = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OSX = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IOS = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY_PLATFORM = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_PLATFORMS = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHROME = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatEntryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREAT_ENTRY_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		URL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTABLE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP_RANGE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHROME_EXTENSION = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILENAME = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERT = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREAT_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MALWARE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOCIAL_ENGINEERING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNWANTED_SOFTWARE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POTENTIALLY_HARMFUL_APPLICATION = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOCIAL_ENGINEERING_INTERNAL = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_ABUSE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MALICIOUS_BINARY = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CSD_WHITELIST = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CSD_DOWNLOAD_WHITELIST = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_INCIDENT = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_INCIDENT_WHITELIST = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APK_MALWARE_OFFLINE = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUBRESOURCE_FILTER = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUSPICIOUS = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRICK_TO_BILL = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIGH_CONFIDENCE_ALLOWLIST = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCURACY_TIPS = 17,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponse
	{
		
		/// <summary>
		/// The list updates requested by the clients. The number of responses here may be less than the number of requests sent by clients. This is the case, for example, if the server has no updates for a particular list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listUpdateResponses")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponseListUpdateResponse[] ListUpdateResponses { get; set; }
		
		/// <summary>
		/// The minimum duration the client must wait before issuing any update request. If this field is not set clients may update as soon as they want.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumWaitDuration")]
		public string MinimumWaitDuration { get; set; }
	}
	
	/// <summary>
	/// An update to an individual list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponseListUpdateResponse
	{
		
		/// <summary>
		/// A set of entries to add to a local threat type's list. Repeated to allow for a combination of compressed and raw data to be sent in a single response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additions")]
		public GoogleSecuritySafebrowsingV4ThreatEntrySet[] Additions { get; set; }
		
		/// <summary>
		/// The expected state of a client's local database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checksum")]
		public GoogleSecuritySafebrowsingV4Checksum Checksum { get; set; }
		
		/// <summary>
		/// The new client state, in encrypted format. Opaque to clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newClientState")]
		public string NewClientState { get; set; }
		
		/// <summary>
		/// The platform type for which data is returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestPlatformType PlatformType { get; set; }
		
		/// <summary>
		/// A set of entries to remove from a local threat type's list. In practice, this field is empty or contains exactly one ThreatEntrySet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="removals")]
		public GoogleSecuritySafebrowsingV4ThreatEntrySet[] Removals { get; set; }
		
		/// <summary>
		/// The type of response. This may indicate that an action is required by the client when the response is received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseType")]
		public System.Nullable<GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponseListUpdateResponseResponseType> ResponseType { get; set; }
		
		/// <summary>
		/// The format of the threats.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatEntryType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatEntryType ThreatEntryType { get; set; }
		
		/// <summary>
		/// The threat type for which data is returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatType ThreatType { get; set; }
	}
	
	/// <summary>
	/// A set of threats that should be added or removed from a client's local database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatEntrySet
	{
		
		/// <summary>
		/// The compression type for the entries in this set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compressionType")]
		public System.Nullable<GoogleSecuritySafebrowsingV4ThreatEntrySetCompressionType> CompressionType { get; set; }
		
		/// <summary>
		/// The uncompressed threat entries in hash format of a particular prefix length. Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4 bytes, but some hashes are lengthened if they collide with the hash of a popular URL. Used for sending ThreatEntrySet to clients that do not support compression, or when sending non-4-byte hashes to clients that do support compression.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawHashes")]
		public GoogleSecuritySafebrowsingV4RawHashes RawHashes { get; set; }
		
		/// <summary>
		/// A set of raw indices to remove from a local list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawIndices")]
		public GoogleSecuritySafebrowsingV4RawIndices RawIndices { get; set; }
		
		/// <summary>
		/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or compressed removal indices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riceHashes")]
		public GoogleSecuritySafebrowsingV4RiceDeltaEncoding RiceHashes { get; set; }
		
		/// <summary>
		/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or compressed removal indices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riceIndices")]
		public GoogleSecuritySafebrowsingV4RiceDeltaEncoding RiceIndices { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GoogleSecuritySafebrowsingV4ThreatEntrySetCompressionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPRESSION_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RAW = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RICE = 2,
	}
	
	/// <summary>
	/// The uncompressed threat entries in hash format of a particular prefix length. Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4 bytes, but some hashes are lengthened if they collide with the hash of a popular URL. Used for sending ThreatEntrySet to clients that do not support compression, or when sending non-4-byte hashes to clients that do support compression.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4RawHashes
	{
		
		/// <summary>
		/// The number of bytes for each prefix encoded below. This field can be anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixSize")]
		public System.Nullable<System.Int32> PrefixSize { get; set; }
		
		/// <summary>
		/// The hashes, in binary format, concatenated into one long string. Hashes are sorted in lexicographic order. For JSON API users, hashes are base64-encoded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawHashes")]
		public string RawHashes { get; set; }
	}
	
	/// <summary>
	/// A set of raw indices to remove from a local list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4RawIndices
	{
		
		/// <summary>
		/// The indices to remove from a lexicographically-sorted local list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indices")]
		public int[] Indices { get; set; }
	}
	
	/// <summary>
	/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or compressed removal indices.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4RiceDeltaEncoding
	{
		
		/// <summary>
		/// The encoded deltas that are encoded using the Golomb-Rice coder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encodedData")]
		public string EncodedData { get; set; }
		
		/// <summary>
		/// The offset of the first entry in the encoded data, or, if only a single integer was encoded, that single integer's value. If the field is empty or missing, assume zero.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstValue")]
		public string FirstValue { get; set; }
		
		/// <summary>
		/// The number of entries that are delta encoded in the encoded data. If only a single integer was encoded, this will be zero and the single value will be stored in `first_value`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numEntries")]
		public System.Nullable<System.Int32> NumEntries { get; set; }
		
		/// <summary>
		/// The Golomb-Rice parameter, which is a number between 2 and 28. This field is missing (that is, zero) if `num_entries` is zero.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riceParameter")]
		public System.Nullable<System.Int32> RiceParameter { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponseListUpdateResponseResponseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESPONSE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTIAL_UPDATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_UPDATE = 2,
	}
	
	/// <summary>
	/// Request to return full hashes matched by the provided hash prefixes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FindFullHashesRequest
	{
		
		/// <summary>
		/// The client metadata associated with Safe Browsing API requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiClient")]
		public GoogleSecuritySafebrowsingV4ClientInfo ApiClient { get; set; }
		
		/// <summary>
		/// The client metadata associated with Safe Browsing API requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client")]
		public GoogleSecuritySafebrowsingV4ClientInfo Client { get; set; }
		
		/// <summary>
		/// The current client states for each of the client's local threat lists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientStates")]
		public string[] ClientStates { get; set; }
		
		/// <summary>
		/// The information regarding one or more threats that a client submits when checking for matches in threat lists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatInfo")]
		public GoogleSecuritySafebrowsingV4ThreatInfo ThreatInfo { get; set; }
	}
	
	/// <summary>
	/// The information regarding one or more threats that a client submits when checking for matches in threat lists.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatInfo
	{
		
		/// <summary>
		/// The platform types to be checked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformTypes")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestPlatformType[] PlatformTypes { get; set; }
		
		/// <summary>
		/// The threat entries to be checked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatEntries")]
		public GoogleSecuritySafebrowsingV4ThreatEntry[] ThreatEntries { get; set; }
		
		/// <summary>
		/// The entry types to be checked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatEntryTypes")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatEntryType[] ThreatEntryTypes { get; set; }
		
		/// <summary>
		/// The threat types to be checked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatTypes")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatType[] ThreatTypes { get; set; }
	}
	
	/// <summary>
	/// An individual threat; for example, a malicious URL or its hash representation. Only one of these fields should be set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatEntry
	{
		
		/// <summary>
		/// The digest of an executable in SHA256 format. The API supports both binary and hex digests. For JSON requests, digests are base64-encoded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		/// <summary>
		/// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256 hash. This field is in binary format. For JSON requests, hashes are base64-encoded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hash")]
		public string Hash { get; set; }
		
		/// <summary>
		/// A URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FindFullHashesResponse
	{
		
		/// <summary>
		/// The full hashes that matched the requested prefixes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public GoogleSecuritySafebrowsingV4ThreatMatch[] Matches { get; set; }
		
		/// <summary>
		/// The minimum duration the client must wait before issuing any find hashes request. If this field is not set, clients can issue a request as soon as they want.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumWaitDuration")]
		public string MinimumWaitDuration { get; set; }
		
		/// <summary>
		/// For requested entities that did not match the threat list, how long to cache the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="negativeCacheDuration")]
		public string NegativeCacheDuration { get; set; }
	}
	
	/// <summary>
	/// A match when checking a threat entry in the Safe Browsing threat lists.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatMatch
	{
		
		/// <summary>
		/// The cache lifetime for the returned match. Clients must not cache this response for more than this duration to avoid false positives.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheDuration")]
		public string CacheDuration { get; set; }
		
		/// <summary>
		/// The platform type matching this threat.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestPlatformType PlatformType { get; set; }
		
		/// <summary>
		/// An individual threat; for example, a malicious URL or its hash representation. Only one of these fields should be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threat")]
		public GoogleSecuritySafebrowsingV4ThreatEntry Threat { get; set; }
		
		/// <summary>
		/// The metadata associated with a specific threat entry. The client is expected to know the metadata key/value pairs associated with each threat type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatEntryMetadata")]
		public GoogleSecuritySafebrowsingV4ThreatEntryMetadata ThreatEntryMetadata { get; set; }
		
		/// <summary>
		/// The threat entry type matching this threat.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatEntryType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatEntryType ThreatEntryType { get; set; }
		
		/// <summary>
		/// The threat type matching this threat.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatType ThreatType { get; set; }
	}
	
	/// <summary>
	/// The metadata associated with a specific threat entry. The client is expected to know the metadata key/value pairs associated with each threat type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatEntryMetadata
	{
		
		/// <summary>
		/// The metadata entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public GoogleSecuritySafebrowsingV4ThreatEntryMetadataMetadataEntry[] Entries { get; set; }
	}
	
	/// <summary>
	/// A single metadata entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatEntryMetadataMetadataEntry
	{
		
		/// <summary>
		/// The metadata entry key. For JSON requests, the key is base64-encoded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The metadata entry value. For JSON requests, the value is base64-encoded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Request to check entries against lists.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FindThreatMatchesRequest
	{
		
		/// <summary>
		/// The client metadata associated with Safe Browsing API requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client")]
		public GoogleSecuritySafebrowsingV4ClientInfo Client { get; set; }
		
		/// <summary>
		/// The information regarding one or more threats that a client submits when checking for matches in threat lists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatInfo")]
		public GoogleSecuritySafebrowsingV4ThreatInfo ThreatInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4FindThreatMatchesResponse
	{
		
		/// <summary>
		/// The threat list matches.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public GoogleSecuritySafebrowsingV4ThreatMatch[] Matches { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ListThreatListsResponse
	{
		
		/// <summary>
		/// The lists available for download by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatLists")]
		public GoogleSecuritySafebrowsingV4ThreatListDescriptor[] ThreatLists { get; set; }
	}
	
	/// <summary>
	/// Describes an individual threat list. A list is defined by three parameters: the type of threat posed, the type of platform targeted by the threat, and the type of entries in the list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatListDescriptor
	{
		
		/// <summary>
		/// The platform type targeted by the list's entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestPlatformType PlatformType { get; set; }
		
		/// <summary>
		/// The entry types contained in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatEntryType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatEntryType ThreatEntryType { get; set; }
		
		/// <summary>
		/// The threat type posed by the list's entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatType ThreatType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatHit
	{
		
		/// <summary>
		/// The client metadata associated with Safe Browsing API requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientInfo")]
		public GoogleSecuritySafebrowsingV4ClientInfo ClientInfo { get; set; }
		
		/// <summary>
		/// An individual threat; for example, a malicious URL or its hash representation. Only one of these fields should be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entry")]
		public GoogleSecuritySafebrowsingV4ThreatEntry Entry { get; set; }
		
		/// <summary>
		/// The platform type reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestPlatformType PlatformType { get; set; }
		
		/// <summary>
		/// The resources related to the threat hit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public GoogleSecuritySafebrowsingV4ThreatHitThreatSource[] Resources { get; set; }
		
		/// <summary>
		/// The threat type reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatType")]
		public GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequestListUpdateRequestThreatType ThreatType { get; set; }
		
		/// <summary>
		/// Details about the user that encountered the threat.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userInfo")]
		public GoogleSecuritySafebrowsingV4ThreatHitUserInfo UserInfo { get; set; }
	}
	
	/// <summary>
	/// A single resource related to a threat hit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatHitThreatSource
	{
		
		/// <summary>
		/// Referrer of the resource. Only set if the referrer is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="referrer")]
		public string Referrer { get; set; }
		
		/// <summary>
		/// The remote IP of the resource in ASCII format. Either IPv4 or IPv6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteIp")]
		public string RemoteIp { get; set; }
		
		/// <summary>
		/// The type of source reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<GoogleSecuritySafebrowsingV4ThreatHitThreatSourceType> Type { get; set; }
		
		/// <summary>
		/// The URL of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GoogleSecuritySafebrowsingV4ThreatHitThreatSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREAT_SOURCE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATCHING_URL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAB_URL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAB_REDIRECT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAB_RESOURCE = 4,
	}
	
	/// <summary>
	/// Details about the user that encountered the threat.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GoogleSecuritySafebrowsingV4ThreatHitUserInfo
	{
		
		/// <summary>
		/// The UN M.49 region code associated with the user's location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regionCode")]
		public string RegionCode { get; set; }
		
		/// <summary>
		/// Unique user identifier defined by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Safebrowsing_encodedFullHashes_get v4/encodedFullHashes/{encodedRequest}
		/// </summary>
		/// <param name="encodedRequest">A serialized FindFullHashesRequest proto.</param>
		/// <param name="clientId">A client ID that (hopefully) uniquely identifies the client implementation of the Safe Browsing API.</param>
		/// <param name="clientVersion">The version of the client implementation.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleSecuritySafebrowsingV4FindFullHashesResponse> Safebrowsing_encodedFullHashes_getAsync(string encodedRequest, string clientId, string clientVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/encodedFullHashes/"+ (encodedRequest==null? "" : System.Uri.EscapeDataString(encodedRequest))+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"&clientVersion=" + (clientVersion==null? "" : System.Uri.EscapeDataString(clientVersion));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleSecuritySafebrowsingV4FindFullHashesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Safebrowsing_encodedUpdates_get v4/encodedUpdates/{encodedRequest}
		/// </summary>
		/// <param name="encodedRequest">A serialized FetchThreatListUpdatesRequest proto.</param>
		/// <param name="clientId">A client ID that uniquely identifies the client implementation of the Safe Browsing API.</param>
		/// <param name="clientVersion">The version of the client implementation.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponse> Safebrowsing_encodedUpdates_getAsync(string encodedRequest, string clientId, string clientVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/encodedUpdates/"+ (encodedRequest==null? "" : System.Uri.EscapeDataString(encodedRequest))+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"&clientVersion=" + (clientVersion==null? "" : System.Uri.EscapeDataString(clientVersion));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Finds the full hashes that match the requested hash prefixes.
		/// Safebrowsing_fullHashes_find v4/fullHashes:find
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<GoogleSecuritySafebrowsingV4FindFullHashesResponse> Safebrowsing_fullHashes_findAsync(GoogleSecuritySafebrowsingV4FindFullHashesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/fullHashes:find";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleSecuritySafebrowsingV4FindFullHashesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reports a Safe Browsing threat list hit to Google. Only projects with TRUSTED_REPORTER visibility can use this method.
		/// Safebrowsing_threatHits_create v4/threatHits
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<GoogleProtobufEmpty> Safebrowsing_threatHits_createAsync(GoogleSecuritySafebrowsingV4ThreatHit requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/threatHits";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleProtobufEmpty>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Fetches the most recent threat list updates. A client can request updates for multiple lists at once.
		/// Safebrowsing_threatListUpdates_fetch v4/threatListUpdates:fetch
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponse> Safebrowsing_threatListUpdates_fetchAsync(GoogleSecuritySafebrowsingV4FetchThreatListUpdatesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/threatListUpdates:fetch";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleSecuritySafebrowsingV4FetchThreatListUpdatesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the Safe Browsing threat lists available for download.
		/// Safebrowsing_threatLists_list v4/threatLists
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<GoogleSecuritySafebrowsingV4ListThreatListsResponse> Safebrowsing_threatLists_listAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/threatLists";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleSecuritySafebrowsingV4ListThreatListsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Finds the threat entries that match the Safe Browsing lists.
		/// Safebrowsing_threatMatches_find v4/threatMatches:find
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<GoogleSecuritySafebrowsingV4FindThreatMatchesResponse> Safebrowsing_threatMatches_findAsync(GoogleSecuritySafebrowsingV4FindThreatMatchesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v4/threatMatches:find";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleSecuritySafebrowsingV4FindThreatMatchesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
