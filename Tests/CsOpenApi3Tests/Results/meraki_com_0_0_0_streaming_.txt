//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateNetworkSmTargetGroupCreatenetworksmtargetgroup
	{
		
		/// <summary>
		/// The name of this target group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules
	{
		
		/// <summary>
		/// An ordered array of the firewall rules (not including the default rule)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules[] UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules { get; set; }
		
		/// <summary>
		/// Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogDefaultRule")]
		public System.Nullable<System.Boolean> SyslogDefaultRule { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogEnabled")]
		public System.Nullable<System.Boolean> SyslogEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		allow = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deny = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		icmp = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		icmp6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 4,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Returns live state from camera of analytics zones
		/// Returns live state from camera of analytics zones
		/// GetDeviceCameraAnalyticsLive devices/{serial}/camera/analytics/live
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraAnalyticsLiveAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/live";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an overview of aggregate analytics data for a timespan
		/// Returns an overview of aggregate analytics data for a timespan
		/// GetDeviceCameraAnalyticsOverview devices/{serial}/camera/analytics/overview
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour.</param>
		/// <param name="objectType">[optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraAnalyticsOverviewAsync(string serial, string t0, string t1, float timespan, GetDeviceCameraAnalyticsOverviewObjectType objectType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/overview&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&objectType=" + objectType;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns most recent record for analytics zones
		/// Returns most recent record for analytics zones
		/// GetDeviceCameraAnalyticsRecent devices/{serial}/camera/analytics/recent
		/// </summary>
		/// <param name="objectType">[optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraAnalyticsRecentAsync(string serial, GetDeviceCameraAnalyticsOverviewObjectType objectType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/recent&objectType=" + objectType;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all configured analytic zones for this camera
		/// Returns all configured analytic zones for this camera
		/// GetDeviceCameraAnalyticsZones devices/{serial}/camera/analytics/zones
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraAnalyticsZonesAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/zones";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return historical records for analytic zones
		/// Return historical records for analytic zones
		/// GetDeviceCameraAnalyticsZoneHistory devices/{serial}/camera/analytics/zones/{zoneId}/history
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 14 hours after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60.</param>
		/// <param name="objectType">[optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraAnalyticsZoneHistoryAsync(string serial, string zoneId, string t0, string t1, float timespan, int resolution, GetDeviceCameraAnalyticsOverviewObjectType objectType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/zones/"+ (zoneId==null? "" : System.Uri.EscapeDataString(zoneId))+"/history&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&objectType=" + objectType;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns video settings for the given camera
		/// Returns video settings for the given camera
		/// GetDeviceCameraVideoSettings devices/{serial}/camera/video/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraVideoSettingsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/video/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update video settings for the given camera
		/// Update video settings for the given camera
		/// UpdateDeviceCameraVideoSettings devices/{serial}/camera/video/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCameraVideoSettingsAsync(string serial, UpdateDeviceCameraVideoSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/video/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Show the LAN Settings of a MG
		/// Show the LAN Settings of a MG
		/// GetDeviceCellularGatewaySettings devices/{serial}/cellularGateway/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCellularGatewaySettingsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellularGateway/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the LAN Settings for a single MG.
		/// Update the LAN Settings for a single MG.
		/// UpdateDeviceCellularGatewaySettings devices/{serial}/cellularGateway/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCellularGatewaySettingsAsync(string serial, UpdateDeviceCellularGatewaySettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellularGateway/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the port forwarding rules for a single MG.
		/// Returns the port forwarding rules for a single MG.
		/// GetDeviceCellularGatewaySettingsPortForwardingRules devices/{serial}/cellularGateway/settings/portForwardingRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCellularGatewaySettingsPortForwardingRulesAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellularGateway/settings/portForwardingRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the port forwarding rules for a single MG.
		/// Updates the port forwarding rules for a single MG.
		/// UpdateDeviceCellularGatewaySettingsPortForwardingRules devices/{serial}/cellularGateway/settings/portForwardingRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCellularGatewaySettingsPortForwardingRulesAsync(string serial, UpdateDeviceCellularGatewaySettingsPortForwardingRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellularGateway/settings/portForwardingRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the clients of a device, up to a maximum of a month ago
		/// List the clients of a device, up to a maximum of a month ago. The usage of each client is returned in kilobytes. If the device is a switch, the switchport is returned; otherwise the switchport field is null.
		/// GetDeviceClients devices/{serial}/clients
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceClientsAsync(string serial, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/clients&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cycle a set of switch ports
		/// Cycle a set of switch ports
		/// CycleDeviceSwitchPorts devices/{serial}/switch/ports/cycle
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CycleDeviceSwitchPortsAsync(string serial, CycleDeviceSwitchPortsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/ports/cycle";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the status for all the ports of a switch
		/// Return the status for all the ports of a switch
		/// GetDeviceSwitchPortStatuses devices/{serial}/switchPortStatuses
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceSwitchPortStatusesAsync(string serial, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switchPortStatuses&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the packet counters for all the ports of a switch
		/// Return the packet counters for all the ports of a switch
		/// GetDeviceSwitchPortStatusesPackets devices/{serial}/switchPortStatuses/packets
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 1 day from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceSwitchPortStatusesPacketsAsync(string serial, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switchPortStatuses/packets&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the bluetooth settings for a wireless device
		/// Update the bluetooth settings for a wireless device
		/// UpdateDeviceWirelessBluetoothSettings devices/{serial}/wireless/bluetooth/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateDeviceWirelessBluetoothSettingsReturn> UpdateDeviceWirelessBluetoothSettingsAsync(string serial, UpdateDeviceWirelessBluetoothSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/bluetooth/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateDeviceWirelessBluetoothSettingsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a network
		/// Delete a network
		/// DeleteNetwork networks/{networkId}
		/// </summary>
		public async Task DeleteNetworkAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a network
		/// Return a network
		/// GetNetwork networks/{networkId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a network
		/// Update a network
		/// UpdateNetwork networks/{networkId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkAsync(string networkId, UpdateNetworkPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the access policies for this network
		/// List the access policies for this network. Only valid for MS networks.
		/// GetNetworkAccessPolicies networks/{networkId}/accessPolicies
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkAccessPoliciesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/accessPolicies";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List Air Marshal scan results from a network
		/// List Air Marshal scan results from a network
		/// GetNetworkAirMarshal networks/{networkId}/airMarshal
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkAirMarshalAsync(string networkId, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/airMarshal&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the alert configuration for this network
		/// Return the alert configuration for this network
		/// GetNetworkAlertSettings networks/{networkId}/alertSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkAlertSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/alertSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the alert configuration for this network
		/// Update the alert configuration for this network
		/// UpdateNetworkAlertSettings networks/{networkId}/alertSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkAlertSettingsAsync(string networkId, UpdateNetworkAlertSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/alertSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the inbound firewall rules for an MX network
		/// Return the inbound firewall rules for an MX network
		/// GetNetworkApplianceFirewallInboundFirewallRules networks/{networkId}/appliance/firewall/inboundFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallInboundFirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/inboundFirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the inbound firewall rules of an MX network
		/// Update the inbound firewall rules of an MX network
		/// UpdateNetworkApplianceFirewallInboundFirewallRules networks/{networkId}/appliance/firewall/inboundFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallInboundFirewallRulesAsync(string networkId, UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/inboundFirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List per-port VLAN settings for all ports of a MX.
		/// List per-port VLAN settings for all ports of a MX.
		/// GetNetworkAppliancePorts networks/{networkId}/appliancePorts
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkAppliancePortsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliancePorts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return per-port VLAN settings for a single MX port.
		/// Return per-port VLAN settings for a single MX port.
		/// GetNetworkAppliancePort networks/{networkId}/appliancePorts/{appliancePortId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkAppliancePortAsync(string networkId, string appliancePortId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliancePorts/"+ (appliancePortId==null? "" : System.Uri.EscapeDataString(appliancePortId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the per-port VLAN settings for a single MX port.
		/// Update the per-port VLAN settings for a single MX port.
		/// UpdateNetworkAppliancePort networks/{networkId}/appliancePorts/{appliancePortId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkAppliancePortAsync(string networkId, string appliancePortId, UpdateNetworkAppliancePortPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliancePorts/"+ (appliancePortId==null? "" : System.Uri.EscapeDataString(appliancePortId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Bind a network to a template.
		/// Bind a network to a template.
		/// BindNetwork networks/{networkId}/bind
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task BindNetworkAsync(string networkId, BindNetworkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/bind";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the Bluetooth clients seen by APs in this network
		/// List the Bluetooth clients seen by APs in this network
		/// GetNetworkBluetoothClients networks/{networkId}/bluetoothClients
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 7 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="includeConnectivityHistory">Include the connectivity history for this client</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkBluetoothClientsAsync(string networkId, string t0, float timespan, int perPage, string startingAfter, string endingBefore, bool includeConnectivityHistory, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/bluetoothClients&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&includeConnectivityHistory="+includeConnectivityHistory;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a Bluetooth client
		/// Return a Bluetooth client. Bluetooth clients can be identified by their ID or their MAC.
		/// GetNetworkBluetoothClient networks/{networkId}/bluetoothClients/{bluetoothClientId}
		/// </summary>
		/// <param name="includeConnectivityHistory">Include the connectivity history for this client</param>
		/// <param name="connectivityHistoryTimespan">The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkBluetoothClientAsync(string networkId, string bluetoothClientId, bool includeConnectivityHistory, int connectivityHistoryTimespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/bluetoothClients/"+ (bluetoothClientId==null? "" : System.Uri.EscapeDataString(bluetoothClientId))+"&includeConnectivityHistory="+includeConnectivityHistory+"&connectivityHistoryTimespan="+connectivityHistoryTimespan;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the Bluetooth settings for a network. <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the network.
		/// Return the Bluetooth settings for a network. <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the network.
		/// GetNetworkBluetoothSettings networks/{networkId}/bluetoothSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkBluetoothSettingsReturn> GetNetworkBluetoothSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/bluetoothSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetNetworkBluetoothSettingsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the Bluetooth settings for a network
		/// Update the Bluetooth settings for a network. See the docs page for <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a>.
		/// UpdateNetworkBluetoothSettings networks/{networkId}/bluetoothSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkBluetoothSettingsReturn> UpdateNetworkBluetoothSettingsAsync(string networkId, UpdateNetworkBluetoothSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/bluetoothSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateNetworkBluetoothSettingsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the quality retention profiles for this network
		/// List the quality retention profiles for this network
		/// GetNetworkCameraQualityRetentionProfiles networks/{networkId}/camera/qualityRetentionProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkCameraQualityRetentionProfilesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates new quality retention profile for this network.
		/// Creates new quality retention profile for this network.
		/// CreateNetworkCameraQualityRetentionProfile networks/{networkId}/camera/qualityRetentionProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CreateNetworkCameraQualityRetentionProfileAsync(string networkId, CreateNetworkCameraQualityRetentionProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an existing quality retention profile for this network.
		/// Delete an existing quality retention profile for this network.
		/// DeleteNetworkCameraQualityRetentionProfile networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		/// </summary>
		public async Task DeleteNetworkCameraQualityRetentionProfileAsync(string networkId, string qualityRetentionProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles/"+ (qualityRetentionProfileId==null? "" : System.Uri.EscapeDataString(qualityRetentionProfileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a single quality retention profile
		/// Retrieve a single quality retention profile
		/// GetNetworkCameraQualityRetentionProfile networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkCameraQualityRetentionProfileAsync(string networkId, string qualityRetentionProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles/"+ (qualityRetentionProfileId==null? "" : System.Uri.EscapeDataString(qualityRetentionProfileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing quality retention profile for this network.
		/// Update an existing quality retention profile for this network.
		/// UpdateNetworkCameraQualityRetentionProfile networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkCameraQualityRetentionProfileAsync(string networkId, string qualityRetentionProfileId, UpdateNetworkCameraQualityRetentionProfilePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles/"+ (qualityRetentionProfileId==null? "" : System.Uri.EscapeDataString(qualityRetentionProfileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of all camera recording schedules.
		/// Returns a list of all camera recording schedules.
		/// GetNetworkCameraSchedules networks/{networkId}/camera/schedules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkCameraSchedulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/schedules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Generate a snapshot of what the camera sees at the specified time and return a link to that image.
		/// Generate a snapshot of what the camera sees at the specified time and return a link to that image.
		/// GenerateNetworkCameraSnapshot networks/{networkId}/cameras/{serial}/snapshot
		/// </summary>
		public async Task GenerateNetworkCameraSnapshotAsync(string networkId, string serial, GenerateNetworkCameraSnapshotPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cameras/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/snapshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns video link to the specified camera
		/// Returns video link to the specified camera. If a timestamp is supplied, it links to that timestamp.
		/// GetNetworkCameraVideoLink networks/{networkId}/cameras/{serial}/videoLink
		/// </summary>
		/// <param name="timestamp">[optional] The video link will start at this timestamp. The timestamp is in UNIX Epoch time (milliseconds). If no timestamp is specified, we will assume current time.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkCameraVideoLinkAsync(string networkId, string serial, string timestamp, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cameras/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/videoLink&timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the cellular firewall rules for an MX network
		/// Return the cellular firewall rules for an MX network
		/// GetNetworkCellularFirewallRules networks/{networkId}/cellularFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkCellularFirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularFirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the cellular firewall rules of an MX network
		/// Update the cellular firewall rules of an MX network
		/// UpdateNetworkCellularFirewallRules networks/{networkId}/cellularFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> UpdateNetworkCellularFirewallRulesAsync(string networkId, UpdateNetworkCellularFirewallRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularFirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the clients that have used this network in the timespan
		/// List the clients that have used this network in the timespan
		/// GetNetworkClients networks/{networkId}/clients
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkClientsReturn> GetNetworkClientsAsync(string networkId, string t0, float timespan, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetNetworkClientsReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for this network, grouped by clients
		/// Aggregated connectivity info for this network, grouped by clients
		/// GetNetworkClientsConnectionStats networks/{networkId}/clients/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientsConnectionStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkClientsConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregated latency info for this network, grouped by clients
		/// Aggregated latency info for this network, grouped by clients
		/// GetNetworkClientsLatencyStats networks/{networkId}/clients/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientsLatencyStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkClientsLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Provisions a client with a name and policy
		/// Provisions a client with a name and policy. Clients can be provisioned before they associate to the network.
		/// ProvisionNetworkClients networks/{networkId}/clients/provision
		/// </summary>
		public async Task ProvisionNetworkClientsAsync(string networkId, ProvisionNetworkClientsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/provision";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the client associated with the given identifier
		/// Return the client associated with the given identifier. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClient networks/{networkId}/clients/{clientId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkClientAsync(string networkId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for a given client on this network
		/// Aggregated connectivity info for a given client on this network. Clients are identified by their MAC.
		/// GetNetworkClientConnectionStats networks/{networkId}/clients/{clientId}/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkClientConnectionStatsAsync(string networkId, string clientId, string t0, string t1, float timespan, GetNetworkClientConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the events associated with this client
		/// Return the events associated with this client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClientEvents networks/{networkId}/clients/{clientId}/events
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 100. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientEventsAsync(string networkId, string clientId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/events&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the latency history for a client
		/// Return the latency history for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP. The latency data is from a sample of 2% of packets and is grouped into 4 traffic categories: background, best effort, video, voice. Within these categories the sampled packet counters are bucketed by latency in milliseconds.
		/// GetNetworkClientLatencyHistory networks/{networkId}/clients/{clientId}/latencyHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 791 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 791 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientLatencyHistoryAsync(string networkId, string clientId, string t0, string t1, float timespan, int resolution, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/latencyHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregated latency info for a given client on this network
		/// Aggregated latency info for a given client on this network. Clients are identified by their MAC.
		/// GetNetworkClientLatencyStats networks/{networkId}/clients/{clientId}/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkClientLatencyStatsAsync(string networkId, string clientId, string t0, string t1, float timespan, GetNetworkClientLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the policy assigned to a client on the network
		/// Return the policy assigned to a client on the network. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClientPolicy networks/{networkId}/clients/{clientId}/policy
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkClientPolicyAsync(string networkId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the policy assigned to a client on the network
		/// Update the policy assigned to a client on the network. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// UpdateNetworkClientPolicy networks/{networkId}/clients/{clientId}/policy
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkClientPolicyAsync(string networkId, string clientId, UpdateNetworkClientPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the splash authorization for a client, for each SSID they've associated with through splash
		/// Return the splash authorization for a client, for each SSID they've associated with through splash. Only enabled SSIDs with Click-through splash enabled will be included. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClientSplashAuthorizationStatus networks/{networkId}/clients/{clientId}/splashAuthorizationStatus
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkClientSplashAuthorizationStatusAsync(string networkId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/splashAuthorizationStatus";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a client's splash authorization
		/// Update a client's splash authorization. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// UpdateNetworkClientSplashAuthorizationStatus networks/{networkId}/clients/{clientId}/splashAuthorizationStatus
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkClientSplashAuthorizationStatusAsync(string networkId, string clientId, UpdateNetworkClientSplashAuthorizationStatusPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/splashAuthorizationStatus";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the client's daily usage history
		/// Return the client's daily usage history. Usage data is in kilobytes. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClientUsageHistory networks/{networkId}/clients/{clientId}/usageHistory
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientUsageHistoryAsync(string networkId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/usageHistory";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for this network
		/// Aggregated connectivity info for this network
		/// GetNetworkConnectionStats networks/{networkId}/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkConnectionStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the content filtering settings for an MX network
		/// Return the content filtering settings for an MX network
		/// GetNetworkContentFiltering networks/{networkId}/contentFiltering
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkContentFilteringAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/contentFiltering";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the content filtering settings for an MX network
		/// Update the content filtering settings for an MX network
		/// UpdateNetworkContentFiltering networks/{networkId}/contentFiltering
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkContentFilteringAsync(string networkId, UpdateNetworkContentFilteringPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/contentFiltering";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List all available content filtering categories for an MX network
		/// List all available content filtering categories for an MX network
		/// GetNetworkContentFilteringCategories networks/{networkId}/contentFiltering/categories
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkContentFilteringCategoriesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/contentFiltering/categories";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the devices in a network
		/// List the devices in a network
		/// GetNetworkDevices networks/{networkId}/devices
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkDevicesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
		/// Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
		/// ClaimNetworkDevices networks/{networkId}/devices/claim
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task ClaimNetworkDevicesAsync(string networkId, ClaimNetworkDevicesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/claim";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for this network, grouped by node
		/// Aggregated connectivity info for this network, grouped by node
		/// GetNetworkDevicesConnectionStats networks/{networkId}/devices/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkDevicesConnectionStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkDevicesConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregated latency info for this network, grouped by node
		/// Aggregated latency info for this network, grouped by node
		/// GetNetworkDevicesLatencyStats networks/{networkId}/devices/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkDevicesLatencyStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkDevicesLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a single device
		/// Return a single device
		/// GetNetworkDevice networks/{networkId}/devices/{serial}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkDeviceAsync(string networkId, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the attributes of a device
		/// Update the attributes of a device
		/// UpdateNetworkDevice networks/{networkId}/devices/{serial}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkDeviceAsync(string networkId, string serial, UpdateNetworkDevicePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for a given AP on this network
		/// Aggregated connectivity info for a given AP on this network
		/// GetNetworkDeviceConnectionStats networks/{networkId}/devices/{serial}/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkDeviceConnectionStatsAsync(string networkId, string serial, string t0, string t1, float timespan, GetNetworkDeviceConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregated latency info for a given AP on this network
		/// Aggregated latency info for a given AP on this network
		/// GetNetworkDeviceLatencyStats networks/{networkId}/devices/{serial}/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkDeviceLatencyStatsAsync(string networkId, string serial, string t0, string t1, float timespan, GetNetworkDeviceLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the uplink loss percentage and latency in milliseconds for a wired network device.
		/// Get the uplink loss percentage and latency in milliseconds for a wired network device.
		/// GetNetworkDeviceLossAndLatencyHistory networks/{networkId}/devices/{serial}/lossAndLatencyHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 60 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60.</param>
		/// <param name="uplink">The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1.</param>
		/// <param name="ip">The destination IP used to obtain the requested stats. This is required.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkDeviceLossAndLatencyHistoryAsync(string networkId, string serial, string t0, string t1, float timespan, int resolution, GetNetworkDeviceLossAndLatencyHistoryUplink uplink, string ip, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/lossAndLatencyHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&uplink=" + uplink+"&ip=" + (ip==null? "" : System.Uri.EscapeDataString(ip));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the performance score for a single MX
		/// Return the performance score for a single MX. Only primary MX devices supported. If no data is available, a 204 error code is returned.
		/// GetNetworkDevicePerformance networks/{networkId}/devices/{serial}/performance
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkDevicePerformanceAsync(string networkId, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/performance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reboot a device
		/// Reboot a device
		/// RebootNetworkDevice networks/{networkId}/devices/{serial}/reboot
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> RebootNetworkDeviceAsync(string networkId, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/reboot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a single device
		/// Remove a single device
		/// RemoveNetworkDevice networks/{networkId}/devices/{serial}/remove
		/// </summary>
		public async Task RemoveNetworkDeviceAsync(string networkId, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/remove";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the uplink information for a device.
		/// Return the uplink information for a device.
		/// GetNetworkDeviceUplink networks/{networkId}/devices/{serial}/uplink
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkDeviceUplinkAsync(string networkId, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/uplink";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the SSID statuses of an access point
		/// Return the SSID statuses of an access point
		/// GetNetworkDeviceWirelessStatus networks/{networkId}/devices/{serial}/wireless/status
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkDeviceWirelessStatusAsync(string networkId, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the events for the network
		/// List the events for the network
		/// GetNetworkEvents networks/{networkId}/events
		/// </summary>
		/// <param name="productType">The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental</param>
		/// <param name="includedEventTypes">A list of event types. The returned events will be filtered to only include events with these types.</param>
		/// <param name="excludedEventTypes">A list of event types. The returned events will be filtered to exclude events with these types.</param>
		/// <param name="deviceMac">The MAC address of the Meraki device which the list of events will be filtered with</param>
		/// <param name="deviceSerial">The serial of the Meraki device which the list of events will be filtered with</param>
		/// <param name="deviceName">The name of the Meraki device which the list of events will be filtered with</param>
		/// <param name="clientIp">The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks.</param>
		/// <param name="clientMac">The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks.</param>
		/// <param name="clientName">The name, or partial name, of the client which the list of events will be filtered with</param>
		/// <param name="smDeviceMac">The MAC address of the Systems Manager device which the list of events will be filtered with</param>
		/// <param name="smDeviceName">The name of the Systems Manager device which the list of events will be filtered with</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkEventsAsync(
					string networkId, 
					string productType, 
					string[] includedEventTypes, 
					string[] excludedEventTypes, 
					string deviceMac, 
					string deviceSerial, 
					string deviceName, 
					string clientIp, 
					string clientMac, 
					string clientName, 
					string smDeviceMac, 
					string smDeviceName, 
					int perPage, 
					string startingAfter, 
					string endingBefore, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/events&productType=" + (productType==null? "" : System.Uri.EscapeDataString(productType))+"&"+string.Join("&", includedEventTypes.Select(z => $"includedEventTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", excludedEventTypes.Select(z => $"excludedEventTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&deviceMac=" + (deviceMac==null? "" : System.Uri.EscapeDataString(deviceMac))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&deviceName=" + (deviceName==null? "" : System.Uri.EscapeDataString(deviceName))+"&clientIp=" + (clientIp==null? "" : System.Uri.EscapeDataString(clientIp))+"&clientMac=" + (clientMac==null? "" : System.Uri.EscapeDataString(clientMac))+"&clientName=" + (clientName==null? "" : System.Uri.EscapeDataString(clientName))+"&smDeviceMac=" + (smDeviceMac==null? "" : System.Uri.EscapeDataString(smDeviceMac))+"&smDeviceName=" + (smDeviceName==null? "" : System.Uri.EscapeDataString(smDeviceName))+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the event type to human-readable description
		/// List the event type to human-readable description
		/// GetNetworkEventsEventTypes networks/{networkId}/events/eventTypes
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkEventsEventTypesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/events/eventTypes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List of all failed client connection events on this network in a given time range
		/// List of all failed client connection events on this network in a given time range
		/// GetNetworkFailedConnections networks/{networkId}/failedConnections
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="serial">Filter by AP</param>
		/// <param name="clientId">Filter by client MAC</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkFailedConnectionsAsync(string networkId, string t0, string t1, float timespan, GetNetworkFailedConnectionsBand band, int ssid, int vlan, string apTag, string serial, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/failedConnections&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the appliance services and their accessibility rules
		/// List the appliance services and their accessibility rules
		/// GetNetworkFirewalledServices networks/{networkId}/firewalledServices
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkFirewalledServicesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firewalledServices";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')
		/// Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')
		/// GetNetworkFirewalledService networks/{networkId}/firewalledServices/{service}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkFirewalledServiceAsync(string networkId, string service, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firewalledServices/"+ (service==null? "" : System.Uri.EscapeDataString(service));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the floor plans that belong to your network
		/// List the floor plans that belong to your network
		/// GetNetworkFloorPlans networks/{networkId}/floorPlans
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkFloorPlansAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Upload a floor plan
		/// Upload a floor plan
		/// CreateNetworkFloorPlan networks/{networkId}/floorPlans
		/// </summary>
		public async Task CreateNetworkFloorPlanAsync(string networkId, CreateNetworkFloorPlanPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Destroy a floor plan
		/// Destroy a floor plan
		/// DeleteNetworkFloorPlan networks/{networkId}/floorPlans/{floorPlanId}
		/// </summary>
		public async Task DeleteNetworkFloorPlanAsync(string networkId, string floorPlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans/"+ (floorPlanId==null? "" : System.Uri.EscapeDataString(floorPlanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Find a floor plan by ID
		/// Find a floor plan by ID
		/// GetNetworkFloorPlan networks/{networkId}/floorPlans/{floorPlanId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkFloorPlanAsync(string networkId, string floorPlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans/"+ (floorPlanId==null? "" : System.Uri.EscapeDataString(floorPlanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a floor plan's geolocation and other meta data
		/// Update a floor plan's geolocation and other meta data
		/// UpdateNetworkFloorPlan networks/{networkId}/floorPlans/{floorPlanId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkFloorPlanAsync(string networkId, string floorPlanId, UpdateNetworkFloorPlanPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans/"+ (floorPlanId==null? "" : System.Uri.EscapeDataString(floorPlanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the L3 firewall rules for an MX network
		/// Return the L3 firewall rules for an MX network
		/// GetNetworkL3FirewallRules networks/{networkId}/l3FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkL3FirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/l3FirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the L3 firewall rules of an MX network
		/// Update the L3 firewall rules of an MX network
		/// UpdateNetworkL3FirewallRules networks/{networkId}/l3FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> UpdateNetworkL3FirewallRulesAsync(string networkId, UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/l3FirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the MX L7 firewall rules for an MX network
		/// List the MX L7 firewall rules for an MX network
		/// GetNetworkL7FirewallRules networks/{networkId}/l7FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkL7FirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/l7FirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the MX L7 firewall rules for an MX network
		/// Update the MX L7 firewall rules for an MX network
		/// UpdateNetworkL7FirewallRules networks/{networkId}/l7FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkL7FirewallRulesAsync(string networkId, UpdateNetworkL7FirewallRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/l7FirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the L7 firewall application categories and their associated applications for an MX network
		/// Return the L7 firewall application categories and their associated applications for an MX network
		/// GetNetworkL7FirewallRulesApplicationCategories networks/{networkId}/l7FirewallRules/applicationCategories
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkL7FirewallRulesApplicationCategoriesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/l7FirewallRules/applicationCategories";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregated latency info for this network
		/// Aggregated latency info for this network
		/// GetNetworkLatencyStats networks/{networkId}/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4' or '5'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkLatencyStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the splash or RADIUS users configured under Meraki Authentication for a network
		/// List the splash or RADIUS users configured under Meraki Authentication for a network
		/// GetNetworkMerakiAuthUsers networks/{networkId}/merakiAuthUsers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkMerakiAuthUsersAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/merakiAuthUsers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the Meraki Auth splash or RADIUS user
		/// Return the Meraki Auth splash or RADIUS user
		/// GetNetworkMerakiAuthUser networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkMerakiAuthUserAsync(string networkId, string merakiAuthUserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/merakiAuthUsers/"+ (merakiAuthUserId==null? "" : System.Uri.EscapeDataString(merakiAuthUserId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the 1:Many NAT mapping rules for an MX network
		/// Return the 1:Many NAT mapping rules for an MX network
		/// GetNetworkOneToManyNatRules networks/{networkId}/oneToManyNatRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkOneToManyNatRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/oneToManyNatRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the 1:Many NAT mapping rules for an MX network
		/// Set the 1:Many NAT mapping rules for an MX network
		/// UpdateNetworkOneToManyNatRules networks/{networkId}/oneToManyNatRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkOneToManyNatRulesAsync(string networkId, UpdateNetworkOneToManyNatRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/oneToManyNatRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the 1:1 NAT mapping rules for an MX network
		/// Return the 1:1 NAT mapping rules for an MX network
		/// GetNetworkOneToOneNatRules networks/{networkId}/oneToOneNatRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkOneToOneNatRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/oneToOneNatRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the 1:1 NAT mapping rules for an MX network
		/// Set the 1:1 NAT mapping rules for an MX network
		/// UpdateNetworkOneToOneNatRules networks/{networkId}/oneToOneNatRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkOneToOneNatRulesAsync(string networkId, UpdateNetworkOneToOneNatRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/oneToOneNatRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the keys required to access Personally Identifiable Information (PII) for a given identifier
		/// List the keys required to access Personally Identifiable Information (PII) for a given identifier. Exactly one identifier will be accepted. If the organization contains org-wide Systems Manager users matching the key provided then there will be an entry with the key "0" containing the applicable keys.
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/piiKeys
		/// ```
		/// GetNetworkPiiPiiKeys networks/{networkId}/pii/piiKeys
		/// </summary>
		/// <param name="username">The username of a Systems Manager user</param>
		/// <param name="email">The email of a network user account or a Systems Manager device</param>
		/// <param name="mac">The MAC of a network client device or a Systems Manager device</param>
		/// <param name="serial">The serial of a Systems Manager device</param>
		/// <param name="imei">The IMEI of a Systems Manager device</param>
		/// <param name="bluetoothMac">The MAC of a Bluetooth client</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPiiPiiKeysAsync(string networkId, string username, string email, string mac, string serial, string imei, string bluetoothMac, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/piiKeys&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&email=" + (email==null? "" : System.Uri.EscapeDataString(email))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&imei=" + (imei==null? "" : System.Uri.EscapeDataString(imei))+"&bluetoothMac=" + (bluetoothMac==null? "" : System.Uri.EscapeDataString(bluetoothMac));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the PII requests for this network or organization
		/// List the PII requests for this network or organization
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/requests
		/// ```
		/// GetNetworkPiiRequests networks/{networkId}/pii/requests
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkPiiRequestsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/requests";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Submit a new delete or restrict processing PII request
		/// Submit a new delete or restrict processing PII request
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/requests
		/// ```
		/// CreateNetworkPiiRequest networks/{networkId}/pii/requests
		/// </summary>
		public async Task CreateNetworkPiiRequestAsync(string networkId, CreateNetworkPiiRequestPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/requests";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a restrict processing PII request
		/// Delete a restrict processing PII request
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/requests/{requestId}
		/// ```
		/// DeleteNetworkPiiRequest networks/{networkId}/pii/requests/{requestId}
		/// </summary>
		public async Task DeleteNetworkPiiRequestAsync(string networkId, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/requests/"+ (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a PII request
		/// Return a PII request
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/requests/{requestId}
		/// ```
		/// GetNetworkPiiRequest networks/{networkId}/pii/requests/{requestId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPiiRequestAsync(string networkId, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/requests/"+ (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier
		/// Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier. These device IDs can be used with the Systems Manager API endpoints to retrieve device details. Exactly one identifier will be accepted.
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/smDevicesForKey
		/// ```
		/// GetNetworkPiiSmDevicesForKey networks/{networkId}/pii/smDevicesForKey
		/// </summary>
		/// <param name="username">The username of a Systems Manager user</param>
		/// <param name="email">The email of a network user account or a Systems Manager device</param>
		/// <param name="mac">The MAC of a network client device or a Systems Manager device</param>
		/// <param name="serial">The serial of a Systems Manager device</param>
		/// <param name="imei">The IMEI of a Systems Manager device</param>
		/// <param name="bluetoothMac">The MAC of a Bluetooth client</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPiiSmDevicesForKeyAsync(string networkId, string username, string email, string mac, string serial, string imei, string bluetoothMac, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/smDevicesForKey&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&email=" + (email==null? "" : System.Uri.EscapeDataString(email))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&imei=" + (imei==null? "" : System.Uri.EscapeDataString(imei))+"&bluetoothMac=" + (bluetoothMac==null? "" : System.Uri.EscapeDataString(bluetoothMac));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier
		/// Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier. These owner IDs can be used with the Systems Manager API endpoints to retrieve owner details. Exactly one identifier will be accepted.
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/smOwnersForKey
		/// ```
		/// GetNetworkPiiSmOwnersForKey networks/{networkId}/pii/smOwnersForKey
		/// </summary>
		/// <param name="username">The username of a Systems Manager user</param>
		/// <param name="email">The email of a network user account or a Systems Manager device</param>
		/// <param name="mac">The MAC of a network client device or a Systems Manager device</param>
		/// <param name="serial">The serial of a Systems Manager device</param>
		/// <param name="imei">The IMEI of a Systems Manager device</param>
		/// <param name="bluetoothMac">The MAC of a Bluetooth client</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPiiSmOwnersForKeyAsync(string networkId, string username, string email, string mac, string serial, string imei, string bluetoothMac, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/smOwnersForKey&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&email=" + (email==null? "" : System.Uri.EscapeDataString(email))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&imei=" + (imei==null? "" : System.Uri.EscapeDataString(imei))+"&bluetoothMac=" + (bluetoothMac==null? "" : System.Uri.EscapeDataString(bluetoothMac));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the port forwarding rules for an MX network
		/// Return the port forwarding rules for an MX network
		/// GetNetworkPortForwardingRules networks/{networkId}/portForwardingRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPortForwardingRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/portForwardingRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the port forwarding rules for an MX network
		/// Update the port forwarding rules for an MX network
		/// UpdateNetworkPortForwardingRules networks/{networkId}/portForwardingRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkPortForwardingRulesAsync(string networkId, UpdateNetworkPortForwardingRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/portForwardingRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all supported intrusion settings for an MX network
		/// Returns all supported intrusion settings for an MX network
		/// GetNetworkSecurityIntrusionSettings networks/{networkId}/security/intrusionSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSecurityIntrusionSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/security/intrusionSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the supported intrusion settings for an MX network
		/// Set the supported intrusion settings for an MX network
		/// UpdateNetworkSecurityIntrusionSettings networks/{networkId}/security/intrusionSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSecurityIntrusionSettingsAsync(string networkId, UpdateNetworkSecurityIntrusionSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/security/intrusionSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all supported malware settings for an MX network
		/// Returns all supported malware settings for an MX network
		/// GetNetworkSecurityMalwareSettings networks/{networkId}/security/malwareSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSecurityMalwareSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/security/malwareSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set the supported malware settings for an MX network
		/// Set the supported malware settings for an MX network
		/// UpdateNetworkSecurityMalwareSettings networks/{networkId}/security/malwareSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSecurityMalwareSettingsAsync(string networkId, UpdateNetworkSecurityMalwareSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/security/malwareSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the security events (intrusion detection only) for a network
		/// List the security events (intrusion detection only) for a network
		/// GetNetworkSecurityEvents networks/{networkId}/securityEvents
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 365 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSecurityEventsAsync(string networkId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/securityEvents&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the site-to-site VPN settings of a network
		/// Return the site-to-site VPN settings of a network. Only valid for MX networks.
		/// GetNetworkSiteToSiteVpn networks/{networkId}/siteToSiteVpn
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSiteToSiteVpnAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/siteToSiteVpn";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the site-to-site VPN settings of a network
		/// Update the site-to-site VPN settings of a network. Only valid for MX networks in NAT mode.
		/// UpdateNetworkSiteToSiteVpn networks/{networkId}/siteToSiteVpn
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSiteToSiteVpnAsync(string networkId, UpdateNetworkSiteToSiteVpnPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/siteToSiteVpn";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Bypass activation lock attempt
		/// Bypass activation lock attempt
		/// CreateNetworkSmBypassActivationLockAttempt networks/{networkId}/sm/bypassActivationLockAttempts
		/// </summary>
		public async Task CreateNetworkSmBypassActivationLockAttemptAsync(string networkId, CreateNetworkSmBypassActivationLockAttemptPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/bypassActivationLockAttempts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Bypass activation lock attempt status
		/// Bypass activation lock attempt status
		/// GetNetworkSmBypassActivationLockAttempt networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSmBypassActivationLockAttemptAsync(string networkId, string attemptId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/bypassActivationLockAttempts/"+ (attemptId==null? "" : System.Uri.EscapeDataString(attemptId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify the fields of a device
		/// Modify the fields of a device
		/// UpdateNetworkSmDeviceFields networks/{networkId}/sm/device/fields
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSmDeviceFieldsAsync(string networkId, UpdateNetworkSmDeviceFieldsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/device/fields";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Wipe a device
		/// Wipe a device
		/// WipeNetworkSmDevice networks/{networkId}/sm/device/wipe
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> WipeNetworkSmDeviceAsync(string networkId, WipeNetworkSmDevicePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/device/wipe";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Refresh the details of a device
		/// Refresh the details of a device
		/// RefreshNetworkSmDeviceDetails networks/{networkId}/sm/device/{deviceId}/refreshDetails
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task RefreshNetworkSmDeviceDetailsAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/device/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/refreshDetails";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the devices enrolled in an SM network with various specified fields and filters
		/// List the devices enrolled in an SM network with various specified fields and filters
		/// GetNetworkSmDevices networks/{networkId}/sm/devices
		/// </summary>
		/// <param name="fields">Additional fields that will be displayed for each device. Multiple fields can be passed in as comma separated values.
		///    The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,
		///    systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,
		///    ownerEmail, ownerUsername, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,
		///    simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,
		///    isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,
		///    hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, and androidSecurityPatchVersion.</param>
		/// <param name="wifiMacs">Filter devices by wifi mac(s). Multiple wifi macs can be passed in as comma separated values.</param>
		/// <param name="serials">Filter devices by serial(s). Multiple serials can be passed in as comma separated values.</param>
		/// <param name="ids">Filter devices by id(s). Multiple ids can be passed in as comma separated values.</param>
		/// <param name="scope">Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags as comma separated values.</param>
		/// <param name="batchSize">Number of devices to return, 1000 is the default as well as the max.</param>
		/// <param name="batchToken">If the network has more devices than the batch size, a batch token will be returned
		///    as a part of the device list. To see the remainder of the devices, pass in the batchToken as a parameter in the next request.
		///    Requests made with the batchToken do not require additional parameters as the batchToken includes the parameters passed in
		///    with the original request. Additional parameters passed in with the batchToken will be ignored.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSmDevicesAsync(string networkId, string fields, string wifiMacs, string serials, string ids, string scope, int batchSize, string batchToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&wifiMacs=" + (wifiMacs==null? "" : System.Uri.EscapeDataString(wifiMacs))+"&serials=" + (serials==null? "" : System.Uri.EscapeDataString(serials))+"&ids=" + (ids==null? "" : System.Uri.EscapeDataString(ids))+"&scope=" + (scope==null? "" : System.Uri.EscapeDataString(scope))+"&batchSize="+batchSize+"&batchToken=" + (batchToken==null? "" : System.Uri.EscapeDataString(batchToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add, delete, or update the tags of a set of devices
		/// Add, delete, or update the tags of a set of devices
		/// UpdateNetworkSmDevicesTags networks/{networkId}/sm/devices/tags
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSmDevicesTagsAsync(string networkId, UpdateNetworkSmDevicesTagsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/tags";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Unenroll a device
		/// Unenroll a device
		/// UnenrollNetworkSmDevice networks/{networkId}/sm/devices/{deviceId}/unenroll
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UnenrollNetworkSmDeviceAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/unenroll";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all the profiles in the network
		/// List all the profiles in the network
		/// GetNetworkSmProfiles networks/{networkId}/sm/profiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSmProfilesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/profiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the target groups in this network
		/// List the target groups in this network
		/// GetNetworkSmTargetGroups networks/{networkId}/sm/targetGroups
		/// </summary>
		/// <param name="withDetails">Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmTargetGroupsAsync(string networkId, bool withDetails, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups&withDetails="+withDetails;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a target group
		/// Add a target group
		/// CreateNetworkSmTargetGroup networks/{networkId}/sm/targetGroups
		/// </summary>
		public async Task CreateNetworkSmTargetGroupAsync(string networkId, CreateNetworkSmTargetGroupCreatenetworksmtargetgroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a target group from a network
		/// Delete a target group from a network
		/// DeleteNetworkSmTargetGroup networks/{networkId}/sm/targetGroups/{targetGroupId}
		/// </summary>
		public async Task DeleteNetworkSmTargetGroupAsync(string networkId, string targetGroupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups/"+ (targetGroupId==null? "" : System.Uri.EscapeDataString(targetGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a target group
		/// Return a target group
		/// GetNetworkSmTargetGroup networks/{networkId}/sm/targetGroups/{targetGroupId}
		/// </summary>
		/// <param name="withDetails">Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSmTargetGroupAsync(string networkId, string targetGroupId, bool withDetails, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups/"+ (targetGroupId==null? "" : System.Uri.EscapeDataString(targetGroupId))+"&withDetails="+withDetails;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a target group
		/// Update a target group
		/// UpdateNetworkSmTargetGroup networks/{networkId}/sm/targetGroups/{targetGroupId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSmTargetGroupAsync(string networkId, string targetGroupId, CreateNetworkSmTargetGroupCreatenetworksmtargetgroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups/"+ (targetGroupId==null? "" : System.Uri.EscapeDataString(targetGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the profiles associated with a user
		/// Get the profiles associated with a user
		/// GetNetworkSmUserDeviceProfiles networks/{networkId}/sm/user/{userId}/deviceProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmUserDeviceProfilesAsync(string networkId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/user/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/deviceProfiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of softwares associated with a user
		/// Get a list of softwares associated with a user
		/// GetNetworkSmUserSoftwares networks/{networkId}/sm/user/{userId}/softwares
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmUserSoftwaresAsync(string networkId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/user/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/softwares";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the owners in an SM network with various specified fields and filters
		/// List the owners in an SM network with various specified fields and filters
		/// GetNetworkSmUsers networks/{networkId}/sm/users
		/// </summary>
		/// <param name="ids">Filter users by id(s). Multiple ids can be passed in as comma separated values.</param>
		/// <param name="usernames">Filter users by username(s). Multiple usernames can be passed in as comma separated values.</param>
		/// <param name="emails">Filter users by email(s). Multiple emails can be passed in as comma separated values.</param>
		/// <param name="scope">Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags as comma separated values.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmUsersAsync(string networkId, string ids, string usernames, string emails, string scope, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/users&ids=" + (ids==null? "" : System.Uri.EscapeDataString(ids))+"&usernames=" + (usernames==null? "" : System.Uri.EscapeDataString(usernames))+"&emails=" + (emails==null? "" : System.Uri.EscapeDataString(emails))+"&scope=" + (scope==null? "" : System.Uri.EscapeDataString(scope));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the client's daily cellular data usage history
		/// Return the client's daily cellular data usage history. Usage data is in kilobytes.
		/// GetNetworkSmCellularUsageHistory networks/{networkId}/sm/{deviceId}/cellularUsageHistory
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmCellularUsageHistoryAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/cellularUsageHistory";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the certs on a device
		/// List the certs on a device
		/// GetNetworkSmCerts networks/{networkId}/sm/{deviceId}/certs
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmCertsAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/certs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the profiles associated with a device
		/// Get the profiles associated with a device
		/// GetNetworkSmDeviceProfiles networks/{networkId}/sm/{deviceId}/deviceProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmDeviceProfilesAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/deviceProfiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the network adapters of a device
		/// List the network adapters of a device
		/// GetNetworkSmNetworkAdapters networks/{networkId}/sm/{deviceId}/networkAdapters
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmNetworkAdaptersAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/networkAdapters";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the restrictions on a device
		/// List the restrictions on a device
		/// GetNetworkSmRestrictions networks/{networkId}/sm/{deviceId}/restrictions
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmRestrictionsAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/restrictions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the security centers on a device
		/// List the security centers on a device
		/// GetNetworkSmSecurityCenters networks/{networkId}/sm/{deviceId}/securityCenters
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmSecurityCentersAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/securityCenters";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of softwares associated with a device
		/// Get a list of softwares associated with a device
		/// GetNetworkSmSoftwares networks/{networkId}/sm/{deviceId}/softwares
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmSoftwaresAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/softwares";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the saved SSID names on a device
		/// List the saved SSID names on a device
		/// GetNetworkSmWlanLists networks/{networkId}/sm/{deviceId}/wlanLists
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmWlanListsAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/wlanLists";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the SNMP settings for a network
		/// Return the SNMP settings for a network
		/// GetNetworkSnmpSettings networks/{networkId}/snmpSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSnmpSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/snmpSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the splash login attempts for a network
		/// List the splash login attempts for a network
		/// GetNetworkSplashLoginAttempts networks/{networkId}/splashLoginAttempts
		/// </summary>
		/// <param name="ssidNumber">Only return the login attempts for the specified SSID</param>
		/// <param name="loginIdentifier">The username, email, or phone number used during login</param>
		/// <param name="timespan">The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSplashLoginAttemptsAsync(string networkId, GetNetworkSplashLoginAttemptsSsidNumber ssidNumber, string loginIdentifier, int timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/splashLoginAttempts&ssidNumber="+ssidNumber+"&loginIdentifier=" + (loginIdentifier==null? "" : System.Uri.EscapeDataString(loginIdentifier))+"&timespan="+timespan;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Split a combined network into individual networks for each type of device
		/// Split a combined network into individual networks for each type of device
		/// SplitNetwork networks/{networkId}/split
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> SplitNetworkAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/split";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the SSIDs in a network
		/// List the SSIDs in a network. Supports networks with access points or wireless-enabled security appliances and teleworker gateways.
		/// GetNetworkSsids networks/{networkId}/ssids
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSsidsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/ssids";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a single SSID
		/// Return a single SSID
		/// GetNetworkSsid networks/{networkId}/ssids/{number}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSsidAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the attributes of an SSID
		/// Update the attributes of an SSID
		/// UpdateNetworkSsid networks/{networkId}/ssids/{number}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSsidAsync(string networkId, string number, UpdateNetworkSsidPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the L3 firewall rules for an SSID on an MR network
		/// Return the L3 firewall rules for an SSID on an MR network
		/// GetNetworkSsidL3FirewallRules networks/{networkId}/ssids/{number}/l3FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSsidL3FirewallRulesAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/l3FirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the L3 firewall rules of an SSID on an MR network
		/// Update the L3 firewall rules of an SSID on an MR network
		/// UpdateNetworkSsidL3FirewallRules networks/{networkId}/ssids/{number}/l3FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> UpdateNetworkSsidL3FirewallRulesAsync(string networkId, string number, UpdateNetworkSsidL3FirewallRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/l3FirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Display the splash page settings for the given SSID
		/// Display the splash page settings for the given SSID
		/// GetNetworkSsidSplashSettings networks/{networkId}/ssids/{number}/splashSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSsidSplashSettingsAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/splashSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify the splash page settings for the given SSID
		/// Modify the splash page settings for the given SSID
		/// UpdateNetworkSsidSplashSettings networks/{networkId}/ssids/{number}/splashSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSsidSplashSettingsAsync(string networkId, string number, UpdateNetworkSsidSplashSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/splashSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the static routes for an MX or teleworker network
		/// List the static routes for an MX or teleworker network
		/// GetNetworkStaticRoutes networks/{networkId}/staticRoutes
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkStaticRoutesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/staticRoutes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a static route for an MX or teleworker network
		/// Add a static route for an MX or teleworker network
		/// CreateNetworkStaticRoute networks/{networkId}/staticRoutes
		/// </summary>
		public async Task CreateNetworkStaticRouteAsync(string networkId, CreateNetworkStaticRoutePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/staticRoutes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a static route from an MX or teleworker network
		/// Delete a static route from an MX or teleworker network
		/// DeleteNetworkStaticRoute networks/{networkId}/staticRoutes/{staticRouteId}
		/// </summary>
		public async Task DeleteNetworkStaticRouteAsync(string networkId, string staticRouteId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a static route for an MX or teleworker network
		/// Return a static route for an MX or teleworker network
		/// GetNetworkStaticRoute networks/{networkId}/staticRoutes/{staticRouteId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkStaticRouteAsync(string networkId, string staticRouteId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a static route for an MX or teleworker network
		/// Update a static route for an MX or teleworker network
		/// UpdateNetworkStaticRoute networks/{networkId}/staticRoutes/{staticRouteId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkStaticRouteAsync(string networkId, string staticRouteId, UpdateNetworkStaticRoutePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Swap MX primary and warm spare appliances
		/// Swap MX primary and warm spare appliances
		/// SwapNetworkWarmSpare networks/{networkId}/swapWarmSpare
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> SwapNetworkWarmSpareAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/swapWarmSpare";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List link aggregation groups
		/// List link aggregation groups
		/// GetNetworkSwitchLinkAggregations networks/{networkId}/switch/linkAggregations
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchLinkAggregationsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/linkAggregations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a link aggregation group
		/// Create a link aggregation group
		/// CreateNetworkSwitchLinkAggregation networks/{networkId}/switch/linkAggregations
		/// </summary>
		public async Task CreateNetworkSwitchLinkAggregationAsync(string networkId, CreateNetworkSwitchLinkAggregationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/linkAggregations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Split a link aggregation group into separate ports
		/// Split a link aggregation group into separate ports
		/// DeleteNetworkSwitchLinkAggregation networks/{networkId}/switch/linkAggregations/{linkAggregationId}
		/// </summary>
		public async Task DeleteNetworkSwitchLinkAggregationAsync(string networkId, string linkAggregationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/linkAggregations/"+ (linkAggregationId==null? "" : System.Uri.EscapeDataString(linkAggregationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a link aggregation group
		/// Update a link aggregation group
		/// UpdateNetworkSwitchLinkAggregation networks/{networkId}/switch/linkAggregations/{linkAggregationId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchLinkAggregationAsync(string networkId, string linkAggregationId, UpdateNetworkSwitchLinkAggregationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/linkAggregations/"+ (linkAggregationId==null? "" : System.Uri.EscapeDataString(linkAggregationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List switch port schedules
		/// List switch port schedules
		/// GetNetworkSwitchPortSchedules networks/{networkId}/switch/portSchedules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchPortSchedulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/portSchedules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a switch port schedule
		/// Add a switch port schedule
		/// CreateNetworkSwitchPortSchedule networks/{networkId}/switch/portSchedules
		/// </summary>
		public async Task CreateNetworkSwitchPortScheduleAsync(string networkId, CreateNetworkSwitchPortSchedulePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/portSchedules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a switch port schedule
		/// Delete a switch port schedule
		/// DeleteNetworkSwitchPortSchedule networks/{networkId}/switch/portSchedules/{portScheduleId}
		/// </summary>
		public async Task DeleteNetworkSwitchPortScheduleAsync(string networkId, string portScheduleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/portSchedules/"+ (portScheduleId==null? "" : System.Uri.EscapeDataString(portScheduleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a switch port schedule
		/// Update a switch port schedule
		/// UpdateNetworkSwitchPortSchedule networks/{networkId}/switch/portSchedules/{portScheduleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchPortScheduleAsync(string networkId, string portScheduleId, UpdateNetworkSwitchPortSchedulePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/portSchedules/"+ (portScheduleId==null? "" : System.Uri.EscapeDataString(portScheduleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the switch network settings
		/// Returns the switch network settings
		/// GetNetworkSwitchSettings networks/{networkId}/switch/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update switch network settings
		/// Update switch network settings
		/// UpdateNetworkSwitchSettings networks/{networkId}/switch/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchSettingsAsync(string networkId, UpdateNetworkSwitchSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the MTU configuration
		/// Return the MTU configuration
		/// GetNetworkSwitchSettingsMtu networks/{networkId}/switch/settings/mtu
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchSettingsMtuAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/mtu";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return multicast settings for a network
		/// Return multicast settings for a network
		/// GetNetworkSwitchSettingsMulticast networks/{networkId}/switch/settings/multicast
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchSettingsMulticastAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/multicast";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update multicast settings for a network
		/// Update multicast settings for a network
		/// UpdateNetworkSwitchSettingsMulticast networks/{networkId}/switch/settings/multicast
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchSettingsMulticastAsync(string networkId, UpdateNetworkSwitchSettingsMulticastPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/multicast";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List quality of service rules
		/// List quality of service rules
		/// GetNetworkSwitchSettingsQosRules networks/{networkId}/switch/settings/qosRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchSettingsQosRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/qosRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a quality of service rule
		/// Add a quality of service rule
		/// CreateNetworkSwitchSettingsQosRule networks/{networkId}/switch/settings/qosRules
		/// </summary>
		public async Task CreateNetworkSwitchSettingsQosRuleAsync(string networkId, CreateNetworkSwitchSettingsQosRulePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/qosRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the quality of service rule IDs by order in which they will be processed by the switch
		/// Return the quality of service rule IDs by order in which they will be processed by the switch
		/// GetNetworkSwitchSettingsQosRulesOrder networks/{networkId}/switch/settings/qosRules/order
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchSettingsQosRulesOrderAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/qosRules/order";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the order in which the rules should be processed by the switch
		/// Update the order in which the rules should be processed by the switch
		/// UpdateNetworkSwitchSettingsQosRulesOrder networks/{networkId}/switch/settings/qosRules/order
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchSettingsQosRulesOrderAsync(string networkId, UpdateNetworkSwitchSettingsQosRulesOrderPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/qosRules/order";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a quality of service rule
		/// Delete a quality of service rule
		/// DeleteNetworkSwitchSettingsQosRule networks/{networkId}/switch/settings/qosRules/{qosRuleId}
		/// </summary>
		public async Task DeleteNetworkSwitchSettingsQosRuleAsync(string networkId, string qosRuleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/qosRules/"+ (qosRuleId==null? "" : System.Uri.EscapeDataString(qosRuleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a quality of service rule
		/// Return a quality of service rule
		/// GetNetworkSwitchSettingsQosRule networks/{networkId}/switch/settings/qosRules/{qosRuleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchSettingsQosRuleAsync(string networkId, string qosRuleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/qosRules/"+ (qosRuleId==null? "" : System.Uri.EscapeDataString(qosRuleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a quality of service rule
		/// Update a quality of service rule
		/// UpdateNetworkSwitchSettingsQosRule networks/{networkId}/switch/settings/qosRules/{qosRuleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchSettingsQosRuleAsync(string networkId, string qosRuleId, UpdateNetworkSwitchSettingsQosRulePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/qosRules/"+ (qosRuleId==null? "" : System.Uri.EscapeDataString(qosRuleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the storm control configuration for a switch network
		/// Return the storm control configuration for a switch network
		/// GetNetworkSwitchSettingsStormControl networks/{networkId}/switch/settings/stormControl
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchSettingsStormControlAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/stormControl";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the storm control configuration for a switch network
		/// Update the storm control configuration for a switch network
		/// UpdateNetworkSwitchSettingsStormControl networks/{networkId}/switch/settings/stormControl
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchSettingsStormControlAsync(string networkId, UpdateNetworkSwitchSettingsStormControlPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings/stormControl";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the switch stacks in a network
		/// List the switch stacks in a network
		/// GetNetworkSwitchStacks networks/{networkId}/switchStacks
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchStacksAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switchStacks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the syslog servers for a network
		/// List the syslog servers for a network
		/// GetNetworkSyslogServers networks/{networkId}/syslogServers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSyslogServersAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/syslogServers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the syslog servers for a network
		/// Update the syslog servers for a network
		/// UpdateNetworkSyslogServers networks/{networkId}/syslogServers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> UpdateNetworkSyslogServersAsync(string networkId, UpdateNetworkSyslogServersPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/syslogServers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the traffic analysis data for this network
		/// Return the traffic analysis data for this network. Traffic analysis with hostname visibility must be enabled on the network.
		/// GetNetworkTraffic networks/{networkId}/traffic
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 30 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days.</param>
		/// <param name="deviceType">Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkTrafficAsync(string networkId, string t0, float timespan, GetNetworkTrafficDeviceType deviceType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/traffic&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan+"&deviceType=" + deviceType;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unbind a network from a template.
		/// Unbind a network from a template.
		/// UnbindNetwork networks/{networkId}/unbind
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task UnbindNetworkAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/unbind";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the uplink settings for your MX network.
		/// Returns the uplink settings for your MX network.
		/// GetNetworkUplinkSettings networks/{networkId}/uplinkSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkUplinkSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/uplinkSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the uplink settings for your MX network.
		/// Updates the uplink settings for your MX network.
		/// UpdateNetworkUplinkSettings networks/{networkId}/uplinkSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkUplinkSettingsAsync(string networkId, UpdateNetworkUplinkSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/uplinkSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the VLANs for an MX network
		/// List the VLANs for an MX network
		/// GetNetworkVlans networks/{networkId}/vlans
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkVlansAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/vlans";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a VLAN
		/// Add a VLAN
		/// CreateNetworkVlan networks/{networkId}/vlans
		/// </summary>
		public async Task CreateNetworkVlanAsync(string networkId, CreateNetworkVlanPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/vlans";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a VLAN from a network
		/// Delete a VLAN from a network
		/// DeleteNetworkVlan networks/{networkId}/vlans/{vlanId}
		/// </summary>
		public async Task DeleteNetworkVlanAsync(string networkId, string vlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/vlans/"+ (vlanId==null? "" : System.Uri.EscapeDataString(vlanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a VLAN
		/// Return a VLAN
		/// GetNetworkVlan networks/{networkId}/vlans/{vlanId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkVlanAsync(string networkId, string vlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/vlans/"+ (vlanId==null? "" : System.Uri.EscapeDataString(vlanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a VLAN
		/// Update a VLAN
		/// UpdateNetworkVlan networks/{networkId}/vlans/{vlanId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkVlanAsync(string networkId, string vlanId, UpdateNetworkVlanPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/vlans/"+ (vlanId==null? "" : System.Uri.EscapeDataString(vlanId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the enabled status of VLANs for the network
		/// Returns the enabled status of VLANs for the network
		/// GetNetworkVlansEnabledState networks/{networkId}/vlansEnabledState
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkVlansEnabledStateAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/vlansEnabledState";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable/Disable VLANs for the given network
		/// Enable/Disable VLANs for the given network
		/// UpdateNetworkVlansEnabledState networks/{networkId}/vlansEnabledState
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkVlansEnabledStateAsync(string networkId, UpdateNetworkVlansEnabledStatePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/vlansEnabledState";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return MX warm spare settings
		/// Return MX warm spare settings
		/// GetNetworkWarmSpareSettings networks/{networkId}/warmSpareSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWarmSpareSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/warmSpareSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update MX warm spare settings
		/// Update MX warm spare settings
		/// UpdateNetworkWarmSpareSettings networks/{networkId}/warmSpareSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWarmSpareSettingsAsync(string networkId, UpdateNetworkWarmSpareSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/warmSpareSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the non-basic RF profiles for this network
		/// List the non-basic RF profiles for this network
		/// GetNetworkWirelessRfProfiles networks/{networkId}/wireless/rfProfiles
		/// </summary>
		/// <param name="includeTemplateProfiles">If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessRfProfilesAsync(string networkId, bool includeTemplateProfiles, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles&includeTemplateProfiles="+includeTemplateProfiles;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates new RF profile for this network
		/// Creates new RF profile for this network
		/// CreateNetworkWirelessRfProfile networks/{networkId}/wireless/rfProfiles
		/// </summary>
		public async Task CreateNetworkWirelessRfProfileAsync(string networkId, CreateNetworkWirelessRfProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a RF Profile
		/// Delete a RF Profile
		/// DeleteNetworkWirelessRfProfile networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		/// </summary>
		public async Task DeleteNetworkWirelessRfProfileAsync(string networkId, string rfProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles/"+ (rfProfileId==null? "" : System.Uri.EscapeDataString(rfProfileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a RF profile
		/// Return a RF profile
		/// GetNetworkWirelessRfProfile networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessRfProfileAsync(string networkId, string rfProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles/"+ (rfProfileId==null? "" : System.Uri.EscapeDataString(rfProfileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates specified RF profile for this network
		/// Updates specified RF profile for this network
		/// UpdateNetworkWirelessRfProfile networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessRfProfileAsync(string networkId, string rfProfileId, UpdateNetworkWirelessRfProfilePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles/"+ (rfProfileId==null? "" : System.Uri.EscapeDataString(rfProfileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the wireless settings for a network
		/// Return the wireless settings for a network
		/// GetNetworkWirelessSettings networks/{networkId}/wireless/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the wireless settings for a network
		/// Update the wireless settings for a network
		/// UpdateNetworkWirelessSettings networks/{networkId}/wireless/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSettingsAsync(string networkId, UpdateNetworkWirelessSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lock a set of devices
		/// Lock a set of devices
		/// LockNetworkSmDevices networks/{network_id}/sm/devices/lock
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> LockNetworkSmDevicesAsync(string network_id, LockNetworkSmDevicesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (network_id==null? "" : System.Uri.EscapeDataString(network_id))+"/sm/devices/lock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
		/// Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
		/// GetNetworkSmConnectivity networks/{network_id}/sm/{id}/connectivity
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmConnectivityAsync(string network_id, string id, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (network_id==null? "" : System.Uri.EscapeDataString(network_id))+"/sm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/connectivity&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return historical records of various Systems Manager network connection details for desktop devices.
		/// Return historical records of various Systems Manager network connection details for desktop devices.
		/// GetNetworkSmDesktopLogs networks/{network_id}/sm/{id}/desktopLogs
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmDesktopLogsAsync(string network_id, string id, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (network_id==null? "" : System.Uri.EscapeDataString(network_id))+"/sm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/desktopLogs&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return historical records of commands sent to Systems Manager devices
		/// Return historical records of commands sent to Systems Manager devices. Note that this will include the name of the Dashboard user who initiated the command if it was generated by a Dashboard admin rather than the automatic behavior of the system; you may wish to filter this out of any reports.
		/// GetNetworkSmDeviceCommandLogs networks/{network_id}/sm/{id}/deviceCommandLogs
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmDeviceCommandLogsAsync(string network_id, string id, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (network_id==null? "" : System.Uri.EscapeDataString(network_id))+"/sm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/deviceCommandLogs&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return historical records of various Systems Manager client metrics for desktop devices.
		/// Return historical records of various Systems Manager client metrics for desktop devices.
		/// GetNetworkSmPerformanceHistory networks/{network_id}/sm/{id}/performanceHistory
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmPerformanceHistoryAsync(string network_id, string id, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (network_id==null? "" : System.Uri.EscapeDataString(network_id))+"/sm/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/performanceHistory&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the organizations that the user has privileges on
		/// List the organizations that the user has privileges on
		/// GetOrganizations organizations
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return an organization
		/// Return an organization
		/// GetOrganization organizations/{organizationId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the list of action batches in the organization
		/// Return the list of action batches in the organization
		/// GetOrganizationActionBatches organizations/{organizationId}/actionBatches
		/// </summary>
		/// <param name="status">Filter batches by status. Valid types are pending, completed, and failed.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationActionBatchesAsync(string organizationId, GetOrganizationActionBatchesStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an action batch
		/// Create an action batch
		/// CreateOrganizationActionBatch organizations/{organizationId}/actionBatches
		/// </summary>
		public async Task CreateOrganizationActionBatchAsync(string organizationId, CreateOrganizationActionBatchPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an action batch
		/// Delete an action batch
		/// DeleteOrganizationActionBatch organizations/{organizationId}/actionBatches/{actionBatchId}
		/// </summary>
		public async Task DeleteOrganizationActionBatchAsync(string organizationId, string actionBatchId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches/"+ (actionBatchId==null? "" : System.Uri.EscapeDataString(actionBatchId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an action batch
		/// Update an action batch
		/// UpdateOrganizationActionBatch organizations/{organizationId}/actionBatches/{actionBatchId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationActionBatchAsync(string organizationId, string actionBatchId, UpdateOrganizationActionBatchPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches/"+ (actionBatchId==null? "" : System.Uri.EscapeDataString(actionBatchId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the dashboard administrators in this organization
		/// List the dashboard administrators in this organization
		/// GetOrganizationAdmins organizations/{organizationId}/admins
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationAdminsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/admins";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new dashboard administrator
		/// Create a new dashboard administrator
		/// CreateOrganizationAdmin organizations/{organizationId}/admins
		/// </summary>
		public async Task CreateOrganizationAdminAsync(string organizationId, CreateOrganizationAdminPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/admins";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Revoke all access for a dashboard administrator within this organization
		/// Revoke all access for a dashboard administrator within this organization
		/// DeleteOrganizationAdmin organizations/{organizationId}/admins/{adminId}
		/// </summary>
		public async Task DeleteOrganizationAdminAsync(string organizationId, string adminId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/admins/"+ (adminId==null? "" : System.Uri.EscapeDataString(adminId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an administrator
		/// Update an administrator
		/// UpdateOrganizationAdmin organizations/{organizationId}/admins/{adminId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationAdminAsync(string organizationId, string adminId, UpdateOrganizationAdminPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/admins/"+ (adminId==null? "" : System.Uri.EscapeDataString(adminId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the API requests made by an organization
		/// List the API requests made by an organization
		/// GetOrganizationApiRequests organizations/{organizationId}/apiRequests
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="adminId">Filter the results by the ID of the admin who made the API requests</param>
		/// <param name="path">Filter the results by the path of the API requests</param>
		/// <param name="method">Filter the results by the method of the API requests (must be 'GET', 'PUT', 'POST' or 'DELETE')</param>
		/// <param name="responseCode">Filter the results by the response code of the API requests</param>
		/// <param name="sourceIp">Filter the results by the IP address of the originating API request</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationApiRequestsAsync(string organizationId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, string adminId, string path, string method, int responseCode, string sourceIp, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/apiRequests&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&adminId=" + (adminId==null? "" : System.Uri.EscapeDataString(adminId))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&method=" + (method==null? "" : System.Uri.EscapeDataString(method))+"&responseCode="+responseCode+"&sourceIp=" + (sourceIp==null? "" : System.Uri.EscapeDataString(sourceIp));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return an aggregated overview of API requests data
		/// Return an aggregated overview of API requests data
		/// GetOrganizationApiRequestsOverview organizations/{organizationId}/apiRequests/overview
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationApiRequestsOverviewAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/apiRequests/overview&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Claim a list of devices, licenses, and/or orders into an organization
		/// Claim a list of devices, licenses, and/or orders into an organization. When claiming by order, all devices and licenses in the order will be claimed; licenses will be added to the organization and devices will be placed in the organization's inventory.
		/// ClaimIntoOrganization organizations/{organizationId}/claim
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> ClaimIntoOrganizationAsync(string organizationId, ClaimIntoOrganizationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/claim";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a new organization by cloning the addressed organization
		/// Create a new organization by cloning the addressed organization
		/// CloneOrganization organizations/{organizationId}/clone
		/// </summary>
		public async Task CloneOrganizationAsync(string organizationId, CloneOrganizationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/clone";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the configuration templates for this organization
		/// List the configuration templates for this organization
		/// GetOrganizationConfigTemplates organizations/{organizationId}/configTemplates
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationConfigTemplatesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a configuration template
		/// Remove a configuration template
		/// DeleteOrganizationConfigTemplate organizations/{organizationId}/configTemplates/{configTemplateId}
		/// </summary>
		public async Task DeleteOrganizationConfigTemplateAsync(string organizationId, string configTemplateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the switch profiles for your switch template configuration
		/// List the switch profiles for your switch template configuration
		/// GetOrganizationConfigTemplateSwitchProfiles organizations/{organizationId}/configTemplates/{configTemplateId}/switchProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationConfigTemplateSwitchProfilesAsync(string organizationId, string configTemplateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId))+"/switchProfiles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// View the Change Log for your organization
		/// View the Change Log for your organization
		/// GetOrganizationConfigurationChanges organizations/{organizationId}/configurationChanges
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 365 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkId">Filters on the given network</param>
		/// <param name="adminId">Filters on the given Admin</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationConfigurationChangesAsync(string organizationId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, string networkId, string adminId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configurationChanges&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&networkId=" + (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"&adminId=" + (adminId==null? "" : System.Uri.EscapeDataString(adminId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the status of every Meraki device in the organization
		/// List the status of every Meraki device in the organization
		/// GetOrganizationDeviceStatuses organizations/{organizationId}/deviceStatuses
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationDeviceStatusesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/deviceStatuses";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the devices in an organization
		/// List the devices in an organization
		/// GetOrganizationDevices organizations/{organizationId}/devices
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="configurationUpdatedAfter">Filter results by whether or not the device's configuration has been updated after the given timestamp</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationDevicesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string configurationUpdatedAfter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/devices&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&configurationUpdatedAfter=" + (configurationUpdatedAfter==null? "" : System.Uri.EscapeDataString(configurationUpdatedAfter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the inventory for an organization
		/// Return the inventory for an organization
		/// GetOrganizationInventory organizations/{organizationId}/inventory
		/// </summary>
		/// <param name="includeLicenseInfo">When this parameter is true, each entity in the response will include the license expiration date of the device (if any). Only applies to organizations that are on the per-device licensing model. Defaults to false.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationInventoryAsync(string organizationId, bool includeLicenseInfo, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory&includeLicenseInfo="+includeLicenseInfo;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return an overview of the license state for an organization
		/// Return an overview of the license state for an organization
		/// GetOrganizationLicenseState organizations/{organizationId}/licenseState
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationLicenseStateAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenseState";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the licenses for an organization
		/// List the licenses for an organization
		/// GetOrganizationLicenses organizations/{organizationId}/licenses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="deviceSerial">Filter the licenses to those assigned to a particular device</param>
		/// <param name="networkId">Filter the licenses to those assigned in a particular network</param>
		/// <param name="state">Filter the licenses to those in a particular state. Can be one of 'active', 'expired', 'expiring', 'recentlyQueued', 'unused' or 'unusedActive'</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationLicensesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string deviceSerial, string networkId, GetOrganizationLicensesState state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&networkId=" + (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"&state=" + state;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Assign SM seats to a network
		/// Assign SM seats to a network. This will increase the managed SM device limit of the network
		/// AssignOrganizationLicensesSeats organizations/{organizationId}/licenses/assignSeats
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> AssignOrganizationLicensesSeatsAsync(string organizationId, AssignOrganizationLicensesSeatsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/assignSeats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Move SM seats to another organization
		/// Move SM seats to another organization
		/// MoveOrganizationLicensesSeats organizations/{organizationId}/licenses/moveSeats
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> MoveOrganizationLicensesSeatsAsync(string organizationId, MoveOrganizationLicensesSeatsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/moveSeats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Renew SM seats of a license
		/// Renew SM seats of a license. This will extend the license expiration date of managed SM devices covered by this license
		/// RenewOrganizationLicensesSeats organizations/{organizationId}/licenses/renewSeats
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> RenewOrganizationLicensesSeatsAsync(string organizationId, RenewOrganizationLicensesSeatsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/renewSeats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Display a license
		/// Display a license
		/// GetOrganizationLicense organizations/{organizationId}/licenses/{licenseId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationLicenseAsync(string organizationId, string licenseId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/"+ (licenseId==null? "" : System.Uri.EscapeDataString(licenseId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the networks in an organization
		/// List the networks in an organization
		/// GetOrganizationNetworks organizations/{organizationId}/networks
		/// </summary>
		/// <param name="configTemplateId">An optional parameter that is the ID of a config template. Will return all networks bound to that template.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationNetworksAsync(string organizationId, string configTemplateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/networks&configTemplateId=" + (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a network
		/// Create a network
		/// CreateOrganizationNetwork organizations/{organizationId}/networks
		/// </summary>
		public async Task CreateOrganizationNetworkAsync(string organizationId, CreateOrganizationNetworkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/networks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Combine multiple networks into a single network
		/// Combine multiple networks into a single network
		/// CombineOrganizationNetworks organizations/{organizationId}/networks/combine
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CombineOrganizationNetworksAsync(string organizationId, CombineOrganizationNetworksPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/networks/combine";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
		/// Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
		/// GetOrganizationOpenapiSpec organizations/{organizationId}/openapiSpec
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationOpenapiSpecAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/openapiSpec";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the SAML roles for this organization
		/// List the SAML roles for this organization
		/// GetOrganizationSamlRoles organizations/{organizationId}/samlRoles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationSamlRolesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a SAML role
		/// Create a SAML role
		/// CreateOrganizationSamlRole organizations/{organizationId}/samlRoles
		/// </summary>
		public async Task CreateOrganizationSamlRoleAsync(string organizationId, CreateOrganizationSamlRolePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return a SAML role
		/// Return a SAML role
		/// GetOrganizationSamlRole organizations/{organizationId}/samlRoles/{samlRoleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationSamlRoleAsync(string organizationId, string samlRoleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles/"+ (samlRoleId==null? "" : System.Uri.EscapeDataString(samlRoleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a SAML role
		/// Update a SAML role
		/// UpdateOrganizationSamlRole organizations/{organizationId}/samlRoles/{samlRoleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationSamlRoleAsync(string organizationId, string samlRoleId, UpdateOrganizationSamlRolePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles/"+ (samlRoleId==null? "" : System.Uri.EscapeDataString(samlRoleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns all supported intrusion settings for an organization
		/// Returns all supported intrusion settings for an organization
		/// GetOrganizationSecurityIntrusionSettings organizations/{organizationId}/security/intrusionSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationSecurityIntrusionSettingsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/security/intrusionSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets supported intrusion settings for an organization
		/// Sets supported intrusion settings for an organization
		/// UpdateOrganizationSecurityIntrusionSettings organizations/{organizationId}/security/intrusionSettings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationSecurityIntrusionSettingsAsync(string organizationId, UpdateOrganizationSecurityIntrusionSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/security/intrusionSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the security events (intrusion detection only) for an organization
		/// List the security events (intrusion detection only) for an organization
		/// GetOrganizationSecurityEvents organizations/{organizationId}/securityEvents
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 365 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationSecurityEventsAsync(string organizationId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/securityEvents&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the SNMP settings for an organization
		/// Return the SNMP settings for an organization
		/// GetOrganizationSnmp organizations/{organizationId}/snmp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationSnmpAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/snmp";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the third party VPN peers for an organization
		/// Return the third party VPN peers for an organization
		/// GetOrganizationThirdPartyVPNPeers organizations/{organizationId}/thirdPartyVPNPeers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationThirdPartyVPNPeersAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/thirdPartyVPNPeers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the third party VPN peers for an organization
		/// Update the third party VPN peers for an organization
		/// UpdateOrganizationThirdPartyVPNPeers organizations/{organizationId}/thirdPartyVPNPeers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> UpdateOrganizationThirdPartyVPNPeersAsync(string organizationId, UpdateOrganizationThirdPartyVPNPeersPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/thirdPartyVPNPeers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
		/// Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
		/// GetOrganizationUplinksLossAndLatency organizations/{organizationId}/uplinksLossAndLatency
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 60 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes.</param>
		/// <param name="uplink">Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks.</param>
		/// <param name="ip">Optional filter for a specific destination IP. Default will return all destination IPs.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationUplinksLossAndLatencyAsync(string organizationId, string t0, string t1, float timespan, GetNetworkDeviceLossAndLatencyHistoryUplink uplink, string ip, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/uplinksLossAndLatency&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&uplink=" + uplink+"&ip=" + (ip==null? "" : System.Uri.EscapeDataString(ip));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the firewall rules for an organization's site-to-site VPN
		/// Return the firewall rules for an organization's site-to-site VPN
		/// GetOrganizationVpnFirewallRules organizations/{organizationId}/vpnFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationVpnFirewallRulesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/vpnFirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the firewall rules of an organization's site-to-site VPN
		/// Update the firewall rules of an organization's site-to-site VPN
		/// UpdateOrganizationVpnFirewallRules organizations/{organizationId}/vpnFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> UpdateOrganizationVpnFirewallRulesAsync(string organizationId, UpdateOrganizationVpnFirewallRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/vpnFirewallRules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum GetDeviceCameraAnalyticsOverviewObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		person = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vehicle = 1,
	}
	
	public class UpdateDeviceCameraVideoSettingsPutBody
	{
		
		/// <summary>
		/// Boolean indicating if external rtsp stream is exposed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalRtspEnabled")]
		public System.Nullable<System.Boolean> ExternalRtspEnabled { get; set; }
	}
	
	public class UpdateDeviceCellularGatewaySettingsPutBody
	{
		
		/// <summary>
		/// list of all fixed IP assignments for a single MG
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public UpdateDeviceCellularGatewaySettingsPutBodyFixedIpAssignments[] UpdateDeviceCellularGatewaySettingsPutBodyFixedIpAssignments { get; set; }
		
		/// <summary>
		/// list of all reserved IP ranges for a single MG
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateDeviceCellularGatewaySettingsPutBodyReservedIpRanges[] UpdateDeviceCellularGatewaySettingsPutBodyReservedIpRanges { get; set; }
	}
	
	public class UpdateDeviceCellularGatewaySettingsPutBodyFixedIpAssignments
	{
		
		/// <summary>
		/// The IP address you want to assign to a specific server or device
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// A descriptive name of the assignment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateDeviceCellularGatewaySettingsPutBodyReservedIpRanges
	{
		
		/// <summary>
		/// Comment explaining the reserved IP range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Ending IP included in the reserved range of IPs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// Starting IP included in the reserved range of IPs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class UpdateDeviceCellularGatewaySettingsPortForwardingRulesPutBody
	{
		
		/// <summary>
		/// An array of port forwarding params
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateDeviceCellularGatewaySettingsPortForwardingRulesPutBodyRules[] UpdateDeviceCellularGatewaySettingsPortForwardingRulesPutBodyRules { get; set; }
	}
	
	public class UpdateDeviceCellularGatewaySettingsPortForwardingRulesPutBodyRules
	{
		
		/// <summary>
		/// `any` or `restricted`. Specify the right to make inbound connections on the specified ports or port ranges. If `restricted`, a list of allowed IPs is mandatory.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
		
		/// <summary>
		/// The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lanIp")]
		public string LanIp { get; set; }
		
		/// <summary>
		/// A port or port ranges that will receive the forwarded traffic from the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="localPort")]
		public string LocalPort { get; set; }
		
		/// <summary>
		/// A descriptive name for the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// TCP or UDP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public string Protocol { get; set; }
		
		/// <summary>
		/// A port or port ranges that will be forwarded to the host on the LAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicPort")]
		public string PublicPort { get; set; }
	}
	
	public class CycleDeviceSwitchPortsPostBody
	{
		
		/// <summary>
		/// List of switch ports. Example: [1, 2-5, 1_MA-MOD-8X10G_1, 1_MA-MOD-8X10G_2-1_MA-MOD-8X10G_8]
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public string[] Ports { get; set; }
	}
	
	public class UpdateDeviceWirelessBluetoothSettingsPutBody
	{
		
		/// <summary>
		/// Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public class UpdateDeviceWirelessBluetoothSettingsReturn
	{
		
		/// <summary>
		/// Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public class UpdateNetworkPutBody
	{
		
		/// <summary>
		/// Disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableMyMerakiCom")]
		public System.Nullable<System.Boolean> DisableMyMerakiCom { get; set; }
		
		/// <summary>
		/// Disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if disableMyMerakiCom is set to false
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableRemoteStatusPage")]
		public System.Nullable<System.Boolean> DisableRemoteStatusPage { get; set; }
		
		/// <summary>
		/// A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// The name of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A space-separated list of tags to be applied to the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		/// <summary>
		/// The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
	}
	
	public class UpdateNetworkAlertSettingsPutBody
	{
		
		/// <summary>
		/// Alert-specific configuration for each type. Only alerts that pertain to the network can be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alerts")]
		public UpdateNetworkAlertSettingsPutBodyAlerts[] UpdateNetworkAlertSettingsPutBodyAlerts { get; set; }
		
		/// <summary>
		/// The network-wide destinations for all alerts on the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultDestinations")]
		public UpdateNetworkAlertSettingsPutBodyDefaultDestinations DefaultDestinations { get; set; }
	}
	
	public class UpdateNetworkAlertSettingsPutBodyAlerts
	{
		
		/// <summary>
		/// A hash of destinations for this specific alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alertDestinations")]
		public UpdateNetworkAlertSettingsPutBodyAlertsAlertDestinations AlertDestinations { get; set; }
		
		/// <summary>
		/// A boolean depicting if the alert is turned on or off
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filters")]
		public string Filters { get; set; }
		
		/// <summary>
		/// The type of alert
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class UpdateNetworkAlertSettingsPutBodyAlertsAlertDestinations
	{
		
		/// <summary>
		/// If true, then all network admins will receive emails for this alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allAdmins")]
		public System.Nullable<System.Boolean> AllAdmins { get; set; }
		
		/// <summary>
		/// A list of emails that will receive information about the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of HTTP server IDs to send a Webhook to for this alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snmp")]
		public System.Nullable<System.Boolean> Snmp { get; set; }
	}
	
	public class UpdateNetworkAlertSettingsPutBodyDefaultDestinations
	{
		
		/// <summary>
		/// If true, then all network admins will receive emails.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allAdmins")]
		public System.Nullable<System.Boolean> AllAdmins { get; set; }
		
		/// <summary>
		/// A list of emails that will recieve the alert(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of HTTP server IDs to send a Webhook to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snmp")]
		public System.Nullable<System.Boolean> Snmp { get; set; }
	}
	
	public class UpdateNetworkAppliancePortPutBody
	{
		
		/// <summary>
		/// The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicy")]
		public string AccessPolicy { get; set; }
		
		/// <summary>
		/// Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dropUntaggedTraffic")]
		public System.Nullable<System.Boolean> DropUntaggedTraffic { get; set; }
		
		/// <summary>
		/// The status of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The type of the port: 'access' or 'trunk'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class BindNetworkPostBody
	{
		
		/// <summary>
		/// Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoBind")]
		public System.Nullable<System.Boolean> AutoBind { get; set; }
		
		/// <summary>
		/// The ID of the template to which the network should be bound.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configTemplateId")]
		public string ConfigTemplateId { get; set; }
	}
	
	public class GetNetworkBluetoothSettingsReturn
	{
		
		/// <summary>
		/// Whether APs will advertise beacons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisingEnabled")]
		public System.Nullable<System.Boolean> AdvertisingEnabled { get; set; }
		
		/// <summary>
		/// The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="majorMinorAssignmentMode")]
		public string MajorMinorAssignmentMode { get; set; }
		
		/// <summary>
		/// The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Whether APs will scan for Bluetooth enabled clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanningEnabled")]
		public System.Nullable<System.Boolean> ScanningEnabled { get; set; }
		
		/// <summary>
		/// The UUID to be used in the beacon identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public class UpdateNetworkBluetoothSettingsPutBody
	{
		
		/// <summary>
		/// Whether APs will advertise beacons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisingEnabled")]
		public System.Nullable<System.Boolean> AdvertisingEnabled { get; set; }
		
		/// <summary>
		/// The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="majorMinorAssignmentMode")]
		public System.Nullable<UpdateNetworkBluetoothSettingsPutBodyMajorMinorAssignmentMode> MajorMinorAssignmentMode { get; set; }
		
		/// <summary>
		/// The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Whether APs will scan for Bluetooth enabled clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanningEnabled")]
		public System.Nullable<System.Boolean> ScanningEnabled { get; set; }
		
		/// <summary>
		/// The UUID to be used in the beacon identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkBluetoothSettingsPutBodyMajorMinorAssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Non-unique")]
		NonMinusunique = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unique = 1,
	}
	
	public class UpdateNetworkBluetoothSettingsReturn
	{
		
		/// <summary>
		/// Whether APs will advertise beacons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisingEnabled")]
		public System.Nullable<System.Boolean> AdvertisingEnabled { get; set; }
		
		/// <summary>
		/// The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="majorMinorAssignmentMode")]
		public string MajorMinorAssignmentMode { get; set; }
		
		/// <summary>
		/// The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Whether APs will scan for Bluetooth enabled clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanningEnabled")]
		public System.Nullable<System.Boolean> ScanningEnabled { get; set; }
		
		/// <summary>
		/// The UUID to be used in the beacon identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBody
	{
		
		/// <summary>
		/// Whether or not to record audio. Can be either true or false. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioRecordingEnabled")]
		public System.Nullable<System.Boolean> AudioRecordingEnabled { get; set; }
		
		/// <summary>
		/// Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudArchiveEnabled")]
		public System.Nullable<System.Boolean> CloudArchiveEnabled { get; set; }
		
		/// <summary>
		/// The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetentionDays")]
		public System.Nullable<System.Int32> MaxRetentionDays { get; set; }
		
		/// <summary>
		/// Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionBasedRetentionEnabled")]
		public System.Nullable<System.Boolean> MotionBasedRetentionEnabled { get; set; }
		
		/// <summary>
		/// The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionDetectorVersion")]
		public System.Nullable<System.Int32> MotionDetectorVersion { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique. This parameter is required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restrictedBandwidthModeEnabled")]
		public System.Nullable<System.Boolean> RestrictedBandwidthModeEnabled { get; set; }
		
		/// <summary>
		/// Schedule for which this camera will record video, or 'null' to always record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleId")]
		public string ScheduleId { get; set; }
		
		/// <summary>
		/// Video quality and resolution settings for all the camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="videoSettings")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings VideoSettings { get; set; }
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings
	{
		
		/// <summary>
		/// Quality and resolution for MV12/MV22/MV72 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV12/MV22/MV72")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72 MV12SlashMV22SlashMV72 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV12WE camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WE MV12WE { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV13 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13 MV13 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV21/MV71 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV21/MV71")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV21SlashMV71 MV21SlashMV71 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV22X/MV72X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV22X/MV72X")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV22XSlashMV72X MV22XSlashMV72X { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV32 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32 MV32 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV33 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33 MV33 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV52 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52 MV52 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV63 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63 MV63 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV63X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63X MV63X { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV93 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93 MV93 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV93X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93X MV93X { get; set; }
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enhanced = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		High = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WE
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WEResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WEResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV21SlashMV71
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV21SlashMV71Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV21SlashMV71Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV22XSlashMV72X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV22XSlashMV72XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV22XSlashMV72XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 2,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2058x2058")]
		_2058x2058 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 3,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 2,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2880x2880")]
		_2880x2880 = 2,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBody
	{
		
		/// <summary>
		/// Whether or not to record audio. Can be either true or false. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioRecordingEnabled")]
		public System.Nullable<System.Boolean> AudioRecordingEnabled { get; set; }
		
		/// <summary>
		/// Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudArchiveEnabled")]
		public System.Nullable<System.Boolean> CloudArchiveEnabled { get; set; }
		
		/// <summary>
		/// The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetentionDays")]
		public System.Nullable<System.Int32> MaxRetentionDays { get; set; }
		
		/// <summary>
		/// Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionBasedRetentionEnabled")]
		public System.Nullable<System.Boolean> MotionBasedRetentionEnabled { get; set; }
		
		/// <summary>
		/// The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionDetectorVersion")]
		public System.Nullable<System.Int32> MotionDetectorVersion { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restrictedBandwidthModeEnabled")]
		public System.Nullable<System.Boolean> RestrictedBandwidthModeEnabled { get; set; }
		
		/// <summary>
		/// Schedule for which this camera will record video, or 'null' to always record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleId")]
		public string ScheduleId { get; set; }
		
		/// <summary>
		/// Video quality and resolution settings for all the camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="videoSettings")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings VideoSettings { get; set; }
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings
	{
		
		/// <summary>
		/// Quality and resolution for MV12/MV22/MV72 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV12/MV22/MV72")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12SlashMV22SlashMV72 MV12SlashMV22SlashMV72 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV12WE camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WE MV12WE { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV13 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13 MV13 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV21/MV71 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV21/MV71")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV21SlashMV71 MV21SlashMV71 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV22X/MV72X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV22X/MV72X")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV22XSlashMV72X MV22XSlashMV72X { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV32 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32 MV32 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV33 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33 MV33 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV52 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52 MV52 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV63 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63 MV63 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV63X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63X MV63X { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV93 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93 MV93 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV93X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93X MV93X { get; set; }
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12SlashMV22SlashMV72
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12SlashMV22SlashMV72Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12SlashMV22SlashMV72Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WE
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WEResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WEResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV21SlashMV71
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV21SlashMV71Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV21SlashMV71Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV22XSlashMV72X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV22XSlashMV72XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV22XSlashMV72XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 2,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2058x2058")]
		_2058x2058 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 3,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 2,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Quality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2880x2880")]
		_2880x2880 = 2,
	}
	
	public class GenerateNetworkCameraSnapshotPostBody
	{
		
		/// <summary>
		/// [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullframe")]
		public System.Nullable<System.Boolean> Fullframe { get; set; }
		
		/// <summary>
		/// [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
	}
	
	public class UpdateNetworkCellularFirewallRulesPutBody
	{
		
		/// <summary>
		/// An ordered array of the firewall rules (not including the default rule)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkCellularFirewallRulesPutBodyRules[] UpdateNetworkCellularFirewallRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkCellularFirewallRulesPutBodyRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogEnabled")]
		public System.Nullable<System.Boolean> SyslogEnabled { get; set; }
	}
	
	public class GetNetworkClientsReturn
	{
		
		/// <summary>
		/// Short description of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Timestamp client was first seen in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstSeen")]
		public System.Nullable<System.Int32> FirstSeen { get; set; }
		
		/// <summary>
		/// 802.1x group policy of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicy8021x")]
		public string GroupPolicy8021x { get; set; }
		
		/// <summary>
		/// The ID of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The IP address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The IPv6 address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip6")]
		public string Ip6 { get; set; }
		
		/// <summary>
		/// Local IPv6 address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip6Local")]
		public string Ip6Local { get; set; }
		
		/// <summary>
		/// Timestamp client was last seen in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSeen")]
		public System.Nullable<System.Int32> LastSeen { get; set; }
		
		/// <summary>
		/// The MAC address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Manufacturer of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="manufacturer")]
		public string Manufacturer { get; set; }
		
		/// <summary>
		/// Notes on the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The operating system of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="os")]
		public string Os { get; set; }
		
		/// <summary>
		/// The MAC address of the node that the device was last connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentDeviceMac")]
		public string RecentDeviceMac { get; set; }
		
		/// <summary>
		/// The name of the node the device was last connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentDeviceName")]
		public string RecentDeviceName { get; set; }
		
		/// <summary>
		/// The serial of the node the device was last connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentDeviceSerial")]
		public string RecentDeviceSerial { get; set; }
		
		/// <summary>
		/// Status of SM for the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smInstalled")]
		public System.Nullable<System.Boolean> SmInstalled { get; set; }
		
		/// <summary>
		/// The name of the SSID that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssid")]
		public string Ssid { get; set; }
		
		/// <summary>
		/// The connection status of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<GetNetworkClientsReturnStatus> Status { get; set; }
		
		/// <summary>
		/// The switch port that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchport")]
		public string Switchport { get; set; }
		
		/// <summary>
		/// Usage, sent and received
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetNetworkClientsReturnUsage Usage { get; set; }
		
		/// <summary>
		/// The username of the user of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		/// <summary>
		/// The name of the VLAN that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public string Vlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkClientsReturnStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Offline = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Online = 1,
	}
	
	public class GetNetworkClientsReturnUsage
	{
		
		/// <summary>
		/// Usage received by the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recv")]
		public System.Nullable<System.Single> Recv { get; set; }
		
		/// <summary>
		/// Usage sent by the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public System.Nullable<System.Single> Sent { get; set; }
	}
	
	public enum GetNetworkClientsConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public enum GetNetworkClientsLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public class ProvisionNetworkClientsPostBody
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Group policy', 'Whitelisted', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyDevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The MAC address of the client. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The display name for the client. Optional. Limited to 255 bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policiesBySecurityAppliance")]
		public ProvisionNetworkClientsPostBodyPoliciesBySecurityAppliance PoliciesBySecurityAppliance { get; set; }
		
		/// <summary>
		/// An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policiesBySsid")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid PoliciesBySsid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyDevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Per connection")]
		Per_connection = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 5,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySecurityAppliance
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked' or 'Normal'. Required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public System.Nullable<ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceDevicePolicy> DevicePolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceDevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 2,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid
	{
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="0")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_0 _0 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_1 _1 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="2")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_2 _2 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="3")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_3 _3 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="4")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_4 _4 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="5")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_5 _5 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="6")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_6 _6 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="7")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_7 _7 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="8")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_8 _8 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="9")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_9 _9 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="10")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_10 _10 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="11")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_11 _11 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="12")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_12 _12 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="13")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_13 _13 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="14")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_14 _14 { get; set; }
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_0
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_0DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_0DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_1
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_1DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_1DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_2
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_2DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_2DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_3
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_3DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_3DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_4
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_4DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_4DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_5
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_5DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_5DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_6
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_6DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_6DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_7
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_7DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_7DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_8
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_8DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_8DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_9
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_9DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_9DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_10
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_10DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_10DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_11
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_11DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_11DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_12
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_12DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_12DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_13
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_13DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_13DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_14
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_14DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_14DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Whitelisted = 3,
	}
	
	public enum GetNetworkClientConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public enum GetNetworkClientLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public class UpdateNetworkClientPolicyPutBody
	{
		
		/// <summary>
		/// The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public string DevicePolicy { get; set; }
		
		/// <summary>
		/// [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBody
	{
		
		/// <summary>
		/// The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssids")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids Ssids { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids
	{
		
		/// <summary>
		/// Splash authorization for SSID 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="0")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0 _0 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1 _1 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="2")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2 _2 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="3")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3 _3 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="4")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4 _4 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="5")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5 _5 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 6
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="6")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6 _6 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 7
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="7")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7 _7 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="8")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8 _8 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 9
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="9")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9 _9 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="10")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10 _10 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 11
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="11")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11 _11 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 12
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="12")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12 _12 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 13
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="13")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13 _13 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 14
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="14")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14 _14 { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public enum GetNetworkConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public class UpdateNetworkContentFilteringPutBody
	{
		
		/// <summary>
		/// A list of URL patterns that are allowed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedUrlPatterns")]
		public string[] AllowedUrlPatterns { get; set; }
		
		/// <summary>
		/// A list of URL categories to block
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedUrlCategories")]
		public string[] BlockedUrlCategories { get; set; }
		
		/// <summary>
		/// A list of URL patterns that are blocked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedUrlPatterns")]
		public string[] BlockedUrlPatterns { get; set; }
		
		/// <summary>
		/// URL category list size which is either 'topSites' or 'fullList'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlCategoryListSize")]
		public System.Nullable<UpdateNetworkContentFilteringPutBodyUrlCategoryListSize> UrlCategoryListSize { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkContentFilteringPutBodyUrlCategoryListSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fullList = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		topSites = 1,
	}
	
	public class ClaimNetworkDevicesPostBody
	{
		
		/// <summary>
		/// [DEPRECATED] The serial of a device to claim
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// A list of serials of devices to claim
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public enum GetNetworkDevicesConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public enum GetNetworkDevicesLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public class UpdateNetworkDevicePutBody
	{
		
		/// <summary>
		/// The address of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The floor plan to associate to this device. null disassociates the device from the floorplan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="floorPlanId")]
		public string FloorPlanId { get; set; }
		
		/// <summary>
		/// The latitude of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// The longitude of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
		
		/// <summary>
		/// Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="moveMapMarker")]
		public System.Nullable<System.Boolean> MoveMapMarker { get; set; }
		
		/// <summary>
		/// The name of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The notes for the device. String. Limited to 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The ID of a switch profile to bind to the device (for available switch profiles, see the 'Switch Profiles' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch profile, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfileId")]
		public string SwitchProfileId { get; set; }
		
		/// <summary>
		/// The tags of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
	}
	
	public enum GetNetworkDeviceConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public enum GetNetworkDeviceLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public enum GetNetworkDeviceLossAndLatencyHistoryUplink
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellular = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan2 = 2,
	}
	
	public enum GetNetworkFailedConnectionsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public class CreateNetworkFloorPlanPostBody
	{
		
		/// <summary>
		/// The longitude and latitude of the bottom left corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bottomLeftCorner")]
		public CreateNetworkFloorPlanPostBodyBottomLeftCorner BottomLeftCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the bottom right corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bottomRightCorner")]
		public CreateNetworkFloorPlanPostBodyBottomRightCorner BottomRightCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="center")]
		public CreateNetworkFloorPlanPostBodyCenter Center { get; set; }
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="imageContents")]
		public string ImageContents { get; set; }
		
		/// <summary>
		/// The name of your floor plan.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the top left corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topLeftCorner")]
		public CreateNetworkFloorPlanPostBodyTopLeftCorner TopLeftCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the top right corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topRightCorner")]
		public CreateNetworkFloorPlanPostBodyTopRightCorner TopRightCorner { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyBottomLeftCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyBottomRightCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyCenter
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyTopLeftCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyTopRightCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBody
	{
		
		/// <summary>
		/// The longitude and latitude of the bottom left corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bottomLeftCorner")]
		public UpdateNetworkFloorPlanPutBodyBottomLeftCorner BottomLeftCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the bottom right corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bottomRightCorner")]
		public UpdateNetworkFloorPlanPutBodyBottomRightCorner BottomRightCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="center")]
		public UpdateNetworkFloorPlanPutBodyCenter Center { get; set; }
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageContents")]
		public string ImageContents { get; set; }
		
		/// <summary>
		/// The name of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the top left corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topLeftCorner")]
		public UpdateNetworkFloorPlanPutBodyTopLeftCorner TopLeftCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the top right corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topRightCorner")]
		public UpdateNetworkFloorPlanPutBodyTopRightCorner TopRightCorner { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyBottomLeftCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyBottomRightCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyCenter
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyTopLeftCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyTopRightCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkL7FirewallRulesPutBody
	{
		
		/// <summary>
		/// An ordered array of the MX L7 firewall rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkL7FirewallRulesPutBodyRules[] UpdateNetworkL7FirewallRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkL7FirewallRulesPutBodyRules
	{
		
		/// <summary>
		/// 'Deny' traffic specified by this rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public System.Nullable<UpdateNetworkL7FirewallRulesPutBodyRulesPolicy> Policy { get; set; }
		
		/// <summary>
		/// Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<UpdateNetworkL7FirewallRulesPutBodyRulesType> Type { get; set; }
		
		/// <summary>
		/// The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkL7FirewallRulesPutBodyRulesPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deny = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkL7FirewallRulesPutBodyRulesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		application = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		applicationCategory = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		host = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipRange = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		port = 4,
	}
	
	public enum GetNetworkLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
	}
	
	public class UpdateNetworkOneToManyNatRulesPutBody
	{
		
		/// <summary>
		/// An array of 1:Many nat rules
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkOneToManyNatRulesPutBodyRules[] UpdateNetworkOneToManyNatRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkOneToManyNatRulesPutBodyRules
	{
		
		/// <summary>
		/// An array of associated forwarding rules
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portRules")]
		public UpdateNetworkOneToManyNatRulesPutBodyRulesPortRules[] UpdateNetworkOneToManyNatRulesPutBodyRulesPortRules { get; set; }
		
		/// <summary>
		/// The IP address that will be used to access the internal resource from the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uplink")]
		public UpdateNetworkOneToManyNatRulesPutBodyRulesUplink Uplink { get; set; }
	}
	
	public class UpdateNetworkOneToManyNatRulesPutBodyRulesPortRules
	{
		
		/// <summary>
		/// Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
		
		/// <summary>
		/// Local IP address to which traffic will be forwarded
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localIp")]
		public string LocalIp { get; set; }
		
		/// <summary>
		/// Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localPort")]
		public string LocalPort { get; set; }
		
		/// <summary>
		/// A description of the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// 'tcp' or 'udp'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<UpdateNetworkOneToManyNatRulesPutBodyRulesPortRulesProtocol> Protocol { get; set; }
		
		/// <summary>
		/// Destination port of the traffic that is arriving on the WAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicPort")]
		public string PublicPort { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkOneToManyNatRulesPutBodyRulesPortRulesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkOneToManyNatRulesPutBodyRulesUplink
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet2 = 1,
	}
	
	public class UpdateNetworkOneToOneNatRulesPutBody
	{
		
		/// <summary>
		/// An array of 1:1 nat rules
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkOneToOneNatRulesPutBodyRules[] UpdateNetworkOneToOneNatRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkOneToOneNatRulesPutBodyRules
	{
		
		/// <summary>
		/// The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedInbound")]
		public UpdateNetworkOneToOneNatRulesPutBodyRulesAllowedInbound[] UpdateNetworkOneToOneNatRulesPutBodyRulesAllowedInbound { get; set; }
		
		/// <summary>
		/// The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lanIp")]
		public string LanIp { get; set; }
		
		/// <summary>
		/// A descriptive name for the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The IP address that will be used to access the internal resource from the WAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplink")]
		public UpdateNetworkOneToManyNatRulesPutBodyRulesUplink Uplink { get; set; }
	}
	
	public class UpdateNetworkOneToOneNatRulesPutBodyRulesAllowedInbound
	{
		
		/// <summary>
		/// An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
		
		/// <summary>
		/// An array of ports or port ranges that will be forwarded to the host on the LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationPorts")]
		public string[] DestinationPorts { get; set; }
		
		/// <summary>
		/// Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<UpdateNetworkOneToOneNatRulesPutBodyRulesAllowedInboundProtocol> Protocol { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkOneToOneNatRulesPutBodyRulesAllowedInboundProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="icmp-ping")]
		icmpMinusping = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 3,
	}
	
	public class CreateNetworkPiiRequestPostBody
	{
		
		/// <summary>
		/// The datasets related to the provided key that should be deleted. Only applies to "delete" requests. The value "all" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datasets")]
		public string[] Datasets { get; set; }
		
		/// <summary>
		/// The email of a network user account. Only applies to "delete" requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The MAC of a network client device. Applies to both "restrict processing" and "delete" requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smDeviceId")]
		public string SmDeviceId { get; set; }
		
		/// <summary>
		/// The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smUserId")]
		public string SmUserId { get; set; }
		
		/// <summary>
		/// One of "delete" or "restrict processing"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<CreateNetworkPiiRequestPostBodyType> Type { get; set; }
		
		/// <summary>
		/// The username of a network log in. Only applies to "delete" requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkPiiRequestPostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delete = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="restrict processing")]
		restrict_processing = 1,
	}
	
	public class UpdateNetworkPortForwardingRulesPutBody
	{
		
		/// <summary>
		/// An array of port forwarding params
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkPortForwardingRulesPutBodyRules[] UpdateNetworkPortForwardingRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkPortForwardingRulesPutBodyRules
	{
		
		/// <summary>
		/// An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
		
		/// <summary>
		/// The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lanIp")]
		public string LanIp { get; set; }
		
		/// <summary>
		/// A port or port ranges that will receive the forwarded traffic from the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="localPort")]
		public string LocalPort { get; set; }
		
		/// <summary>
		/// A descriptive name for the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// TCP or UDP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkOneToManyNatRulesPutBodyRulesPortRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// A port or port ranges that will be forwarded to the host on the LAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicPort")]
		public string PublicPort { get; set; }
		
		/// <summary>
		/// The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplink")]
		public System.Nullable<UpdateNetworkPortForwardingRulesPutBodyRulesUplink> Uplink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkPortForwardingRulesPutBodyRulesUplink
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		both = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet2 = 2,
	}
	
	public class UpdateNetworkSecurityIntrusionSettingsPutBody
	{
		
		/// <summary>
		/// Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idsRulesets")]
		public System.Nullable<UpdateNetworkSecurityIntrusionSettingsPutBodyIdsRulesets> IdsRulesets { get; set; }
		
		/// <summary>
		/// Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<UpdateNetworkSecurityIntrusionSettingsPutBodyMode> Mode { get; set; }
		
		/// <summary>
		/// Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectedNetworks")]
		public UpdateNetworkSecurityIntrusionSettingsPutBodyProtectedNetworks ProtectedNetworks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSecurityIntrusionSettingsPutBodyIdsRulesets
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		balanced = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		connectivity = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		security = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSecurityIntrusionSettingsPutBodyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		detection = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		prevention = 2,
	}
	
	public class UpdateNetworkSecurityIntrusionSettingsPutBodyProtectedNetworks
	{
		
		/// <summary>
		/// list of IP addresses or subnets being excluded from protection (required if 'useDefault' is false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludedCidr")]
		public string[] ExcludedCidr { get; set; }
		
		/// <summary>
		/// list of IP addresses or subnets being protected (required if 'useDefault' is false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includedCidr")]
		public string[] IncludedCidr { get; set; }
		
		/// <summary>
		/// true/false whether to use special IPv4 addresses: https://tools.ietf.org/html/rfc5735 (required). Default value is true if none currently saved
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useDefault")]
		public System.Nullable<System.Boolean> UseDefault { get; set; }
	}
	
	public class UpdateNetworkSecurityMalwareSettingsPutBody
	{
		
		/// <summary>
		/// The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedFiles")]
		public UpdateNetworkSecurityMalwareSettingsPutBodyAllowedFiles[] UpdateNetworkSecurityMalwareSettingsPutBodyAllowedFiles { get; set; }
		
		/// <summary>
		/// The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedUrls")]
		public UpdateNetworkSecurityMalwareSettingsPutBodyAllowedUrls[] UpdateNetworkSecurityMalwareSettingsPutBodyAllowedUrls { get; set; }
		
		/// <summary>
		/// Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public UpdateNetworkSecurityMalwareSettingsPutBodyMode Mode { get; set; }
	}
	
	public class UpdateNetworkSecurityMalwareSettingsPutBodyAllowedFiles
	{
		
		/// <summary>
		/// Comment about the allowed entity
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The file sha256 hash to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha256")]
		public string Sha256 { get; set; }
	}
	
	public class UpdateNetworkSecurityMalwareSettingsPutBodyAllowedUrls
	{
		
		/// <summary>
		/// Comment about the allowed entity
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The url to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSecurityMalwareSettingsPutBodyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 1,
	}
	
	public class UpdateNetworkSiteToSiteVpnPutBody
	{
		
		/// <summary>
		/// The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hubs")]
		public UpdateNetworkSiteToSiteVpnPutBodyHubs[] UpdateNetworkSiteToSiteVpnPutBodyHubs { get; set; }
		
		/// <summary>
		/// The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public UpdateNetworkSiteToSiteVpnPutBodyMode Mode { get; set; }
		
		/// <summary>
		/// The list of subnets and their VPN presence.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnets")]
		public UpdateNetworkSiteToSiteVpnPutBodySubnets[] UpdateNetworkSiteToSiteVpnPutBodySubnets { get; set; }
	}
	
	public class UpdateNetworkSiteToSiteVpnPutBodyHubs
	{
		
		/// <summary>
		/// The network ID of the hub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hubId")]
		public string HubId { get; set; }
		
		/// <summary>
		/// Only valid in 'spoke' mode. Indicates whether default route traffic should be sent to this hub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useDefaultRoute")]
		public System.Nullable<System.Boolean> UseDefaultRoute { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSiteToSiteVpnPutBodyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hub = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		spoke = 2,
	}
	
	public class UpdateNetworkSiteToSiteVpnPutBodySubnets
	{
		
		/// <summary>
		/// The CIDR notation subnet used within the VPN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="localSubnet")]
		public string LocalSubnet { get; set; }
		
		/// <summary>
		/// Indicates the presence of the subnet in the VPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useVpn")]
		public System.Nullable<System.Boolean> UseVpn { get; set; }
	}
	
	public class CreateNetworkSmBypassActivationLockAttemptPostBody
	{
		
		/// <summary>
		/// The ids of the devices to attempt activation lock bypass.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	public class UpdateNetworkSmDeviceFieldsPutBody
	{
		
		/// <summary>
		/// The new fields of the device. Each field of this object is optional.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deviceFields")]
		public UpdateNetworkSmDeviceFieldsPutBodyDeviceFields DeviceFields { get; set; }
		
		/// <summary>
		/// The id of the device to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The serial of the device to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// The wifiMac of the device to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMac")]
		public string WifiMac { get; set; }
	}
	
	public class UpdateNetworkSmDeviceFieldsPutBodyDeviceFields
	{
		
		/// <summary>
		/// New name for the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// New notes for the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
	}
	
	public class WipeNetworkSmDevicePutBody
	{
		
		/// <summary>
		/// The id of the device to be wiped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pin")]
		public System.Nullable<System.Int32> Pin { get; set; }
		
		/// <summary>
		/// The serial of the device to be wiped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// The wifiMac of the device to be wiped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMac")]
		public string WifiMac { get; set; }
	}
	
	public class UpdateNetworkSmDevicesTagsPutBody
	{
		
		/// <summary>
		/// The ids of the devices to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string Ids { get; set; }
		
		/// <summary>
		/// The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
		
		/// <summary>
		/// The serials of the devices to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string Serials { get; set; }
		
		/// <summary>
		/// The tags to be added, deleted, or updated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		/// <summary>
		/// One of add, delete, or update. Only devices that have been modified will be returned.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updateAction")]
		public string UpdateAction { get; set; }
		
		/// <summary>
		/// The wifiMacs of the devices to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMacs")]
		public string WifiMacs { get; set; }
	}
	
	public enum GetNetworkSplashLoginAttemptsSsidNumber
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
	}
	
	public class UpdateNetworkSsidPutBody
	{
		
		/// <summary>
		/// The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apTagsAndVlanIds")]
		public UpdateNetworkSsidPutBodyApTagsAndVlanIds[] UpdateNetworkSsidPutBodyApTagsAndVlanIds { get; set; }
		
		/// <summary>
		/// The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authMode")]
		public System.Nullable<UpdateNetworkSsidPutBodyAuthMode> AuthMode { get; set; }
		
		/// <summary>
		/// Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availabilityTags")]
		public string[] AvailabilityTags { get; set; }
		
		/// <summary>
		/// Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableOnAllAps")]
		public System.Nullable<System.Boolean> AvailableOnAllAps { get; set; }
		
		/// <summary>
		/// The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSelection")]
		public string BandSelection { get; set; }
		
		/// <summary>
		/// The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentratorNetworkId")]
		public string ConcentratorNetworkId { get; set; }
		
		/// <summary>
		/// The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultVlanId")]
		public System.Nullable<System.Int32> DefaultVlanId { get; set; }
		
		/// <summary>
		/// Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disassociateClientsOnVpnFailover")]
		public System.Nullable<System.Boolean> DisassociateClientsOnVpnFailover { get; set; }
		
		/// <summary>
		/// Whether or not the SSID is enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionMode")]
		public System.Nullable<UpdateNetworkSsidPutBodyEncryptionMode> EncryptionMode { get; set; }
		
		/// <summary>
		/// Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enterpriseAdminAccess")]
		public System.Nullable<UpdateNetworkSsidPutBodyEnterpriseAdminAccess> EnterpriseAdminAccess { get; set; }
		
		/// <summary>
		/// The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAssignmentMode")]
		public string IpAssignmentMode { get; set; }
		
		/// <summary>
		/// Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lanIsolationEnabled")]
		public System.Nullable<System.Boolean> LanIsolationEnabled { get; set; }
		
		/// <summary>
		/// The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
		
		/// <summary>
		/// The name of the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The download bandwidth limit in Kbps. (0 represents no limit.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perClientBandwidthLimitDown")]
		public System.Nullable<System.Int32> PerClientBandwidthLimitDown { get; set; }
		
		/// <summary>
		/// The upload bandwidth limit in Kbps. (0 represents no limit.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perClientBandwidthLimitUp")]
		public System.Nullable<System.Int32> PerClientBandwidthLimitUp { get; set; }
		
		/// <summary>
		/// The passkey for the SSID. This param is only valid if the authMode is 'psk'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="psk")]
		public string Psk { get; set; }
		
		/// <summary>
		/// Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingEnabled")]
		public System.Nullable<System.Boolean> RadiusAccountingEnabled { get; set; }
		
		/// <summary>
		/// The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingServers")]
		public UpdateNetworkSsidPutBodyRadiusAccountingServers[] UpdateNetworkSsidPutBodyRadiusAccountingServers { get; set; }
		
		/// <summary>
		/// Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAttributeForGroupPolicies")]
		public string RadiusAttributeForGroupPolicies { get; set; }
		
		/// <summary>
		/// If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusCoaEnabled")]
		public System.Nullable<System.Boolean> RadiusCoaEnabled { get; set; }
		
		/// <summary>
		/// This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusFailoverPolicy")]
		public System.Nullable<UpdateNetworkSsidPutBodyRadiusFailoverPolicy> RadiusFailoverPolicy { get; set; }
		
		/// <summary>
		/// This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusLoadBalancingPolicy")]
		public System.Nullable<UpdateNetworkSsidPutBodyRadiusLoadBalancingPolicy> RadiusLoadBalancingPolicy { get; set; }
		
		/// <summary>
		/// If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusOverride")]
		public System.Nullable<System.Boolean> RadiusOverride { get; set; }
		
		/// <summary>
		/// The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public UpdateNetworkSsidPutBodyRadiusServers[] UpdateNetworkSsidPutBodyRadiusServers { get; set; }
		
		/// <summary>
		/// The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryConcentratorNetworkId")]
		public string SecondaryConcentratorNetworkId { get; set; }
		
		/// <summary>
		/// The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashPage")]
		public System.Nullable<UpdateNetworkSsidPutBodySplashPage> SplashPage { get; set; }
		
		/// <summary>
		/// Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useVlanTagging")]
		public System.Nullable<System.Boolean> UseVlanTagging { get; set; }
		
		/// <summary>
		/// Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visible")]
		public System.Nullable<System.Boolean> Visible { get; set; }
		
		/// <summary>
		/// The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
		
		/// <summary>
		/// Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="walledGardenEnabled")]
		public System.Nullable<System.Boolean> WalledGardenEnabled { get; set; }
		
		/// <summary>
		/// Specify your walled garden by entering space-separated addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. 192.168.1.1/24 192.168.37.10/32 www.yahoo.com *.google.com). Meraki's splash page is automatically included in your walled garden.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="walledGardenRanges")]
		public string WalledGardenRanges { get; set; }
		
		/// <summary>
		/// The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only' or 'WPA3 192-bit Security')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wpaEncryptionMode")]
		public System.Nullable<UpdateNetworkSsidPutBodyWpaEncryptionMode> WpaEncryptionMode { get; set; }
	}
	
	public class UpdateNetworkSsidPutBodyApTagsAndVlanIds
	{
		
		/// <summary>
		/// Comma-separated list of AP tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		/// <summary>
		/// Numerical identifier that is assigned to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSsidPutBodyAuthMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-google")]
		_8021xMinusgoogle = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-localradius")]
		_8021xMinuslocalradius = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-meraki")]
		_8021xMinusmeraki = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-nac")]
		_8021xMinusnac = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-radius")]
		_8021xMinusradius = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ipsk-with-radius")]
		ipskMinuswithMinusradius = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ipsk-without-radius")]
		ipskMinuswithoutMinusradius = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="open-enhanced")]
		openMinusenhanced = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="open-with-nac")]
		openMinuswithMinusnac = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="open-with-radius")]
		openMinuswithMinusradius = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		psk = 11,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSsidPutBodyEncryptionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wep = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wpa = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSsidPutBodyEnterpriseAdminAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="access disabled")]
		access_disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="access enabled")]
		access_enabled = 1,
	}
	
	public class UpdateNetworkSsidPutBodyRadiusAccountingServers
	{
		
		/// <summary>
		/// IP address to which the APs will send RADIUS accounting messages
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Port on the RADIUS server that is listening for accounting messages
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Shared key used to authenticate messages between the APs and RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSsidPutBodyRadiusFailoverPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Allow access")]
		Allow_access = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Deny access")]
		Deny_access = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSsidPutBodyRadiusLoadBalancingPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Round robin")]
		Round_robin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Strict priority order")]
		Strict_priority_order = 1,
	}
	
	public class UpdateNetworkSsidPutBodyRadiusServers
	{
		
		/// <summary>
		/// IP address of your RADIUS server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port the RADIUS server listens on for Access-requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// RADIUS client shared secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSsidPutBodySplashPage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Billing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cisco ISE")]
		Cisco_ISE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Click-through splash page")]
		ClickMinusthrough_splash_page = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Facebook Wi-Fi")]
		Facebook_WiMinusFi = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Google Apps domain")]
		Google_Apps_domain = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Google OAuth")]
		Google_OAuth = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Password-protected with Active Directory")]
		PasswordMinusprotected_with_Active_Directory = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Password-protected with LDAP")]
		PasswordMinusprotected_with_LDAP = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Password-protected with Meraki RADIUS")]
		PasswordMinusprotected_with_Meraki_RADIUS = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Password-protected with custom RADIUS")]
		PasswordMinusprotected_with_custom_RADIUS = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SMS authentication")]
		SMS_authentication = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sponsored guest")]
		Sponsored_guest = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Systems Manager Sentry")]
		Systems_Manager_Sentry = 13,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSsidPutBodyWpaEncryptionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA1 and WPA2")]
		WPA1_and_WPA2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA1 only")]
		WPA1_only = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA2 only")]
		WPA2_only = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA3 192-bit Security")]
		WPA3_192Minusbit_Security = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA3 Transition Mode")]
		WPA3_Transition_Mode = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA3 only")]
		WPA3_only = 5,
	}
	
	public class UpdateNetworkSsidL3FirewallRulesPutBody
	{
		
		/// <summary>
		/// Allow wireless client access to local LAN (boolean value - true allows access and false denies access) (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowLanAccess")]
		public System.Nullable<System.Boolean> AllowLanAccess { get; set; }
		
		/// <summary>
		/// An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkSsidL3FirewallRulesPutBodyRules[] UpdateNetworkSsidL3FirewallRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkSsidL3FirewallRulesPutBodyRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesProtocol Protocol { get; set; }
	}
	
	public class UpdateNetworkSsidSplashSettingsPutBody
	{
		
		/// <summary>
		/// [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashUrl")]
		public string SplashUrl { get; set; }
		
		/// <summary>
		/// [optional] Boolean indicating whether the user will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useSplashUrl")]
		public System.Nullable<System.Boolean> UseSplashUrl { get; set; }
	}
	
	public class CreateNetworkStaticRoutePostBody
	{
		
		/// <summary>
		/// The gateway IP (next hop) of the static route
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayIp")]
		public string GatewayIp { get; set; }
		
		/// <summary>
		/// The name of the new static route
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The subnet of the static route
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class UpdateNetworkStaticRoutePutBody
	{
		
		/// <summary>
		/// The enabled state of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public string FixedIpAssignments { get; set; }
		
		/// <summary>
		/// The gateway IP (next hop) of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gatewayIp")]
		public string GatewayIp { get; set; }
		
		/// <summary>
		/// The name of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The DHCP reserved IP ranges on the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateNetworkStaticRoutePutBodyReservedIpRanges[] UpdateNetworkStaticRoutePutBodyReservedIpRanges { get; set; }
		
		/// <summary>
		/// The subnet of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class UpdateNetworkStaticRoutePutBodyReservedIpRanges
	{
		
		/// <summary>
		/// A text comment for the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The last IP in the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The first IP in the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class CreateNetworkSwitchLinkAggregationPostBody
	{
		
		/// <summary>
		/// Array of switch or stack ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchPorts")]
		public CreateNetworkSwitchLinkAggregationPostBodySwitchPorts[] CreateNetworkSwitchLinkAggregationPostBodySwitchPorts { get; set; }
		
		/// <summary>
		/// Array of switch profile ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfilePorts")]
		public CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts[] CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts { get; set; }
	}
	
	public class CreateNetworkSwitchLinkAggregationPostBodySwitchPorts
	{
		
		/// <summary>
		/// Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// Serial number of the switch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts
	{
		
		/// <summary>
		/// Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// Profile identifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public string Profile { get; set; }
	}
	
	public class UpdateNetworkSwitchLinkAggregationPutBody
	{
		
		/// <summary>
		/// Array of switch or stack ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchPorts")]
		public UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts[] UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts { get; set; }
		
		/// <summary>
		/// Array of switch profile ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfilePorts")]
		public UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts[] UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts { get; set; }
	}
	
	public class UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts
	{
		
		/// <summary>
		/// Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// Serial number of the switch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts
	{
		
		/// <summary>
		/// Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// Profile identifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public string Profile { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBody
	{
		
		/// <summary>
		/// The name for your port schedule. Required
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		///     The schedule for switch port scheduling. Schedules are applied to days of the week.
		///    When it's empty, default schedule with all days of a week are configured.
		///    Any unspecified day in the schedule is added as a default schedule configuration of the day.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSchedule")]
		public CreateNetworkSwitchPortSchedulePostBodyPortSchedule PortSchedule { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortSchedule
	{
		
		/// <summary>
		/// The schedule object for Friday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleFriday Friday { get; set; }
		
		/// <summary>
		/// The schedule object for Monday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleMonday Monday { get; set; }
		
		/// <summary>
		/// The schedule object for Saturday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saturday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturday Saturday { get; set; }
		
		/// <summary>
		/// The schedule object for Sunday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sunday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleSunday Sunday { get; set; }
		
		/// <summary>
		/// The schedule object for Thursday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thursday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleThursday Thursday { get; set; }
		
		/// <summary>
		/// The schedule object for Tuesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tuesday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesday Tuesday { get; set; }
		
		/// <summary>
		/// The schedule object for Wednesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wednesday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesday Wednesday { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleFriday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleMonday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleSunday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleThursday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBody
	{
		
		/// <summary>
		/// The name for your port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		///     The schedule for switch port scheduling. Schedules are applied to days of the week.
		///    When it's empty, default schedule with all days of a week are configured.
		///    Any unspecified day in the schedule is added as a default schedule configuration of the day.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSchedule")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortSchedule PortSchedule { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortSchedule
	{
		
		/// <summary>
		/// The schedule object for Friday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFriday Friday { get; set; }
		
		/// <summary>
		/// The schedule object for Monday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleMonday Monday { get; set; }
		
		/// <summary>
		/// The schedule object for Saturday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saturday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturday Saturday { get; set; }
		
		/// <summary>
		/// The schedule object for Sunday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sunday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSunday Sunday { get; set; }
		
		/// <summary>
		/// The schedule object for Thursday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thursday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursday Thursday { get; set; }
		
		/// <summary>
		/// The schedule object for Tuesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tuesday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesday Tuesday { get; set; }
		
		/// <summary>
		/// The schedule object for Wednesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wednesday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesday Wednesday { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFriday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleMonday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSunday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsPutBody
	{
		
		/// <summary>
		/// Exceptions on a per switch basis to "useCombinedPower"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerExceptions")]
		public UpdateNetworkSwitchSettingsPutBodyPowerExceptions[] UpdateNetworkSwitchSettingsPutBodyPowerExceptions { get; set; }
		
		/// <summary>
		/// The use Combined Power as the default behavior of secondary power supplies on supported devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useCombinedPower")]
		public System.Nullable<System.Boolean> UseCombinedPower { get; set; }
		
		/// <summary>
		/// Management VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsPutBodyPowerExceptions
	{
		
		/// <summary>
		/// Per switch exception (combined, redundant, useNetworkSetting)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="powerType")]
		public UpdateNetworkSwitchSettingsPutBodyPowerExceptionsPowerType PowerType { get; set; }
		
		/// <summary>
		/// Serial number of the switch
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchSettingsPutBodyPowerExceptionsPowerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		combined = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		redundant = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		useNetworkSetting = 2,
	}
	
	public class UpdateNetworkSwitchSettingsMulticastPutBody
	{
		
		/// <summary>
		/// Default multicast setting for entire network. IGMP snooping and Flood unknown multicast traffic settings are enabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultSettings")]
		public UpdateNetworkSwitchSettingsMulticastPutBodyDefaultSettings DefaultSettings { get; set; }
		
		/// <summary>
		/// Array of paired switches/stacks/profiles and corresponding multicast settings. An empty array will clear the multicast settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overrides")]
		public UpdateNetworkSwitchSettingsMulticastPutBodyOverrides[] UpdateNetworkSwitchSettingsMulticastPutBodyOverrides { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsMulticastPutBodyDefaultSettings
	{
		
		/// <summary>
		/// Flood unknown multicast traffic setting for entire network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="floodUnknownMulticastTrafficEnabled")]
		public System.Nullable<System.Boolean> FloodUnknownMulticastTrafficEnabled { get; set; }
		
		/// <summary>
		/// IGMP snooping setting for entire network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="igmpSnoopingEnabled")]
		public System.Nullable<System.Boolean> IgmpSnoopingEnabled { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsMulticastPutBodyOverrides
	{
		
		/// <summary>
		/// Flood unknown multicast traffic setting for switches, switch stacks or switch profiles
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floodUnknownMulticastTrafficEnabled")]
		public bool FloodUnknownMulticastTrafficEnabled { get; set; }
		
		/// <summary>
		/// IGMP snooping setting for switches, switch stacks or switch profiles
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="igmpSnoopingEnabled")]
		public bool IgmpSnoopingEnabled { get; set; }
		
		/// <summary>
		/// List of switch stack ids for non-template network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stacks")]
		public string[] Stacks { get; set; }
		
		/// <summary>
		/// List of switch profiles ids for template network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfiles")]
		public string[] SwitchProfiles { get; set; }
		
		/// <summary>
		/// List of switch serials for non-template network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switches")]
		public string[] Switches { get; set; }
	}
	
	public class CreateNetworkSwitchSettingsQosRulePostBody
	{
		
		/// <summary>
		/// DSCP tag. Set this to -1 to trust incoming DSCP. Default value is 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscp")]
		public System.Nullable<System.Int32> Dscp { get; set; }
		
		/// <summary>
		/// The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public System.Nullable<System.Int32> DstPort { get; set; }
		
		/// <summary>
		/// The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPortRange")]
		public string DstPortRange { get; set; }
		
		/// <summary>
		/// The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<CreateNetworkSwitchSettingsQosRulePostBodyProtocol> Protocol { get; set; }
		
		/// <summary>
		/// The source port of the incoming packet. Applicable only if protocol is TCP or UDP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public System.Nullable<System.Int32> SrcPort { get; set; }
		
		/// <summary>
		/// The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPortRange")]
		public string SrcPortRange { get; set; }
		
		/// <summary>
		/// The VLAN of the incoming packet. A null value will match any VLAN.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public int Vlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkSwitchSettingsQosRulePostBodyProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 2,
	}
	
	public class UpdateNetworkSwitchSettingsQosRulesOrderPutBody
	{
		
		/// <summary>
		/// A list of quality of service rule IDs arranged in order in which they should be processed by the switch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleIds")]
		public string[] RuleIds { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsQosRulePutBody
	{
		
		/// <summary>
		/// DSCP tag that should be assigned to incoming packet. Set this to -1 to trust incoming DSCP. Default value is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscp")]
		public System.Nullable<System.Int32> Dscp { get; set; }
		
		/// <summary>
		/// The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public System.Nullable<System.Int32> DstPort { get; set; }
		
		/// <summary>
		/// The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPortRange")]
		public string DstPortRange { get; set; }
		
		/// <summary>
		/// The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public CreateNetworkSwitchSettingsQosRulePostBodyProtocol Protocol { get; set; }
		
		/// <summary>
		/// The source port of the incoming packet. Applicable only if protocol is TCP or UDP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public System.Nullable<System.Int32> SrcPort { get; set; }
		
		/// <summary>
		/// The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPortRange")]
		public string SrcPortRange { get; set; }
		
		/// <summary>
		/// The VLAN of the incoming packet. A null value will match any VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsStormControlPutBody
	{
		
		/// <summary>
		/// Percentage (1 to 99) of total available port bandwidth for broadcast traffic type. Default value 100 percent rate is to clear the configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="broadcastThreshold")]
		public System.Nullable<System.Int32> BroadcastThreshold { get; set; }
		
		/// <summary>
		/// Percentage (1 to 99) of total available port bandwidth for multicast traffic type. Default value 100 percent rate is to clear the configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastThreshold")]
		public System.Nullable<System.Int32> MulticastThreshold { get; set; }
		
		/// <summary>
		/// Percentage (1 to 99) of total available port bandwidth for unknown unicast (dlf-destination lookup failure) traffic type. Default value 100 percent rate is to clear the configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unknownUnicastThreshold")]
		public System.Nullable<System.Int32> UnknownUnicastThreshold { get; set; }
	}
	
	public class UpdateNetworkSyslogServersPutBody
	{
		
		/// <summary>
		/// A list of the syslog servers for this network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public UpdateNetworkSyslogServersPutBodyServers[] UpdateNetworkSyslogServersPutBodyServers { get; set; }
	}
	
	public class UpdateNetworkSyslogServersPutBodyServers
	{
		
		/// <summary>
		/// The IP address of the syslog server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The port of the syslog server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public string[] Roles { get; set; }
	}
	
	public enum GetNetworkTrafficDeviceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		combined = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 3,
	}
	
	public class UpdateNetworkUplinkSettingsPutBody
	{
		
		/// <summary>
		/// A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public UpdateNetworkUplinkSettingsPutBodyBandwidthLimits BandwidthLimits { get; set; }
	}
	
	public class UpdateNetworkUplinkSettingsPutBodyBandwidthLimits
	{
		
		/// <summary>
		/// The bandwidth settings for the 'cellular' uplink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cellular")]
		public UpdateNetworkUplinkSettingsPutBodyBandwidthLimitsCellular Cellular { get; set; }
		
		/// <summary>
		/// The bandwidth settings for the 'wan1' uplink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan1")]
		public UpdateNetworkUplinkSettingsPutBodyBandwidthLimitsWan1 Wan1 { get; set; }
		
		/// <summary>
		/// The bandwidth settings for the 'wan2' uplink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan2")]
		public UpdateNetworkUplinkSettingsPutBodyBandwidthLimitsWan2 Wan2 { get; set; }
	}
	
	public class UpdateNetworkUplinkSettingsPutBodyBandwidthLimitsCellular
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class UpdateNetworkUplinkSettingsPutBodyBandwidthLimitsWan1
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class UpdateNetworkUplinkSettingsPutBodyBandwidthLimitsWan2
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class CreateNetworkVlanPostBody
	{
		
		/// <summary>
		/// The local IP of the appliance on the VLAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// The id of the desired group policy to apply to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The VLAN ID of the new VLAN (must be between 1 and 4094)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the new VLAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The subnet of the VLAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class UpdateNetworkVlanPutBody
	{
		
		/// <summary>
		/// The local IP of the appliance on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// DHCP boot option for boot filename
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootFilename")]
		public string DhcpBootFilename { get; set; }
		
		/// <summary>
		/// DHCP boot option to direct boot clients to the server to load the boot file from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootNextServer")]
		public string DhcpBootNextServer { get; set; }
		
		/// <summary>
		/// Use DHCP boot options specified in other properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootOptionsEnabled")]
		public System.Nullable<System.Boolean> DhcpBootOptionsEnabled { get; set; }
		
		/// <summary>
		/// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpHandling")]
		public System.Nullable<UpdateNetworkVlanPutBodyDhcpHandling> DhcpHandling { get; set; }
		
		/// <summary>
		/// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<UpdateNetworkVlanPutBodyDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpOptions")]
		public UpdateNetworkVlanPutBodyDhcpOptions[] UpdateNetworkVlanPutBodyDhcpOptions { get; set; }
		
		/// <summary>
		/// The IPs of the DHCP servers that DHCP requests should be relayed to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpRelayServerIps")]
		public string[] DhcpRelayServerIps { get; set; }
		
		/// <summary>
		/// The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameservers")]
		public string DnsNameservers { get; set; }
		
		/// <summary>
		/// The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public string FixedIpAssignments { get; set; }
		
		/// <summary>
		/// The id of the desired group policy to apply to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The name of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The DHCP reserved IP ranges on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateNetworkVlanPutBodyReservedIpRanges[] UpdateNetworkVlanPutBodyReservedIpRanges { get; set; }
		
		/// <summary>
		/// The subnet of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnNatSubnet")]
		public string VpnNatSubnet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkVlanPutBodyDhcpHandling
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Do not respond to DHCP requests")]
		Do_not_respond_to_DHCP_requests = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Relay DHCP to another server")]
		Relay_DHCP_to_another_server = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Run a DHCP server")]
		Run_a_DHCP_server = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkVlanPutBodyDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	public class UpdateNetworkVlanPutBodyDhcpOptions
	{
		
		/// <summary>
		/// The code for the DHCP option. This should be an integer between 2 and 254.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkVlanPutBodyDhcpOptionsType Type { get; set; }
		
		/// <summary>
		/// The value for the DHCP option
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkVlanPutBodyDhcpOptionsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hex = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		integer = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ip = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		text = 3,
	}
	
	public class UpdateNetworkVlanPutBodyReservedIpRanges
	{
		
		/// <summary>
		/// A text comment for the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The last IP in the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The first IP in the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class UpdateNetworkVlansEnabledStatePutBody
	{
		
		/// <summary>
		/// Boolean indicating whether to enable (true) or disable (false) VLANs for the network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class UpdateNetworkWarmSpareSettingsPutBody
	{
		
		/// <summary>
		/// Enable warm spare
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Serial number of the warm spare appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spareSerial")]
		public string SpareSerial { get; set; }
		
		/// <summary>
		/// Uplink mode, either virtual or public
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplinkMode")]
		public string UplinkMode { get; set; }
		
		/// <summary>
		/// The WAN 1 shared IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualIp1")]
		public string VirtualIp1 { get; set; }
		
		/// <summary>
		/// The WAN 2 shared IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualIp2")]
		public string VirtualIp2 { get; set; }
	}
	
	public class CreateNetworkWirelessRfProfilePostBody
	{
		
		/// <summary>
		/// Settings that will be enabled if selectionType is set to 'ap'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apBandSettings")]
		public CreateNetworkWirelessRfProfilePostBodyApBandSettings ApBandSettings { get; set; }
		
		/// <summary>
		/// Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bandSelectionType")]
		public CreateNetworkWirelessRfProfilePostBodyBandSelectionType BandSelectionType { get; set; }
		
		/// <summary>
		/// Steers client to best available access point. Can be either true or false. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientBalancingEnabled")]
		public System.Nullable<System.Boolean> ClientBalancingEnabled { get; set; }
		
		/// <summary>
		/// Settings related to 5Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fiveGhzSettings")]
		public CreateNetworkWirelessRfProfilePostBodyFiveGhzSettings FiveGhzSettings { get; set; }
		
		/// <summary>
		/// Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrateType")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyMinBitrateType> MinBitrateType { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique. This param is required on creation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Settings related to 2.4Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twoFourGhzSettings")]
		public CreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettings TwoFourGhzSettings { get; set; }
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyApBandSettings
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band. Can be either true or false. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyBandSelectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ap = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ssid = 1,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyFiveGhzSettings
	{
		
		/// <summary>
		/// Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channelWidth")]
		public string ChannelWidth { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyMinBitrateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		band = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ssid = 1,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettings
	{
		
		/// <summary>
		/// Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="axEnabled")]
		public System.Nullable<System.Boolean> AxEnabled { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfilePutBody
	{
		
		/// <summary>
		/// Settings that will be enabled if selectionType is set to 'ap'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apBandSettings")]
		public UpdateNetworkWirelessRfProfilePutBodyApBandSettings ApBandSettings { get; set; }
		
		/// <summary>
		/// Band selection can be set to either 'ssid' or 'ap'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSelectionType")]
		public CreateNetworkWirelessRfProfilePostBodyBandSelectionType BandSelectionType { get; set; }
		
		/// <summary>
		/// Steers client to best available access point. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientBalancingEnabled")]
		public System.Nullable<System.Boolean> ClientBalancingEnabled { get; set; }
		
		/// <summary>
		/// Settings related to 5Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fiveGhzSettings")]
		public UpdateNetworkWirelessRfProfilePutBodyFiveGhzSettings FiveGhzSettings { get; set; }
		
		/// <summary>
		/// Minimum bitrate can be set to either 'band' or 'ssid'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrateType")]
		public CreateNetworkWirelessRfProfilePostBodyMinBitrateType MinBitrateType { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Settings related to 2.4Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twoFourGhzSettings")]
		public UpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettings TwoFourGhzSettings { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyApBandSettings
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyApBandSettingsBandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyApBandSettingsBandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyFiveGhzSettings
	{
		
		/// <summary>
		/// Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channelWidth")]
		public string ChannelWidth { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettings
	{
		
		/// <summary>
		/// Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="axEnabled")]
		public System.Nullable<System.Boolean> AxEnabled { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	public class UpdateNetworkWirelessSettingsPutBody
	{
		
		/// <summary>
		/// Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6BridgeEnabled")]
		public System.Nullable<System.Boolean> Ipv6BridgeEnabled { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ledLightsOn")]
		public System.Nullable<System.Boolean> LedLightsOn { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling location analytics for your network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationAnalyticsEnabled")]
		public System.Nullable<System.Boolean> LocationAnalyticsEnabled { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling meshing in a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meshingEnabled")]
		public System.Nullable<System.Boolean> MeshingEnabled { get; set; }
		
		/// <summary>
		/// The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeStrategy")]
		public System.Nullable<UpdateNetworkWirelessSettingsPutBodyUpgradeStrategy> UpgradeStrategy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSettingsPutBodyUpgradeStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		minimizeClientDowntime = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		minimizeUpgradeTime = 1,
	}
	
	public class LockNetworkSmDevicesPutBody
	{
		
		/// <summary>
		/// The ids of the devices to be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string Ids { get; set; }
		
		/// <summary>
		/// The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pin")]
		public System.Nullable<System.Int32> Pin { get; set; }
		
		/// <summary>
		/// The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
		
		/// <summary>
		/// The serials of the devices to be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string Serials { get; set; }
		
		/// <summary>
		/// The wifiMacs of the devices to be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMacs")]
		public string WifiMacs { get; set; }
	}
	
	public enum GetOrganizationActionBatchesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 2,
	}
	
	public class CreateOrganizationActionBatchPostBody
	{
		
		/// <summary>
		/// A set of changes to make as part of this action (<a href='https://developer.cisco.com/meraki/api/#/rest/guides/action-batches/'>more details</a>)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public CreateOrganizationActionBatchPostBodyActions[] CreateOrganizationActionBatchPostBodyActions { get; set; }
		
		/// <summary>
		/// Set to true for immediate execution. Set to false if the action should be previewed before executing. This property cannot be unset once it is true. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmed")]
		public System.Nullable<System.Boolean> Confirmed { get; set; }
		
		/// <summary>
		/// Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="synchronous")]
		public System.Nullable<System.Boolean> Synchronous { get; set; }
	}
	
	public class CreateOrganizationActionBatchPostBodyActions
	{
		
		/// <summary>
		/// The body of the action
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The operation to be used
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operation")]
		public string Operation { get; set; }
		
		/// <summary>
		/// Unique identifier for the resource to be acted on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
	}
	
	public class UpdateOrganizationActionBatchPutBody
	{
		
		/// <summary>
		/// A boolean representing whether or not the batch has been confirmed. This property cannot be unset once it is true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmed")]
		public System.Nullable<System.Boolean> Confirmed { get; set; }
		
		/// <summary>
		/// Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="synchronous")]
		public System.Nullable<System.Boolean> Synchronous { get; set; }
	}
	
	public class CreateOrganizationAdminPostBody
	{
		
		/// <summary>
		/// The method of authentication the user will use to sign in to the Meraki dashboard. Can be one of 'Email' or 'Cisco SecureX Sign-On'. The default is Email authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationMethod")]
		public System.Nullable<CreateOrganizationAdminPostBodyAuthenticationMethod> AuthenticationMethod { get; set; }
		
		/// <summary>
		/// The email of the dashboard administrator. This attribute can not be updated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The name of the dashboard administrator
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of networks that the dashboard administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public CreateOrganizationAdminPostBodyNetworks[] CreateOrganizationAdminPostBodyNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public CreateOrganizationAdminPostBodyOrgAccess OrgAccess { get; set; }
		
		/// <summary>
		/// The list of tags that the dashboard administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public CreateOrganizationAdminPostBodyTags[] CreateOrganizationAdminPostBodyTags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationAdminPostBodyAuthenticationMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cisco SecureX Sign-On")]
		Cisco_SecureX_SignMinusOn = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Email = 1,
	}
	
	public class CreateOrganizationAdminPostBodyNetworks
	{
		
		/// <summary>
		/// The privilege of the dashboard administrator on the network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationAdminPostBodyOrgAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class CreateOrganizationAdminPostBodyTags
	{
		
		/// <summary>
		/// The privilege of the dashboard administrator on the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	public class UpdateOrganizationAdminPutBody
	{
		
		/// <summary>
		/// The name of the dashboard administrator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of networks that the dashboard administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public UpdateOrganizationAdminPutBodyNetworks[] UpdateOrganizationAdminPutBodyNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public System.Nullable<UpdateOrganizationAdminPutBodyOrgAccess> OrgAccess { get; set; }
		
		/// <summary>
		/// The list of tags that the dashboard administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public UpdateOrganizationAdminPutBodyTags[] UpdateOrganizationAdminPutBodyTags { get; set; }
	}
	
	public class UpdateOrganizationAdminPutBodyNetworks
	{
		
		/// <summary>
		/// The privilege of the dashboard administrator on the network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationAdminPutBodyOrgAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class UpdateOrganizationAdminPutBodyTags
	{
		
		/// <summary>
		/// The privilege of the dashboard administrator on the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	public class ClaimIntoOrganizationPostBody
	{
		
		/// <summary>
		/// The licenses that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public ClaimIntoOrganizationPostBodyLicenses[] ClaimIntoOrganizationPostBodyLicenses { get; set; }
		
		/// <summary>
		/// The numbers of the orders that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orders")]
		public string[] Orders { get; set; }
		
		/// <summary>
		/// The serials of the devices that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class ClaimIntoOrganizationPostBodyLicenses
	{
		
		/// <summary>
		/// The key of the license
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<ClaimIntoOrganizationPostBodyLicensesMode> Mode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ClaimIntoOrganizationPostBodyLicensesMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		addDevices = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		renew = 1,
	}
	
	public class CloneOrganizationPostBody
	{
		
		/// <summary>
		/// The name of the new organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public enum GetOrganizationLicensesState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		expired = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		expiring = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recentlyQueued = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unused = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unusedActive = 5,
	}
	
	public class AssignOrganizationLicensesSeatsPostBody
	{
		
		/// <summary>
		/// The ID of the SM license to assign seats from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenseId")]
		public string LicenseId { get; set; }
		
		/// <summary>
		/// The ID of the SM network to assign the seats to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public int SeatCount { get; set; }
	}
	
	public class MoveOrganizationLicensesSeatsPostBody
	{
		
		/// <summary>
		/// The ID of the organization to move the SM seats to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destOrganizationId")]
		public string DestOrganizationId { get; set; }
		
		/// <summary>
		/// The ID of the SM license to move the seats from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenseId")]
		public string LicenseId { get; set; }
		
		/// <summary>
		/// The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public int SeatCount { get; set; }
	}
	
	public class RenewOrganizationLicensesSeatsPostBody
	{
		
		/// <summary>
		/// The ID of the SM license to renew. This license must already be assigned to an SM network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenseIdToRenew")]
		public string LicenseIdToRenew { get; set; }
		
		/// <summary>
		/// The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unusedLicenseId")]
		public string UnusedLicenseId { get; set; }
	}
	
	public class CreateOrganizationNetworkPostBody
	{
		
		/// <summary>
		/// The ID of the network to copy configuration from. Other provided parameters will override the copied configuration, except type which must match this network's type exactly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copyFromNetworkId")]
		public string CopyFromNetworkId { get; set; }
		
		/// <summary>
		/// Disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableMyMerakiCom")]
		public System.Nullable<System.Boolean> DisableMyMerakiCom { get; set; }
		
		/// <summary>
		/// Disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if disableMyMerakiCom is set to false
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableRemoteStatusPage")]
		public System.Nullable<System.Boolean> DisableRemoteStatusPage { get; set; }
		
		/// <summary>
		/// The name of the new network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A space-separated list of tags to be applied to the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		/// <summary>
		/// The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// The type of the new network. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, environmental, or a space-separated list of those for a combined network.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class CombineOrganizationNetworksPostBody
	{
		
		/// <summary>
		/// A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// The name of the combined network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkIds")]
		public string[] NetworkIds { get; set; }
	}
	
	public class CreateOrganizationSamlRolePostBody
	{
		
		/// <summary>
		/// The list of networks that the SAML administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public CreateOrganizationSamlRolePostBodyNetworks[] CreateOrganizationSamlRolePostBodyNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the SAML administrator on the organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public string OrgAccess { get; set; }
		
		/// <summary>
		/// The role of the SAML administrator
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// The list of tags that the SAML administrator has privleges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public CreateOrganizationSamlRolePostBodyTags[] CreateOrganizationSamlRolePostBodyTags { get; set; }
	}
	
	public class CreateOrganizationSamlRolePostBodyNetworks
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class CreateOrganizationSamlRolePostBodyTags
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	public class UpdateOrganizationSamlRolePutBody
	{
		
		/// <summary>
		/// The list of networks that the SAML administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public UpdateOrganizationSamlRolePutBodyNetworks[] UpdateOrganizationSamlRolePutBodyNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the SAML administrator on the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public string OrgAccess { get; set; }
		
		/// <summary>
		/// The role of the SAML administrator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// The list of tags that the SAML administrator has privleges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public UpdateOrganizationSamlRolePutBodyTags[] UpdateOrganizationSamlRolePutBodyTags { get; set; }
	}
	
	public class UpdateOrganizationSamlRolePutBodyNetworks
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateOrganizationSamlRolePutBodyTags
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	public class UpdateOrganizationSecurityIntrusionSettingsPutBody
	{
		
		/// <summary>
		/// Sets a list of specific SNORT signatures to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="whitelistedRules")]
		public UpdateOrganizationSecurityIntrusionSettingsPutBodyWhitelistedRules[] UpdateOrganizationSecurityIntrusionSettingsPutBodyWhitelistedRules { get; set; }
	}
	
	public class UpdateOrganizationSecurityIntrusionSettingsPutBodyWhitelistedRules
	{
		
		/// <summary>
		/// Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// A rule identifier of the format meraki:intrusion/snort/GID/<gid>/SID/<sid>. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleId")]
		public string RuleId { get; set; }
	}
	
	public class UpdateOrganizationThirdPartyVPNPeersPutBody
	{
		
		/// <summary>
		/// The list of VPN peers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="peers")]
		public UpdateOrganizationThirdPartyVPNPeersPutBodyPeers[] UpdateOrganizationThirdPartyVPNPeersPutBodyPeers { get; set; }
	}
	
	public class UpdateOrganizationThirdPartyVPNPeersPutBodyPeers
	{
		
		/// <summary>
		/// [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeVersion")]
		public System.Nullable<UpdateOrganizationThirdPartyVPNPeersPutBodyPeersIkeVersion> IkeVersion { get; set; }
		
		/// <summary>
		/// Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecPolicies")]
		public UpdateOrganizationThirdPartyVPNPeersPutBodyPeersIpsecPolicies IpsecPolicies { get; set; }
		
		/// <summary>
		/// One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecPoliciesPreset")]
		public string IpsecPoliciesPreset { get; set; }
		
		/// <summary>
		/// The name of the VPN peer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// The list of the private subnets of the VPN peer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="privateSubnets")]
		public string[] PrivateSubnets { get; set; }
		
		/// <summary>
		/// The public IP of the VPN peer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteId")]
		public string RemoteId { get; set; }
		
		/// <summary>
		/// The shared secret with the VPN peer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationThirdPartyVPNPeersPutBodyPeersIkeVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1")]
		_1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 1,
	}
	
	public class UpdateOrganizationThirdPartyVPNPeersPutBodyPeersIpsecPolicies
	{
		
		/// <summary>
		/// This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childAuthAlgo")]
		public string[] ChildAuthAlgo { get; set; }
		
		/// <summary>
		/// This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childCipherAlgo")]
		public string[] ChildCipherAlgo { get; set; }
		
		/// <summary>
		/// The lifetime of the Phase 2 SA in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childLifetime")]
		public System.Nullable<System.Int32> ChildLifetime { get; set; }
		
		/// <summary>
		/// This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childPfsGroup")]
		public string[] ChildPfsGroup { get; set; }
		
		/// <summary>
		/// This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeAuthAlgo")]
		public string[] IkeAuthAlgo { get; set; }
		
		/// <summary>
		/// This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeCipherAlgo")]
		public string[] IkeCipherAlgo { get; set; }
		
		/// <summary>
		/// This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeDiffieHellmanGroup")]
		public string[] IkeDiffieHellmanGroup { get; set; }
		
		/// <summary>
		/// The lifetime of the Phase 1 SA in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeLifetime")]
		public System.Nullable<System.Int32> IkeLifetime { get; set; }
		
		/// <summary>
		/// [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikePrfAlgo")]
		public string[] IkePrfAlgo { get; set; }
	}
	
	public class UpdateOrganizationVpnFirewallRulesPutBody
	{
		
		/// <summary>
		/// An ordered array of the firewall rules (not including the default rule)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateOrganizationVpnFirewallRulesPutBodyRules[] UpdateOrganizationVpnFirewallRulesPutBodyRules { get; set; }
		
		/// <summary>
		/// Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogDefaultRule")]
		public System.Nullable<System.Boolean> SyslogDefaultRule { get; set; }
	}
	
	public class UpdateOrganizationVpnFirewallRulesPutBodyRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination IP address(es) (in IP or CIDR notation) or 'any' (FQDN not supported)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (FQDN not supported)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogEnabled")]
		public System.Nullable<System.Boolean> SyslogEnabled { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
