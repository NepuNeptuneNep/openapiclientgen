//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Amqp_external_rule_patch
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public System.Nullable<Amqp_external_rule_patchRequestMode> RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AMQP external (using Firehose). See the <a href="https://ably.com/documentation/general/firehose">Ably documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Amqp_external_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<Amqp_external_rule_patchStatus> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Amqp_external_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Amqp_external_rule_patchRequestMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		single = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Amqp_external_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="amqp/external")]
		amqp_external = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Rule_source
	{
		
		/// <summary>
		/// This field allows you to filter your rule based on a regular expression that is matched against the complete channel name. Leave this empty if you want the rule to apply to all channels.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelFilter")]
		public string ChannelFilter { get; set; }
		
		/// <summary>
		/// The type `channel.message` delivers all messages published on a channel. The type `channel.presence` delivers all enter, update and leave events for members present on a channel. The type `channel.lifecycle` events for this rule type are currently not supported. Get in touch (https://ably.com/contact) if you need this feature. The type `channel.occupancy` delivers all occupancy events for the channel.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Rule_sourceType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Rule_sourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel.message")]
		channel_message = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel.presence")]
		channel_presence = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel.lifecycle")]
		channel_lifecycle = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel.occupancy")]
		channel_occupancy = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Amqp_external_rule_patchStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
	}
	
	public class Amqp_external_rule_patchTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Amqp_external_rule_patchTargetHeaders[] Amqp_external_rule_patchTargetHeaders { get; set; }
		
		/// <summary>
		/// Reject delivery of the message if the route does not exist, otherwise fail silently.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryRoute")]
		public System.Nullable<System.Boolean> MandatoryRoute { get; set; }
		
		/// <summary>
		/// You can optionally override the default TTL on a queue and specify a TTL in minutes for messages to be persisted. It is unusual to change the default TTL, so if this field is left empty, the default TTL for the queue will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageTtl")]
		public System.Nullable<System.Int32> MessageTtl { get; set; }
		
		/// <summary>
		/// Marks the message as persistent, instructing the broker to write it to disk if it is in a durable queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistentMessages")]
		public System.Nullable<System.Boolean> PersistentMessages { get; set; }
		
		/// <summary>
		/// The AMQP routing key. See this <a href="https://knowledge.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule">Ably knowledge base article</a> for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routingKey")]
		public string RoutingKey { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Amqp_external_rule_patchTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Amqp_external_rule_post
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AMQP external (using Firehose). See the <a href="https://ably.com/documentation/general/firehose">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Amqp_external_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Amqp_external_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Amqp_external_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="amqp/external")]
		amqp_external = 0,
	}
	
	public class Amqp_external_rule_postTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Amqp_external_rule_postTargetHeaders[] Amqp_external_rule_postTargetHeaders { get; set; }
		
		/// <summary>
		/// Reject delivery of the message if the route does not exist, otherwise fail silently.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mandatoryRoute")]
		public bool MandatoryRoute { get; set; }
		
		/// <summary>
		/// You can optionally override the default TTL on a queue and specify a TTL in minutes for messages to be persisted. It is unusual to change the default TTL, so if this field is left empty, the default TTL for the queue will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageTtl")]
		public System.Nullable<System.Int32> MessageTtl { get; set; }
		
		/// <summary>
		/// Marks the message as persistent, instructing the broker to write it to disk if it is in a durable queue.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="persistentMessages")]
		public bool PersistentMessages { get; set; }
		
		/// <summary>
		/// The AMQP routing key. See this <a href="https://knowledge.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule">Ably knowledge base article</a> for details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routingKey")]
		public string RoutingKey { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Amqp_external_rule_postTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Amqp_external_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AMQP external (using Firehose). See the <a href="https://ably.com/documentation/general/firehose">Ably documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Amqp_external_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Amqp_external_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Amqp_external_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="amqp/external")]
		amqp_external = 0,
	}
	
	public class Amqp_external_rule_responseTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Amqp_external_rule_responseTargetHeaders[] Amqp_external_rule_responseTargetHeaders { get; set; }
		
		/// <summary>
		/// Reject delivery of the message if the route does not exist, otherwise fail silently.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mandatoryRoute")]
		public bool MandatoryRoute { get; set; }
		
		/// <summary>
		/// You can optionally override the default TTL on a queue and specify a TTL in minutes for messages to be persisted. It is unusual to change the default TTL, so if this field is left empty, the default TTL for the queue will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageTtl")]
		public System.Nullable<System.Int32> MessageTtl { get; set; }
		
		/// <summary>
		/// Marks the message as persistent, instructing the broker to write it to disk if it is in a durable queue.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="persistentMessages")]
		public bool PersistentMessages { get; set; }
		
		/// <summary>
		/// The AMQP routing key. See this <a href="https://knowledge.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule">Ably knowledge base article</a> for details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routingKey")]
		public string RoutingKey { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Amqp_external_rule_responseTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Amqp_rule_patch
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AMQP. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Amqp_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Amqp_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Amqp_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		amqp = 0,
	}
	
	public class Amqp_rule_patchTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Amqp_rule_patchTargetHeaders[] Amqp_rule_patchTargetHeaders { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="queueId")]
		public string QueueId { get; set; }
	}
	
	public class Amqp_rule_patchTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Amqp_rule_post
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AMQP. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Amqp_rule_patchRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Amqp_rule_postTarget Target { get; set; }
	}
	
	public class Amqp_rule_postTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Amqp_rule_postTargetHeaders[] Amqp_rule_postTargetHeaders { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="queueId")]
		public string QueueId { get; set; }
	}
	
	public class Amqp_rule_postTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Amqp_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AMQP. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Amqp_rule_patchRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Amqp_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class Amqp_rule_responseTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Amqp_rule_responseTargetHeaders[] Amqp_rule_responseTargetHeaders { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="queueId")]
		public string QueueId { get; set; }
	}
	
	public class Amqp_rule_responseTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class App_patch
	{
		
		/// <summary>
		/// The Apple Push Notification service certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apnsCertificate")]
		public string ApnsCertificate { get; set; }
		
		/// <summary>
		/// The Apple Push Notification service private key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apnsPrivateKey")]
		public string ApnsPrivateKey { get; set; }
		
		/// <summary>
		/// The Apple Push Notification service sandbox endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apnsUseSandboxEndpoint")]
		public System.Nullable<System.Boolean> ApnsUseSandboxEndpoint { get; set; }
		
		/// <summary>
		/// The Firebase Cloud Messaging key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fcmKey")]
		public string FcmKey { get; set; }
		
		/// <summary>
		/// The name of the application for your reference only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The status of the application. Can be `enabled` or `disabled`. Enabled means available to accept inbound connections and all services are available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Enforce TLS for all connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tlsOnly")]
		public System.Nullable<System.Boolean> TlsOnly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class App_pkcs12
	{
		
		/// <summary>
		/// The `.p12` file containing the app's APNs information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="p12File")]
		public string P12File { get; set; }
		
		/// <summary>
		/// The password for the corresponding `.p12` file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="p12Pass")]
		public string P12Pass { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class App_post
	{
		
		/// <summary>
		/// The Apple Push Notification service certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apnsCertificate")]
		public string ApnsCertificate { get; set; }
		
		/// <summary>
		/// The Apple Push Notification service private key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apnsPrivateKey")]
		public string ApnsPrivateKey { get; set; }
		
		/// <summary>
		/// The Apple Push Notification service sandbox endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apnsUseSandboxEndpoint")]
		public System.Nullable<System.Boolean> ApnsUseSandboxEndpoint { get; set; }
		
		/// <summary>
		/// The Firebase Cloud Messaging key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fcmKey")]
		public string FcmKey { get; set; }
		
		/// <summary>
		/// The name of the application for your reference only.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The status of the application. Can be `enabled` or `disabled`. Enabled means available to accept inbound connections and all services are available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Enforce TLS for all connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tlsOnly")]
		public System.Nullable<System.Boolean> TlsOnly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class App_response
	{
		
		/// <summary>
		/// A link self-referencing the app that has been created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The ID of your Ably account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountId")]
		public string AccountId { get; set; }
		
		/// <summary>
		/// Apple Push Notification service endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apnsUseSandboxEndpoint")]
		public System.Nullable<System.Boolean> ApnsUseSandboxEndpoint { get; set; }
		
		/// <summary>
		/// The application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The application name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The application status. Disabled applications will not accept new connections and will return an error to all clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Enforce TLS for all connections. This setting overrides any channel setting.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tlsOnly")]
		public System.Nullable<System.Boolean> TlsOnly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_access_keys
	{
		
		/// <summary>
		/// The AWS key ID for the AWS IAM user. See this <a href="https://knowledge.ably.com/authentication-for-reactor-rules-for-aws-reactor-events-for-lambda-functions-reactor-firehose-for-aws-sqs-and-kinesis">Ably knowledge base article</a> for details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accessKeyId")]
		public string AccessKeyId { get; set; }
		
		/// <summary>
		/// Authentication method is using AWS credentials (AWS key ID and secret key).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationMode")]
		public System.Nullable<Aws_access_keysAuthenticationMode> AuthenticationMode { get; set; }
		
		/// <summary>
		/// The AWS secret key for the AWS IAM user. See this <a href="https://knowledge.ably.com/authentication-for-reactor-rules-for-aws-reactor-events-for-lambda-functions-reactor-firehose-for-aws-sqs-and-kinesis">Ably knowledge base article</a> for details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretAccessKey")]
		public string SecretAccessKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_access_keysAuthenticationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		credentials = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_access_keys_response
	{
		
		/// <summary>
		/// The AWS key ID for the AWS IAM user. See this <a href="https://knowledge.ably.com/authentication-for-reactor-rules-for-aws-reactor-events-for-lambda-functions-reactor-firehose-for-aws-sqs-and-kinesis">Ably knowledge base article</a> for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessKeyId")]
		public string AccessKeyId { get; set; }
		
		/// <summary>
		/// Authentication method is using AWS credentials (AWS key ID and secret key).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationMode")]
		public Aws_access_keysAuthenticationMode AuthenticationMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_assume_role
	{
		
		/// <summary>
		/// If you are using the "ARN of an assumable role" authentication method, this is your Assume Role ARN. See this <a href="https://knowledge.ably.com/authentication-for-reactor-rules-for-aws-reactor-events-for-lambda-functions-reactor-firehose-for-aws-sqs-and-kinesis">Ably knowledge base article</a> for details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assumeRoleArn")]
		public string AssumeRoleArn { get; set; }
		
		/// <summary>
		/// Authentication method is using the ARN of an assumable role. See this <a href="https://knowledge.ably.com/authentication-for-reactor-rules-for-aws-reactor-events-for-lambda-functions-reactor-firehose-for-aws-sqs-and-kinesis">Ably knowledge base article</a> for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationMode")]
		public System.Nullable<Aws_assume_roleAuthenticationMode> AuthenticationMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_assume_roleAuthenticationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		assumeRole = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_kinesis_rule_patch
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS Kinesis. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Aws_kinesis_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_kinesis_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_kinesis_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/kinesis")]
		aws_kinesis = 0,
	}
	
	public class Aws_kinesis_rule_patchTarget
	{
		
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys Authentication { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public System.Nullable<Aws_kinesis_rule_patchTargetFormat> Format { get; set; }
		
		/// <summary>
		/// The AWS Kinesis partition key. See this <a href="https://knowledge.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule">Ably knowledge base article</a> for details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partitionKey")]
		public string PartitionKey { get; set; }
		
		/// <summary>
		/// The region is which AWS Kinesis is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The name of your AWS Kinesis Stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="streamName")]
		public string StreamName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_kinesis_rule_patchTargetFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		json = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_kinesis_rule_post
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS Kinesis. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Aws_kinesis_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_kinesis_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_kinesis_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/kinesis")]
		aws_kinesis = 0,
	}
	
	public class Aws_kinesis_rule_postTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys Authentication { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Aws_kinesis_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// The AWS Kinesis partition key. See this <a href="https://knowledge.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule">Ably knowledge base article</a> for details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="partitionKey")]
		public string PartitionKey { get; set; }
		
		/// <summary>
		/// The region is which AWS Kinesis is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The name of your AWS Kinesis Stream.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamName")]
		public string StreamName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_kinesis_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS Kinesis. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Aws_kinesis_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_kinesis_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_kinesis_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/kinesis")]
		aws_kinesis = 0,
	}
	
	public class Aws_kinesis_rule_responseTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys_response Authentication { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Aws_kinesis_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// The AWS Kinesis partition key. See this <a href="https://knowledge.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule">Ably knowledge base article</a> for details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="partitionKey")]
		public string PartitionKey { get; set; }
		
		/// <summary>
		/// The region is which AWS Kinesis is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The name of your AWS Kinesis Stream.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamName")]
		public string StreamName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_lambda_rule_patch
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS Lambda. See the <a href="https://ably.com/integrations">Ably documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Aws_lambda_rule_patchRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_lambda_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_lambda_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/lambda")]
		aws_lambda = 0,
	}
	
	public class Aws_lambda_rule_patchTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys Authentication { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// The name of your AWS Lambda Function.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="functionName")]
		public string FunctionName { get; set; }
		
		/// <summary>
		/// The region is which your AWS Lambda Function is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_lambda_rule_post
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS Lambda. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Aws_lambda_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_lambda_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_lambda_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/lambda")]
		aws_lambda = 0,
	}
	
	public class Aws_lambda_rule_postTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys Authentication { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// The name of your AWS Lambda Function.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="functionName")]
		public string FunctionName { get; set; }
		
		/// <summary>
		/// The region is which your AWS Lambda Function is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_lambda_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS Lambda. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Aws_lambda_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_lambda_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_lambda_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/lambda")]
		aws_lambda = 0,
	}
	
	public class Aws_lambda_rule_responseTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys_response Authentication { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// The name of your AWS Lambda Function.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="functionName")]
		public string FunctionName { get; set; }
		
		/// <summary>
		/// The region is which your AWS Lambda Function is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_sqs_rule_patch
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS SQS. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Aws_sqs_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_sqs_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_sqs_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/sqs")]
		aws_sqs = 0,
	}
	
	public class Aws_sqs_rule_patchTarget
	{
		
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys Authentication { get; set; }
		
		/// <summary>
		/// Your AWS account ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="awsAccountId")]
		public string AwsAccountId { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// The AWS SQS queue name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queueName")]
		public string QueueName { get; set; }
		
		/// <summary>
		/// The region is which AWS SQS is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_sqs_rule_post
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS SQS. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Aws_sqs_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_sqs_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_sqs_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/sqs")]
		aws_sqs = 0,
	}
	
	public class Aws_sqs_rule_postTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys Authentication { get; set; }
		
		/// <summary>
		/// Your AWS account ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="awsAccountId")]
		public string AwsAccountId { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// The AWS SQS queue name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="queueName")]
		public string QueueName { get; set; }
		
		/// <summary>
		/// The region is which AWS SQS is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Aws_sqs_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case AWS SQS. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Aws_sqs_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Aws_sqs_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Aws_sqs_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="aws/sqs")]
		aws_sqs = 0,
	}
	
	public class Aws_sqs_rule_responseTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Aws_access_keys_response Authentication { get; set; }
		
		/// <summary>
		/// Your AWS account ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="awsAccountId")]
		public string AwsAccountId { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// The AWS SQS queue name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="queueName")]
		public string QueueName { get; set; }
		
		/// <summary>
		/// The region is which AWS SQS is hosted. See the <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region">AWS documentation</a> for more detail.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Azure_function_rule_patch
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public System.Nullable<Azure_function_rule_patchRequestMode> RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Microsoft Azure Function. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Azure_function_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Azure_function_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Azure_function_rule_patchRequestMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		single = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		batch = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Azure_function_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/azure-function")]
		http_azureMinusfunction = 0,
	}
	
	public class Azure_function_rule_patchTarget
	{
		
		/// <summary>
		/// The Microsoft Azure Application ID. You can find your Microsoft Azure Application ID as shown in this <a href="https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID">article</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azureAppId")]
		public string AzureAppId { get; set; }
		
		/// <summary>
		/// The name of your Microsoft Azure Function.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azureFunctionName")]
		public string AzureFunctionName { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Aws_kinesis_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Azure_function_rule_patchTargetHeaders[] Azure_function_rule_patchTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
	}
	
	public class Azure_function_rule_patchTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Azure_function_rule_post
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Microsoft Azure Function. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Azure_function_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Azure_function_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Azure_function_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/azure-function")]
		http_azureMinusfunction = 0,
	}
	
	public class Azure_function_rule_postTarget
	{
		
		/// <summary>
		/// The Microsoft Azure Application ID. You can find your Microsoft Azure Application ID as shown in this <a href="https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID">article</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="azureAppId")]
		public string AzureAppId { get; set; }
		
		/// <summary>
		/// The name of your Microsoft Azure Function.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="azureFunctionName")]
		public string AzureFunctionName { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Aws_kinesis_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Azure_function_rule_postTargetHeaders[] Azure_function_rule_postTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
	}
	
	public class Azure_function_rule_postTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Azure_function_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Microsoft Azure Function. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Azure_function_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Azure_function_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Azure_function_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/azure-function")]
		http_azureMinusfunction = 0,
	}
	
	public class Azure_function_rule_responseTarget
	{
		
		/// <summary>
		/// The Microsoft Azure Application ID. You can find your Microsoft Azure Application ID as shown in this <a href="https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID">article</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="azureAppId")]
		public string AzureAppId { get; set; }
		
		/// <summary>
		/// The name of your Microsoft Azure Function.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="azureFunctionName")]
		public string AzureFunctionName { get; set; }
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Aws_kinesis_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Azure_function_rule_responseTargetHeaders[] Azure_function_rule_responseTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
	}
	
	public class Azure_function_rule_responseTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Cloudflare_worker_rule_patch
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Cloudflare Worker. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Cloudflare_worker_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Cloudflare_worker_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Cloudflare_worker_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/cloudflare-worker")]
		http_cloudflareMinusworker = 0,
	}
	
	public class Cloudflare_worker_rule_patchTarget
	{
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Cloudflare_worker_rule_patchTargetHeaders[] Cloudflare_worker_rule_patchTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Cloudflare_worker_rule_patchTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Cloudflare_worker_rule_post
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Cloudflare Worker. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Cloudflare_worker_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Cloudflare_worker_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Cloudflare_worker_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/cloudflare-worker")]
		http_cloudflareMinusworker = 0,
	}
	
	public class Cloudflare_worker_rule_postTarget
	{
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Cloudflare_worker_rule_postTargetHeaders[] Cloudflare_worker_rule_postTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Cloudflare_worker_rule_postTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Cloudflare_worker_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Cloudflare Worker. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Cloudflare_worker_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Cloudflare_worker_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Cloudflare_worker_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/cloudflare-worker")]
		http_cloudflareMinusworker = 0,
	}
	
	public class Cloudflare_worker_rule_responseTarget
	{
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Cloudflare_worker_rule_responseTargetHeaders[] Cloudflare_worker_rule_responseTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Cloudflare_worker_rule_responseTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Error
	{
		
		/// <summary>
		/// The HTTP status code returned.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public int Code { get; set; }
		
		/// <summary>
		/// Any additional details about the error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
		
		/// <summary>
		/// The URL to documentation about the error code.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
		
		/// <summary>
		/// The error message.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The Ably error code.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public int StatusCode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Google_cloud_function_rule_patch
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Google Cloud Function. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Google_cloud_function_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Google_cloud_function_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Google_cloud_function_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/google-cloud-function")]
		http_googleMinuscloudMinusfunction = 0,
	}
	
	public class Google_cloud_function_rule_patchTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Aws_kinesis_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// The name of your Google Cloud Function.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="functionName")]
		public string FunctionName { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Google_cloud_function_rule_patchTargetHeaders[] Google_cloud_function_rule_patchTargetHeaders { get; set; }
		
		/// <summary>
		/// The project ID for your Google Cloud Project that was generated when you created your project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectId")]
		public string ProjectId { get; set; }
		
		/// <summary>
		/// The region in which your Google Cloud Function is hosted. See the <a href="https://cloud.google.com/compute/docs/regions-zones/">Google documentation</a> for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
	}
	
	public class Google_cloud_function_rule_patchTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Google_cloud_function_rule_post
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Google Cloud Function. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Google_cloud_function_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Google_cloud_function_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Google_cloud_function_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/google-cloud-function")]
		http_googleMinuscloudMinusfunction = 0,
	}
	
	public class Google_cloud_function_rule_postTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Aws_kinesis_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// The name of your Google Cloud Function.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="functionName")]
		public string FunctionName { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Google_cloud_function_rule_postTargetHeaders[] Google_cloud_function_rule_postTargetHeaders { get; set; }
		
		/// <summary>
		/// The project ID for your Google Cloud Project that was generated when you created your project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="projectId")]
		public string ProjectId { get; set; }
		
		/// <summary>
		/// The region in which your Google Cloud Function is hosted. See the <a href="https://cloud.google.com/compute/docs/regions-zones/">Google documentation</a> for more details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
	}
	
	public class Google_cloud_function_rule_postTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Google_cloud_function_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Google Cloud Function. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Google_cloud_function_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Google_cloud_function_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Google_cloud_function_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/google-cloud-function")]
		http_googleMinuscloudMinusfunction = 0,
	}
	
	public class Google_cloud_function_rule_responseTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a text-based encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Aws_kinesis_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// The name of your Google Cloud Function.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="functionName")]
		public string FunctionName { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Google_cloud_function_rule_responseTargetHeaders[] Google_cloud_function_rule_responseTargetHeaders { get; set; }
		
		/// <summary>
		/// The project ID for your Google Cloud Project that was generated when you created your project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="projectId")]
		public string ProjectId { get; set; }
		
		/// <summary>
		/// The region in which your Google Cloud Function is hosted. See the <a href="https://cloud.google.com/compute/docs/regions-zones/">Google documentation</a> for more details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
	}
	
	public class Google_cloud_function_rule_responseTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Http_rule_patch
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Http_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Http_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Http_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		http = 0,
	}
	
	public class Http_rule_patchTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a simpler text-based encoding, whereas MsgPack provides a more efficient binary encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public System.Nullable<Http_rule_patchTargetFormat> Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Http_rule_patchTargetHeaders[] Http_rule_patchTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Http_rule_patchTargetFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		json = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		msgpack = 1,
	}
	
	public class Http_rule_patchTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Http_rule_post
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Http_rule_patchRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Http_rule_postTarget Target { get; set; }
	}
	
	public class Http_rule_postTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a simpler text-based encoding, whereas MsgPack provides a more efficient binary encoding.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Http_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Http_rule_postTargetHeaders[] Http_rule_postTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		/// <summary>
		/// The URL of the endpoint that is invoked when events occur on Ably.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Http_rule_postTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Http_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Http_rule_patchRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Http_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class Http_rule_responseTarget
	{
		
		/// <summary>
		/// Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enveloped")]
		public System.Nullable<System.Boolean> Enveloped { get; set; }
		
		/// <summary>
		/// JSON provides a simpler text-based encoding, whereas MsgPack provides a more efficient binary encoding.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public Http_rule_patchTargetFormat Format { get; set; }
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Http_rule_responseTargetHeaders[] Http_rule_responseTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Http_rule_responseTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Ifttt_rule_patch
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Ifttt_rule_post
	{
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case IFTTT. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Ifttt_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Ifttt_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Ifttt_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/ifttt")]
		http_ifttt = 0,
	}
	
	public class Ifttt_rule_postTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventName")]
		public string EventName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="webhookKey")]
		public string WebhookKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Ifttt_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// Single request mode sends each event separately to the endpoint specified by the rule. You can read more about single request mode events in the <a href="https://ably.com/documentation/general/events#batching">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Amqp_external_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case IFTTT. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Ifttt_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Ifttt_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Ifttt_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/ifttt")]
		http_ifttt = 0,
	}
	
	public class Ifttt_rule_responseTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventName")]
		public string EventName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="webhookKey")]
		public string WebhookKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Key_patch
	{
		
		/// <summary>
		/// The capabilities that this key has. More information on capabilities can be found in the <a href="https://ably.com/documentation/core-features/authentication#capabilities-explained">Ably documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capabilities")]
		public string[] Capabilities { get; set; }
		
		/// <summary>
		/// Specify the channels and queues that this key can be used with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channels")]
		public string Channels { get; set; }
		
		/// <summary>
		/// The name for your API key. This is a friendly name for your reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Key_post
	{
		
		/// <summary>
		/// The capabilities that this key has. More information on capabilities can be found in the <a href="https://ably.com/documentation/core-features/authentication#capabilities-explained">Ably documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="capabilities")]
		public string[] Capabilities { get; set; }
		
		/// <summary>
		/// Specify the channels and queues that this key can be used with.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channels")]
		public string Channels { get; set; }
		
		/// <summary>
		/// The name for your API key. This is a friendly name for your reference.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Key_response
	{
		
		/// <summary>
		/// The Ably application ID which this key is associated with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// The capabilities that this key has. More information on capabilities can be found in the <a href="https://ably.com/documentation/core-features/authentication#capabilities-explained">Ably documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capability")]
		public System.Collections.Generic.Dictionary<string, string[]> Capability { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Int32> Created { get; set; }
		
		/// <summary>
		/// The key ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The complete API key including API secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of the last modification of the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Int32> Modified { get; set; }
		
		/// <summary>
		/// The name of the application this key is associated with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Me
	{
		
		[System.Runtime.Serialization.DataMember(Name="account")]
		public MeAccount Account { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="token")]
		public MeToken Token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user")]
		public MeUser User { get; set; }
	}
	
	public class MeAccount
	{
		
		/// <summary>
		/// The account ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the account.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class MeToken
	{
		
		/// <summary>
		/// An array containing the access capabilities associated with the access token.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="capabilities")]
		public string[] Capabilities { get; set; }
		
		/// <summary>
		/// The token ID. This is a UUID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// The friendly name for the token.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class MeUser
	{
		
		/// <summary>
		/// Email address of the user associated with the account.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The user ID associated with the account. This is a UUID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Namespace_patch
	{
		
		/// <summary>
		/// If `true`, clients will not be permitted to use (including to attach, publish, or subscribe) any channels within this namespace unless they are identified, that is, authenticated using a client ID. See the <a href="https://knowledge.ably.com/authenticated-and-identified-clients">Ably knowledge base/a> for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticated")]
		public System.Nullable<System.Boolean> Authenticated { get; set; }
		
		/// <summary>
		/// If `true`, the last message published on a channel will be stored for 365 days. You can access the stored message only by using the channel rewind mechanism and attaching with rewind=1. Please note that for each message stored, an additional message is deducted from your monthly allocation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistLast")]
		public System.Nullable<System.Boolean> PersistLast { get; set; }
		
		/// <summary>
		/// If `true`, all messages on a channel will be stored for 24 hours. You can access stored messages via the History API. Please note that for each message stored, an additional message is deducted from your monthly allocation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persisted")]
		public System.Nullable<System.Boolean> Persisted { get; set; }
		
		/// <summary>
		/// If `true`, publishing messages with a push payload in the extras field is permitted and can trigger the delivery of a native push notification to registered devices for the channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pushEnabled")]
		public System.Nullable<System.Boolean> PushEnabled { get; set; }
		
		/// <summary>
		/// If `true`, only clients that are connected using TLS will be permitted to subscribe to any channels within this namespace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tlsOnly")]
		public System.Nullable<System.Boolean> TlsOnly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Namespace_post
	{
		
		/// <summary>
		/// If `true`, clients will not be permitted to use (including to attach, publish, or subscribe) any channels within this namespace unless they are identified, that is, authenticated using a client ID. See the <a href="https://knowledge.ably.com/authenticated-and-identified-clients">Ably Knowledge base</a> for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticated")]
		public System.Nullable<System.Boolean> Authenticated { get; set; }
		
		/// <summary>
		/// The namespace or channel name that the channel rule will apply to. For example, if you specify `namespace` the namespace will be set to `namespace` and will match with channels `namespace:*` and `namespace`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If `true`, the last message published on a channel will be stored for 365 days. You can access the stored message only by using the channel rewind mechanism and attaching with rewind=1. Please note that for each message stored, an additional message is deducted from your monthly allocation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistLast")]
		public System.Nullable<System.Boolean> PersistLast { get; set; }
		
		/// <summary>
		/// If `true`, all messages on a channel will be stored for 24 hours. You can access stored messages via the History API. Please note that for each message stored, an additional message is deducted from your monthly allocation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persisted")]
		public System.Nullable<System.Boolean> Persisted { get; set; }
		
		/// <summary>
		/// If `true`, publishing messages with a push payload in the extras field is permitted and can trigger the delivery of a native push notification to registered devices for the channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pushEnabled")]
		public System.Nullable<System.Boolean> PushEnabled { get; set; }
		
		/// <summary>
		/// If `true`, only clients that are connected using TLS will be permitted to subscribe to any channels within this namespace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tlsOnly")]
		public System.Nullable<System.Boolean> TlsOnly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Namespace_response
	{
		
		/// <summary>
		/// If `true`, clients will not be permitted to use (including to attach, publish, or subscribe) any channels within this namespace unless they are identified, that is, authenticated using a client ID. See the <a href="https://knowledge.ably.com/authenticated-and-identified-clients">Ably knowledge base</a> for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticated")]
		public System.Nullable<System.Boolean> Authenticated { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the namespace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Int32> Created { get; set; }
		
		/// <summary>
		/// The namespace or channel name that the channel rule will apply to. For example, if you specify `namespace` the namespace will be set to `namespace` and will match with channels `namespace:*` and `namespace`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the namespace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Int32> Modified { get; set; }
		
		/// <summary>
		/// If `true`, the last message published on a channel will be stored for 365 days. You can access the stored message only by using the channel rewind mechanism and attaching with rewind=1. Please note that for each message stored, an additional message is deducted from your monthly allocation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistLast")]
		public System.Nullable<System.Boolean> PersistLast { get; set; }
		
		/// <summary>
		/// If `true`, all messages on a channel will be stored for 24 hours. You can access stored messages via the History API. Please note that for each message stored, an additional message is deducted from your monthly allocation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persisted")]
		public System.Nullable<System.Boolean> Persisted { get; set; }
		
		/// <summary>
		/// If `true`, publishing messages with a push payload in the extras field is permitted and can trigger the delivery of a native push notification to registered devices for the channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pushEnabled")]
		public System.Nullable<System.Boolean> PushEnabled { get; set; }
		
		/// <summary>
		/// If `true`, only clients that are connected using TLS will be permitted to subscribe to any channels within this namespace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tlsOnly")]
		public System.Nullable<System.Boolean> TlsOnly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Queue
	{
		
		/// <summary>
		/// Message limit in number of messages.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxLength")]
		public int MaxLength { get; set; }
		
		/// <summary>
		/// A friendly name for your queue.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The data center region. US East (Virginia) or EU West (Ireland). Values are `us-east-1-a` or `eu-west-1-a`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// TTL in minutes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public int Ttl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Queue_response
	{
		
		[System.Runtime.Serialization.DataMember(Name="amqp")]
		public Queue_responseAmqp Amqp { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// A boolean that indicates whether this is a dead letter queue or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deadletter")]
		public System.Nullable<System.Boolean> Deadletter { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deadletterId")]
		public string DeadletterId { get; set; }
		
		/// <summary>
		/// The ID of the Ably queue
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Message limit in number of messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLength")]
		public System.Nullable<System.Int32> MaxLength { get; set; }
		
		/// <summary>
		/// Details of messages in the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messages")]
		public Queue_responseMessages Messages { get; set; }
		
		/// <summary>
		/// The friendly name of the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The data center region for the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The current state of the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stats")]
		public Queue_responseStats Stats { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stomp")]
		public Queue_responseStomp Stomp { get; set; }
		
		/// <summary>
		/// TTL in minutes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
	}
	
	public class Queue_responseAmqp
	{
		
		/// <summary>
		/// Name of the Ably queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queueName")]
		public string QueueName { get; set; }
		
		/// <summary>
		/// URI for the AMQP queue interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	public class Queue_responseMessages
	{
		
		/// <summary>
		/// The number of ready messages in the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ready")]
		public System.Nullable<System.Int32> Ready { get; set; }
		
		/// <summary>
		/// The total number of messages in the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
		
		/// <summary>
		/// The number of unacknowledged messages in the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unacknowledged")]
		public System.Nullable<System.Int32> Unacknowledged { get; set; }
	}
	
	public class Queue_responseStats
	{
		
		/// <summary>
		/// The rate at which messages are acknowledged. Rate is messages per minute.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acknowledgementRate")]
		public System.Nullable<System.Double> AcknowledgementRate { get; set; }
		
		/// <summary>
		/// The rate at which messages are delivered from the queue. Rate is messages per minute.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryRate")]
		public System.Nullable<System.Double> DeliveryRate { get; set; }
		
		/// <summary>
		/// The rate at which messages are published to the queue. Rate is messages per minute.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publishRate")]
		public System.Nullable<System.Double> PublishRate { get; set; }
	}
	
	public class Queue_responseStomp
	{
		
		/// <summary>
		/// Destination queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// The host type for the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// URI for the STOMP queue interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Rule_attributes
	{
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Rule_patch
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Rule_post
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Rule_response
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Rule_source_patch
	{
		
		/// <summary>
		/// This field allows you to filter your rule based on a regular expression that is matched against the complete channel name. Leave this empty if you want the rule to apply to all channels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channelFilter")]
		public string ChannelFilter { get; set; }
		
		/// <summary>
		/// The type `channel.message` delivers all messages published on a channel. The type `channel.presence` delivers all enter, update and leave events for members present on a channel. The type `channel.lifecycle` events for this rule type are currently not supported. Get in touch (https://ably.com/contact) if you need this feature. The type `channel.occupancy` delivers all occupancy events for the channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<Rule_source_patchType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Rule_source_patchType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel.message")]
		channel_message = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel.presence")]
		channel_presence = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel.lifecycle")]
		channel_lifecycle = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel.occupancy")]
		channel_occupancy = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Unsupported_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// This rule type is currently unsupported.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Unsupported_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Unsupported_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Unsupported_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unsupported = 0,
	}
	
	public class Unsupported_rule_responseTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Zapier_rule_patch
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Zapier. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public System.Nullable<Zapier_rule_patchRuleType> RuleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Zapier_rule_patchTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Zapier_rule_patchRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/zapier")]
		http_zapier = 0,
	}
	
	public class Zapier_rule_patchTarget
	{
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Zapier_rule_patchTargetHeaders[] Zapier_rule_patchTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Zapier_rule_patchTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Zapier_rule_post
	{
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Zapier. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Zapier_rule_postRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Zapier_rule_postTarget Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Zapier_rule_postRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/zapier")]
		http_zapier = 0,
	}
	
	public class Zapier_rule_postTarget
	{
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Zapier_rule_postTargetHeaders[] Zapier_rule_postTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Zapier_rule_postTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Zapier_rule_response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string _links { get; set; }
		
		/// <summary>
		/// The Ably application ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of creation of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Double> Created { get; set; }
		
		/// <summary>
		/// The rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unix timestamp representing the date and time of last modification of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modified")]
		public System.Nullable<System.Double> Modified { get; set; }
		
		/// <summary>
		/// This is Single Request mode or Batch Request mode. Single Request mode sends each event separately to the endpoint specified by the rule. Batch Request mode rolls up multiple events into the same request. You can read more about the difference between single and batched events in the Ably <a href="https://ably.com/documentation/general/events#batching">documentation</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestMode")]
		public Azure_function_rule_patchRequestMode RequestMode { get; set; }
		
		/// <summary>
		/// The type of rule. In this case Zapier. See the <a href="https://ably.com/integrations">documentation</a> for further information.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleType")]
		public Zapier_rule_responseRuleType RuleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Rule_source Source { get; set; }
		
		/// <summary>
		/// The status of the rule. Rules can be enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Amqp_external_rule_patchStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Zapier_rule_responseTarget Target { get; set; }
		
		/// <summary>
		/// API version. Events and the format of their payloads are versioned. Please see the <a href="https://ably.com/documentation/general/events">Events documentation</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Zapier_rule_responseRuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http/zapier")]
		http_zapier = 0,
	}
	
	public class Zapier_rule_responseTarget
	{
		
		/// <summary>
		/// If you have additional information to send, you'll need to include the relevant headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Zapier_rule_responseTargetHeaders[] Zapier_rule_responseTargetHeaders { get; set; }
		
		/// <summary>
		/// The signing key ID for use in `batch` mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the <a href="https://ably.com/documentation/general/events#security">webhook security docs</a> for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKeyId")]
		public string SigningKeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class Zapier_rule_responseTargetHeaders
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists apps
		/// List all applications for the specified account ID.
		/// AppsGetByAccount_id accounts/{account_id}/apps
		/// </summary>
		/// <param name="account_id">The account ID for which to retrieve the associated applications.</param>
		/// <returns>List of apps for the specified account are returned</returns>
		public async Task<App_response[]> AppsGetByAccount_idAsync(string account_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (account_id==null? "" : System.Uri.EscapeDataString(account_id))+"/apps";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<App_response[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an app
		/// Creates an application with the specified properties.
		/// AppsPostByAccount_id accounts/{account_id}/apps
		/// </summary>
		/// <param name="account_id">The account ID of the account in which to create the application.</param>
		public async Task AppsPostByAccount_idAsync(string account_id, App_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (account_id==null? "" : System.Uri.EscapeDataString(account_id))+"/apps";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists app keys
		/// Lists the API keys associated with the application ID.
		/// KeysGetByApp_id apps/{app_id}/keys
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <returns>Key list</returns>
		public async Task<Key_response[]> KeysGetByApp_idAsync(string app_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Key_response[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a key
		/// Creates an API key for the application specified.
		/// KeysPostByApp_id apps/{app_id}/keys
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		public async Task KeysPostByApp_idAsync(string app_id, Key_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a key
		/// Update the API key with the specified key ID, for the application with the specified application ID.
		/// KeysPatchByApp_idAndKey_id apps/{app_id}/keys/{key_id}
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="key_id">The API key ID.</param>
		/// <returns>Key updated</returns>
		public async Task<Key_response> KeysPatchByApp_idAndKey_idAsync(string app_id, string key_id, Key_patch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/keys/"+ (key_id==null? "" : System.Uri.EscapeDataString(key_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Key_response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Revokes a key
		/// Revokes the API key with the specified ID, with the Application ID. This deletes the key.
		/// KeysPostByApp_idAndKey_id apps/{app_id}/keys/{key_id}/revoke
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="key_id">The key ID.</param>
		/// <returns>Key revoked</returns>
		public async Task KeysPostByApp_idAndKey_idAsync(string app_id, string key_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/keys/"+ (key_id==null? "" : System.Uri.EscapeDataString(key_id))+"/revoke";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists namespaces
		/// List the namespaces for the specified application ID.
		/// NamespacesGetByApp_id apps/{app_id}/namespaces
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <returns>Namespace list</returns>
		public async Task<Namespace_response[]> NamespacesGetByApp_idAsync(string app_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/namespaces";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Namespace_response[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a namespace
		/// Creates a namespace for the specified application ID.
		/// NamespacesPostByApp_id apps/{app_id}/namespaces
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		public async Task NamespacesPostByApp_idAsync(string app_id, Namespace_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/namespaces";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a namespace
		/// Deletes the namespace with the specified ID, for the specified application ID.
		/// NamespacesDeleteByApp_idAndNamespace_id apps/{app_id}/namespaces/{namespace_id}
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="namespace_id">The namespace ID.</param>
		public async Task NamespacesDeleteByApp_idAndNamespace_idAsync(string app_id, string namespace_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/namespaces/"+ (namespace_id==null? "" : System.Uri.EscapeDataString(namespace_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a namespace
		/// Updates the namespace with the specified ID, for the application with the specified application ID.
		/// NamespacesPatchByApp_idAndNamespace_id apps/{app_id}/namespaces/{namespace_id}
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="namespace_id">The namespace ID.</param>
		/// <returns>Namespace updated</returns>
		public async Task<Namespace_response> NamespacesPatchByApp_idAndNamespace_idAsync(string app_id, string namespace_id, Namespace_patch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/namespaces/"+ (namespace_id==null? "" : System.Uri.EscapeDataString(namespace_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Namespace_response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists queues
		/// Lists the queues associated with the specified application ID.
		/// QueuesGetByApp_id apps/{app_id}/queues
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <returns>Queue list</returns>
		public async Task<Queue_response[]> QueuesGetByApp_idAsync(string app_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/queues";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Queue_response[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a queue
		/// Creates a queue for the application specified by application ID. The properties for the queue to be created are specified in the request body.
		/// QueuesPostByApp_id apps/{app_id}/queues
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		public async Task QueuesPostByApp_idAsync(string app_id, Queue requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/queues";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a queue
		/// Delete the queue with the specified queue name, from the application with the specified application ID.
		/// QueuesDeleteByApp_idAndQueue_id apps/{app_id}/queues/{queue_id}
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="queue_id">The queue ID.</param>
		public async Task QueuesDeleteByApp_idAndQueue_idAsync(string app_id, string queue_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/queues/"+ (queue_id==null? "" : System.Uri.EscapeDataString(queue_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists Reactor rules
		/// Lists the rules for the application specified by the application ID.
		/// RulesGetByApp_id apps/{app_id}/rules
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <returns>Reactor rule list</returns>
		public async Task<Rule_response[]> RulesGetByApp_idAsync(string app_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Rule_response[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a Reactor rule
		/// Creates a rule for the application with the specified application ID.
		/// RulesPostByApp_id apps/{app_id}/rules
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="requestBody">The rule properties.</param>
		public async Task RulesPostByApp_idAsync(string app_id, Rule_post requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a Reactor rule
		/// RulesDeleteByApp_idAndRule_id apps/{app_id}/rules/{rule_id}
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="rule_id">The rule ID.</param>
		public async Task RulesDeleteByApp_idAndRule_idAsync(string app_id, string rule_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/rules/"+ (rule_id==null? "" : System.Uri.EscapeDataString(rule_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a reactor rule by rule ID
		/// Returns the rule specified by the rule ID, for the application specified by application ID.
		/// RulesGetByApp_idAndRule_id apps/{app_id}/rules/{rule_id}
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="rule_id">The rule ID.</param>
		/// <returns>Reactor rule</returns>
		public async Task<Rule_response> RulesGetByApp_idAndRule_idAsync(string app_id, string rule_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/rules/"+ (rule_id==null? "" : System.Uri.EscapeDataString(rule_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Rule_response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a Reactor rule
		/// RulesPatchByApp_idAndRule_id apps/{app_id}/rules/{rule_id}
		/// </summary>
		/// <param name="app_id">The application ID.</param>
		/// <param name="rule_id">The rule ID.</param>
		/// <param name="requestBody">Properties for the rule.</param>
		/// <returns>Reactor rule updated</returns>
		public async Task<Rule_response> RulesPatchByApp_idAndRule_idAsync(string app_id, string rule_id, Rule_patch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (app_id==null? "" : System.Uri.EscapeDataString(app_id))+"/rules/"+ (rule_id==null? "" : System.Uri.EscapeDataString(rule_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Rule_response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an app
		/// Deletes the application with the specified application ID.
		/// AppsDeleteById apps/{id}
		/// </summary>
		/// <param name="id">The ID of the application to be deleted.</param>
		public async Task AppsDeleteByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an app
		/// Updates the application with the specified application ID.
		/// AppsPatchById apps/{id}
		/// </summary>
		/// <param name="id">The ID of application to be updated.</param>
		/// <returns>App updated</returns>
		public async Task<App_response> AppsPatchByIdAsync(string id, App_patch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "apps/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<App_response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get token details
		/// TokensGet me
		/// </summary>
		/// <returns>Token details</returns>
		public async Task<Me> TokensGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "me";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Me>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
